#include "stdafx.h"
#include <NxPracticeSharedLib/RichEditUtils.h>
#include "EMN.h"
#include "EmrItemAdvNarrativeDlg.h"
#include "EmrItemAdvTableDlg.h"
#include "EmrItemAdvImageDlg.h"
#include "DateTimeUtils.h"
#include "InternationalUtils.h"
#include "AuditTrail.h"
#include "GlobalUtils.h"
#include "FileUtils.h"
#include "MergeEngine.h"
#include "LetterWriting.h"
#include "HistoryDlg.h"
#include "NxWordProcessorLib\GenericWordProcessorManager.h"
#include "ShowProgressFeedbackDlg.h"
#include "EMRChargePromptDlg.h"
#include "ChooseEMNCategoryDlg.h"
#include "NxCDO.h"
#include "EmrTreeWnd.h"
#include "EmnMoreInfoDlg.h"
#include "NxPracticeSharedLib/StringSortedArray.h"
#include "EMRItemAdvPopupDlg.h"
#include "EMRItemAdvPopupWnd.h"
#include "EMRItemAdvMultiPopupDlg.h"
#include "PrescriptionEditDlg.h"
#include "TodoUtils.h"
#include "EMRDeleteTodosDlg.h"
#include "EMRCopyTodosDlg.h"
#include "LabEntryDlg.h"
#include "EmrTopicWnd.h"
#include "EmrEditorDlg.h"
#include "PicContainerDlg.h"
#include "LabConfirmDeleteDlg.h"
#include "CorrectMedicationQuantitiesDlg.h"
#include "SureScriptsPractice.h"
#include "EmrCodingGroupEditDlg.h"
#include "ReconcileMedicationsDlg.h"
#include "NewCropBrowserDlg.h"
#include "EMNUnspawner.h"
#include "WoundCareSetupDlg.h" // (r.gonet 08/03/2012) - PLID 51948
#include "EMNMedication.h"	// (j.jones 2012-11-30 14:03) - PLID 53966 - moved the EMNMedication class to its own file
#include "EMRTopic.h"
#include "EMNDetail.h"
#include "EMR.h"
#include "GlobalAuditUtils.h"
#include "ConfigEMRPreviewDlg.h"
#include "GlobalLabUtils.h"
#include "EmrCodingGroupManager.h"
#include "EMNDefaultProvider.h"
// (c.haag 2007-04-24 11:01) - PLID 26463 - We now use the official EMN loader
// object rather than the old preloaded detail array object
#include "EMNLoader.h"
#include "PicContainerDlg.h"
#include <NxAlgorithm.h>
#include "WriteTokenInfo.h"
#include <NxSystemUtilitiesLib/NxHandle.h>
#include "NxAutoQuantum.h"
#include "EMNProvider.h"
#include "EMNTodo.h"
#include "DiagSearchUtils.h"
#include "NxAPI.h"
#include <foreach.h>
#include "NexGEM.h" // (a.walling 2014-03-12 12:31) - PLID 61334 - #import of API in stdafx causes crash in cl.exe
#include "DiagQuickListUtils.h"
#include <boost/container/flat_set.hpp>

// (a.walling 2009-10-13 10:01) - PLID 35930
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

using namespace ADODB;


// (a.walling 2011-08-11 16:43) - PLID 45021 - TableRow.m_pID is now TableRow.m_ID, which is not allocated on the heap.

// (a.walling 2010-01-21 16:43) - PLID 37022 - Modified all auditing to take in a patient's internal ID when applicable, -1 if not.

// (a.walling 2014-01-30 00:00) - PLID 60541 - #NewObjectsT now a table so can be referenced by other sprocs

///



// (a.walling 2014-01-30 00:00) - PLID 60543 - Quantize TopicPositionEntry
Nx::Quantum::Batch TopicPositionEntry::GenerateSaveString(BOOL bIsTemplateTopic) 
{
	try {
		Nx::Quantum::Batch batch;

		long nOrderIndex = GetSortOrder();
		//TES 5/4/2010 - PLID 24692 - Only save if the order has actually changed.
		if(nTopicID != -1 && nOrderIndex != nLastSavedOrderIndex) {
			if(bIsTemplateTopic) {
				AddStatementToSqlBatch(batch, "UPDATE EmrTemplateTopicsT SET OrderIndex = %li WHERE ID = %li", nOrderIndex, nTopicID);
			}
			else {
				AddStatementToSqlBatch(batch, "UPDATE EmrTopicsT SET OrderIndex = %li WHERE ID = %li", nOrderIndex, nTopicID);
			}
		}

		if(pNext) {
			batch += pNext->GenerateSaveString(bIsTemplateTopic);
		}
		if(pChild) {
			batch += pChild->GenerateSaveString(bIsTemplateTopic);
		}

		return batch;
	} NxCatchAll("Error in GenerateSaveString()");
	return Nx::Quantum::Batch();
}

CString NarrativeMergeField::GetValue()
{
	//
	// (c.haag 2007-03-29 17:25) - PLID 25423 - Functions that used to execute
	//		str = field.strValue
	// now call
	//		str = field.GetValue()
	//
	// We now support retaining detail objects in merge fields, and calculating the value
	// and sentence formats on demand. If the detail object is not null, then we will calculate
	// those values, reset the object to NULL, and return the desired value
	//
	// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated
	/*
	if (NULL != pPendingDetail && NULL != pPendingDetailEMN) {
		CString strDataOutput = pPendingDetailEMN->GetDataOutput(pPendingDetail, NULL, false, false);
		strValue = strDataOutput;
		strSentenceFormat = pPendingDetailEMN->GetSentence(pPendingDetail, NULL, false, false, ecfParagraph, strDataOutput);
		pPendingDetail = NULL;
	}
	*/
	return strValue;
}

// (z.manning 2009-08-18 10:15) - PLID 35207 - Moved the body of this function to EMN.cpp
void EMNDiagCode::operator =(EMNDiagCode &cSource)
{
	nID = cSource.nID;
	nDiagCodeID = cSource.nDiagCodeID;
	// (b.savon 2014-02-27 14:04) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN
	nDiagCodeID_ICD10 = cSource.nDiagCodeID_ICD10;
	nOrderIndex = cSource.nOrderIndex;		
	sai = cSource.sai;
	bIsNew = cSource.bIsNew;
	// ICD - 9
	strCode = cSource.strCode;
	strCodeDesc = cSource.strCodeDesc;
	// (r.farnworth 2014-02-27 08:42) - PLID 60785 - UPDATE - Add preview pane functionality for icd-10 diag code logic 
	// ICD - 10
	strCode_ICD10 = cSource.strCode_ICD10;
	strCodeDesc_ICD10 = cSource.strCodeDesc_ICD10;
	// (r.farnworth 2014-03-05 14:51) - PLID 60820 - SPAWN - Need to store information on matchtype.
	MatchType = cSource.MatchType;
	// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
	nQuickListID = cSource.nQuickListID;
	bChanged = cSource.bChanged;
	bHasMoved = cSource.bHasMoved;
	// (j.jones 2014-12-23 15:07) - PLID 64491 - added bReplaced
	bReplaced = cSource.bReplaced;

	// (c.haag 2009-05-19 10:03) - PLID 34310 - We now copy problem links
	for(int i = 0; i < cSource.m_apEmrProblemLinks.GetSize(); i++) {
		// (z.manning 2009-08-18 10:19) - PLID 35207 - When copying problem links, check and see if
		// we have another EMN pointer to use to associate with the problem links and if so, use that.
		CEMR *pOwningEmr = NULL;
		if(pEmnOverride != NULL) {
			pOwningEmr = pEmnOverride->GetParentEMR();
		}
		else {
			pEmnOverride = cSource.m_apEmrProblemLinks[i]->GetEMN();
		}
		CEmrProblemLink *pNewLink = new CEmrProblemLink(cSource.m_apEmrProblemLinks[i], pOwningEmr);
		pNewLink->UpdatePointersWithDiagCode(pEmnOverride, this);
		m_apEmrProblemLinks.Add(pNewLink);
	}
}

// (r.gonet 2015-01-06 11:02) - PLID 64509 - Added.
// Returns TRUE if any problem links are changed. FALSE otherwise.
BOOL EMNDiagCode::HasChangedProblemLinks()
{
	try {
		for (int i = 0; i < m_apEmrProblemLinks.GetSize(); i++) {
			CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(i);
			if (pProblemLink != NULL) {
				if (pProblemLink->GetID() == -1) {
					return TRUE;
				}
			}
		}

	} NxCatchAll(__FUNCTION__);

	return FALSE;
}

// (c.haag 2016-06-09 14:54) - PLID-66502 - Write pertinent information about this EMR object to NxLog. This is used to help pin down save errors.
void EMNDiagCode::LogEmrObjectData(int nIndent, BOOL bDeleted)
{
	// Log this object
	::LogEmrObjectData(nIndent, nID, this, esotDiagCode, (nID == -1), bChanged, bDeleted, strCodeDesc_ICD10 + "(" + strCodeDesc + ")",
		"nDiagCodeID_ICD10 = %d  nDiagCodeID = %d  sourceActionID = %d  sourceDetailID = %d  sourceDataGroupID = %d  sourceDetailImageStampID = %d"
		, nDiagCodeID_ICD10
		, nDiagCodeID
		, sai.nSourceActionID
		, sai.GetSourceDetailID()
		, sai.GetDataGroupID()
		, sai.GetDetailStampID()
	);

	// Log problems and problem links
	for (auto l : m_apEmrProblemLinks)
	{
		if (nullptr != l)
		{
			CEmrProblem* p = l->GetProblem();
			if (nullptr != p)
			{
				p->LogEmrObjectData(nIndent + 1);
			}
			if (nullptr != l)
			{
				l->LogEmrObjectData(nIndent + 1);
			}
		}
	}
}

// (a.walling 2013-01-16 13:04) - PLID 54650 - Appointment linking
// returns <None> or ID
CString EMNAppointment::GetAuditString() const
{ 
	if (nID != -1) {
		return FormatString("%li", nID); 
	}
	return "<None>";
}

// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated
/*
CString NarrativeMergeField::GetSentenceFormat()
{
	//
	// (c.haag 2007-03-29 17:25) - PLID 25423 - Functions that used to execute
	//		str = field.strSentenceFormat
	// now call
	//		str = field.GetSentenceFormat()
	//
	// We now support retaining detail objects in merge fields, and calculating the value
	// and sentence formats on demand. If the detail object is not null, then we will calculate
	// those values, reset the object to NULL, and return the desired value
	//
	if (NULL != pPendingDetail && NULL != pPendingDetailEMN) {
		CString strDataOutput = pPendingDetailEMN->GetDataOutput(pPendingDetail, NULL, false, false);
		strValue = strDataOutput;
		strSentenceFormat = pPendingDetailEMN->GetSentence(pPendingDetail, NULL, false, false, ecfParagraph, strDataOutput);
		pPendingDetail = NULL;
	}
	return strSentenceFormat;
}
*/

// (a.walling 2010-10-18 17:07) - PLID 40260 - Allow using a default connection
CEMN::CEMN(CEMR *pParentEMR, ADODB::_ConnectionPtr pDefaultConnection)
	: m_pDefaultConnection(pDefaultConnection)
{
	m_bInDestructor = FALSE; // (c.haag 2007-10-30 17:28) - PLID 27914
	m_nID = -1;
	m_nTemplateID = -1;
	m_bIsTemplate = FALSE;
	m_pLoader = NULL;
	m_pRetiredTemplateLoader = NULL;
	//m_pEMNMoreInfoDlg = NULL;
	m_cbPatientGender = 0;
	m_pParentEMR = pParentEMR;
	if(!m_pParentEMR) {
		m_bOwnParentEMR = TRUE;
	}
	else {
		m_bOwnParentEMR = FALSE;
	}
	m_nRefCnt = 1;
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	m_Status.nID = 0;
	m_Status.strName = "Open";
	m_nPatientCreatedStatus = 0; // (z.manning 2009-11-19 09:04) - PLID 35810
	m_nEMRCollectionID = -1;
	m_pInterface = NULL;
	m_Location.nID = GetCurrentLocationID();
	m_Location.strName = GetCurrentLocationName();
	// (a.walling 2008-07-01 16:30) - PLID 30586
	m_Location.strLogo = GetCurrentLocationLogo();
	// (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width
	m_Location.nLogoWidth = GetCurrentLocationLogoWidth();
	m_dtEMNDate = COleDateTime::GetCurrentTime();
	// (a.walling 2012-06-07 08:53) - PLID 50920 - Dates - Modified, Created
	m_dtEMNInputDate = m_dtEMNDate;
	m_dtEMNModifiedDate = m_dtEMNDate;
	m_dtEMNDate.SetDateTime(m_dtEMNDate.GetYear(), m_dtEMNDate.GetMonth(),m_dtEMNDate.GetDay(), 0, 0, 0);
	m_bUnsaved = FALSE;
	m_bMoreInfoUnsaved = FALSE;
	m_bCodesUnsaved = FALSE;
	m_bOwnChildren = TRUE;
	m_bAddOnce = FALSE;
	m_bDetailsHaveMoved = FALSE;
	m_bNeedRegenerateTableItemList = TRUE;
	m_strPatNameFirst.Empty();
	m_strPatNameMiddle.Empty();
	m_strPatNameLast.Empty();
	m_Category.nID = -1;
	m_Chart.nID = -1;

	// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
	m_nVisitTypeID = -1;
	m_strVisitTypeName = "";
	// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
	m_DischargeStatus.nID = -1;
	m_DischargeStatus.strCode = "";
	m_DischargeStatus.strDesc = "";
	COleDateTime dtEmpty;
	dtEmpty.SetStatus(COleDateTime::null);
	m_dtAdmissionTime = dtEmpty;
	m_dtDischargeTime = dtEmpty;

	//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
	m_bHideTitleOnPreview = false;

	m_dtLastSavedDate = m_dtEMNDate;
	m_LastSavedLocation.nID = m_Location.nID;
	// (a.walling 2013-01-16 13:30) - PLID 54652 - Last saved appointment
	m_LastSavedAppointment = m_Appointment;
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	m_LastSavedStatus = m_Status;
	// (z.manning, 04/19/2007) - PLID 25714
	m_LastSavedChart.nID = m_Chart.nID;
	m_LastSavedCategory.nID = m_Category.nID;

	// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
	m_LastSavedDischargeStatus.nID = m_DischargeStatus.nID;
	m_dtLastSavedAdmissionTime = m_dtAdmissionTime;
	m_dtLastSavedDischargeTime = m_dtDischargeTime;

	m_bInitialLoadComplete = FALSE;
	m_bInitialLoadPendingCompletion = FALSE;

	m_bTopicArrayChanged = FALSE;

	//TES 1/23/2008 - PLID 24157 - Renamed.
	m_nDetailChangeLocks = 0;

	// (j.jones 2007-09-11 17:41) - PLID 27243 - Office Visit incrementing is no longer
	// used in the L2 EMR, it's in Custom Records only
	//m_bAlreadyDeclinedOfficeVisitUpgrade = FALSE;

	// (c.haag 2007-01-23 11:38) - PLID 24376 - This will be set to TRUE
	// whenever someone edits any official Current Medications detail
	m_bUpdatingCurrentMedicationDetails = FALSE;

	// (c.haag 2007-04-05 11:26) - PLID 25516 - TRUE if we are traversing
	// the EMR for official Allergies details and making sure all of the states are the same
	m_bUpdatingAllergiesDetails = FALSE;

	// (j.jones 2007-01-29 13:30) - PLID 24353 - initialize the start time
	m_bIsTrackingTime = FALSE;
	m_dtStartEditingTime.SetStatus(COleDateTime::invalid);
	m_bChangesMadeThisSession = FALSE;

	// (j.jones 2007-09-17 17:52) - PLID 27396 - initialize the total time opened to 0, not invalid
	m_dtTotalTimeOpened_PreviousSessions.SetDateTimeSpan(0, 0, 0, 0);

	// (a.walling 2007-04-10 13:12) - PLID 25548
	m_bNeedToSavePreview = FALSE;
	// (a.walling 2008-08-12 10:59) - PLID 31037 - Has the preview been rebuilt for this session?
	m_bIsPreviewCurrent = FALSE;

	//TES 4/11/2007 - PLID 25456 - Nothing's popped up until something tells us it is.
	// (a.walling 2007-08-23 11:26) - PLID 27160 - we use a list now.
	// m_pPoppedUpDetail = NULL;

	// (j.jones 2007-06-14 11:38) - PLID 26276 - the Completion Status
	m_ecsCompletionStatus = ecsNeedsCalculated;
	m_ecsLastSavedCompletionStatus = ecsNeedsCalculated;

	// (j.jones 2007-08-06 16:08) - PLID 26974 - store the last saved Patient Demographics
	m_strLastSavedPatNameFirst = m_strPatNameFirst;
	m_strLastSavedPatNameMiddle = m_strPatNameMiddle;
	m_strLastSavedPatNameLast = m_strPatNameLast;
	m_cbLastSavedPatientGender = m_cbPatientGender;
	m_strLastSavedPatientAge = m_strPatientAge;
	// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
	m_nLastSavedVisitTypeID = m_nVisitTypeID;
	m_strLastSavedVisitTypeName = m_strVisitTypeName;

	//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
	m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview;

	//TES 1/11/2008 - PLID 24157 - Initialization
	m_pMultiPopupDlg = NULL;

	// (a.walling 2008-06-27 16:55) - PLID 30482
	m_bParentEMRChanged = FALSE;
	// (d.thompson 2009-05-08) - PLID 29909
	m_bConfidentialInfoChanged = false;

	//TES 7/10/2009 - PLID 25154
	// (a.wilson 2013-05-21 14:39) - PLID 56763 - default to false.
	m_bSendBillToHL7 = false;
	m_bChargesChanged = false;

	//TES 4/15/2010 - PLID 24692
	m_pTopicPositionHead = NULL;

	//(e.lally 2011-05-04) PLID 43537 - Reset our visible flag m_bNexWebVisible
	m_bNexWebVisible = FALSE;

	// (j.gruber 2012-08-31 14:43) - PLID 52285 - reset the variable
	m_bIsOMRTemplate = FALSE;

	// (z.manning 2013-09-17 14:18) - PLID 58450
	m_bNeedToHandleCheckSaveEMNForDrugInteractionsOnDetailUnlock = FALSE;
	m_bAlreadySavedAnInteractionChange_WhenUnlockingDetail = TRUE;
}

CEMN::~CEMN()
{
	// (c.haag 2007-10-30 17:28) - PLID 27914 - Flag the fact we are in the destructor
	m_bInDestructor = TRUE;

	// (a.walling 2008-05-22 13:33) - PLID 22049 - Try to release the write token
	if (m_nID != -1 && !GetWriteToken().IsEmpty()) {
		ReleaseWriteToken();
	}

	// (c.haag 2007-08-04 09:42) - PLID 26945 - Destroy the EMN loader
	// object once and for all
	// (c.haag 2007-05-21 13:11) - PLID 26084 - Delete the loader objects
	// regardless of their reference counts
	if (NULL != m_pLoader) {
		delete m_pLoader;
		m_pLoader = NULL;
	}
	// (c.haag 2007-09-10 11:50) - PLID 27024 - Delete the retired loader object
	EnsureNotRetiredTemplateLoader();

	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	// (j.jones 2008-07-22 11:41) - PLID 30789 - remove all problems
	// (c.haag 2009-05-16 14:37) - PLID 34310 - Remove problem links
	for(i = 0; i < m_apEmrProblemLinks.GetSize(); i++) {
		delete m_apEmrProblemLinks[i];
	}
	m_apEmrProblemLinks.RemoveAll();

	m_aryCharges.Clear();
	//TES 6/15/2012 - PLID 50983 - Added m_aryOriginalCharges
	m_aryOriginalCharges.Clear();

	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		delete (EMNMedication*)m_aryMedications.GetAt(i);
	}

	if(m_bOwnChildren) {
		for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
			delete (CEMRTopic*)m_arypEMRTopics.GetAt(i);
		}
	}
	//TES 4/15/2010 - PLID 24692 - Clean up our linked list of topic positions.
	if(m_pTopicPositionHead) {
		m_pTopicPositionHead->FreeDescendants();
		delete m_pTopicPositionHead;
		m_pTopicPositionHead = NULL;
	}
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		delete (EMNDiagCode*)m_aryDiagCodes[i];
	}
	for(i = 0; i < m_aryProcedures.GetSize(); i++) {
		delete (EMNProcedure*)m_aryProcedures[i];
	}
	for(i = 0; i < m_aryProviders.GetSize(); i++) {
		delete (EMNProvider*)m_aryProviders[i];
	}
	// (j.gruber 2007-01-08 11:27) - PLID 23399 - delete the secondary providers from memory
	for(i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
		delete (EMNProvider*)m_arySecondaryProviders[i];
	}
	// (d.lange 2011-03-23 10:40) - PLID 42136 - delete the technicians from memory
	for(i = 0; i < m_aryTechnicians.GetSize(); i++) {
		delete (EMNProvider*)m_aryTechnicians[i];
	}

	// (j.gruber 2009-05-07 16:47) - PLID 33688 - delete the other providers from memory
	for(i = 0; i < m_aryOtherProviders.GetSize(); i++) {
		delete (EMNProvider*)m_aryOtherProviders[i];
	}

	// (z.manning 2011-07-07 13:14) - PLID 44469
	m_arypCodingGroups.ClearAll();

	for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
		delete m_arypDeletedTopics[i];
	}
	// (c.haag 2008-07-21 14:06) - PLID 30725 - EMR problems
	// (c.haag 2009-05-16 14:37) - PLID 34310 - Remove problem links
	for(i = 0; i < m_apEmrProblemLinks.GetSize(); i++) {
		delete m_apEmrProblemLinks[i];
	}
	// (c.haag 2008-07-23 17:58) - PLID 30820 - Deleted charges, medications and diagnosis codes
	for (i=0; i < m_aryDeletedCharges.GetSize(); i++) {
		delete m_aryDeletedCharges[i];
	}
	for (i=0; i < m_aryDeletedDiagCodes.GetSize(); i++) {
		delete m_aryDeletedDiagCodes[i];
	}
	for (i=0; i < m_aryDeletedMedications.GetSize(); i++) {
		delete m_aryDeletedMedications[i];
	}
	// (z.manning 2008-10-06 10:56) - PLID 21094 - Labs
	for (i=0; i < m_aryLabs.GetSize(); i++) {
		delete m_aryLabs.GetAt(i);
	}

	// (c.haag 2008-07-09 12:10) - PLID 30648 - Flush the arrays that had tracked what
	// todo alarms were spawned and unspawned while the topic was unsaved
	// (c.haag 2008-07-14 12:16) - PLID 30696 - Also include created and deleted todos
	// that have no relationship with spawning (in the same array)
	for (i=0; i < m_apCreatedTodosWhileUnsaved.GetSize(); i++) {
		delete m_apCreatedTodosWhileUnsaved[i];
	}
	m_apCreatedTodosWhileUnsaved.RemoveAll();

	for (i=0; i < m_apDeletedTodosWhileUnsaved.GetSize(); i++) {
		delete m_apDeletedTodosWhileUnsaved[i];
	}
	m_apDeletedTodosWhileUnsaved.RemoveAll();

	// (c.haag 2007-04-04 13:25) - PLID 25495 - Clean up our default merge field map
	// (c.haag 2007-07-30 17:08) - PLID 26848 - Properly release the recordsets
	// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated
	/*
	POSITION pos = m_mapDefaultNarrativeFields.GetStartPosition();
	CArray<long, long> anSpawnedGroupIDs;
	while (pos != NULL) {
		LPDISPATCH prs;
		long nSpawnedGroupID;
		m_mapDefaultNarrativeFields.GetNextAssoc( pos, nSpawnedGroupID, prs );
		if (NULL != prs) {
			prs->Release();
		}
	}
	*/

	if(m_bOwnParentEMR) {
		if(m_pParentEMR) {
			delete m_pParentEMR;
			m_pParentEMR = NULL;
		}
	}

	try {
		// (a.walling 2013-03-14 08:51) - PLID 55640 - Already a cdo thread in progress? wait for it to complete before removing temp files
		WaitForCDOThread();

		// (a.walling 2007-04-10 13:31) - PLID 25548
		// (a.walling 2012-03-12 12:43) - PLID 48712 - No HTMLPreviewTempFile anymore basically
		//if (m_strEMRPreviewTempFile.GetLength() > 0) {
		//	// we have a temp file.. so delete it.
		//	DeleteFileWhenPossible(m_strEMRPreviewTempFile);
		//}

		// (a.walling 2007-04-12 12:21) - PLID 25605 - need to handle images
		for (i = 0; i < m_arTempPreviewFiles.GetSize(); i++) {
			DeleteFileWhenPossible(m_arTempPreviewFiles[i]);
		}
	} NxCatchAll("Error removing temp files");

	// (a.walling 2009-10-13 13:56) - PLID 36024
	POSITION popupPos = m_lstPoppedUpDetails.GetHeadPosition();
	while(popupPos) {
		CEMNDetail* pPoppedUpDetail = m_lstPoppedUpDetails.GetNext(popupPos);
		pPoppedUpDetail->__Release("~CEMN dangling popped up detail");
	}

	if(m_pMultiPopupDlg) {
		//TES 1/11/2008 - PLID 24157 - If m_pMultiPopupDlg isn't null, it means we've started spawning things but
		// haven't finished, it shouldn't be possible for this to be destroyed during that time.  So, we ASSERT, but
		// then we might as well go ahead and clean up our memory.
		ASSERT(FALSE);
		delete m_pMultiPopupDlg;
		m_pMultiPopupDlg = NULL;
	}

	//TES 1/28/2008 - PLID 28673 - Its our job to clean up any popup information we've been given.
	for(i = 0; i < m_arDetailPopups.GetSize(); i++) {
		//delete m_arDetailPopups[i];
		DetailPopup *pDp = m_arDetailPopups[i];
		delete pDp;
	}
	m_arDetailPopups.RemoveAll();

	// (a.walling 2008-08-13 13:42) - PLID 31037 - Ensure that the preview pane (and whatever else) no longer has
	// any references to this object
	if (GetInterface() != NULL && ::IsWindow(GetInterface()->GetSafeHwnd())) {
		GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 2);
	}

	// (c.haag 2007-10-30 17:28) - PLID 27914 - Flag the fact we are no longer in the destructor
	m_bInDestructor = FALSE;
}

void CEMN::EnsureNotRetiredTemplateLoader()
{
	// (c.haag 2007-10-02 08:49) - PLID 27024 - Ensures that the "retired" template loader;
	// that is, the CEMNLoader object that was used to load this template, no longer exists.
	// This is either called when a template is saved and the loader becomes out of date; or
	// when we're deleting the CEMN object.
	if (NULL != m_pRetiredTemplateLoader) {
		delete m_pRetiredTemplateLoader;
		m_pRetiredTemplateLoader = NULL;
	}
}

// (s.dhole 2014-03-06 14:19) - PLID 60825
NexGEMMatchType GetNexGEMMatchType(long nMatchType)
{	 
	switch(nMatchType)
		{
			case 0:
				return nexgemtDone;
				break;
			case 1:
				return nexgemtNoMatch;
				break;
			case 2:
				return nexgemtManyMatch;
				break;
			default:
				return nexgemtDone;
		}

}

// (c.haag 2014-07-17) - PLID 54905 - Called to read results from a recordset built from AppendLoadSubQuery_rsChargesWhichCodes
void CEMN::LoadChargesFromEmnRecordsets(long nEmnID, _RecordsetPtr rsCharges, _RecordsetPtr rsWhichCodes)
{
	//Load the charges
	m_aryCharges.RemoveAll();
	//TES 6/15/2012 - PLID 50983 - Added m_aryOriginalCharges
	m_aryOriginalCharges.RemoveAll();
	//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
	//	 are sorted by EMN ID.
	while (!rsCharges->eof && AdoFldLong(rsCharges, "EMRID") == nEmnID) {
		EMNCharge *pNewCharge = new EMNCharge;
		pNewCharge->nID = AdoFldLong(rsCharges, "ID");
		pNewCharge->nServiceID = AdoFldLong(rsCharges, "ServiceID");
		// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category 
		pNewCharge->nCategoryID = AdoFldLong(rsCharges, "Category", -1);
		pNewCharge->nCategoryCount = AdoFldLong(rsCharges, "CategoryCount", 0);
		pNewCharge->strDescription = AdoFldString(rsCharges, "Description", "");
		pNewCharge->strMod1 = AdoFldString(rsCharges, "CPTModifier1", "");
		pNewCharge->strMod2 = AdoFldString(rsCharges, "CPTModifier2", "");
		pNewCharge->strMod3 = AdoFldString(rsCharges, "CPTModifier3", "");
		pNewCharge->strMod4 = AdoFldString(rsCharges, "CPTModifier4", "");
		pNewCharge->dblQuantity = AdoFldDouble(rsCharges, "Quantity", 0.0);
		pNewCharge->cyUnitCost = AdoFldCurrency(rsCharges, "UnitCost", COleCurrency(0, 0));
		pNewCharge->bChanged = FALSE;
		pNewCharge->sai.nSourceActionID = AdoFldLong(rsCharges, "SourceActionID", -1);
		// (j.jones 2007-01-11 10:20) - PLID 24027 - supported SourceDetailID
		pNewCharge->sai.nSourceDetailID = AdoFldLong(rsCharges, "SourceDetailID", -1);
		// (z.manning 2009-02-26 11:36) - PLID 33141 - SourceDataGroupID
		pNewCharge->sai.SetDataGroupID(AdoFldLong(rsCharges, "SourceDataGroupID", -1));
		// (z.manning 2010-02-25 10:05) - PLID 37532
		pNewCharge->sai.SetDetailStampID(AdoFldLong(rsCharges, "SourceDetailImageStampID", -1));
		pNewCharge->sai.eaoSourceType = (EmrActionObject)AdoFldLong(rsCharges, "SourceType", eaoInvalid);
		pNewCharge->strSubCode = AdoFldString(rsCharges, "SubCode", "");
		pNewCharge->strCode = AdoFldString(rsCharges, "Code", "");
		// (j.jones 2008-06-04 16:21) - PLID 30255 - added nQuoteChargeID
		pNewCharge->nQuoteChargeID = AdoFldLong(rsCharges, "QuoteChargeID", -1);
		// (j.jones 2011-03-28 14:45) - PLID 42575 - added Billable flag
		pNewCharge->bBillable = AdoFldBool(rsCharges, "Billable", TRUE);
		// (j.dinatale 2012-01-05 10:30) - PLID 39451 - need to see if we had an entry in EMRChargeRespT.
		// if for some reason it doesnt have an entry in EMRChargeRespT, then we know its not assigned a resp.
		// if we do have an entry, but the InsuredPartyID is null, then we know its patient resp
		if (AdoFldLong(rsCharges, "RespChargeID", -1) != -1){
			// patient resp (if InsuredPartyID is null) or other resp
			pNewCharge->nInsuredPartyID = AdoFldLong(rsCharges, "InsuredPartyID", -1);
		}
		else{
			// unassigned
			pNewCharge->nInsuredPartyID = -2;
		}

		m_aryCharges.Add(pNewCharge);
		rsCharges->MoveNext();
	}

	//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
	//	 are sorted by EMN ID.
	while (!rsWhichCodes->eof && AdoFldLong(rsWhichCodes, "EMRID") == nEmnID) {
		//We just need to append each code to it's EMNCharge
		long nChargeID = AdoFldLong(rsWhichCodes, "ID");
		//TES 2/28/2014 - PLID 61080 - Added ICD-10 fields
		long nDiagID = AdoFldLong(rsWhichCodes, "DiagCodeID", -1);
		CString strCode = AdoFldString(rsWhichCodes, "CodeNumber", "");
		long nDiagID_ICD10 = AdoFldLong(rsWhichCodes, "DiagCodeID_ICD10", -1);
		CString strICD10Code = AdoFldString(rsWhichCodes, "ICD10CodeNumber", "");

		BOOL bFound = FALSE;
		for (int i = 0; i < m_aryCharges.GetSize() && !bFound; i++) {
			EMNCharge *pCharge = m_aryCharges.GetAt(i);
			if (pCharge->nID == nChargeID) {
				bFound = TRUE;
				// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs, and added strDiagCodeList
				//TES 2/28/2014 - PLID 61080 - We need the index within the EMN
				long nIndex = GetDiagCodeIndexByDiagID(nDiagID, nDiagID_ICD10);
				//TES 3/20/2014 - PLID 61080 - There is bad data out there where charges are linked to diagnoses that aren't in the list. In that case
				// just don't add it to our array (I had previously been throwing an exception, but there's too much bad data out there, and this will
				// just cause the code to be ignored, as it has been up until now).
				if (nIndex != -1) {
					pCharge->aryDiagIndexes.Add(nIndex);
				}


				//TES 2/28/2014 - PLID 61080 - Use the audit value that incorporates both codes
				CString strCodeForAudit = GenerateEMRDiagCodesTAuditValue(strCode, strICD10Code);
				if (pCharge->strDiagCodeList.IsEmpty()) {
					pCharge->strDiagCodeList += strCodeForAudit;
				}
				else {
					pCharge->strDiagCodeList += ", " + strCodeForAudit;
				}
			}
		}

		rsWhichCodes->MoveNext();
	}
}

//DRT 7/27/2007 - PLID 26836 - Added bLoadInBackground parameter.  If this flag is set to TRUE, the EMN preloader
//	will work in the "large single load" mode.  This means that the EMN will load using less recordsets & server resources, 
//	but it must wait until the whole EMN is loaded to display.  This should be set to TRUE for all EMNs which will not
//	be initially displayed to the user (for example, loading an EMR from data that has 8 EMNs on it -- 7 of them will be
//	loaded in the background, and the one that is displayed will not be).
//DRT 9/13/2007 - PLID 27384 - The input to this function has now changed slightly.  We still get the same set of
//	recordsets that we received before, however that set of recordsets now contains the data for all EMNs in the EMR, 
//	not just this single EMN.  There is an "EMRID" field in every recordset that must be filtered on to the current.
//_RecordsetPtr CEMN::LoadFromEmnRecordsets(long nEmnID, _Recordset *lprsAllRecordsets, BOOL bLoadInBackground)
// (j.jones 2008-10-31 13:00) - PLID 31869 - passed in a connection pointer
void CEMN::LoadFromEmnRecordsets(long nEmnID, LoadEMNRecordsets_Objects* pLero, BOOL bLoadInBackground, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	try {

		// (j.jones 2008-10-31 13:01) - PLID 31869 - converted to support a passed-in connection
		_ConnectionPtr pCon;
		if(lpCon) {
			pCon = lpCon;
		}
		else {
			pCon = GetRemoteData();
		}

		// (b.cardillo 2006-06-01 16:06) - PLID 20861 - All the recordsets we need are given to 
		// us via the recordset parameter.  We'll just keep advancing to the next one by calling 
		// prsNextRecordset->NextRecordset() each time.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//_RecordsetPtr prsNextRecordset(lprsAllRecordsets);

		BOOL bLocalIgnoringProcessActions = FALSE;

		m_nID = nEmnID;
		m_bIsTemplate = FALSE;
		if(!m_pParentEMR) {
			ASSERT(m_bOwnParentEMR);
			// (a.walling 2010-10-18 17:32) - PLID 40260 - Allow using a default connection
			m_pParentEMR = new CEMR(FALSE, GetRemoteData());
			m_pParentEMR->LoadFromEmn(this, pCon);

			// (j.jones 2006-02-13 14:49) - used to stop actions from firing when loading an existing EMN
			m_pParentEMR->m_bIgnoreActions = TRUE;
			bLocalIgnoringProcessActions = TRUE;
		}
		SetInterface(m_pParentEMR->GetInterface());

		// (a.walling 2012-03-12 12:43) - PLID 48712 - Since we always reload this anyway, loading the existing one is just a waste of time, and might be causing trouble.
		//// (a.walling 2007-04-10 13:09) - PLID 25548 - Load the preview
		//if(GetInterface()) {
		//	// sending NULL will tell our preview window to attempt to load an existing file from the patient documents
		//	LRESULT lrVal = GetInterface()->SendMessage(NXM_EMN_PREVIEW_LOAD, (WPARAM)this, NULL);

		//	if (lrVal == EMR_PREVIEW_LOADED) {
		//		m_bEMRPreviewLoaded = TRUE;
		//	} else if (lrVal == EMR_PREVIEW_FAILED) {
		//		m_bEMRPreviewLoaded = FALSE;
		//	} else {
		//		// the message was not handled! if this is true, we shouldn't have an InterfaceWnd to begin with.
		//		ASSERT(FALSE);
		//	}
		//}

		//load all the topics and details, but not the detail dialogs

		//first load the EMN-level data.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsEMN = pLero->prsEMNInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this recordset, we need to filter.  This will also
		//	have to become a while loop.  The records are in order by EMN ID
		while(!rsEMN->eof && AdoFldLong(rsEMN, "EMRID") == nEmnID) {
			m_dtEMNDate = AdoFldDateTime(rsEMN, "Date",COleDateTime::GetCurrentTime());
			// (a.walling 2012-06-07 08:52) - PLID 50920 - Dates - Modified, Created
			m_dtEMNInputDate = AdoFldDateTime(rsEMN, "InputDate", COleDateTime::GetCurrentTime());
			m_dtEMNModifiedDate = AdoFldDateTime(rsEMN, "ModifiedDate", COleDateTime::GetCurrentTime());
			// (z.manning 2010-01-13 11:39) - PLID 22672 - Age is now a string
			m_strPatientAge = AdoFldString(rsEMN, "PatientAge","");
			m_strDescription = AdoFldString(rsEMN, "Description","");
			m_strNotes = AdoFldString(rsEMN, "AdditionalNotes","");
			m_nTemplateID = AdoFldLong(rsEMN, "TemplateID", -1);
			m_Status.nID = AdoFldLong(rsEMN, "Status", 0);
			m_Status.strName = AdoFldString(rsEMN, "StatusName", "Open");
			m_nPatientCreatedStatus = AdoFldByte(rsEMN, "PatientCreatedStatus", 0);
			m_nEMRCollectionID = AdoFldLong(rsEMN, "EMRCollectionID", -1);
			m_sai.nSourceActionID = AdoFldLong(rsEMN, "SourceActionID", -1);
			// (j.jones 2007-01-11 10:20) - PLID 24027 - supported SourceDetailID
			m_sai.nSourceDetailID = AdoFldLong(rsEMN, "SourceDetailID", -1);
			// (z.manning 2009-03-04 14:28) - PLID 33338 - SourceDataGroupID
			m_sai.SetDataGroupID(AdoFldLong(rsEMN, "SourceDataGroupID", -1));
			m_sai.SetDetailStampID(AdoFldLong(rsEMN, "SourceDetailImageStampID", -1));
			m_sai.eaoSourceType = (EmrActionObject)(rsEMN->Fields, "SourceType", eaoInvalid);
			// (a.walling 2013-01-16 13:04) - PLID 54650 - Appointment linked with this EMN
			m_Appointment = EMNAppointment(AdoFldLong(rsEMN, "AppointmentID", -1));  
			// (z.manning, 05/07/2007) - PLID 25925 - We now track both location ID and name.
			m_Location.nID = AdoFldLong(rsEMN, "LocationID", -1);
			m_Location.strName = AdoFldString(rsEMN, "LocationName", "");
			// (a.walling 2008-07-01 15:00) - PLID 30586 - Also the location logo path
			m_Location.strLogo = AdoFldString(rsEMN, "LocationLogo", "");
			// (a.walling 2010-10-29 10:33) - PLID 31435 - Also the location logo width
			m_Location.nLogoWidth = AdoFldLong(rsEMN, "LocationLogoWidth", 100);
			// (z.manning, 04/11/2007) - PLID 25569 - Chart
			SetChart(AdoFldLong(rsEMN, "EmnTabChartID", -1), AdoFldString(rsEMN, "ChartName", ""));
			// (z.manning, 05/07/2007) - PLID 25731 - Category
			m_Category.nID = AdoFldLong(rsEMN, "EmnTabCategoryID", -1);
			m_Category.strName = AdoFldString(rsEMN, "CategoryName", "");
			// (j.jones 2007-06-14 11:41) - PLID 26276 - CompletionStatus
			m_ecsCompletionStatus = (EMNCompletionStatus)AdoFldLong(rsEMN, "CompletionStatus", -1);

			// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
			m_nVisitTypeID = AdoFldLong(rsEMN, "VisitTypeID", -1);
			m_strVisitTypeName = AdoFldString(rsEMN, "VisitTypeName", "");
			// (d.thompson 2009-05-27) - PLID 29909 - Added confidential info
			m_strConfidentialInfo = AdoFldString(rsEMN, "ConfidentialInfo");

			//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
			m_bHideTitleOnPreview = AdoFldBool(rsEMN, "HideTitleOnPreview", FALSE)?true:false;

			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			m_DischargeStatus.nID = AdoFldLong(rsEMN, "DischargeStatusID", -1);
			m_DischargeStatus.strCode = AdoFldString(rsEMN, "DischargeStatusCode", "");
			m_DischargeStatus.strDesc = AdoFldString(rsEMN, "DischargeStatusDesc", "");
			COleDateTime dtEmpty;
			dtEmpty.SetStatus(COleDateTime::null);
			m_dtAdmissionTime = AdoFldDateTime(rsEMN, "AdmissionTime", dtEmpty);
			m_dtDischargeTime = AdoFldDateTime(rsEMN, "DischargeTime", dtEmpty);

			// (j.jones 2007-09-18 08:49) - PLID 27396 - added TotalTimeInSeconds
			long nTotalTimeInSeconds = AdoFldLong(rsEMN, "TotalTimeInSeconds", -1);
			if(nTotalTimeInSeconds == -1)
				//set to 0, not invalid
				m_dtTotalTimeOpened_PreviousSessions.SetDateTimeSpan(0, 0, 0, 0);
			else
				SetTotalTimeOpened_PreviousSessions(nTotalTimeInSeconds);

			// (j.jones 2007-08-06 14:47) - PLID 26974 - We now will always use the patient info. from the saved EMN,
			// and never revert to the current patient info. Locked or unlocked, it doesn't matter.

			//m.hancock - 3/13/2006 - 19579 - Patient demographics shouldn't change after the EMN is locked.
			//if(m_nStatus == 2) { //The EMN is locked, so retrieve and display the stored values
				//Name
				m_strPatNameFirst = AdoFldString(rsEMN, "PatientFirst","");
				m_strPatNameMiddle = AdoFldString(rsEMN, "PatientMiddle","");
				m_strPatNameLast = AdoFldString(rsEMN, "PatientLast","");
				//If the name fields are blank (because of records created prior to this change), lookup the patient's name.
				//Only check the first and last name because it is common for middle name to be blank.
				if(m_strPatNameFirst.IsEmpty() || m_strPatNameLast.IsEmpty()) {
					//DRT 8/28/2007 - PLID 27207 - Parameterized.
					_RecordsetPtr rsPatientInfo = CreateParamRecordset(pCon, "SELECT First, Middle, Last FROM PersonT WHERE ID = {INT}", GetParentEMR()->GetPatientID());
					if(!rsPatientInfo->eof) {
						m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
						m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
						m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					}
				}
				//Gender
				m_cbPatientGender = AdoFldByte(rsEMN, "PatientGender",0);
			//}
			/*
			else { //The EMN is active, so retrieve and display the currently set values from the patient's data
				_RecordsetPtr rsPatientInfo = CreateRecordset("SELECT First, Middle, Last, Gender FROM PersonT WHERE ID = %li", GetParentEMR()->GetPatientID());
				if(!rsPatientInfo->eof) {
					//Name
					m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
					m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
					m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					//Gender
					m_cbPatientGender = AdoFldByte(rsPatientInfo, "Gender", 0);
				}
			}
			*/

			// (a.walling 2008-05-29 10:43) - PLID 22049 - Added Revision
			SetRevision(rsEMN->Fields->Item["Revision"]->Value);

			//These were all just loaded from data, so...
			m_dtLastSavedDate = m_dtEMNDate;
			m_LastSavedLocation.nID = m_Location.nID;
			m_LastSavedLocation.strName = m_Location.strName;
			// (a.walling 2008-07-01 15:00) - PLID 30586
			m_LastSavedLocation.strLogo = m_Location.strLogo;
			// (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width
			m_LastSavedLocation.nLogoWidth = m_Location.nLogoWidth;
			// (a.walling 2013-01-16 13:30) - PLID 54652 - Last saved appointment
			m_LastSavedAppointment = m_Appointment;
			// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
			m_LastSavedStatus = m_Status;
			m_strLastSavedNotes = m_strNotes;
			m_strLastSavedDescription = m_strDescription;
			// (z.manning, 04/19/2007) - PLID 25714
			m_LastSavedChart.nID = m_Chart.nID;
			m_LastSavedCategory.nID = m_Category.nID;
			// (z.manning, 05/07/2007) - PLID 25731
			m_LastSavedChart.strName = m_Chart.strName;
			m_LastSavedCategory.strName = m_Category.strName;
			// (j.jones 2007-06-14 11:42) - PLID 26276 - CompletionStatus
			m_ecsLastSavedCompletionStatus = m_ecsCompletionStatus;

			// (j.jones 2007-08-06 16:08) - PLID 26974 - store the last saved Patient Demographics
			m_strLastSavedPatNameFirst = m_strPatNameFirst;
			m_strLastSavedPatNameMiddle = m_strPatNameMiddle;
			m_strLastSavedPatNameLast = m_strPatNameLast;
			m_cbLastSavedPatientGender = m_cbPatientGender;
			m_strLastSavedPatientAge = m_strPatientAge;
			// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
			m_nLastSavedVisitTypeID = m_nVisitTypeID;
			m_strLastSavedVisitTypeName = m_strVisitTypeName;

			//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
			m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview;

			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			m_LastSavedDischargeStatus.nID = m_DischargeStatus.nID;
			m_LastSavedDischargeStatus.strCode = m_DischargeStatus.strCode;
			m_LastSavedDischargeStatus.strDesc = m_DischargeStatus.strDesc;
			m_dtLastSavedAdmissionTime = m_dtAdmissionTime;
			m_dtLastSavedDischargeTime = m_dtDischargeTime;

			//DRT 9/13/2007 - PLID 27384 - We're now looping
			rsEMN->MoveNext();
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//Load the procedures.
		m_aryProcedures.RemoveAll();
		_RecordsetPtr rsProcs = pLero->prsProcInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsProcs->eof && AdoFldLong(rsProcs, "EMRID") == nEmnID) {
			EMNProcedure *pProc = new EMNProcedure;
			pProc->nID = AdoFldLong(rsProcs, "ProcedureID");
			pProc->sai.nSourceActionID = AdoFldLong(rsProcs, "SourceActionID", -1);
			// (j.jones 2007-01-11 10:20) - PLID 24027 - supported SourceDetailID
			pProc->sai.nSourceDetailID = AdoFldLong(rsProcs, "SourceDetailID", -1);
			// (z.manning 2009-02-27 10:35) - PLID 33141 - SourceDataGroupID
			pProc->sai.SetDataGroupID(AdoFldLong(rsProcs, "SourceDataGroupID", -1));
			// (z.manning 2010-02-25 10:04) - PLID 37532
			pProc->sai.SetDetailStampID(AdoFldLong(rsProcs, "SourceDetailImageStampID", -1));
			pProc->sai.eaoSourceType = (EmrActionObject)AdoFldLong(rsProcs, "SourceType", eaoInvalid);
			pProc->bIsNew = FALSE;
			pProc->strName = AdoFldString(rsProcs, "Name", "");
			m_aryProcedures.Add(pProc);

			//DRT 9/6/2007 - PLID 27310 - Moved below this loop, see comments there.
			//if(GetInterface())
			//	GetInterface()->SendMessage(NXM_EMN_PROCEDURE_ADDED, (WPARAM)pProc, (LPARAM)this);

			rsProcs->MoveNext();
		}

		//DRT 9/6/2007 - PLID 27310 - Instead of firing off "new procedure" messages for each
		//	iteration of the loop, let's do it all at the end!  The PICContainerDlg ends up
		//	with these messages, and it sometimes does several data accesses to lookup more
		//	information that it needs in regards to master procedures, etc.
		//We are safe to send our member array because we're using SendMessage, so there's no concern
		//	about the message being hung up in the queue for a time and more procedures being added
		//	before it's processed (thus causing duplicate processing).
		if(m_aryProcedures.GetSize() > 0) {
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_EMN_MULTI_PROCEDURES_ADDED, (WPARAM)&m_aryProcedures, (LPARAM)this);
			}
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//Load the diag codes
		m_aryDiagCodes.RemoveAll();
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsDiags = pLero->prsDiagInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsDiags->eof && AdoFldLong(rsDiags, "EMRID") == nEmnID) {
			EMNDiagCode *pCode = new EMNDiagCode;
			// (j.jones 2008-07-23 10:20) - PLID 30819 - changed the original nID to nDiagCodeID,
			// then added a new nID for the actual record ID
			pCode->nID = AdoFldLong(rsDiags, "ID");
			//TES 2/28/2014 - PLID 61046 - DiagCodeID might be null
			pCode->nDiagCodeID = AdoFldLong(rsDiags, "DiagCodeID",-1);
			pCode->sai.nSourceActionID = AdoFldLong(rsDiags, "SourceActionID", -1);
			// (j.jones 2007-01-11 10:20) - PLID 24027 - supported SourceDetailID
			pCode->sai.nSourceDetailID = AdoFldLong(rsDiags, "SourceDetailID", -1);
			pCode->sai.SetDataGroupID(AdoFldLong(rsDiags, "SourceDataGroupID", -1));
			// (z.manning 2010-02-25 10:05) - PLID 37532
			pCode->sai.SetDetailStampID(AdoFldLong(rsDiags, "SourceDetailImageStampID", -1));
			pCode->sai.eaoSourceType = (EmrActionObject)AdoFldLong(rsDiags, "SourceType", eaoInvalid);
			pCode->bIsNew = FALSE;
			pCode->strCode = AdoFldString(rsDiags, "CodeNumber", "");
			pCode->strCodeDesc = AdoFldString(rsDiags, "CodeDesc", "");
			pCode->nOrderIndex = AdoFldLong(rsDiags, "OrderIndex", -1);
			//TES 2/28/2014 - PLID 61046 - Added ICD-10 fields
			pCode->nDiagCodeID_ICD10 = AdoFldLong(rsDiags, "DiagCodeID_ICD10", -1);
			pCode->strCode_ICD10 = AdoFldString(rsDiags, "ICD10CodeNumber", "");
			pCode->strCodeDesc_ICD10 = AdoFldString(rsDiags, "ICD10CodeDesc", "");
			// (s.dhole 2014-03-06 12:44) - PLID 60825 load EmrDiagCodesT.NexGEMMatchType 
			pCode->MatchType = GetNexGEMMatchType (AdoFldByte(rsDiags, "NexGEMMatchType",0));
			// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
			pCode->nQuickListID = AdoFldLong(rsDiags, "QuickListID", -1);
			pCode->bHasMoved = FALSE;
			pCode->bChanged = FALSE;
			// (j.jones 2014-12-23 15:07) - PLID 64491 - added bReplaced
			pCode->bReplaced = FALSE;
			m_aryDiagCodes.Add(pCode);
			rsDiags->MoveNext();
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		// (c.haag 2014-07-17) - PLID 54905 - Load the charges and charge WhichCodes from a utility function
		LoadChargesFromEmnRecordsets(nEmnID, pLero->prsChargeInfo, pLero->prsWhichCodesInfo);

		// (z.manning 2011-07-07 12:51) - PLID 44469 - Load EMN coding group data
		_RecordsetPtr prsEmnCodingGroupData = pLero->prsEmrCodingGroupData;
		for(; !prsEmnCodingGroupData->eof && AdoFldLong(prsEmnCodingGroupData, "EmnID") == nEmnID; prsEmnCodingGroupData->MoveNext())
		{
			CEmnCodingGroupInfo *pCodingGroupInfo = new CEmnCodingGroupInfo;
			pCodingGroupInfo->m_nEmrCodingGroupID = AdoFldLong(prsEmnCodingGroupData, "EmrCodingGroupID");
			pCodingGroupInfo->m_nGroupQuantity = AdoFldLong(prsEmnCodingGroupData, "GroupQuantity");

			// (j.jones 2011-07-11 14:25) - PLID 44509 - added booleans to track if this group is new or modified,
			// as well as m_nOldQuantity, used for auditing purposes
			pCodingGroupInfo->m_bIsNew = FALSE;
			pCodingGroupInfo->m_bIsModified = FALSE;
			pCodingGroupInfo->m_nOldQuantity = pCodingGroupInfo->m_nGroupQuantity;

			m_arypCodingGroups.Add(pCodingGroupInfo);
		}

		//DRT 1/16/2007 - PLID 24177 - Added a recordset to handle all charge -> diagnosis code links
		//	via the WhichCodes field.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		// (c.haag 2014-07-17) - PLID 54905 - We now load WhichCodes from LoadChargesFromEmnRecordsets
		//_RecordsetPtr prsWhichcodes = pLero->prsWhichCodesInfo;

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//Load the medications
		m_aryMedications.RemoveAll();
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsMedications = pLero->prsMedicationInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsMedications->eof && AdoFldLong(rsMedications, "EMRID") == nEmnID) {

			// (j.jones 2009-04-01 15:24) - PLID 33736 - moved to a shared function
			AddMedicationFromRecordset(rsMedications, pCon);

			rsMedications->MoveNext();
		}

		//TES 3/26/2009 - PLID 33262 - Added a recordset to handle all medication -> diagnosis code links
		_RecordsetPtr rsMedDiagCodes = pLero->prsMedDiagCodesInfo;
		while(!rsMedDiagCodes->eof && AdoFldLong(rsMedDiagCodes, "EMRID") == nEmnID) {
			//We just need to append each code to its EMNMedication
			long nMedID = AdoFldLong(rsMedDiagCodes, "ID");
			long nDiagID = AdoFldLong(rsMedDiagCodes, "DiagCodeID");
			CString strCodeNumber = AdoFldString(rsMedDiagCodes, "CodeNumber");
			CString strCodeDesc = AdoFldString(rsMedDiagCodes, "CodeDesc");
			long nSortOrder = AdoFldLong(rsMedDiagCodes, "SortOrder");

			BOOL bFound = FALSE;
			for(int i = 0; i < m_aryMedications.GetSize() && !bFound; i++) {
				EMNMedication *pMed = m_aryMedications.GetAt(i);
				if(pMed->nID == nMedID) {
					bFound = TRUE;
					Med_DiagCodeInfo dci;
					dci.nID = nDiagID;
					dci.strCodeNumber = strCodeNumber;
					dci.strCodeDesc = strCodeDesc;
					dci.nSortOrder = nSortOrder;
					pMed->aryDiagnoses.Add(dci);			
				}
			}

			rsMedDiagCodes->MoveNext();
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//TES 12/26/2006 - PLID 23400 - Load the providers.
		for(int i = 0; i < m_aryProviders.GetSize(); i++) {
			delete m_aryProviders[i];
		}
		m_aryProviders.RemoveAll();
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsProviders = pLero->prsProviderInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsProviders->eof && AdoFldLong(rsProviders, "EMRID") == nEmnID) {
			EMNProvider *pNewProv = new EMNProvider;
			pNewProv->nID = AdoFldLong(rsProviders, "ProviderID");
			pNewProv->strName = AdoFldString(rsProviders, "ProviderName");
			pNewProv->bIsNew = FALSE;
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to true)
			pNewProv->bFloatEMRData = AdoFldBool(rsProviders, "FloatEMRData", TRUE);
			m_aryProviders.Add(pNewProv);
			rsProviders->MoveNext();
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (j.gruber 2007-01-08 11:29) - PLID 23399 - Load Secondary Providers
		for(int j = 0; j < m_arySecondaryProviders.GetSize(); j++) {
			delete m_arySecondaryProviders[j];
		}
		m_arySecondaryProviders.RemoveAll();
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsSecondaryProviders = pLero->prsSecProviderInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsSecondaryProviders->eof && AdoFldLong(rsSecondaryProviders, "EMRID") == nEmnID) {
			EMNProvider *pNewProv = new EMNProvider;
			pNewProv->nID = AdoFldLong(rsSecondaryProviders, "ProviderID");
			pNewProv->strName = AdoFldString(rsSecondaryProviders, "ProviderName");
			pNewProv->bIsNew = FALSE;
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to true)
			pNewProv->bFloatEMRData = AdoFldBool(rsSecondaryProviders, "FloatEMRData", TRUE);
			m_arySecondaryProviders.Add(pNewProv);
			rsSecondaryProviders->MoveNext();
		}

		// (d.lange 2011-03-23 10:43) - PLID 42136 - Load Assistant/Technician
		for(int j = 0; j < m_aryTechnicians.GetSize(); j++) {
			delete m_aryTechnicians[j];
		}
		m_aryTechnicians.RemoveAll();

		_RecordsetPtr rsTechnicians = pLero->prsTechnicianInfo;
		while(!rsTechnicians->eof && AdoFldLong(rsTechnicians, "EMRID") == nEmnID) {
			EMNProvider *pNewTech = new EMNProvider;
			pNewTech->nID = AdoFldLong(rsTechnicians, "PersonID");
			pNewTech->strName = AdoFldString(rsTechnicians, "TechnicianName");
			pNewTech->bIsNew = FALSE;
			m_aryTechnicians.Add(pNewTech);
			rsTechnicians->MoveNext();
		}

		// (j.gruber 2009-05-07 16:48) - PLID 33688 - Other Providers
		for(int j = 0; j < m_aryOtherProviders.GetSize(); j++) {
			delete m_aryOtherProviders[j];
		}
		m_aryOtherProviders.RemoveAll();
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsOtherProviders = pLero->prsOtherProviderInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have the data for all EMNs in this EMR, so we need to filter.  The records
		//	 are sorted by EMN ID.
		while(!rsOtherProviders->eof && AdoFldLong(rsOtherProviders, "EMRID") == nEmnID) {
			EMNProvider *pNewProv = new EMNProvider;
			pNewProv->nID = AdoFldLong(rsOtherProviders, "ProviderID");
			pNewProv->strName = AdoFldString(rsOtherProviders, "ProviderName");
			pNewProv->nTypeID = AdoFldLong(rsOtherProviders, "ProvTypeID", -1);
			pNewProv->strTypeName = AdoFldString(rsOtherProviders, "Description", "");
			pNewProv->bIsNew = FALSE;
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to true)
			pNewProv->bFloatEMRData = AdoFldBool(rsOtherProviders, "FloatEMRData", TRUE);
			m_aryOtherProviders.Add(pNewProv);
			rsOtherProviders->MoveNext();
		}


		// (z.manning 2008-10-07 08:40) - PLID 21094 - Labs
		_RecordsetPtr prsLabs = pLero->prsLabInfo;
		while(!prsLabs->eof && AdoFldLong(prsLabs, "EmrID") == nEmnID)
		{
			EMNLab *pLab = new EMNLab;
			pLab->nID = AdoFldLong(prsLabs, "LabID");
			pLab->nLabProcedureID = AdoFldLong(prsLabs, "LabProcedureID");
			pLab->bIsNew = FALSE;
			pLab->sai.nSourceActionID = AdoFldLong(prsLabs, "SourceActionID", -1);
			pLab->sai.nSourceDetailID = AdoFldLong(prsLabs, "SourceDetailID", -1);
			// (z.manning 2009-02-26 17:49) - PLID 33141 - SourceDataGroupID
			pLab->sai.SetDataGroupID(AdoFldLong(prsLabs, "SourceDataGroupID", -1));
			// (z.manning 2010-02-25 10:09) - PLID 37532
			pLab->sai.SetDetailStampID(AdoFldLong(prsLabs, "SourceDetailImageStampID", -1));
			pLab->sai.eaoSourceType = (EmrActionObject)AdoFldLong(prsLabs, "SourceType", eaoInvalid);
			pLab->strAnatomicLocation = AdoFldString(prsLabs, "AnatomicLocation", "");
			//TES 11/10/2009 - PLID 36260 - Replaced AnatomySide with AnatomyQualifierID
			//TES 12/8/2009 - PLID 36512 - AnatomySide is back!
			pLab->eAnatomicSide = (AnatomySide)AdoFldLong(prsLabs, "AnatomySide", 0);
			pLab->strAnatomicLocationQualifier = AdoFldString(prsLabs, "LocationQualifier", "");
			pLab->strClinicalData = AdoFldString(prsLabs, "ClinicalData", "");
			// (z.manning 2008-10-24 12:00) - PLID 31561 - Added type and to be ordered
			pLab->eType = (LabType)AdoFldByte(prsLabs, "Type", ltBiopsy);
			pLab->strToBeOrdered = AdoFldString(prsLabs, "ToBeOrdered", "");
			m_aryLabs.Add(pLab);
			prsLabs->MoveNext();
		}

		//TES 4/15/2010 - PLID 24692 - Now load our linked list of topic positions.
		_RecordsetPtr rsTopicPositions = pLero->prsTopicPositionInfo;
		//TES 4/15/2010 - PLID 24692 - We shouldn't already have a list.
		ASSERT(m_pTopicPositionHead == NULL);
		struct SkippedPosition {
			TopicPositionEntry *tpe;
			long nParentTopicID;
		};
		CArray<SkippedPosition,SkippedPosition&> arSkippedPositions;
		while(!rsTopicPositions->eof && AdoFldLong(rsTopicPositions, "EMRID") == nEmnID) {
			TopicPositionEntry *tpe = new TopicPositionEntry;
			tpe->nTopicID = AdoFldLong(rsTopicPositions, "ID");
			//TES 4/15/2010 - PLID 24692 - The recordset orders it, so we can just add to the end.
			long nParentTopicID = AdoFldLong(rsTopicPositions, "EMRParentTopicID", -1);
			//TES 5/8/2010 - PLID 24692 - We may not have the parent in our list yet.
			if(nParentTopicID == -1) { 
				m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, -1);
			} else {
				TopicPositionEntry *tpeParent = m_pTopicPositionHead->GetEntryByID(nParentTopicID);
				if(tpeParent) {
					m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, tpeParent);
				}
				else {
					//TES 5/8/2010 - PLID 24692 - The parent isn't in there yet, so remember this position, we'll try adding once
					// we've finished going through the recordset.
					SkippedPosition sp;
					sp.tpe = tpe;
					sp.nParentTopicID = nParentTopicID;
					arSkippedPositions.Add(sp);
				}
			}
			rsTopicPositions->MoveNext();
		}

		//TES 5/8/2010 - PLID 24692 - Now, keep looping through the positions we skipped until we've added all of them to the list, or
		// until we've gone through the entire list without being able to add any.
		bool bOneAdded = true;
		while(arSkippedPositions.GetSize() && bOneAdded) {
			bOneAdded = false;
			for(int i = 0; i < arSkippedPositions.GetSize(); i++) {
				SkippedPosition sp = arSkippedPositions[i];
				TopicPositionEntry *tpeParent = m_pTopicPositionHead->GetEntryByID(sp.nParentTopicID);
				if(tpeParent) {
					m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, sp.tpe, tpeParent);
					arSkippedPositions.RemoveAt(i);
					i--;
					bOneAdded = true;
				}
			}
		}
		if(arSkippedPositions.GetSize()) {
			//TES 5/8/2010 - PLID 24692 - This has a parent topic that doesn't exist.  That shouldn't be possible, but it may happen
			// with bad data.  We'll free all the memory we allocated, then if those topics do get added, they'll get a new entry
			// added whereever the topic object gets put.
			ASSERT(FALSE);
			for(int i = 0; i < arSkippedPositions.GetSize(); i++) {
				delete arSkippedPositions[i].tpe;
			}
		}

		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (c.haag 2007-03-16 10:58) - PLID 25239 - The EMN now maintains the preloaded detail list.
		// It should always be NULL at this point.
		if (NULL != m_pLoader) {
			ASSERT(FALSE);
			ThrowNxException("The loader object is already in use!");
		}
		// (c.haag 2007-04-20 09:35) - PLID 25730 - Pass in a connection pointer so that the
		// preload object can do some initial processing
		// (c.haag 2007-04-24 09:22) - PLID 26463 - Now the loader object does all the processing
		// of rsPreloadDetails
		// (j.jones 2008-10-31 13:08) - PLID 31869 - this is just passed in now
		//_ConnectionPtr pCon( pLero->prsDetailInfo->GetActiveConnection() );
		// (c.haag 2007-05-01 12:38) - PLID 25853 - Include "this" EMN object when constructing the loader
		// (c.haag 2007-05-02 08:59) - PLID 26463 - Add a reference to the loader object immediately
		// to make it impossible to self-delete before all the records have been processed.
		// (c.haag 2007-05-08 13:00) - PLID 25790 - Include the chart ID
		// (a.walling 2013-03-20 16:09) - PLID 55790 - No more loading behavior

		// (j.jones 2011-04-28 14:39) - PLID 43122 - the loader now requires a provider ID for floating EMR data
		long nProviderIDForFloatingData = GetProviderIDForFloatingData();

		m_pLoader = new CEMNLoader(this, pCon, FALSE, FALSE, nEmnID, nProviderIDForFloatingData);
		m_pLoader->AddRef();

		//DRT 7/26/2007 - PLID 26835 - Since the preloader is the one that does all the "upon load" spawning, we need
		//	to inform it of our decision to ignore actions or not.
		m_pLoader->SetIgnoreLoadingActions(m_pParentEMR->m_bIgnoreActions);

		// (c.haag 2008-07-18 15:38) - PLID 30784 - Preload EMR problems
		_RecordsetPtr rsPreloadProblems = pLero->prsProblemInfo;
		// (c.haag 2009-05-19 11:21) - PLID 34310 - Pass in the EMR pointer
		m_pLoader->PreloadEmrProblems(rsPreloadProblems, m_pParentEMR);

		// (c.haag 2007-02-26 17:54) - PLID 24949 - Load details into a special preload array
		// for faster thread loading. This code is modeled off LoadEmrTopic. The object
		// CEMNPreloadedDetails supports reference counting, and is deleted when its last
		// reference is released after the last topic has loaded.
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//DRT 9/13/2007 - PLID 27384 - We now have all EMR data here, not just the current EMN.  The preloader changed 
		//	to handle this.
		m_pLoader->PreloadEmrDetails(pLero->prsDetailInfo);
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic

		// (z.manning 2011-04-06 16:12) - PLID 43140 - Need to preload detail sort orders for list items.
		m_pLoader->PreloadEmrDetailListOrders(pLero->prsDetailListOrderInfo);

		{
			//hold the mutex while problems are loaded

			CEMNLoaderMutex* pmtxProblems = m_pLoader->GetEMRProblemsMutex();
			CHoldEMNLoaderMutex mhProblems(pmtxProblems);

			// (j.jones 2008-07-23 13:46) - PLID 30789 - load the problems for the EMR
			// (c.haag 2009-05-16 12:14) - PLID 34310 - Associate EMR objects with problem links rather than problems
			{
				CEmrProblemLinkAry *pAry = m_pLoader->GetEmrProblemLinks(eprtEmrEMR, m_pParentEMR->GetID());
				if(pAry) {
					for(int i = 0; i < pAry->GetSize(); i++) {
						//make sure the EMR doesn't already have this problem link
						BOOL bFound = FALSE;
						for(int j=0; j<m_pParentEMR->m_apEmrProblemLinks.GetSize() && !bFound; j++) {
							if(m_pParentEMR->m_apEmrProblemLinks.GetAt(j)->GetID() == pAry->GetAt(i).GetID()) {
								bFound = TRUE;
							}
						}

						if(!bFound) {
							CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(i));
							pNewLink->UpdatePointersWithEMR(m_pParentEMR);
							m_pParentEMR->m_apEmrProblemLinks.Add(pNewLink);
						}
					}
				}
			}

			// (j.jones 2008-07-23 13:46) - PLID 30789 - load the problems for each EMN
			// (c.haag 2009-05-16 12:14) - PLID 34310 - Associate EMR objects with problem links rather than problems
			{
				CEmrProblemLinkAry *pAry = m_pLoader->GetEmrProblemLinks(eprtEmrEMN, GetID());
				if(pAry) {
					for(int i = 0; i < pAry->GetSize(); i++) {
						CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(i));
						pNewLink->UpdatePointersWithEMN(this);
						m_apEmrProblemLinks.Add(pNewLink);
					}
				}
			}

			// (j.jones 2008-07-23 14:05) - PLID 30792 - load the problems for each diagnosis code
			// (c.haag 2009-05-16 12:14) - PLID 34310 - Associate EMR objects with problem links rather than problems
			{
				for(int i=0; i<m_aryDiagCodes.GetSize(); i++) {
					EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
					CEmrProblemLinkAry *pAry = m_pLoader->GetEmrProblemLinks(eprtEmrDiag, pDiag->nID);
					if(pAry) {
						for(int j = 0; j < pAry->GetSize(); j++) {
							CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(j));
							pNewLink->UpdatePointersWithDiagCode(this, pDiag);
							pDiag->m_apEmrProblemLinks.Add(pNewLink);
						}
					}
				}
			}

			// (j.jones 2008-07-23 14:05) - PLID 30792 - load the problems for each charge
			// (c.haag 2009-05-16 12:14) - PLID 34310 - Associate EMR objects with problem links rather than problems
			{
				for(int i=0; i<m_aryCharges.GetSize(); i++) {
					EMNCharge *pCharge = m_aryCharges.GetAt(i);
					CEmrProblemLinkAry *pAry = m_pLoader->GetEmrProblemLinks(eprtEmrCharge, pCharge->nID);
					if(pAry) {
						for(int j = 0; j < pAry->GetSize(); j++) {
							CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(j));
							pNewLink->UpdatePointersWithCharge(this, pCharge);
							pCharge->m_apEmrProblemLinks.Add(pNewLink);
						}
					}
				}
			}

			// (j.jones 2008-07-23 14:05) - PLID 30792 - load the problems for each medication
			// (c.haag 2009-05-16 12:14) - PLID 34310 - Associate EMR objects with problem links rather than problems
			{
				for(int i=0; i<m_aryMedications.GetSize(); i++) {
					EMNMedication *pMed = m_aryMedications.GetAt(i);
					CEmrProblemLinkAry *pAry = m_pLoader->GetEmrProblemLinks(eprtEmrMedication, pMed->nID);
					if(pAry) {
						for(int j = 0; j < pAry->GetSize(); j++) {
							CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(j));
							pNewLink->UpdatePointersWithMedication(this, pMed);
							pMed->m_apEmrProblemLinks.Add(pNewLink);
						}
					}
				}
			}

		}//ends problem mutex hold

		//TES 6/15/2012 - PLID 50983 - Now copy everything we just loaded into m_aryOriginalCharges
		for(int i = 0; i < m_aryCharges.GetSize(); i++) {
			EMNCharge *pOriginalCharge = new EMNCharge;
			*pOriginalCharge = *(m_aryCharges[i]);
			m_aryOriginalCharges.Add(pOriginalCharge);
		}

		// (z.manning 2010-02-17 15:37) - PLID 37412 - Detail image stamps
		_RecordsetPtr rsDetailImageStamps = pLero->prsDetailImageStampInfo;
		m_pLoader->PreloadDetailImageStamps(rsDetailImageStamps);

		// (c.haag 2007-04-30 13:30) - PLID 25853 - Load existing chart topics into a
		// special preload array for faster thread loading
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter
		_RecordsetPtr rsPreloadTopics = pLero->prsTopicInfo;
		//DRT 9/13/2007 - PLID 27384 - We now have all EMR data here, not just the current EMN.  The preloader changed 
		//	to handle this.
		m_pLoader->PreloadEmrTopics(rsPreloadTopics);		

		// (c.haag 2011-03-18) - PLID 42895 - Loading Common Lists for EMR items
		m_pLoader->PreloadEmrInfoCommonLists(pLero->prsCommonLists);
		m_pLoader->PreloadEmrInfoCommonListItems(pLero->prsCommonListItems);

		// (z.manning 2010-03-12 15:56) - PLID 37412 - Note: The call to m_pLoader->PreloadEmrTopics may end up resulting
		// in a complete load of everything before we return from that functions. So if you ever add anything else to
		// preload here, make sure it gets done before PreloadEmrTopics.
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// End Preloading
		//////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// (c.haag 2007-05-02 09:00) - PLID 26463 - Release our reference to the loader object. We
		// created that reference to keep the loader object from self-deleting in the middle of processing
		// data without an interface window
		// (c.haag 2007-08-04 09:34) - PLID 26945 - If the reference count is one, do special handling with it
		// (internal error checking, etc), and then ensure it's deleted.
		if (1 == m_pLoader->GetRefCnt()) {
			RetireInitialLoader();
			ASSERT(NULL == m_pLoader);
		} else {
			m_pLoader->Release();
		}

		if(!m_arypEMRTopics.GetSize()) {
			//TES 2/20/2007 - PLID 24750 - If we have no topics, that means PostTopicLoad() will never get called.  However,
			// since the topics are the only things that are loaded asynchronously, we know now that we are fully loaded,
			// so set our flag.
			SetLoaded();
		}

		// (c.haag 2007-05-01 12:40) - PLID 25853 - This is no longer necessary since the old rsTopics
		// recordset has been depreciated
		// (b.cardillo 2006-06-01 16:15) - PLID 20861 - Done with that recordset, move to the next.
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (j.jones 2006-02-13 14:49) - if we turned off actions from within this EMN, turn them back on
		if(bLocalIgnoringProcessActions) {
			m_pParentEMR->m_bIgnoreActions = FALSE;
		}
		
		// (a.walling 2008-06-02 12:24) - PLID 22049 - Notify the interface
		if (GetInterface()) {
			GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 0);
		}

		//TES 7/10/2009 - PLID 25154 - We're loading an existing EMN, so by default we don't want to send the bill.
		m_bSendBillToHL7 = false;

		// Completed successfully, return the next recordset
		//DRT 9/17/2007 - PLID 27384 - All recordsets are now in as a parameter, there is no return value
		return;
		
		// (j.jones 2008-10-31 13:03) - PLID 31869 - Use thread-safe exception handling
	}NxCatchAllThread("CEMN::LoadFromEmnRecordsets()");

	// (b.cardillo 2006-06-01 16:18) - I don't think we should be catching exceptions in this 
	// function or LoadFromEmnID() or any number of other similar functions throughout EMR, as 
	// they are clearly utility functions.  I let t.schneider know my thinking and I leave it 
	// to him to decide what to do.  In the mean time, we return the default here, which is NULL.
}

// (j.jones 2008-10-30 16:11) - PLID 31869 - passed in a connection pointer
void CEMN::LoadFromEmnID(long nEmnID, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	try {

		// (j.jones 2008-10-30 16:13) - PLID 31869 - converted to support a passed-in connection
		_ConnectionPtr pCon;
		if(lpCon) {
			pCon = lpCon;
		}
		else {
			pCon = GetRemoteData();
		}

		// (j.jones 2012-07-31 16:08) - PLID 51750 - GetEMNProblemSql and GetEmrDetailListOrderSql now take in an Order By clause,
		// for purposes of ordering multiple EMNs on one EMR. This code is only loading one EMN, so that order by is not needed.
		// We'll just use our default order by EMN ID ASC.
		// (j.jones 2013-07-02 08:56) - PLID 57271 - removed sqlEMNSortOrder, these two functions always sort by EMR ID now

		// (b.cardillo 2006-06-01 16:21) - NOTE: this sql statement is extremely similar to the 
		// corresponding one in CEMR::LoadFromID(), except that one is for all EMNs on the EMR 
		// it's trying to load, while this is just for our one EMN.  But changes made to the sql 
		// statement there should probably be ported to here, and vice versa.
		//DRT 1/16/2007 - While trying to implement 24177, we couldn't find how to actually load
		//	this code.  It turns out that this is only used when merging from the PIC but haven't
		//	yet loaded the Clinical tab.  So go to Tracking tab in patients module, open the PIC
		//	that contains your EMR, and merge from the bottom PIC merge section.
		//DRT 8/2/2007 - PLID 26919 - Added SourceActionSourceID to the detail data
		//DRT 8/14/2007 - PLID 27067 - Added nSourceActionSourceDataGroupID
		// (z.manning, 01/23/2008) - PLID 28690 - Added SourceActionSourceHotSpotGroupID
		// (z.manning 2010-02-25 09:52) - PLID 37532 - SourceDetailImageStampID
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		// (c.haag 2014-03-17) - PLID 60929 - Added userID and diagDisplayPref
		_RecordsetPtr prsNextRecordset = CreateParamRecordset(pCon,
			"DECLARE @nEmnID int; SET @nEmnID = {INT}; \r\n"
			"DECLARE @userID INT; SET @userID = {INT}; \r\n"
			"DECLARE @diagDisplayPref INT; SET @diagDisplayPref = {INT}; \r\n"
			//rsProblems
			"{SQL} \r\n"
			// rsEMN
			// (z.manning, 04/11/2007) - PLID 25569 - Added chart ID and category ID.
			// (z.manning, 05/07/2007) - PLID 25731 - Added chart and category names.
			// (z.manning, 05/07/2007) - PLID 25925 - Added location name.
			// (j.jones 2007-06-14 11:44) - PLID 26276 - Added Completion Status
			// (j.jones 2007-08-24 09:12) - PLID 27054 - Added Visit Type
			//DRT 9/17/2007 - PLID 27384 - Added EMRID to all queries, I also gather the queries ahead of time into a structure
			//	to pass to LoadEmnRecordsets.  We do not need to bother with the ORDER BY clauses here, because there is only
			//	every 1 EMN (and adding the ORDER BY's is a slight speed hit).
			// (j.jones 2007-09-18 08:49) - PLID 27396 - added TotalTimeInSeconds
			//DRT 9/27/2007 - PLID 27515 - Added SourceAction SourceID and SourceActionDataGroupID to the topic loading
			// (a.walling 2008-05-29 10:45) - PLID 22049 - Added Revision
			// (a.walling 2008-07-01 15:04) - PLID 30586 - Added location logo
			// (a.walling 2010-10-29 10:33) - PLID 31435 - Added logo width
			// (z.manning 2009-02-19 12:04) - PLID 33141 - Added source action type and SourceDataGroupID
			// (d.thompson 2009-05-27) - PLID 29909 - Added ConfidentialInfo
			// (z.manning 2009-11-19 09:13) - PLID 35810 - Added patient created status
			// (j.jones 2011-07-05 11:44) - PLID 43603 - added StatusName
			// (a.walling 2012-06-07 08:48) - PLID 50920 - Dates - Modified, Created
			// (j.jones 2013-02-27 15:47) - PLID 55351 - Ignore all time slips with a null end time, which means they are uncommitted.
			//TES 1/17/2014 - PLID 60397 - Added EmrTemplateT.HideTitleOnPreview
			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			"SELECT EMRMasterT.ID AS EMRID, EMRMasterT.LocationID, Date, EMRMasterT.InputDate, EMRMasterT.ModifiedDate, PatientAge, PatientGender, "
			"Status, EmrMasterT.Description, AdditionalNotes, TemplateID, Status, EMRStatusListT.Name AS StatusName, EMRCollectionID, SourceActionID, SourceDetailID, "
			"PatientFirst, PatientMiddle, PatientLast, EmnTabChartsLinkT.EmnTabChartID, EmnTabCategoriesLinkT.EmnTabCategoryID, "
			"EmnTabChartsT.Description AS ChartName, EmnTabCategoriesT.Description AS CategoryName, LocationsT.Name AS LocationName, "
			"LocationsT.LogoImagePath AS LocationLogo, LocationsT.LogoWidth AS LocationLogoWidth, SourceType, "
			"EMRMasterT.CompletionStatus, EmrMasterT.VisitTypeID, EMRVisitTypesT.Name AS VisitTypeName, "
			"(SELECT Coalesce(Sum(DATEDIFF(second, StartTime, EndTime)),0) FROM EMRMasterSlipT WHERE EMRID = EMRMasterT.ID AND EndTime Is Not Null) AS TotalTimeInSeconds, "
			"EmrMasterT.Revision, SourceDataGroupID, ConfidentialInfo, PatientCreatedStatus, SourceDetailImageStampID, "
			"EMRMasterT.AppointmentID, " // (a.walling 2013-01-16 13:04) - PLID 54650 - Appointment linked with this EMN
			"EmrTemplateT.HideTitleOnPreview, "
			"EMRMasterT.DischargeStatusID, DischargeStatusT.Code AS DischargeStatusCode, DischargeStatusT.Description AS DischargeStatusDesc, "
			"EMRMasterT.AdmissionTime, EMRMasterT.DischargeTime "
			"FROM EMRMasterT "
			"LEFT JOIN EmnTabChartsLinkT ON EmrMasterT.ID = EmnTabChartsLinkT.EmnID "
			"LEFT JOIN EmnTabCategoriesLinkT ON EmrMasterT.ID = EmnTabCategoriesLinkT.EmnID "
			"LEFT JOIN EmnTabChartsT ON EmnTabChartsLinkT.EmnTabChartID = EmnTabChartsT.ID "
			"LEFT JOIN EmnTabCategoriesT ON EmnTabCategoriesLinkT.EmnTabCategoryID = EmnTabCategoriesT.ID "
			"LEFT JOIN LocationsT ON EmrMasterT.LocationID = LocationsT.ID "
			"LEFT JOIN EMRVisitTypesT ON EMRMasterT.VisitTypeID = EMRVisitTypesT.ID "
			"LEFT JOIN EmrActionsT ON EmrMasterT.SourceActionID = EmrActionsT.ID "
			"LEFT JOIN EMRStatusListT ON EMRMasterT.Status = EMRStatusListT.ID "
			"LEFT JOIN EmrTemplateT ON EmrMasterT.TemplateID = EmrTemplateT.ID "
			"LEFT JOIN DischargeStatusT ON EMRMasterT.DischargeStatusID = DischargeStatusT.ID "
			"WHERE EmrMasterT.ID = @nEmnID; \r\n"

			// (j.armen 2014-05-30 16:57) - PLID 62042 - INNER JOIN to ProceduresT
			// rsProcs
			R"(
SELECT
	EMRID, ProcedureID, SourceActionID, SourceDetailID, ProcedureT.Name,
	SourceDataGroupID, SourceType, SourceDetailImageStampID
FROM EmrProcedureT
INNER JOIN ProcedureT ON EmrProcedureT.ProcedureID = ProcedureT.ID
LEFT JOIN EmrActionsT ON EmrProcedureT.SourceActionID = EmrActionsT.ID
WHERE EmrProcedureT.Deleted = 0 AND EMRID = @nEmnID;

)"
			// rsDiags
			//TES 2/28/2014 - PLID 61046 - Added ICD-10 fields
			// (s.dhole 2014-03-06 12:44) - PLID 60825 Added EmrDiagCodesT.NexGEMMatchType 
			// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
			"SELECT EMRDiagCodesT.ID, EMRID, DiagCodeID, SourceActionID, SourceDetailID, DiagCodes.CodeNumber, "
			"	DiagCodes.CodeDesc, EMRDiagCodesT.OrderIndex, SourceType, SourceDataGroupID, SourceDetailImageStampID, "
			"	EmrDiagCodesT.DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc, "
			"	EmrDiagCodesT.NexGEMMatchType, GCQI.QuickListID "
			"FROM EMRDiagCodesT "
			"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, EMRDiagCodesT.DiagCodeID, EMRDiagCodesT.DiagCodeID_ICD10) GCQI "
			"LEFT JOIN DiagCodes ON EMRDiagCodesT.DiagCodeID = DiagCodes.ID "
			"LEFT JOIN DiagCodes DiagCodes_10 ON EmrDiagCodesT.DiagCodeID_ICD10 = DiagCodes_10.ID "
			"LEFT JOIN EmrActionsT ON EMRDiagCodesT.SourceActionID = EmrActionsT.ID "
			"WHERE EMRDiagCodesT.Deleted = 0 AND EMRID = @nEmnID; \r\n"
			// rsCharges
			// (j.jones 2008-06-04 16:33) - PLID 30255 - added QuoteChargeID
			// (j.jones 2011-03-28 14:45) - PLID 42575 - added Billable flag
			// (j.dinatale 2012-01-05 10:27) - PLID 39451 - added Insured Party ID and EMRChargeID
			// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category 
			"SELECT EMRID, EMRChargesT.ID, EMRChargesT.ServiceID, EmrChargesT.Category , EMRChargesT.Description, "
			"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount, "
			"Quantity, UnitCost, SourceActionID, SourceDetailID, CPTCodeT.Code, CPTCodeT.SubCode, CPTCodeT.Billable, "
			"QuotedChargesQ.ChargeID AS QuoteChargeID, SourceType, SourceDataGroupID, SourceDetailImageStampID, "
			"EMRChargeRespT.EMRChargeID AS RespChargeID, EMRChargeRespT.InsuredPartyID AS InsuredPartyID "
			"FROM EMRChargesT "
			"LEFT JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID "
			"LEFT JOIN CPTCodeT ON EMRChargesT.ServiceID = CPTCodeT.ID "
			"LEFT JOIN EmrActionsT ON EmrChargesT.SourceActionID = EmrActionsT.ID "
			"LEFT JOIN ( "
			"Select ServiceID, COUNT(DISTINCT ServiceMultiCategoryT.CategoryID) as CPTCategoryCount  "
			"FROM ServiceMultiCategoryT Group BY ServiceID) "
			"CptCategoryCountQ On  CptCategoryCountQ.ServiceID = EMRChargesT.ServiceID "
			"LEFT JOIN (SELECT Min(EMRQuotedChargesT.ChargeID) AS ChargeID, EMRQuotedChargesT.EMRChargeID "
			"	FROM EMRQuotedChargesT "
			"	INNER JOIN LineItemT ON EMRQuotedChargesT.ChargeID = LineItemT.ID "
			"	WHERE LineItemT.Deleted = 0 "
			"	GROUP BY EMRQuotedChargesT.EMRChargeID) AS QuotedChargesQ ON EMRChargesT.ID = QuotedChargesQ.EMRChargeID "
			"WHERE EMRChargesT.Deleted = 0 AND EMRID = @nEmnID; \r\n"
			//DRT 1/16/2007 - PLID 24177 - We now need to load the diagnosis code linking for the charges above.
			// (j.jones 2009-01-02 09:03) - PLID 32601 - added DiagCodeID
			//TES 2/28/2014 - PLID 61080 - Added ICD-10 fields
			"SELECT EMRChargesT.EMRID, EMRChargesT.ID, EMRChargesToDiagCodesT.DiagCodeID, DiagCodes.CodeNumber, "
			"EMRChargesToDiagCodesT.DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber "
			"FROM EMRChargesToDiagCodesT LEFT JOIN DiagCodes ON EMRChargesToDiagCodesT.DiagCodeID = DiagCodes.ID "
			"LEFT JOIN DiagCodes DiagCodes_10 ON EMRChargesToDiagCodesT.DiagCodeID_ICD10 = DiagCodes_10.ID "
			"LEFT JOIN EMRChargesT ON EMRChargesToDiagCodesT.ChargeID = EMRChargesT.ID "
			"WHERE EMRChargesT.Deleted = 0 AND EMRChargesT.EMRID = @nEmnID "
			"ORDER BY DiagCodes.CodeNumber; \r\n"
			// rsMedications
			"SELECT EmrMedicationsT.EmrID, PatientMedications.ID, PatientMedications.MedicationID, "
			// (c.haag 2007-02-02 18:36) - PLID 24561 - We now store medication names in EmrDataT.Data rather than DrugList.Name
			// (j.jones 2008-05-20 10:03) - PLID 30079 - added additional fields that the prescription editor uses
			//TES 2/10/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
			// (j.jones 2010-05-07 11:02) - PLID 36062 - added EnglishDescription
			"PatientMedications.PatientExplanation, PatientMedications.EnglishDescription, RefillsAllowed, Quantity, "
			// (s.dhole 2013-03-15 16:34) - PLID 55509  Load unit from table if string els use string
			" CASE WHEN QuantityUnitQ.ID IS NOT NULL THEN QuantityUnitQ.Name ELSE PatientMedications.Unit END AS unit, "
			" SourceActionID, SourceDetailID, EmrDataT.Data AS DrugName, "
			"PatientMedications.ProviderID, PatientMedications.LocationID, PatientMedications.PharmacyID, PatientMedications.PrescriptionDate, "
			//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
			//TES 3/31/2009 - PLID 33750 - Strength and Dosage Form are now properties of DrugList.
			// (d.thompson 2009-04-02) - PLID 33571 - Added StrengthUnit
			"DrugList.Strength, DrugDosageFormsT.Name AS DosageForm, StrengthUnitT.Name AS StrengthUnit, " 
			//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
			"PatientMedications.DaysSupply, PatientMedications.NoteToPharmacist, PatientMedications.AllowSubstitutions, "
			"PatientMedications.PriorAuthorization, PatientMedications.PriorAuthorizationIsSample, SourceType, "
			// (j.jones 2009-04-01 15:59) - PLID 33736 - added NewCropGUID and Discontinued
			// (a.walling 2009-04-22 11:18) - PLID 33948 - Added EPrescibe
			// (a.walling 2009-07-01 13:33) - PLID 34052 - Added AgentID, SupervisorID
			//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
			"SourceDataGroupID, NewCropGUID, Discontinued, EPrescribe, SampleExpirationDate, SourceDetailImageStampID, "
			//TES 8/3/2009 - PLID 35008 - Added DEASchedule
			// (j.jones 2012-10-29 16:06) - PLID 53259 - added QueueStatus
			// (b.savon 2013-01-16 16:04) - PLID 54656 - Removed AgentID

			" SupervisorID, DrugList.DEASchedule, PatientMedications.QueueStatus, "
			" PatientMedications.StrengthUnitID , PatientMedications.DosageFormID ,PatientMedications.QuantityUnitID, "
			// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
			" PatientMedications.DosageUnitID, PatientMedications.DosageRouteID, PatientMedications.DosageQuantity, PatientMedications.DosageFrequency "
			"FROM PatientMedications INNER JOIN EmrMedicationsT ON PatientMedications.ID = EmrMedicationsT.MedicationID "
			"LEFT JOIN DrugList ON PatientMedications.MedicationID = DrugList.ID "
			"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
			// (s.dhole 2013-03-07 12:01) - PLID 55509 change Druglist.DosageFormID => PatientMedications.DosageFormID 
			"LEFT JOIN DrugDosageFormsT ON PatientMedications.DosageFormID = DrugDosageFormsT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS StrengthUnitT ON PatientMedications.StrengthUnitID = StrengthUnitT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS QuantityUnitQ ON PatientMedications.QuantityUnitID = QuantityUnitQ.ID "
			"LEFT JOIN EmrActionsT ON EmrMedicationsT.SourceActionID = EmrActionsT.ID "
			"WHERE EMRMedicationsT.Deleted = 0 AND EmrMedicationsT.EmrID = @nEmnID; \r\n"
			//TES 3/26/2009 - PLID 33262 - We now need to load the diagnosis code linking for the medications above.
			"SELECT EMRMedicationsT.EMRID, EMRMedicationsT.MedicationID AS ID, PatientMedicationDiagCodesT.DiagCodeID, "
			"DiagCodes.CodeNumber, DiagCodes.CodeDesc, PatientMedicationDiagCodesT.SortOrder "
			"FROM PatientMedicationDiagCodesT LEFT JOIN DiagCodes ON PatientMedicationDiagCodesT.DiagCodeID = DiagCodes.ID "
			"LEFT JOIN EMRMedicationsT ON PatientMedicationDiagCodesT.PatientMedicationID = EMRMedicationsT.MedicationID "
			"WHERE EMRMedicationsT.Deleted = 0 AND EMRMedicationsT.EMRID = @nEmnID "
			"ORDER BY DiagCodes.CodeNumber; \r\n"		
			//rsProviders
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
			"SELECT EmrProvidersT.EmrID, EmrProvidersT.ProviderID, PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProviderName, "
			"ProvidersT.FloatEMRData "
			"FROM EmrProvidersT "
			"INNER JOIN PersonT ON EmrProvidersT.ProviderID = PersonT.ID "
			"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
			"WHERE EmrProvidersT.Deleted = 0 AND EmrProvidersT.EmrID = @nEmnID; \r\n"
			//rsSecondaryProviders
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
			"SELECT EmrSecondaryProvidersT.EmrID, EmrSecondaryProvidersT.ProviderID, PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProviderName, "
			"ProvidersT.FloatEMRData "
			"FROM EmrSecondaryProvidersT "
			"INNER JOIN PersonT ON EmrSecondaryProvidersT.ProviderID = PersonT.ID "
			"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
			"WHERE EmrSecondaryProvidersT.Deleted = 0 AND EmrSecondaryProvidersT.EmrID = @nEmnID; \r\n"
			// (d.lange 2011-03-23 11:12) - PLID 42136 - Assistant/Technician
			"SELECT EmrTechniciansT.EmrID, EmrTechniciansT.PersonID, PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS TechnicianName "
			"FROM EmrTechniciansT INNER JOIN PersonT ON EmrTechniciansT.PersonID = PersonT.ID "
			"WHERE EmrTechniciansT.Deleted = 0 AND EmrTechniciansT.EmrID = @nEmnID; \r\n"
			// (j.gruber 2009-05-07 17:24) - PLID 33688 - Other Providers
			// (c.haag 2009-05-19 15:55) - PLID 33688 - Fixed query syntax; now references ProvidersTypesT description
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
			"SELECT EmrOtherProvidersT.EmrID, EmrOtherProvidersT.ProviderID, PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProviderName, "
			"ProvTypeID, ProviderTypesT.Description, ProvidersT.FloatEMRData "
			"FROM EmrOtherProvidersT "
			"INNER JOIN PersonT ON EmrOtherProvidersT.ProviderID = PersonT.ID "
			"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
			"LEFT JOIN ProviderTypesT ON EmrOtherProvidersT.ProvTypeID = ProviderTypesT.ID "
			"WHERE EmrOtherProvidersT.Deleted = 0 AND EmrOtherProvidersT.EmrID = @nEmnID; \r\n"
			// (z.manning 2008-10-06 15:40) - PLID 21094 - rsLabInfo
			// (z.manning 2008-10-09 12:54) - PLID 31628 - Added LabProcedureID
			//TES 11/10/2009 - PLID 36260 - Replaced AnatomySide with AnatomyQualifierID
			//TES 12/8/2009 - PLID 36512 - Restored AnatomySide
			"SELECT EmrDetailsT.EmrID, LabsT.ID AS LabID, LabsT.SourceActionID, LabsT.SourceDetailID \r\n"
			"	, LabProcedureID, LabsT.AnatomySide, AnatomyQualifiersT.Name AS LocationQualifier, ClinicalData, LabAnatomyT.Description AS AnatomicLocation \r\n"
			"	, Type, ToBeOrdered, SourceType, LabsT.SourceDataGroupID, LabsT.SourceDetailImageStampID \r\n"
			"FROM LabsT \r\n"
			"INNER JOIN EmrDetailsT ON LabsT.SourceDetailID = EmrDetailsT.ID \r\n"
			"LEFT JOIN LabAnatomyT ON LabAnatomyT.ID = LabsT.AnatomyID \r\n"
			"LEFT JOIN AnatomyQualifiersT ON LabsT.AnatomyQualifierID = AnatomyQualifiersT.ID \r\n"
			"LEFT JOIN EmrActionsT ON LabsT.SourceActionID = EmrActionsT.ID \r\n"
			"WHERE EmrDetailsT.EmrID = @nEmnID AND LabsT.Deleted = 0; \r\n"

			//TES 4/15/2010 - PLID 24692 - rsTopicPositions - Load the topic positions separately from the topics list; 
			// it is the EMN's job to maintain that list, not the EMRTopic's job.
			"SELECT ID, EMRParentTopicID, EmrID FROM EmrTopicsT "
			"WHERE EmrTopicsT.EmrID = @nEmnID AND EmrTopicsT.Deleted = 0 "
			"ORDER BY EMRParentTopicID ASC, OrderIndex ASC \r\n"
			// (c.haag 2007-05-02 09:44) - I redid the rsPreloadDetails query here to match the one in EMR.cpp
			// as closely as possible. Prior to this, the fields were in a different order and some were even missing.
			// (c.haag 2007-02-26 17:54) - PLID 24949 - rsPreloadDetails
			// (c.haag 2007-04-27 08:34) - PLID 25774 - Pulled additional fields necessary for quickly processing EMR actions
			// (c.haag 2008-06-16 11:58) - PLID 30319 - Changed name calculation for text macros
			// (c.haag 2008-10-16 11:43) - PLID 31709 - TableRowsAsFields
			// (j.jones 2010-02-11 15:24) - PLID 37318 - load ChildEMRInfoMasterID, SmartStampsEnabled, and ChildEMRDetailID
			//TES 2/21/2010 - PLID 37463 - Added SmartStampsLongForm and UseSmartStampsLongForm
			// (z.manning 2010-07-26 13:28) - PLID 39848 - Removed SmartStampsLongForm and UseSmartStampsLongForm
			// (z.manning 2011-01-25 15:09) - PLID 42336 - Removed parent detail IDs
			//TES 3/17/2011 - PLID 41108 - Added HasGlassesOrderData and GlassesOrderLens
			// (z.manning 2011-10-05 16:59) - PLID 45842 - Added PrintData
			// (z.manning 2011-11-15 17:04) - PLID 38130 - Added InfoFlags
			//TES 4/10/2012 - PLID 43829 - Added HasContactLensData
			// (a.walling 2013-03-18 09:30) - PLID 55724 - Load AutoAlphabetizeListData for EMRInfoT records in the CEMNLoader
			// (a.walling 2013-03-27 10:05) - PLID 55900 - CEMNLoader needs to load the revision of EMRInfoT records
			//TES 6/5/2008 - PLID 29416 - The system tables are hardcoded to display as "Remember"ing, but the data doesn't
			// have that flag set, so override the data in that case.
			// (j.jones 2008-09-22 14:53) - PLID 31408 - supported RememberForEMR, which is always disabled when allergy/current meds
			// (j.jones 2010-06-21 12:22) - PLID 37981 - generic tables never remember their values
			// (j.jones 2007-07-18 13:26) - PLID 26730 - load whether or not the info item has Info actions,
			// which it usually does not, such that we don't have to search for them later
			// (c.haag 2007-04-24 12:48) - PLID 25768 - Additional fields for the preload
			// (r.gonet 05/31/2011) - PLID 43896 - Put back in when we want to save and restore zoom and pan offsets.
			//"ZoomLevel, OffsetX, OffsetY, "
			// (j.jones 2007-08-02 10:50) - PLID 26912 - loaded whether or not the detail has list items selected
			// (z.manning 2010-02-23 14:38) - PLID 37412 - Load whether or not detail has detail image stamps
			// (c.haag 2007-05-02 08:23) - PLID 25870 - Load reconstructed detail data
			//DRT 8/2/2007 - PLID 26919 - Added SourceActionSourceID
			//DRT 8/14/2007 - PLID 27067 - Added SourceActionSourceDataGroupID
			// (z.manning 2009-02-13 09:38) - PLID 33070 - Added SourceActionSourceTableDropdownGroupID
			// (j.jones 2007-08-27 10:26) - PLID 27056 - added E/M coding data
			// (j.jones 2011-03-09 09:05) - PLID 42283 - added EMCodeUseTableCategories and Data_EMCodeCategoryID
			// (j.jones 2013-04-16 10:28) - PLID 56300 - removed E/M coding fields, because they are now only calculated in the API, and not in Practice code
			//"EMRInfoMasterT.EMCodeCategoryID, EMRInfoMasterT.EMCodeUseTableCategories, EMRInfoMasterT.UseEMCoding AS Info_UseEMCoding, EMRInfoMasterT.EMCodingType, "
			// (a.walling 2013-03-21 10:01) - PLID 55805 - EM data is not needed, get rid of this, and the join to emrdatagroupst
			// (a.walling 2008-06-30 13:11) - PLID 29271 - Preview Pane flags
			// (z.manning 2008-10-08 11:51) - PLID 31613 - Lab ID
			// (r.gonet 08/03/2012) - PLID 51948 - Added UseWithWoundCareCoding
			// (j.jones 2010-09-22 09:04) - PLID 29039 - ensured we force a join only on data item actions
			// (a.walling 2013-03-21 10:01) - PLID 55805 - EM data is not needed, get rid of the join to emrdatagroupst
			// (c.haag 2007-06-27 12:34) - PLID 26473 - Don't load details that belong to deleted topics
			// (c.haag 2008-06-16 12:05) - PLID 30319 - Changed ordering
			// (j.armen 2014-08-06 15:46) - PLID 63026 - Added InkPenSizePercent and InkPenColor
			R"(
SELECT
	EMRDetailsT.EMRID, EMRDetailsT.ID AS DetailID, EMRDetailsT.EMRTopicID,
	CASE WHEN EmrInfoT.ID = )" + AsString(EMR_BUILT_IN_INFO__TEXT_MACRO) + R"( THEN EMRDetailsT.MacroName ELSE EmrInfoT.Name END AS Name,
	EmrInfoT.DataType, EmrInfoT.DataSubType, EMRDetailsT.EmrInfoID, x, y, Width, Height, MergeOverride, EMRDetailsT.InkPenColor, EMRDetailsT.InkPenSizePercent,
	EmrInfoT.TableRowsAsFields,
	EmrInfoT.BackgroundImageFilePath AS Info_BackgroundImageFilePath, EmrInfoT.BackgroundImageType AS Info_BackgroundImageType,
	EmrInfoT.SliderMin AS Info_SliderMin, EmrInfoT.SliderMax AS Info_SliderMax, EmrInfoT.SliderInc AS Info_SliderInc,
	EmrInfoT.AutoAlphabetizeListData AS Info_AutoAlphabetizeListData,
	EmrInfoT.Revision AS Info_Revision,
	EmrInfoT.LongForm AS Info_LongForm, EmrInfoT.DataSeparator AS Info_DataSeparator, EmrInfoT.DataSeparatorFinal AS Info_DataSeparatorFinal,
	EmrInfoT.ChildEMRInfoMasterID, EmrInfoT.SmartStampsEnabled, EMRDetailsT.ChildEMRDetailID, NULL AS ChildEMRTemplateDetailID,		
	EmrInfoT.DefaultText AS Info_DefaultText, EmrInfoT.DisableTableBorder AS Info_DisableTableBorder,	CASE WHEN EmrInfoT.DataSubType IN ({CONST}, {CONST}) THEN convert(bit,1) WHEN EmrInfoT.DataSubType = {CONST} THEN Convert(bit,0)
		ELSE EmrInfoT.RememberForPatient END AS Info_RememberForPatient,
	CASE WHEN EmrInfoT.DataSubType IN ({CONST}, {CONST}, {CONST}) THEN convert(bit,0)
		ELSE EmrInfoT.RememberForEMR END AS Info_RememberForEMR,
	SourceTemplateID, SaveTableColumnWidths, EMRDetailsT.SourceActionID, EMRDetailsT.SourceDetailID, EmrInfoT.DataFormat,
	EmrInfoT.DisableTableBorder, EmrInfoT.EmrInfoMasterID, EMRTemplateDetailToDetailLinkT.EMRTemplateDetailID,
	(CASE WHEN EmrInfoT.ID IN (SELECT SourceID FROM EMRActionsT WHERE Deleted = 0 AND SourceType = 3) THEN 1 ELSE 0 END) AS HasInfoActions, 
	Text, InkData, InkImagePathOverride, InkImageTypeOverride, ImageTextData, EmrDetailsT.PrintData, SliderValue,
	CASE WHEN EMRDetailsT.ID IN (SELECT EMRDetailID FROM EmrSelectT) THEN 1 ELSE 0 END AS Detail_HasListSelections,
	CASE WHEN EmrDetailsT.ID IN (SELECT EmrDetailID FROM EmrDetailImageStampsT WHERE EmrDetailImageStampsT.Deleted = 0) THEN CONVERT(bit, 1) ELSE CONVERT(bit, 0) END AS Detail_HasDetailImageStamps,
	ReconstructedEMRDetailsT.ReviewStatus,
	EMRActionsT.SourceID AS SourceActionSourceID, EMRDataT.EMRDataGroupID AS SourceActionSourceDataGroupID, EmrTableDropdownInfoT.DropdownGroupID AS SourceActionSourceTableDropdownGroupID,
	EmrSpotGroupID,
	EmrInfoT.PreviewFlags AS Info_PreviewFlags, EMRDetailsT.PreviewFlags, EmrDetailsT.LabID,
	EmrActionsT.SourceType, EmrDetailsT.SourceDataGroupID, EmrDetailsT.SourceDetailImageStampID,
	EmrInfoT.HasGlassesOrderData, EmrInfoT.GlassesOrderLens, EmrInfoT.InfoFlags, EmrInfoT.HasContactLensData,
	EmrInfoT.UseWithWoundCareCoding
FROM EMRDetailsT
INNER JOIN EMRTopicsT ON EMRTopicsT.ID = EMRDetailsT.EMRTopicID
LEFT JOIN ReconstructedEMRDetailsT ON ReconstructedEMRDetailsT.EMRDetailID = EmrDetailsT.ID
LEFT JOIN EMRInfoT ON EMRDetailsT.EMRInfoID = EmrInfoT.ID
LEFT JOIN EMRInfoMasterT ON EMRInfoT.EMRInfoMasterID = EMRInfoMasterT.ID
LEFT JOIN EMRTemplateDetailToDetailLinkT ON EmrDetailsT.ID = EMRTemplateDetailToDetailLinkT.EMRDetailID
LEFT JOIN EMRActionsT ON EMRDetailsT.SourceActionID = EMRActionsT.ID
LEFT JOIN EMRDataT ON EMRActionsT.SourceID = EMRDataT.ID AND EmrActionsT.SourceType = {CONST}
LEFT JOIN EmrImageHotSpotsT ON EmrActionsT.SourceID = EmrImageHotSpotsT.ID AND EmrActionsT.SourceType = {CONST}
LEFT JOIN EmrTableDropdownInfoT ON EmrActionsT.SourceID = EmrTableDropdownInfoT.ID AND EmrActionsT.SourceType = {CONST}
WHERE EMRDetailsT.EMRID = @nEmnID AND EMRDetailsT.Deleted = 0 AND EMRTopicsT.Deleted = 0
ORDER BY CASE WHEN EmrInfoT.ID = )" + AsString(EMR_BUILT_IN_INFO__TEXT_MACRO) + R"( THEN EMRDetailsT.MacroName ELSE EmrInfoT.Name END

)"
			// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
			// (z.manning 2011-04-06 15:14) - PLID 43140
			// prsDetailListOrderInfo
			"{SQL} "
			"\r\n"
			// (c.haag 2007-04-30 13:28) - PLID 25853 - rsPreloadTopics
			"SELECT EmrTopicsT.EMRID, EmrTopicsT.ID, EmrTopicsT.Name, EmrTopicsT.EmrParentTopicID, EmrTemplateTopicToTopicLinkT.EMRTemplateTopicID, "
			"EmrTopicsT.SourceActionID, EMRActionsT.SourceID AS SourceActionSourceID, EMRDataQ.EMRDataGroupID AS SourceActionSourceDataGroupID, EmrTopicsT.SourceDetailID,  "
			"EmrTemplateTopicsT.SourceTemplateTopicID, EmrTopicsT.ShowIfEmpty, EmrTemplateTopicsT.TemplateID, "
			"EmrTemplateTopicsT.OrderIndex AS TemplateOrderIndex, EMRTopicsT.OrderIndex,  "
			//TES 2/16/2010 - PLID 37298 - Added SourceActionName info for HotSpots
			//TES 3/18/2010 - PLID 37530 - Added SourceActionName info for Smart Stamps
			// (a.walling 2010-04-02 17:38) - PLID 38059 - Gather the action name for table dropdown spawns
			"CASE WHEN EmrActionsT.SourceType = 3 THEN EmrInfoQ.Name WHEN EmrActionsT.SourceType = 4 THEN EmrDataQ.Data WHEN EmrActionsT.SourceType = 5 THEN EmrProcedureQ.Name WHEN EmrActionsT.SourceType = 10 THEN EmrImageHotSpotsQ.AnatomicLocation "
			// (a.walling 2010-04-02 17:39) - PLID 38059
			" WHEN EmrActionsT.SourceType = 14 THEN EmrDetailImageStampsQ.StampText + ' - ' + convert(nvarchar(50),EmrDetailImageStampsQ.IndexByStamp) WHEN EmrActionsT.SourceType = 13 THEN EmrTableDropdownQ.DropdownData + ' - ' + EmrTableDropdownRowQ.Data + ' - ' + EmrTableDropdownQ.DropdownTableColumn ELSE '' END AS SourceActionName, "
			"EmrActionsT.DestType AS SourceActionDestType, SourceEMRTemplateTopicsT.TemplateID AS SourceTemplateID, EmrSpotGroupID, "
			// (a.walling 2008-06-30 13:12) - PLID 29271 - Preview Pane flags
			// (z.manning 2009-02-13 09:40) - PLID 33070 - Added SourceActionSourceTableDropdownGroupID
			"EMRTopicsT.PreviewFlags, EmrTableDropdownQ.DropdownGroupID AS SourceActionSourceTableDropdownGroupID, "
			"EmrActionsT.SourceType, EmrTopicsT.SourceDataGroupID, EmrTopicsT.SourceDetailImageStampID "
			"FROM EMRTopicsT "
			"LEFT JOIN EmrTemplateTopicToTopicLinkT ON EmrTopicsT.ID = EmrTemplateTopicToTopicLinkT.EmrTopicID "
			"LEFT JOIN EmrTemplateTopicsT ON EmrTemplateTopicToTopicLinkT.EmrTemplateTopicID = EmrTemplateTopicsT.ID "
			"LEFT JOIN EMRTemplateTopicsT AS SourceEMRTemplateTopicsT ON EMRTemplateTopicsT.SourceTemplateTopicID = SourceEMRTemplateTopicsT.ID "
			"LEFT JOIN EmrActionsT ON EmrActionsT.ID = EmrTopicsT.SourceActionID "
			// (a.walling 2010-04-06 08:16) - PLID 38061 - Filtered these on their appropriate source types
			"LEFT JOIN (SELECT ID, Name FROM EmrInfoT) AS EmrInfoQ ON EmrInfoQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 3  "
			"LEFT JOIN (SELECT ID, Data, EMRDataGroupID FROM EmrDataT) AS EmrDataQ ON EmrDataQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 4  "
			"LEFT JOIN (SELECT ID, Name FROM ProcedureT) AS EmrProcedureQ ON EmrProcedureQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 5  "
			"LEFT JOIN (SELECT EmrImageHotSpotsT.ID, EmrImageHotSpotsT.EmrSpotGroupID, "
			"EmrHotSpotAnatomicLocationQ.AnatomicLocation "
			// (z.manning 2010-04-30 16:27) - PLID 37553 - We now pull anatomic location from a view
			"FROM EmrImageHotSpotsT  "
			"LEFT JOIN EmrHotSpotAnatomicLocationQ ON EmrImageHotSpotsT.ID = EmrHotSpotAnatomicLocationQ.EmrHotSpotID) AS EmrImageHotSpotsQ ON EmrImageHotSpotsQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = {CONST} "
			// (a.walling 2010-04-02 17:40) - PLID 38059
			"LEFT JOIN (SELECT EmrTableDropdownInfoT.ID, EmrTableDropdownInfoT.DropdownGroupID, EmrTableDropdownInfoT.Data AS DropdownData, EMRDataTableColumnQ.Data AS DropdownTableColumn "
				"FROM EmrTableDropdownInfoT "
				"INNER JOIN EMRDataT EMRDataTableColumnQ ON EMRTableDropdownInfoT.EMRDataID = EMRDataTableColumnQ.ID "
				"AND EMRDataTableColumnQ.ListType IN (3,4) " // (a.walling 2013-02-28 17:35) - PLID 55391 - This eliminates thousands of seeks!
				") AS EmrTableDropdownQ ON EmrTableDropdownQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = {CONST} "
			// (a.walling 2010-04-02 17:41) - PLID 38059
			"LEFT JOIN EMRDetailsT SourceEMRDetailQ ON EMRTopicsT.SourceDetailID = SourceEMRDetailQ.ID "
			"LEFT JOIN EMRDataT EmrTableDropdownRowQ ON EMRTopicsT.SourceDataGroupID = EMRTableDropdownRowQ.EmrDataGroupID AND SourceEMRDetailQ.EMRInfoID = EmrTableDropdownRowQ.EMRInfoID AND EmrActionsT.SourceType = 13 "
			"LEFT JOIN (SELECT EmrDetailImageStampsT.ID, EmrImageStampsT.StampText, "
			" (SELECT Count(*) FROM EmrDetailImageStampsT OtherStamps WHERE OtherStamps.EmrDetailID = EmrDetailImageStampsT.EmrDetailID "
			" AND OtherStamps.EmrImageStampID = EmrDetailImageStampsT.EmrImageStampID "
			" AND OtherStamps.OrderIndex < EmrDetailImageStampsT.OrderIndex) + 1 AS IndexByStamp "
			" FROM EmrDetailImageStampsT INNER JOIN EmrImageStampsT ON EmrDetailImageStampsT.EmrImageStampID = EmrImageStampsT.ID "
			") EmrDetailImageStampsQ ON EmrTopicsT.SourceDetailImageStampID = EmrDetailImageStampsQ.ID "
			"WHERE EmrTopicsT.EMRID = @nEmnID AND EmrTopicsT.Deleted = 0 "
			"ORDER BY EmrTopicsT.OrderIndex; \r\n"
			// (z.manning 2010-02-17 15:33) - PLID 37412 - Added query to load detail image stamp data
			// (z.manning 2011-01-27 16:27) - PLID 42335 - Added UsedInTableData
			// (z.manning 2011-09-08 10:20) - PLID 45335 - Added 3D stamp fields
			// rsDetailImageStamps
			"SELECT EmrDetailImageStampsT.ID, EmrDetailImageStampsT.EmrDetailID, EmrDetailImageStampsT.EmrImageStampID, \r\n"
			"	EmrDetailImageStampsT.OrderIndex, EmrDetailImageStampsT.SmartStampTableSpawnRule, "
			"	EmrDetailImageStampsT.XPos, EmrDetailImageStampsT.YPos, EmrDetailsT.EmrID \r\n"
			"	, CONVERT(bit, CASE WHEN EmrDetailTableDataQ.EmrDetailImageStampID IS NULL THEN 0 ELSE 1 END) AS UsedInTableData \r\n"
			"	, XPos3D, YPos3D, ZPos3D, XNormal, YNormal, ZNormal, HotSpot3D \r\n"
			"FROM EmrDetailImageStampsT \r\n"
			"INNER JOIN EmrDetailsT ON EmrDetailImageStampsT.EmrDetailID = EmrDetailsT.ID \r\n"
			"INNER JOIN EmrTopicsT ON EmrDetailsT.EmrTopicID = EmrTopicsT.ID \r\n"
			"LEFT JOIN (SELECT DISTINCT EmrDetailTableDataT.EmrDetailImageStampID FROM EmrDetailTableDataT WHERE EmrDetailTableDataT.EmrDetailImageStampID IS NOT NULL) EmrDetailTableDataQ ON EmrDetailImageStampsT.ID = EmrDetailTableDataQ.EmrDetailImageStampID \r\n"
			"WHERE EMRDetailsT.EMRID = @nEmnID AND EMRDetailsT.Deleted = 0 AND EMRTopicsT.Deleted = 0 AND EmrDetailImageStampsT.Deleted = 0 \r\n"
			"ORDER BY EmrDetailsT.EmrID, EmrDetailImageStampsT.OrderIndex \r\n"
			// (c.haag 2007-05-01 11:07) - PLID 25853 - This query has been depreciated
			// rsTopics
			//"SELECT EmrTopicsT.ID, EmrTopicsT.Name, EmrMasterT.PatientID, CASE WHEN EXISTS (SELECT EmrTopicsT.ID FROM EmrTopicsT ChildTopic LEFT JOIN EmrDetailsT ON ChildTopic.ID = EmrDetailsT.EmrTopicID LEFT JOIN EmrTopicsT SubTopic ON ChildTopic.ID = SubTopic.EmrParentTopicID WHERE ChildTopic.EmrParentTopicID = EmrTopicsT.ID AND (EmrTopicsT.ShowIfEmpty = 1 OR EmrDetailsT.ID Is Not NULL OR SubTopic.ID Is Not Null)) THEN 1 ELSE 0 END AS HasSubTopics, CASE WHEN EXISTS (SELECT ID FROM EmrDetailsT WHERE EmrDetailsT.EmrTopicID = EmrTopicsT.ID) THEN 1 ELSE 0 END AS HasDetails, EmrTopicsT.ShowIfEmpty FROM EmrTopicsT INNER JOIN EmrMasterT ON EmrTopicsT.EmrID = EmrMasterT.ID WHERE EmrTopicsT.EMRID = %li AND EmrTopicsT.EmrParentTopicID Is Null ORDER BY EmrTopicsT.OrderIndex; \r\n"
			// (c.haag 2011-03-18) - PLID 42895 - Loading Common Lists for EMR items
			// (c.haag 2011-04-11) - PLID 43155 - Added GroupOnPreviewPane
			"SELECT EmrInfoCommonListT.ID, EmrInfoCommonListT.EmrInfoID, EmrInfoCommonListT.Name, \r\n"
			"EmrInfoCommonListT.Color, EmrInfoCommonListT.OrderID, EmrInfoCommonListT.Inactive,  \r\n"
			"EmrInfoCommonListT.GroupOnPreviewPane \r\n"
			"FROM EmrInfoCommonListT \r\n"
			"WHERE EmrInfoCommonListT.Inactive = 0 \r\n"
			"AND EmrInfoCommonListT.EmrInfoID IN \r\n"
			"(SELECT EmrInfoID FROM EmrDetailsT \r\n"
			"WHERE EMRDetailsT.EMRID = @nEmnID AND EMRDetailsT.Deleted = 0 \r\n"
			"AND EmrDetailsT.EmrTopicID IN (SELECT ID FROM EMRTopicsT WHERE Deleted = 0)) \r\n "
			"ORDER BY EmrInfoCommonListT.OrderID "
			// (c.haag 2011-03-18) - PLID 42895 - Loading Common List items for EMR items
			"SELECT EmrInfoCommonListItemsT.ID, EmrInfoCommonListItemsT.ListID, EmrInfoCommonListItemsT.EmrDataID, "
			"EmrInfoCommonListT.EmrInfoID, EmrDataT.Data \r\n"
			"FROM EmrInfoCommonListT \r\n"
			"INNER JOIN EmrInfoCommonListItemsT ON EmrInfoCommonListItemsT.ListID = EmrInfoCommonListT.ID \r\n"
			"INNER JOIN EmrDataT ON EmrDataT.ID = EmrInfoCommonListItemsT.EmrDataID \r\n"
			"WHERE EmrInfoCommonListT.Inactive = 0 AND EmrDataT.Inactive = 0 \r\n"
			"AND EmrInfoCommonListT.EmrInfoID IN \r\n"
			"(SELECT EmrInfoID FROM EmrDetailsT WHERE EMRDetailsT.EMRID = @nEmnID AND EMRDetailsT.Deleted = 0 \r\n"
			"AND EmrDetailsT.EmrTopicID IN (SELECT ID FROM EMRTopicsT WHERE Deleted = 0)) \r\n"
			"\r\n"
			// (z.manning 2011-07-07 12:34) - PLID 44469 - Load EMN coding group data
			"SELECT EmnCodingGroupLinkT.EmnID, EmnCodingGroupLinkT.EmrCodingGroupID, EmnCodingGroupLinkT.GroupQuantity \r\n"
			"FROM EmnCodingGroupLinkT \r\n"
			"WHERE EmnCodingGroupLinkT.EmnID = @nEmnID \r\n"
			"\r\n"
			// (c.haag 2008-07-18 15:35) - PLID 30784 - Include EMR problems
			, nEmnID
			, GetCurrentUserID()
			, DiagQuickListUtils::GetAPIDiagDisplayTypeInt()
			,GetEMNProblemSql(CSqlFragment("{INT}", nEmnID)),
			eistCurrentMedicationsTable, eistAllergiesTable, eistGenericTable, 
			eistCurrentMedicationsTable, eistAllergiesTable, eistGenericTable,
			eaoEmrDataItem,
			eaoEmrImageHotSpot, eaoEmrTableDropDownItem,
			GetEmrDetailListOrderSql(CSqlFragment("@nEmnID")),
			eaoEmrImageHotSpot, eaoEmrTableDropDownItem
			);

		//DRT 9/17/2007 - PLID 27384 - We will now pass all our recordsets into a structure.  We get these all once
		//	ahead of time.  We will then pass this structure into CEMN::LoadFromEmnRecordsets.  Each recordset is
		//	sorted by EMN ID, so with 1 traversal of the recordset, we will eventually get through all the records.
		LoadEMNRecordsets_Objects lero;
		lero.prsProblemInfo = prsNextRecordset;
		lero.prsEMNInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsProcInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsDiagInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsChargeInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsWhichCodesInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsMedicationInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsMedDiagCodesInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsProviderInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsSecProviderInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (d.lange 2011-03-23 11:27) - PLID 42136 - added for Assistant/Technician
		lero.prsTechnicianInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (j.gruber 2009-05-07 17:21) - PLID 33688 - Other Providers
		lero.prsOtherProviderInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (z.manning 2008-10-06 15:25) - PLID 21094 - Labs
		lero.prsLabInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		//TES 4/15/2010 - PLID 24692 - Topic positions
		lero.prsTopicPositionInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsDetailInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
		// (z.manning 2011-04-06 15:12) - PLID 43140 - Detail list sort order
		lero.prsDetailListOrderInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsTopicInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));		
		// (z.manning 2010-02-17 16:17) - PLID 37412 - detail image stamps
		lero.prsDetailImageStampInfo = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (c.haag 2011-03-18) - PLID 42895 - Loading Common Lists for EMR items
		lero.prsCommonLists = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		lero.prsCommonListItems = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));
		// (z.manning 2011-07-07 12:43) - PLID 44469
		lero.prsEmrCodingGroupData = (prsNextRecordset = prsNextRecordset->NextRecordset(NULL));

		// (b.cardillo 2006-06-01 17:01) - PLID 20861 - Now Call the standard implementation to 
		// do all the work using the recordsets we just generated.
		//DRT 7/27/2007 - PLID 26836 - We are just loading a single EMN, so we do not want to load it in the background.
		//DRT 9/13/2007 - PLID 27384 - Send the recordsets in as parameters
		//LoadFromEmnRecordsets(nEmnID, prsNextRecordset, FALSE);
		LoadFromEmnRecordsets(nEmnID, &lero, FALSE, pCon);
		// (j.jones 2008-10-31 13:03) - PLID 31869 - Use thread-safe exception handling
	}NxCatchAllThread("Error in CEMN::LoadFromEmnID()");

	// (b.cardillo 2006-06-01 16:18) - I don't think we should be catching exceptions in this 
	// function or LoadFromEmnRecordsets() or any number of other similar functions throughout 
	// EMR, as they are clearly utility functions.  I let t.schneider know my thinking and I 
	// leave it to him to decide what to do.
}

void CEMN::AppendTemplateLoadSubQuery_rsPatientInfo(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query
	strSql += "SELECT First, Middle, Last, Gender, BirthDate FROM PersonT WHERE ID = ?; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsEMN(CString& strSql) const
{
	strSql += // (z.manning, 04/12/2007) - PLID 25600 - Added chart ID and category ID.
			// (z.manning, 05/07/2007) - PLID 25731 - Added chart and category names.
			// (j.jones 2007-06-14 11:44) - PLID 26276 - Added Completion Status
			// (j.jones 2007-08-24 09:10) - PLID 27054 - Added Visit Type
			// (a.walling 2008-05-29 10:47) - PLID 22049 - Added Revision
			//TES 11/2/2009 - PLID 35808 - Added NexWebUUID
			//(e.lally 2011-05-04) PLID 43537 - NexWebUUID is replaced with a subquery to see if ANY subdomain has the template
			//	flagged as NexWebDisplayT.Visible = true
			// (z.manning 2011-05-18 11:13) - PLID 43756 - Added chart location fields
			// (j.gruber 2012-08-31 14:46) - PLID 52285 - added isOMRTemplate
			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			"SELECT EMRTemplateT.Name, CollectionID, AddOnce, EmnTabChartID, EmnTabCategoryID, \r\n"
			"	EmnTabChartsT.Description AS ChartName, EmnTabCategoriesT.Description AS CategoryName, \r\n"
			"	0 AS CompletionStatus, VisitTypeID, EMRVisitTypesT.Name AS VisitTypeName, Revision, \r\n"
			"	EmrTemplateT.UID, \r\n"
			"	(SELECT CASE WHEN EXISTS (SELECT ID FROM NexWebDisplayT WHERE Visible = 1 AND EmrTemplateID = EmrTemplateT.ID) THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END) AS NexWebVisible, \r\n"
			"	CASE WHEN OMRFormT.OMRFormID IS NOT NULL THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END AS IsOMRTemplate, \r\n"
			"	ChartLocation.ID AS ChartLocationID, ChartLocation.Name AS ChartLocationName, \r\n"
			"	ChartLocation.LogoImagePath AS ChartLocationLogoImagePath, ChartLocation.LogoWidth AS ChartLocationLogoWidth, \r\n"
			"	EmrTemplateT.HideTitleOnPreview "
			"FROM EMRTemplateT \r\n"
			"LEFT JOIN EmnTabChartsT ON EmrTemplateT.EmnTabChartID = EmnTabChartsT.ID \r\n"
			"LEFT JOIN EmnTabCategoriesT ON EmrTemplateT.EmnTabCategoryID = EmnTabCategoriesT.ID \r\n"
			"LEFT JOIN EMRVisitTypesT ON EMRTemplateT.VisitTypeID = EMRVisitTypesT.ID \r\n"
			"LEFT JOIN NexWebDisplayT ON EmrTemplateT.ID = NexWebDisplayT.EmrTemplateID \r\n"
			"LEFT JOIN (SELECT Min(ID) as OMRFormID, EMRTemplateID FROM OMRFormT GROUP BY EMRTemplateID) OMRFormT ON EMRTemplateT.ID = OMRFormT.EMRTemplateID \r\n"
			"LEFT JOIN LocationsT ChartLocation ON EmnTabChartsT.LocationID = ChartLocation.ID \r\n"
			"WHERE EmrTemplateT.ID = ?; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsProcs(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query
	strSql += "SELECT ProcedureID, ProcedureT.Name FROM EMRTemplateProceduresT "
			"LEFT JOIN ProcedureT ON EMRTemplateProceduresT.ProcedureID = ProcedureT.ID WHERE EMRTemplateID = ?; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsDiags(CString& strSql, const CString& strIncludePatientICD9) const
{

	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query
	//TES 2/28/2014 - PLID 61046 - Added ICD-10 fields
	// (s.dhole 2014-03-06 12:44) - PLID 60825 Added EmrDiagCodesT.NexGEMMatchType
	// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
	strSql += FormatString("SELECT NULL AS ID, DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, EMRTemplateDiagCodesT.OrderIndex, "
			"EmrTemplateDiagCodesT.DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc, "
			"EmrTemplateDiagCodesT.NexGEMMatchType, GCQI.QuickListID "
			"FROM EMRTemplateDiagCodesT "
			"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, EMRTemplateDiagCodesT.DiagCodeID, EmrTemplateDiagCodesT.DiagCodeID_ICD10) GCQI "
			"LEFT JOIN DiagCodes ON EMRTemplateDiagCodesT.DiagCodeID = DiagCodes.ID "
			"LEFT JOIN DiagCodes DiagCodes_10 ON EmrTemplateDiagCodesT.DiagCodeID_ICD10 = DiagCodes_10.ID "
			"WHERE EMRTemplateID = ? "
				//DRT 9/19/2006 - PLID 22413 - If preference is turned on, we will copy the diagnosis codes from general 2
			"%s; \r\n", strIncludePatientICD9);
}

void CEMN::AppendTemplateLoadSubQuery_rsCharges(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query
	// (j.jones 2008-06-04 16:33) - PLID 30255 - added QuoteChargeID
	// (j.jones 2011-03-28 14:45) - PLID 42575 - added Billable flag
	// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category 
	// (s.tullis 2015-04-14 13:22) - PLID 65540 - Load Default serviceT category for templates ( if there is one)
	strSql += "SELECT EMRTemplateChargesT.ID, EMRTemplateChargesT.ServiceID, EMRTemplateChargesT.Description, "
			"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, ServiceT.Category ,COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount, "
			"Quantity, UnitCost, CPTCodeT.Code, CPTCodeT.SubCode, NULL AS QuoteChargeID, CPTCodeT.Billable "
			"FROM EMRTemplateChargesT LEFT JOIN CPTCodeT ON EMRTemplateChargesT.ServiceID = CPTCodeT.ID "
			"LEFT JOIN ServiceT ON EMRTemplateChargesT.ServiceID = ServiceT.ID "
			"LEFT JOIN ( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount "
						"FROM ServiceMultiCategoryT "
						"Group BY ServiceID ) CptCategoryCountQ "
			"ON  CptCategoryCountQ.ServiceID = EMRTemplateChargesT.ServiceID "
			"WHERE EMRTemplateID = ?; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsMedications(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query
	//TES 2/11/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
	strSql += "SELECT EMRTemplatePrescriptionsT.ID, EMRTemplatePrescriptionsT.MedicationID, EMRTemplatePrescriptionsT.PatientExplanation, "
			// (c.haag 2007-02-02 18:08) - PLID 24561 - We now store medication names in EmrDataT.Data rather than DrugList.Name
			// (j.jones 2008-05-20 10:10) - PLID 30079 - added additional fields that the prescription editor uses
			"EMRTemplatePrescriptionsT.RefillsAllowed, EMRTemplatePrescriptionsT.Quantity, EMRTemplatePrescriptionsT.Unit, EMRDataT.Data AS DrugName, "
			"-1 AS ProviderID, -1 AS LocationID, -1 AS PharmacyID, GetDate() AS PrescriptionDate, "
			//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
			//TES 3/31/2009 - PLID 33750 - Strength and DosageForm are now properties of DrugList
			//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields, including some that don't exist in EMRTemplatePrescriptionsT
			// (d.thompson 2009-04-02) - PLID 33571 - Added StrengthUnit
			//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
			"DrugList.Strength, DrugDosageFormsT.Name AS DosageForm, EMRTemplatePrescriptionsT.DaysSupply, "
			"EMRTemplatePrescriptionsT.NoteToPharmacist, EMRTemplatePrescriptionsT.AllowSubstitutions, "
			"'' AS PriorAuthorization, convert(bit,0) AS PriorAuthorizationIsSample, StrengthUnitT.Name AS StrengthUnit, "
			//TES 8/3/2009 - PLID 35008 - Added DEASchedule
			"NULL AS SampleExpirationDate, DrugList.DEASchedule ,"
			// (s.dhole 2013-03-08 13:42) - PLID  55509
			" StrengthUnitID, DosageFormID, QuantityUnitID, "
			// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
			"EMRTemplatePrescriptionsT.DosageUnitID, EMRTemplatePrescriptionsT.DosageRouteID, "
			"EMRTemplatePrescriptionsT.DosageFrequency, EMRTemplatePrescriptionsT.DosageQuantity "
			"FROM EMRTemplatePrescriptionsT "
			"LEFT JOIN DrugList ON EMRTemplatePrescriptionsT.MedicationID = DrugList.ID "
			"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
			"LEFT JOIN DrugDosageFormsT ON DrugList.DosageFormID = DrugDosageFormsT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS StrengthUnitT ON DrugList.StrengthUnitID = StrengthUnitT.ID "
			"WHERE EMRTemplateID = ?; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsTopicPositions(CString &strSql) const
{
	//TES 4/15/2010 - PLID 24692 - We need a separate recordset to just load the topic positions, because a.) maintaining them is an EMN-level
	// task, not a topic-level task, and b.) we need to know the positions even of topics that we aren't actually loading.
	strSql += "SELECT ID, EMRParentTemplateTopicID FROM EmrTemplateTopicsT "
		"WHERE EMRTemplateTopicsT.TemplateID = ? "
		//		Also include all source topics
		// (c.haag 2007-07-23 10:12) - PLID 26344 - Do not include topics that are related by SourceTemplateTopicID
		//TES 5/27/2010 - PLID 24692 - DON'T include template topics from other templates; we don't want to be positioning topics relative
		// to other templates.
		//"OR EMRTemplateTopicsT.ID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = ?) )"
		"ORDER BY EMRParentTemplateTopicID ASC, OrderIndex ASC \r\n";
}

CString CEMN::GetrsPreloadDetailsBasicQDeclarations() const
{
	return R"(
DECLARE @EMR_BUILT_IN_INFO__TEXT_MACRO INT SET @EMR_BUILT_IN_INFO__TEXT_MACRO = )" + AsString(EMR_BUILT_IN_INFO__TEXT_MACRO) + R"(
DECLARE @eistCurrentMedicationsTable INT SET @eistCurrentMedicationsTable = )" + AsString(eistCurrentMedicationsTable) + R"(
DECLARE @eistAllergiesTable INT SET @eistAllergiesTable = )" + AsString(eistAllergiesTable) + R"(
DECLARE @eistGenericTable INT SET @eistGenericTable = )" + AsString(eistGenericTable) + R"(
DECLARE @eaoEmrDataItem INT SET @eaoEmrDataItem = )" + AsString(eaoEmrDataItem) + R"(
DECLARE @eaoEmrImageHotSpot INT SET @eaoEmrImageHotSpot = )" + AsString(eaoEmrImageHotSpot) + R"(
DECLARE @eaoEmrTableDropDownItem INT SET @eaoEmrTableDropDownItem = )" + AsString(eaoEmrTableDropDownItem) + R"(
)";
}

CString CEMN::GetrsPreloadDetailsBasicQ() const
{
	// (c.haag 2007-04-24 11:02) - PLID 26464 - Load additional data for faster initial loads
	// (c.haag 2007-04-27 08:30) - PLID 25790 - Load additional EmrInfoT data
	//TES 3/17/2011 - PLID 41108 - Added HasGlassesOrderData and GlassesOrderLens
	// (z.manning 2011-10-06 08:44) - PLID 45842 - Added print data
	// (z.manning 2011-11-15 17:04) - PLID 38130 - Added InfoFlags
	//TES 4/10/2012 - PLID 43829 - Added HasContactLensData
	//"EmrTemplateDetailsT.TemplateID, " // (c.haag 2007-06-15 10:18) - PLID 26344 - Pull the template ID
	// (c.haag 2007-08-28 09:27) - PLID 27198 - It is possible for bad data to exist in Practice such
	// that the detail's template id is different from its parent topic's template id. In the initial
	// load of the 8300 scope, the topic template id trumps the detail template id.
	// (c.haag 2008-06-16 12:07) - PLID 30319 - Added name calculation for EMR text macros
	//TES 6/5/2008 - PLID 29416 - The system tables are hardcoded to display as "Remember"ing, but the data doesn't
	// have that flag set, so override the data in that case.
	// (j.jones 2010-06-21 12:22) - PLID 37981 - generic tables never remember their values
	// (j.jones 2008-09-22 14:53) - PLID 31408 - supported RememberForEMR, which is always disabled when allergy/current meds
	// (c.haag 2008-10-16 12:22) - PLID 31709 - TableRowsAsFields
	// (j.jones 2010-02-11 15:24) - PLID 37318 - load ChildEMRInfoMasterID, SmartStampsEnabled, and ChildEMRTemplateDetailID
	// (z.manning 2011-01-25 15:09) - PLID 42336 - Removed parent detail IDs
	// (j.jones 2007-08-01 14:59) - PLID 26905 - added Info_HasDefaultValue and Template_HasDefaultValue, applicable to list items
	//TES 2/21/2010 - PLID 37463 - Added SmartStampsLongForm and UseSmartStampsLongForm
	// (a.walling 2013-03-18 09:30) - PLID 55724 - Load AutoAlphabetizeListData for EMRInfoT records in the CEMNLoader
	// (j.jones 2007-07-18 10:20) - PLID 26730 - load whether or not the info item has Info actions,
	// which it usually does not, such that we don't have to search for them later
	//DRT 8/2/2007 - PLID 26919 - Added SourceActionSourceID -- we already had it as another name, but it didn't seem to be loaded into CEMNDetail
	//DRT 8/14/2007 - PLID 27067 - Added SourceActionSourceDataGroupID
	// (j.jones 2007-08-27 10:26) - PLID 27056 - added E/M coding data
	// (j.jones 2011-03-09 09:05) - PLID 42283 - added EMCodeUseTableCategories and Data_EMCodeCategoryID
	// (j.jones 2013-04-16 10:28) - PLID 56300 - removed E/M coding fields, because they are now only calculated in the API, and not in Practice code
	//"EMRInfoMasterT.EMCodeCategoryID, EMRInfoMasterT.EMCodeUseTableCategories, EMRInfoMasterT.UseEMCoding AS Info_UseEMCoding, EMRInfoMasterT.EMCodingType, "
	// (a.walling 2013-03-21 10:01) - PLID 55805 - EM data is not needed, get rid of this, and the join to emrdatagroupst
	//DRT 2/14/2008 - PLID 28698 - Added an optimization to check if any hotspot actions exist.
	// (a.walling 2008-06-30 13:13) - PLID 29271 - Preview Pane flags
	// (z.manning 2009-02-13 09:45) - PLID 33070 - Added SourceActionSourceTableDropdownGroupID
	// (z.manning 2009-03-05 15:17) - PLID 33338 - SourceDataGroupID
	//TES 3/17/2010 - PLID 37530 - SourceStampID, SourceStampIndex
	// (r.gonet 08/03/2012) - PLID 51948 - Added UseWithWoundCareCoding
	// (j.jones 2010-09-22 09:04) - PLID 29039 - ensured we force a join only on data item actions
	// (a.walling 2013-03-21 10:01) - PLID 55805 - EM data is not needed, get rid of the join to emrdatagroupst
	// (j.armen 2014-07-23 12:42) - PLID 62837 - Query Cleanup
	// (j.armen 2014-07-23 12:42) - PLID 62837 - Aded InkPenColor and InkPenSize
	return 	R"(
SELECT
	-- EmrTemplateDetailsT
	TD.ID AS TemplateDetailID, TD.EmrTemplateTopicID, TD.ChildEMRTemplateDetailID, NULL AS ChildEMRDetailID,
	TD.x, TD.y, TD.Width, TD.Height, TD.DefaultText, TD.SliderValue, 1 AS HasSliderValue, TD.PreviewFlags,
	TD.MergeOverride, TD.SaveTableColumnWidths, TD.SourceActionID, TD.SourceDetailID, TD.EmrInfoMasterID,
	TD.SourceDataGroupID, TD.SourceStampID, TD.SourceStampIndex, TD.PrintData, TD.InkPenColor, TD.InkPenSizePercent,

	CASE WHEN TD.ID IN (SELECT EMRDetailID FROM EMRHotSpotTemplateSelectT) THEN 1 ELSE 0 END AS HasTemplateHotSpots, 
	CASE WHEN TD.ID IN (SELECT EMRTemplateDetailID FROM EMRTemplateSelectT) THEN 1 ELSE 0 END AS Template_HasDefaultValue,

	-- EmrInfoT
	I.ID AS EmrInfoID, I.DataType, I.DataSubType, I.SliderMin AS Info_SliderMin, I.SliderMax AS Info_SliderMax, 
	I.SliderInc AS Info_SliderInc, I.BackgroundImageFilePath AS Info_BackgroundImageFilePath,
	I.BackgroundImageType AS Info_BackgroundImageType, I.DefaultText AS Info_DefaultText, I.TableRowsAsFields,
	I.ChildEMRInfoMasterID, I.SmartStampsEnabled, I.AutoAlphabetizeListData AS Info_AutoAlphabetizeListData,
	I.Revision AS Info_Revision, I.LongForm AS Info_LongForm, I.DataFormat AS Info_DataFormat,
	I.DataSeparator AS Info_DataSeparator, I.DataSeparatorFinal AS Info_DataSeparatorFinal,
	I.DisableTableBorder AS Info_DisableTableBorder, I.PreviewFlags AS Info_PreviewFlags,
	I.HasGlassesOrderData, I.GlassesOrderLens, I.InfoFlags, I.HasContactLensData, I.UseWithWoundCareCoding,

	CASE WHEN I.ID IN (SELECT SourceID FROM EMRActionsT WHERE Deleted = 0 AND SourceType = 3) THEN 1 ELSE 0 END AS HasInfoActions,
	CASE WHEN I.ID = @EMR_BUILT_IN_INFO__TEXT_MACRO THEN TD.MacroName ELSE I.Name END AS Name,

	CASE
		WHEN I.DataSubType IN (@eistCurrentMedicationsTable, @eistAllergiesTable) THEN CONVERT(BIT,1)
		WHEN I.DataSubType = @eistGenericTable THEN CONVERT(BIT,0)
		ELSE I.RememberForPatient
	END AS Info_RememberForPatient,

	CASE
		WHEN I.DataSubType IN (@eistCurrentMedicationsTable, @eistAllergiesTable, @eistGenericTable) THEN CONVERT(BIT,0)
		ELSE I.RememberForEMR
	END AS Info_RememberForEMR,

	CASE
		WHEN I.ID IN (
			SELECT ID.EMRInfoID
			FROM EMRInfoDefaultsT ID
			INNER JOIN EMRDataT D ON ID.EMRDataID = D.ID
			WHERE D.Inactive = 0 AND D.IsLabel = 0
		) THEN 1
		ELSE 0
	END AS Info_HasDefaultValue,

	-- EMRActionsT
	A.SourceID AS SourceActionSourceID, A.SourceType,

	-- EMRDataT
	D.EMRDataGroupID AS SourceActionSourceDataGroupID, 

	-- EmrImageHotSpotsT
	HS.EmrSpotGroupID,

	-- EmrTableDropdownInfoT
	DI.DropdownGroupID AS SourceActionSourceTableDropdownGroupID, 

	-- EMRTemplateTopicsT
	TT.TemplateID

FROM EmrTemplateDetailsT TD
INNER JOIN EmrInfoMasterT IM ON TD.EmrInfoMasterID = IM.ID
INNER JOIN EmrInfoT I ON IM.ActiveEmrInfoID = I.ID
LEFT JOIN EMRActionsT A ON A.ID = SourceActionID
LEFT JOIN EMRDataT D ON A.SourceID = D.ID AND A.SourceType = @eaoEmrDataItem
LEFT JOIN EMRTemplateTopicsT TT ON TD.EMRTemplateTopicID = TT.ID
LEFT JOIN EmrImageHotSpotsT HS ON A.SourceID = HS.ID AND A.SourceType = @eaoEmrImageHotSpot 
LEFT JOIN EmrTableDropdownInfoT DI ON A.SourceID = DI.ID AND A.SourceType = @eaoEmrTableDropDownItem
)";
}

// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic

void CEMN::AppendTemplateLoadSubQuery_rsPreloadDetails(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query or
	// when spawning templates. Additionally, it's faster to run two queries than to run one query with the
	// OR clause on SQL Server 2005, so we actually produce two here.
	// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
	strSql += // (c.haag 2007-02-27 10:22) - PLID 24949 - rsPreloadDetails
			GetrsPreloadDetailsBasicQ() + "WHERE TT.TemplateID = ? "
			// (c.haag 2007-06-15 10:22) - PLID 26344 - Include the details of source template topics
			+ GetrsPreloadDetailsBasicQ() + "WHERE TT.TemplateID <> ? AND EMRTemplateTopicID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = ?) "
			+"; \r\n";
}

void CEMN::AppendTemplateLoadSubQuery_rsPreloadTemplateTopics(CString& strSql) const
{
	// (c.haag 2007-08-31 11:08) - PLID 27268 - Use this when generating an initial template load query or
	// when spawning templates 
	strSql += // (c.haag 2007-05-02 13:09) - PLID 25881 - Preload all template topics and figure out how they will show up later.
			// Note that the original topic query calculated the topic name. We do not do that in our query; the calculation
			// is done in code.
			FormatString("SELECT "
			//		Important fields
			"EMRTemplateTopicsT.ID AS EMRTemplateTopicID, EMRTemplateTopicsT.TemplateID, "
			"EMRTemplateTopicsT.SourceTemplateTopicID, "
			//		Non-calculated fields used in CEMRTopic::LoadTemplateTopicFields
			//DRT 9/25/2007 - PLID 27515 - Added SourceAction SourceID and SourceDataGroupID
			"EMRTemplateTopicsT.SourceActionID, EMRActionsT.SourceID AS SourceActionSourceID, EMRDataT.EMRDataGroupID AS SourceActionSourceDataGroupID, "
			"EMRTemplateTopicsT.SourceDetailID, "
			//		Non-calculated fields used in CEMNLoader::LoadEMRTopic and CEMRTopic::LoadTemplateTopicFields
			"EMRTemplateTopicsT.EMRParentTemplateTopicID, EMRTemplateTopicsT.ShowIfEmpty, EMRTemplateTopicsT.Name, "
			//		Non-calculated fields used in CEMNLoader::LoadEMRTopic
			"EMRTemplateTopicsT.OrderIndex, "
			"EMRTemplateTopicsT.HideOnEMN, "
			// (j.jones 2007-07-30 11:25) - PLID 26874 - include the template's "AddOnce" field
			"EMRTemplateT.AddOnce, "
			// (c.haag 2007-07-24 12:00) - PLID 26344 - If this topic was spawned by a detail in the same template,
			// SourceEMRTemplateTopicsT will pertain to that spawned topic's original template
			"SourceEMRTemplateTopicsT.TemplateID AS OriginalTemplateID, "
			"SourceEMRTemplateTopicsT.Name AS OriginalTopicName, "
			"SourceEMRTemplateTopicsT.ShowIfEmpty AS OriginalShowIfEmpty, "
			//		Calculated action fields used in CEMNLoader::LoadEMRTopic
			//TES 2/17/2010 - PLID 37298 - Added EmrActionName info for HotSpots
			// (a.walling 2010-04-02 18:10) - PLID 38059 - Gather the action name for table dropdown spawns
			"CASE WHEN EmrActionsT.SourceType = %d THEN EmrInfoT.Name WHEN EmrActionsT.SourceType = %d THEN EmrDataT.Data WHEN EmrActionsT.SourceType = %d THEN ProcedureT.Name WHEN EmrActionsT.SourceType = %d THEN EmrImageHotSpotQ.AnatomicLocation WHEN EmrActionsT.SourceType = 13 THEN EmrTableDropdownQ.DropdownData + ' - ' + EmrTableDropdownRowQ.Data + ' - ' + EmrTableDropdownQ.DropdownTableColumn ELSE '' END AS EmrActionName, "
			"EmrActionsT.DestType AS EmrActionDestType, EmrActionsT.ID AS EmrActionID, EmrSpotGroupID, "
			// (a.walling 2008-06-30 13:14) - PLID 29271 - Preview Pane flags
			// (z.manning 2009-02-13 09:48) - PLID SourceActionSourceTableDropdownGroupID
			"EMRTemplateTopicsT.PreviewFlags, EmrTableDropdownQ.DropdownGroupID AS SourceActionSourceTableDropdownGroupID, "
			// (z.manning 2009-03-05 15:16) - PLID 33338 - SourceDataGroupID
			//TES 3/17/2010 - PLID 37530 - SourceStampID, SourceStampIndex
			"EMRTemplateTopicsT.SourceDataGroupID, SourceType, EMRTemplateTopicsT.SourceStampID, EMRTemplateTopicsT.SourceStampIndex "
			"FROM EMRTemplateTopicsT "
			"LEFT JOIN EMRTemplateT ON EMRTemplateTopicsT.TemplateID = EMRTemplateT.ID "
			"LEFT JOIN EMRTemplateTopicsT AS SourceEMRTemplateTopicsT ON EMRTemplateTopicsT.SourceTemplateTopicID = SourceEMRTemplateTopicsT.ID "
			"LEFT JOIN EmrActionsT ON EmrActionsT.ID = EMRTemplateTopicsT.SourceActionID "
			// (a.walling 2010-04-06 08:16) - PLID 38061 - Filtered these on their appropriate source types
			"LEFT JOIN EmrInfoT ON EmrInfoT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 3 "
			"LEFT JOIN EmrDataT ON EmrDataT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 4 "
			"LEFT JOIN ProcedureT ON ProcedureT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 5 "
			"LEFT JOIN (SELECT EmrImageHotSpotsT.ID, EmrImageHotSpotsT.EmrSpotGroupID, "
			// (z.manning 2010-04-30 16:28) - PLID 37553 - Pull anatomic location from a view
			"EmrHotSpotAnatomicLocationQ.AnatomicLocation "
			"FROM EmrImageHotSpotsT  "
			"LEFT JOIN EmrHotSpotAnatomicLocationQ ON EmrImageHotSpotsT.ID = EmrHotSpotAnatomicLocationQ.EmrHotSpotID) AS EmrImageHotSpotQ ON EmrActionsT.SourceID = EmrImageHotSpotQ.ID AND EmrActionsT.SourceType = %i "
			// (a.walling 2010-04-02 18:11) - PLID 38059
			"LEFT JOIN (SELECT EmrTableDropdownInfoT.ID, EmrTableDropdownInfoT.DropdownGroupID, EmrTableDropdownInfoT.Data AS DropdownData, EMRDataTableColumnQ.Data AS DropdownTableColumn "
				"FROM EmrTableDropdownInfoT "
				"INNER JOIN EMRDataT EMRDataTableColumnQ ON EMRTableDropdownInfoT.EMRDataID = EMRDataTableColumnQ.ID "
				"AND EMRDataTableColumnQ.ListType IN (3,4) " // (a.walling 2013-02-28 17:35) - PLID 55391 - This eliminates thousands of seeks!
				") AS EmrTableDropdownQ ON EmrTableDropdownQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = %i "
			// (a.walling 2010-04-02 16:42) - PLID 38059
			"LEFT JOIN EMRTemplateDetailsT SourceEMRDetailQ ON EMRTemplateTopicsT.SourceDetailID = SourceEMRDetailQ.ID "
			"LEFT JOIN EMRInfoMasterT SourceEMRInfoMasterQ ON SourceEMRDetailQ.EMRInfoMasterID = SourceEMRInfoMasterQ.ID "
			"LEFT JOIN EMRDataT EmrTableDropdownRowQ ON EMRTemplateTopicsT.SourceDataGroupID = EMRTableDropdownRowQ.EmrDataGroupID AND SourceEMRInfoMasterQ.ActiveEMRInfoID = EmrTableDropdownRowQ.EMRInfoID AND EmrActionsT.SourceType = 13 "
			//		Include all topics for this template
			"WHERE EMRTemplateTopicsT.TemplateID = ? "
			//		Also include all source topics
			// (c.haag 2007-07-23 10:12) - PLID 26344 - Do not include topics that are related by SourceTemplateTopicID
			"OR EMRTemplateTopicsT.ID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = ?) "
			"ORDER BY EmrTemplateTopicsT.OrderIndex ",
			eaoEmrItem, eaoEmrDataItem, eaoProcedure, eaoEmrImageHotSpot, eaoEmrImageHotSpot, eaoEmrTableDropDownItem);
}

// (c.haag 2011-03-17) - PLID 42895 - Returns common lists of details in topics for a specified template
void CEMN::AppendTemplateLoadSubQuery_rsPreloadCommonLists(CString& strSql) const
{
	// (c.haag 2011-04-11) - PLID 43155 - Added GroupOnPreviewPane
	strSql += "SELECT EmrInfoCommonListT.ID, EmrInfoCommonListT.EmrInfoID, EmrInfoCommonListT.Name, "
		"EmrInfoCommonListT.Color, EmrInfoCommonListT.OrderID, EmrInfoCommonListT.Inactive, "
		"EmrInfoCommonListT.GroupOnPreviewPane "
		"FROM EmrInfoCommonListT "
		"WHERE EmrInfoCommonListT.Inactive = 0 "
		"AND EmrInfoCommonListT.EmrInfoID IN "
		"(SELECT ActiveEmrInfoID "
		"FROM EmrTemplateTopicsT "
		"INNER JOIN EMRTemplateDetailsT ON EMRTemplateDetailsT.EMRTemplateTopicID = EmrTemplateTopicsT.ID "
		"INNER JOIN EMRInfoMasterT ON EMRInfoMasterT.ID = EMRTemplateDetailsT.EmrInfoMasterID "
		"WHERE EmrTemplateTopicsT.TemplateID = ?) "
		"ORDER BY EmrInfoCommonListT.OrderID "
		"; \r\n";
}

// (c.haag 2011-03-17) - PLID 42895 - Returns common list items of details in topics for a specified template
void CEMN::AppendTemplateLoadSubQuery_rsPreloadCommonListItems(CString& strSql) const
{
	strSql += "SELECT EmrInfoCommonListItemsT.ID, EmrInfoCommonListItemsT.ListID, EmrInfoCommonListItemsT.EmrDataID, "
			"EmrInfoCommonListT.EmrInfoID, EmrDataT.Data "
			"FROM EmrInfoCommonListT "
			"INNER JOIN EmrInfoCommonListItemsT ON EmrInfoCommonListItemsT.ListID = EmrInfoCommonListT.ID "
			"INNER JOIN EmrDataT ON EmrDataT.ID = EmrInfoCommonListItemsT.EmrDataID "
			"WHERE EmrInfoCommonListT.Inactive = 0 AND EmrDataT.Inactive = 0 "
			"AND EmrInfoCommonListT.EmrInfoID IN "
			"(SELECT ActiveEmrInfoID "
			"FROM EmrTemplateTopicsT "
			"INNER JOIN EMRTemplateDetailsT ON EMRTemplateDetailsT.EMRTemplateTopicID = EmrTemplateTopicsT.ID "
			"INNER JOIN EMRInfoMasterT ON EMRInfoMasterT.ID = EMRTemplateDetailsT.EmrInfoMasterID "						
			"WHERE EmrTemplateTopicsT.TemplateID = ?) "
			"; \r\n";
}

// (j.jones 2007-07-17 09:45) - PLID 26702 - added pSourceEMN, for when we create dummy EMNs
// for popups, we can query the source EMN for key data		
// (z.manning 2009-03-04 14:29) - PLID 33338 - Use the new source action info class
void CEMN::LoadFromTemplateID(long nEmrTemplateID, BOOL bIsTemplate, SourceActionInfo &sai, BOOL bLoadHiddenTopics /*= FALSE*/, OPTIONAL IN CEMN *pSourceEMN /*= NULL*/)
{
	try {
		//TES 6/29/2006 - This block of code must be called before GetParentEMR() is called (because GetParentEMR() may create 
		// our parent, which will count on us to have a valid ID.  So, it is copied in both LoadFromTemplateID() and LoadFromTemplateRecordsets(),
		// since LoadFromTemplateID() needs to call GetParentEMR() to determine the patient ID.
		if(bIsTemplate) {
			m_nID = nEmrTemplateID;
		}
		else {
			m_bUnsaved = TRUE;
			m_bMoreInfoUnsaved = TRUE;
			//TES 2/12/2014 - PLID 60470 - Added m_bCodesUnsaved
			m_bCodesUnsaved = TRUE;

		}
		m_nTemplateID = nEmrTemplateID;
		m_bIsTemplate = bIsTemplate;
		//END block of duplicated code.

		// (j.jones 2011-04-28 14:39) - PLID 43122 - I moved the provider loading from
		// LoadFromTemplateRecordsets to LoadFromTemplateID, because now we need it
		// prior to generating those recordsets.
		if(!bIsTemplate) {

			// (j.jones 2007-07-17 10:52) - PLID 26702 - if we have a pSourceEMN,
			// we can just copy over its providers
			// (j.jones 2011-04-14 11:17) - PLID 40257 - also copy their secondary providers
			if(pSourceEMN) {
				CArray<EMNProvider*,EMNProvider*> aryMainProviders;
				pSourceEMN->GetProviderList(aryMainProviders);
				SetProviderList(aryMainProviders);

				CArray<long, long> arySecondaryProviders;
				pSourceEMN->GetSecondaryProviders(arySecondaryProviders);
				SetSecondaryProviders(arySecondaryProviders);

				// (a.walling 2013-02-08 12:12) - PLID 55080 - Ensure we copy the appointment as well if one is not already set
				if (-1 == GetAppointment().nID) {
					SetAppointment(pSourceEMN->GetAppointment());
				}
			}
			else {

				//try to default the provider ID to the patient's provider ID,
				//or the provider on the last EMN, if one exists
				LoadDefaultProviderIDs();
			}	
		}
		
		_RecordsetPtr prsNextRecordset;

		// (c.haag 2007-05-15 10:13) - PLID 26013 - Run a minimal query for -1 template ID's
		if (-1 == nEmrTemplateID) {
			if(!bIsTemplate) {
				// (j.jones 2007-07-17 09:58) - PLID 26702 - don't open a recordset for a -1 patient ID,
				// also don't open if we were given a pSourceEMN				
				long nPatientID = GetParentEMR()->GetPatientID();
				if(nPatientID != -1 && pSourceEMN == NULL) {
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					prsNextRecordset = CreateParamRecordset(
						//rsPatientInfo
						"SELECT First, Middle, Last, Gender, BirthDate FROM PersonT WHERE ID = {INT}; \r\n",
						nPatientID);
				}
			} else {
				// If we get here, prsNextRecordset will be null when we pass it in to LoadFromTemplateRecordsets.
				// That function will check for this condition.
			}
		} else { 
			ASSERT(nEmrTemplateID > 0);

			//TES 2/16/2006 - Are we loading hidden topics (spawned ones that haven't been spawned?
			CString strHidden = bLoadHiddenTopics?"1=1":"EmrTemplateTopicsT.SourceActionID Is Null";

			//DRT 9/19/2006 - PLID 22413 - If preference is turned on, we will copy the diagnosis codes from general 2.  This code also
			//	exists in CEmrTreeWnd::AddEMNFromTemplate
			//DRT 7/17/2007 - PLID 26713 - Parameterized this section of the query
			CString strIncludePatientICD9;
			long nLoadG2ICD9 = GetRemotePropertyInt("LoadGeneral2ICD9ToEMR", 0, 0, "<None>", true);
			if(nLoadG2ICD9 != 0) {
				long nPatientID = GetParentEMR()->GetPatientID();
				//TES 2/28/2014 - PLID 61046 - Added ICD-10 fields
				// (s.dhole 2014-03-06 12:44) - PLID 60825 added NexGEMMatchType 
				// (s.dhole 2014-03-07 14:39) - PLID 61261 Added DefaultICD10DiagID validation
				// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
				strIncludePatientICD9.Format(
					"UNION SELECT NULL AS ID, DiagCodes.ID AS DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, 1 AS OrderIndex, "
					"DiagCodes_10.ID AS DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc, CAST(0 AS TINYINT) AS NexGEMMatchType, GCQI.QuickListID "
					"FROM PatientsT LEFT JOIN DiagCodes on PatientsT.DefaultDiagID1 = DiagCodes.ID LEFT JOIN DiagCodes DiagCodes_10 ON PatientsT.DefaultICD10DiagID1 = DiagCodes_10.ID  "
					"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, DefaultDiagID1, DefaultICD10DiagID1) GCQI "
					" WHERE PatientsT.PersonID = ? AND ((Patientst.DefaultDiagID1 IS NOT NULL   AND DiagCodes.Active = 1) OR (Patientst.DefaultICD10DiagID1 IS NOT NULL AND DiagCodes_10.Active = 1))  "
					"UNION SELECT NULL AS ID, DiagCodes.ID AS DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, 2 AS OrderIndex, "
					"DiagCodes_10.ID AS DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc, CAST(0 AS TINYINT)  AS NexGEMMatchType, GCQI.QuickListID "
					"FROM PatientsT LEFT JOIN DiagCodes on PatientsT.DefaultDiagID2 = DiagCodes.ID LEFT JOIN DiagCodes DiagCodes_10 ON PatientsT.DefaultICD10DiagID2 = DiagCodes_10.ID  "
					"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, DefaultDiagID1, DefaultICD10DiagID1) GCQI "
					" WHERE PatientsT.PersonID = ? AND ((Patientst.DefaultDiagID2 IS NOT NULL  AND DiagCodes.Active = 1) OR (Patientst.DefaultICD10DiagID2 IS NOT NULL AND DiagCodes_10.Active = 1)) "
					"UNION SELECT NULL AS ID, DiagCodes.ID AS DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, 3 AS OrderIndex, "
					"DiagCodes_10.ID AS DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc, CAST(0 AS TINYINT)  AS NexGEMMatchType, GCQI.QuickListID "
					"FROM PatientsT LEFT JOIN DiagCodes on PatientsT.DefaultDiagID3 = DiagCodes.ID LEFT JOIN DiagCodes DiagCodes_10 ON PatientsT.DefaultICD10DiagID3 = DiagCodes_10.ID  "
					"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, DefaultDiagID1, DefaultICD10DiagID1) GCQI "
					" WHERE PatientsT.PersonID = ? AND ((Patientst.DefaultDiagID3 IS NOT NULL  AND DiagCodes.Active = 1) OR (Patientst.DefaultICD10DiagID3 IS NOT NULL AND DiagCodes_10.Active = 1))  "
					"UNION SELECT NULL AS ID, DiagCodes.ID AS DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, 4 AS OrderIndex, "
					"DiagCodes_10.ID AS DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber, DiagCodes_10.CodeDesc AS ICD10CodeDesc , CAST(0 AS TINYINT)  AS NexGEMMatchType, GCQI.QuickListID "
					"FROM PatientsT LEFT JOIN DiagCodes on PatientsT.DefaultDiagID4 = DiagCodes.ID LEFT JOIN DiagCodes DiagCodes_10 ON PatientsT.DefaultICD10DiagID4 = DiagCodes_10.ID "
					"CROSS APPLY dbo.GetQuickListIDForCodes(@userID, @diagDisplayPref, DefaultDiagID1, DefaultICD10DiagID1) GCQI "
					" WHERE PatientsT.PersonID = ? AND ((Patientst.DefaultDiagID4 IS NOT NULL AND DiagCodes.Active = 1) OR (Patientst.DefaultICD10DiagID4 IS NOT NULL AND DiagCodes_10.Active = 1)) ");
			}

			//DRT 7/17/2007 - PLID 26713 - Parameterized this query
			// (c.haag 2007-08-31 11:07) - PLID 27268 - This query is now built using Append... functions
			// (c.haag 2014-03-17) - PLID 60929 - Declare new variables here
			CString strLoadSql = GetrsPreloadDetailsBasicQDeclarations() +
				"DECLARE @userID INT; SET @userID = ?;"
				"DECLARE @diagDisplayPref INT; SET @diagDisplayPref = ?;"
				"";
			//rsPatientInfo
			AppendTemplateLoadSubQuery_rsPatientInfo(strLoadSql);
			//rsEMN
			AppendTemplateLoadSubQuery_rsEMN(strLoadSql);
			//rsProcs 
			AppendTemplateLoadSubQuery_rsProcs(strLoadSql);
			//rsDiags
			AppendTemplateLoadSubQuery_rsDiags(strLoadSql, strIncludePatientICD9);
			//rsCharges
			AppendTemplateLoadSubQuery_rsCharges(strLoadSql);
			//rsMedications
			AppendTemplateLoadSubQuery_rsMedications(strLoadSql);
			//TES 4/15/2010 - PLID 24692 - rsTopicPositions
			AppendTemplateLoadSubQuery_rsTopicPositions(strLoadSql);
			// (c.haag 2007-02-27 10:22) - PLID 24949 - rsPreloadDetails
			AppendTemplateLoadSubQuery_rsPreloadDetails(strLoadSql);
			//rsPreloadTemplateTopics
			AppendTemplateLoadSubQuery_rsPreloadTemplateTopics(strLoadSql);
			// (c.haag 2011-03-17) - PLID 42895 - Common lists
			AppendTemplateLoadSubQuery_rsPreloadCommonLists(strLoadSql);
			// (c.haag 2011-03-17) - PLID 42895 - Common list items
			AppendTemplateLoadSubQuery_rsPreloadCommonListItems(strLoadSql);

			//DRT 7/17/2007 - PLID 26713 - Parameterized this query to enable better caching through the SQL server
			_CommandPtr pCmd = OpenParamQuery(strLoadSql);

			// (c.haag 2014-03-17) - PLID 60929 - Populate new variables here
			AddParameterLong(pCmd, "userID", GetCurrentUserID());
			AddParameterLong(pCmd, "diagDisplayPref", DiagQuickListUtils::GetAPIDiagDisplayTypeInt());

			long nPatientID = GetParentEMR()->GetPatientID();
			AddParameterLong(pCmd, "PatientID", nPatientID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			if(nLoadG2ICD9 != 0) {
				//Need to add parameters for the Patient ID generated in the strIncludePatientICD9 query
				AddParameterLong(pCmd, "PatientID", nPatientID);
				AddParameterLong(pCmd, "PatientID", nPatientID);
				AddParameterLong(pCmd, "PatientID", nPatientID);
				AddParameterLong(pCmd, "PatientID", nPatientID);
			}
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
			// (c.haag 2011-03-17) - PLID 42895 - Parameters for common list items
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);
			AddParameterLong(pCmd, "TemplateID", nEmrTemplateID);

			prsNextRecordset = CreateRecordset(pCmd);
		}

		// (j.jones 2007-07-17 10:05) - PLID 26702 - pass in pSourceEMN
		LoadFromTemplateRecordsets(nEmrTemplateID, bIsTemplate, sai, bLoadHiddenTopics, prsNextRecordset, pSourceEMN);
		// (j.armen 2014-01-28 15:46) - PLID 30574 - If an exception was thrown, we must pass it on to the caller so that they know we have failed to load
	}NxCatchAllThrow("Error in CEMN::LoadFromTemplateID()");
}

// (s.dhole 2014-03-10 12:43) - PLID 61303 Check duplicat diagnosis code 
BOOL CEMN::CheckDuplicateDiagCode(long nDiagCodeID, long nDiagCodeID10)
{
	BOOL bIsDuplicate=FALSE;
	for(int i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		if ((nDiagCodeID !=-1 && nDiagCodeID10 !=-1 &&  m_aryDiagCodes[i]->nDiagCodeID == nDiagCodeID && m_aryDiagCodes[i]->nDiagCodeID_ICD10== nDiagCodeID10) ||
			(nDiagCodeID !=-1 && nDiagCodeID10 ==-1 &&  m_aryDiagCodes[i]->nDiagCodeID == nDiagCodeID ) ||
			(nDiagCodeID ==-1 && nDiagCodeID10 !=-1 &&  m_aryDiagCodes[i]->nDiagCodeID_ICD10== nDiagCodeID10 ))
		{
			bIsDuplicate = TRUE;
			break;
		}
	}
	return bIsDuplicate;
}

// (j.jones 2007-07-17 09:45) - PLID 26702 - added pSourceEMN, for when we create dummy EMNs
	// for popups, we can query the source EMN for key data
// (z.manning 2009-03-04 14:29) - PLID 33338 - Use the new source action info class
void CEMN::LoadFromTemplateRecordsets(long nEmrTemplateID, BOOL bIsTemplate, SourceActionInfo &sai, BOOL bLoadHiddenTopics, ADODB::_Recordset *lprsAllRecordsets, OPTIONAL IN CEMN *pSourceEMN /*= NULL*/)
{
	try {
		//TES 6/29/2006 - This block of code must be called before GetParentEMR() is called (because GetParentEMR() may create 
		// our parent, which will count on us to have a valid ID.  So, it is copied in both LoadFromTemplateID() and LoadFromTemplateRecordsets(),
		// since LoadFromTemplateID() needs to call GetParentEMR() to determine the patient ID.
		if(bIsTemplate) {
			m_nID = nEmrTemplateID;
		}
		else {
			m_bUnsaved = TRUE;
			m_bMoreInfoUnsaved = TRUE;
			//TES 2/12/2014 - PLID 60470 - Added m_bCodesUnsaved
			m_bCodesUnsaved = TRUE;
		}
		m_nTemplateID = nEmrTemplateID;
		m_bIsTemplate = bIsTemplate;
		//END block of duplicated code.

		SetInterface(GetParentEMR()->GetInterface());
		if (!GetInterface()) {
			// (a.walling 2007-12-26 14:41) - PLID 28443 - Prevent spawning from occurring if we have no interface to post messages to.
			if (GetParentEMR()) GetParentEMR()->LockSpawning();
		}

		// (z.manning 2009-03-04 14:36) - PLID 33338
		m_sai = sai;

		// (j.jones 2011-04-28 14:39) - PLID 43122 - I moved the provider loading from
		// LoadFromTemplateRecordsets to LoadFromTemplateID, because now we need it
		// prior to generating those recordsets.

		//If this is an EMN, load the patient info.
		_RecordsetPtr prsNextRecordset(lprsAllRecordsets);
		if(!bIsTemplate) {

			// (j.jones 2007-07-17 10:06) - PLID 26702 - if given a pSourceEMN, pull the patient
			// demographics from that EMN
			if(pSourceEMN) {
				m_cbPatientGender = pSourceEMN->GetPatientGender();
				m_strPatientAge = pSourceEMN->GetPatientAge();
				m_strPatNameFirst = pSourceEMN->GetPatientNameFirst();
				m_strPatNameMiddle = pSourceEMN->GetPatientNameMiddle();
				m_strPatNameLast = pSourceEMN->GetPatientNameLast();
			}
			//m.hancock - 3/14/2006 - 19579 - Added patient's first, middle, and last names to query
			else if(!prsNextRecordset->eof) {
				m_cbPatientGender = AdoFldByte(prsNextRecordset, "Gender", 0);
				_variant_t varBirthDate = prsNextRecordset->Fields->GetItem("BirthDate")->Value;
				if(varBirthDate.vt == VT_DATE) {
					// (j.dinatale 2010-10-13) - PLID 38575 - need to call GetPatientAgeOnDate which no longer does any validation, 
					//  validation should only be done when bdays are entered/changed
					m_strPatientAge = ::GetPatientAgeOnDate(VarDateTime(varBirthDate), COleDateTime::GetCurrentTime(), TRUE);
				}
				//m.hancock - 3/14/2006 - 19579 - Set the patient's name fields
				m_strPatNameFirst = AdoFldString(prsNextRecordset, "First", "");
				m_strPatNameMiddle = AdoFldString(prsNextRecordset, "Middle", "");
				m_strPatNameLast = AdoFldString(prsNextRecordset, "Last", "");
			}
		}
		// (c.haag 2007-05-15 10:31) - PLID 26013 - prsNextRecordset can be NULL if nEmrTemplateID is -1
		// and bIsTemplate is true
		if (NULL != prsNextRecordset) {
			prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		}

		if(nEmrTemplateID == -1) {
			//we aren't loading a template from data, so we can quit now
			//TES 2/20/2007 - PLID 24750 - However, we do need to set our flag indicating that the loading is done.
			SetLoaded();
			// (a.walling 2007-12-26 14:41) - PLID 28443 - Unlock spawning
			if (!GetInterface()) {
				if (GetParentEMR()) GetParentEMR()->UnlockSpawning();
			}
			return;
		}

		//load a template
			
		//Load the description
		if(!prsNextRecordset->eof) {					
			m_strDescription = AdoFldString(prsNextRecordset, "Name", "");
			m_nEMRCollectionID = AdoFldLong(prsNextRecordset, "CollectionID", -1);
			if(m_bIsTemplate) {
				m_bAddOnce = AdoFldBool(prsNextRecordset, "AddOnce");
				//TES 11/2/2009 - PLID 35808 - Also load NexWebUUID
				//(e.lally 2011-05-04) PLID 43537 - Now called m_bNexWebVisible
				m_bNexWebVisible = AsBool(AdoFldBool(prsNextRecordset, "NexWebVisible", FALSE));

				// (j.gruber 2012-08-31 14:44) - PLID 52285 - set omr template
				m_bIsOMRTemplate = AsBool(AdoFldBool(prsNextRecordset, "IsOMRTemplate", FALSE));

			}
			m_strLastSavedDescription = m_strDescription;

			// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
			m_nVisitTypeID = AdoFldLong(prsNextRecordset, "VisitTypeID", -1);
			m_strVisitTypeName = AdoFldString(prsNextRecordset, "VisitTypeName", "");

			//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
			m_bHideTitleOnPreview = AdoFldBool(prsNextRecordset, "HideTitleOnPreview", FALSE)?true:false;

			// (z.manning, 04/12/2007) - PLID 25600 - Load chart.
			SetChart(AdoFldLong(prsNextRecordset, "EmnTabChartID", -1), AdoFldString(prsNextRecordset, "ChartName", ""));
			// (z.manning, 05/07/2007) - PLID 25731 - Load category.
			m_Category.nID = AdoFldLong(prsNextRecordset, "EmnTabCategoryID", -1);
			m_Category.strName = AdoFldString(prsNextRecordset, "CategoryName", "");
			// (d.thompson 2009-05-27) - PLID 29909 - Confidential info cannot be applied to a template
			m_strConfidentialInfo = "";

			// (z.manning 2011-05-18 12:14) - PLID 43756 - If this is a new EMN and we have a default chart then we
			// may want to override the EMN location with the chart's location rather than the logged in location.
			if(m_nID == -1 && !m_bIsTemplate && m_Chart.nID != -1)
			{
				long nChartLocationID = AdoFldLong(prsNextRecordset, "ChartLocationID", -1);
				if(nChartLocationID != -1 && nChartLocationID != GetLocationID())
				{
					// (z.manning 2011-05-18 12:16) - PLID 43756 - Ok, the chart for this EMN has a default location so
					// let's set this EMN to use it.
					CString strChartLocationName = AdoFldString(prsNextRecordset, "ChartLocationName", "");
					CString strChartLocationLogoPath = AdoFldString(prsNextRecordset, "ChartLocationLogoImagePath", "");
					long nChartLocationLogoWidth = AdoFldLong(prsNextRecordset, "ChartLocationLogoWidth", 100);
					SetLocation(nChartLocationID, strChartLocationName, strChartLocationLogoPath, nChartLocationLogoWidth);
				}
			}

			// (a.walling 2008-05-29 10:43) - PLID 22049 - Added Revision
			SetRevision(prsNextRecordset->Fields->Item["Revision"]->Value);

			// (z.manning, 10/02/2007) - PLID 25731 - Set the last saved info for charts and categories.
			// (z.manning, 11/01/2007) - But not if this is a new EMN.
			if(m_nID != -1)
			{
				m_LastSavedChart.nID = m_Chart.nID;
				m_LastSavedChart.strName = m_Chart.strName;
				m_LastSavedCategory.nID = m_Category.nID;
				m_LastSavedCategory.strName = m_Category.strName;
			}

			// (j.jones 2007-10-02 10:09) - PLID 27054 - set the last saved info for VisitType
			m_nLastSavedVisitTypeID = m_nVisitTypeID;
			m_strLastSavedVisitTypeName = m_strVisitTypeName;

			//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
			m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview;

			// (j.jones 2007-06-14 11:45) - PLID 26276 - although unused on templates,
			// set the Completion Status to ecsEmpty
			m_ecsCompletionStatus = ecsEmpty;

		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (z.manning, 04/12/2007) - PLID 25600 - If we didn't find a category, then ask them for one
		// if they have the preference set and we're on a patient EMN.
		// (z.manning, 06/04/2007) - PLID 25701 - Category prompting is handled in CEmrTreeWnd::AddEMNFromTemplate().

		//Load the procedures.
		m_aryProcedures.RemoveAll();
		while(!prsNextRecordset->eof) {
			EMNProcedure *pProc = new EMNProcedure;
			pProc->nID = AdoFldLong(prsNextRecordset, "ProcedureID");
			if(bIsTemplate)
				pProc->bIsNew = FALSE;
			else
				pProc->bIsNew = TRUE;
			pProc->strName = AdoFldString(prsNextRecordset, "Name", "");
			m_aryProcedures.Add(pProc);

			if(GetInterface())
				GetInterface()->SendMessage(NXM_EMN_PROCEDURE_ADDED, (WPARAM)pProc, (LPARAM)this);

			prsNextRecordset->MoveNext();
		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (z.manning, 01/31/2007) - PLID 24468 - Process any actions for this procedure.
		if(GetParentEMR()) {
			GetParentEMR()->ProcessEmrProcedureActions(m_aryProcedures, this, TRUE);
		}
		else {
			ASSERT(FALSE);
		}

		//Load the diag codes
		m_aryDiagCodes.RemoveAll();
		while(!prsNextRecordset->eof) {
			// (s.dhole 2014-03-10 12:43) - PLID 61303
			long nDiagCodeID =AdoFldLong(prsNextRecordset, "DiagCodeID",-1);
			long nDiagCodeID10 =AdoFldLong(prsNextRecordset, "DiagCodeID_ICD10",-1);
			BOOL bDuplicate = CheckDuplicateDiagCode(nDiagCodeID,nDiagCodeID10);
			if (bDuplicate){
				prsNextRecordset->MoveNext();
				continue;
			}
			
			EMNDiagCode *pCode = new EMNDiagCode;
			// (j.jones 2008-07-23 10:20) - PLID 30819 - changed the original nID to nDiagCodeID,
			// then added a new nID for the actual record ID
			//TES 2/28/2014 - PLID 61046 - DiagCodeID might be NULL
			pCode->nDiagCodeID = nDiagCodeID ;// (s.dhole 2014-03-10 12:43) - PLID 61303
			if(bIsTemplate) {
				pCode->bIsNew = FALSE;
				// (j.jones 2008-07-23 10:20) - PLID 30819 - changed the original nID to nDiagCodeID,
				// then added a new nID for the actual record ID (will be -1 always on templates)
				pCode->nID = AdoFldLong(prsNextRecordset, "ID", -1);
			}
			else {
				pCode->bIsNew = TRUE;
				pCode->nID = -1;
			}
			pCode->strCode = AdoFldString(prsNextRecordset, "CodeNumber", "");
			pCode->strCodeDesc = AdoFldString(prsNextRecordset, "CodeDesc", "");
			pCode->nOrderIndex = AdoFldLong(prsNextRecordset, "OrderIndex", -1);
			//TES 2/28/2014 - PLID 61046 - Added ICD-10 fields
			pCode->nDiagCodeID_ICD10 = nDiagCodeID10;// (s.dhole 2014-03-10 12:43) - PLID 61303
			pCode->strCode_ICD10 = AdoFldString(prsNextRecordset, "ICD10CodeNumber", "");
			pCode->strCodeDesc_ICD10 = AdoFldString(prsNextRecordset, "ICD10CodeDesc", "");
			// (s.dhole 2014-03-06 12:44) - PLID 60825 load EmrDiagCodesT.NexGEMMatchType 
			pCode->MatchType = GetNexGEMMatchType(AdoFldByte(prsNextRecordset, "NexGEMMatchType", 0));
			// (c.haag 2014-03-17) - PLID 60929 - Added QuickListID
			pCode->nQuickListID = AdoFldLong(prsNextRecordset, "QuickListID", -1);
			pCode->bHasMoved = FALSE;
			pCode->bChanged = FALSE;
			// (j.jones 2014-12-23 15:07) - PLID 64491 - added bReplaced
			pCode->bReplaced = FALSE;
			m_aryDiagCodes.Add(pCode);
			prsNextRecordset->MoveNext();
		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//Load the charges
		m_aryCharges.RemoveAll();
		//TES 6/15/2012 - PLID 50983 - Added m_aryOriginalCharges
		// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
		m_aryOriginalCharges.RemoveAll();
		while(!prsNextRecordset->eof) {
			EMNCharge *pNewCharge = new EMNCharge;
			if (bIsTemplate){
				// (s.tullis 2015-04-15 09:52) - PLID 65539 
				// This is loading a template to edit 
				// we don't support saving categories in template setup
				// this is hidden but load the (none) ID and 0 categorycount to disable it just in case the user unhides it
				pNewCharge->nID = AdoFldLong(prsNextRecordset, "ID");
				pNewCharge->nCategoryID = -1;
				pNewCharge->nCategoryCount = 0;
			}
			else{
				pNewCharge->nID = -1;
				pNewCharge->nCategoryID =AdoFldLong(prsNextRecordset, "Category",-1);
				pNewCharge->nCategoryCount = AdoFldLong(prsNextRecordset, "CategoryCount", 0);
			}
			
			pNewCharge->nServiceID = AdoFldLong(prsNextRecordset, "ServiceID");
			pNewCharge->strDescription = AdoFldString(prsNextRecordset, "Description","");
			pNewCharge->strMod1 = AdoFldString(prsNextRecordset, "CPTModifier1","");
			pNewCharge->strMod2 = AdoFldString(prsNextRecordset, "CPTModifier2","");
			pNewCharge->strMod3 = AdoFldString(prsNextRecordset, "CPTModifier3","");
			pNewCharge->strMod4 = AdoFldString(prsNextRecordset, "CPTModifier4","");
			pNewCharge->dblQuantity = AdoFldDouble(prsNextRecordset, "Quantity",0.0);
			pNewCharge->cyUnitCost = AdoFldCurrency(prsNextRecordset, "UnitCost",COleCurrency(0,0));
			if(bIsTemplate)
				pNewCharge->bChanged = FALSE;
			else
				pNewCharge->bChanged = TRUE;
			pNewCharge->strSubCode = AdoFldString(prsNextRecordset, "SubCode","");
			pNewCharge->strCode = AdoFldString(prsNextRecordset, "Code","");
			// (j.jones 2008-06-04 16:17) - PLID 30255 - added nQuoteChargeID
			pNewCharge->nQuoteChargeID = AdoFldLong(prsNextRecordset, "QuoteChargeID", -1);
			// (j.jones 2011-03-28 14:45) - PLID 42575 - added Billable flag
			pNewCharge->bBillable = AdoFldBool(prsNextRecordset, "Billable", TRUE);
			m_aryCharges.Add(pNewCharge);

			// (j.jones 2011-11-21 17:28) - PLID 38366 - ensure we update coding groups properly
			if(!bIsTemplate) {
				TryUpdateCodingGroupByServiceID(pNewCharge->nServiceID, FALSE, (long)(pNewCharge->dblQuantity));

				if(GetParentEMR()) {
					// (j.jones 2012-08-22 09:23) - PLID 50486 - set the default insured party ID
					pNewCharge->nInsuredPartyID = GetParentEMR()->GetDefaultChargeInsuredPartyID();

					// (j.jones 2012-03-27 15:10) - PLID 44763 - warn if we're under a global period
					if(GetParentEMR()->GetInterface()) {
						GetParentEMR()->GetInterface()->CheckWarnGlobalPeriod_EMR(m_dtEMNDate);
					}
				}
			}

			prsNextRecordset->MoveNext();
		}
		//TES 6/15/2012 - PLID 50983 - Now copy everything we just loaded into m_aryOriginalCharges
		for(int i = 0; i < m_aryCharges.GetSize(); i++) {
			EMNCharge *pOriginalCharge = new EMNCharge;
			*pOriginalCharge = *(m_aryCharges[i]);
			m_aryOriginalCharges.Add(pOriginalCharge);
		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//Load the medications
		m_aryMedications.RemoveAll();
		while(!prsNextRecordset->eof) {

			// (j.jones 2012-11-21 14:19) - PLID 53818 - shared this function from loading a template and ReloadTemplateMedicationsFromData
			AddTemplateMedicationFromRecordset(bIsTemplate, prsNextRecordset);

			prsNextRecordset->MoveNext();
		}

		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//TES 4/15/2010 - PLID 24692 - Load the topic positions into a linked list.
		_RecordsetPtr rsTopicPositions = prsNextRecordset;
		if(m_bIsTemplate) {
			//TES 4/15/2010 - PLID 24692 - We shouldn't already have a linked list.
			ASSERT(m_pTopicPositionHead == NULL);
			struct SkippedPosition {
				TopicPositionEntry *tpe;
				long nParentTopicID;
			};
			CArray<SkippedPosition,SkippedPosition&> arSkippedPositions;
			while(!rsTopicPositions->eof) {
				TopicPositionEntry *tpe = new TopicPositionEntry;
				tpe->nTopicID = AdoFldLong(rsTopicPositions, "ID");
				//TES 4/15/2010 - PLID 24692 - The recordset orders it, so we can just add to the end.
				long nParentTopicID = AdoFldLong(rsTopicPositions, "EMRParentTemplateTopicID", -1);
				//TES 5/8/2010 - PLID 24692 - We may not have the parent in our list yet.
				if(nParentTopicID == -1) { 
					m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, -1);
				} else {
					TopicPositionEntry *tpeParent = m_pTopicPositionHead->GetEntryByID(nParentTopicID);
					if(tpeParent) {
						m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, tpeParent);
					}
					else {
						//TES 5/8/2010 - PLID 24692 - The parent isn't in there yet, so remember this position, we'll try adding once
						// we've finished going through the recordset.
						SkippedPosition sp;
						sp.tpe = tpe;
						sp.nParentTopicID = nParentTopicID;
						arSkippedPositions.Add(sp);
					}
				}
				rsTopicPositions->MoveNext();
			}
			//TES 5/8/2010 - PLID 24692 - Now, keep looping through the positions we skipped until we've added all of them to the list, or
			// until we've gone through the entire list without being able to add any.
			bool bOneAdded = true;
			while(arSkippedPositions.GetSize() && bOneAdded) {
				bOneAdded = false;
				for(int i = 0; i < arSkippedPositions.GetSize(); i++) {
					SkippedPosition sp = arSkippedPositions[i];
					TopicPositionEntry *tpeParent = m_pTopicPositionHead->GetEntryByID(sp.nParentTopicID);
					if(tpeParent) {
						m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, sp.tpe, tpeParent);
						arSkippedPositions.RemoveAt(i);
						i--;
						bOneAdded = true;
					}
				}
			}
			if(arSkippedPositions.GetSize()) {
				//TES 5/8/2010 - PLID 24692 - This has a parent topic that doesn't exist.  That shouldn't be possible, but it may happen
				// with bad data.  We'll free all the memory we allocated, then if those topics do get added, they'll get a new entry
				// added whereever the topic object gets put.
				ASSERT(FALSE);
				for(int i = 0; i < arSkippedPositions.GetSize(); i++) {
					delete arSkippedPositions[i].tpe;
				}
			}
		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);


		// (c.haag 2007-02-27 10:27) - PLID 24949 - Load details into a special preload array
		// for faster thread loading. This code is modeled off LoadEmrTopic. The object
		// CEMNPreloadedDetails supports reference counting, and is deleted when its last
		// reference is released after the last topic has loaded.
		// (c.haag 2007-03-16 10:58) - PLID 25239 - The EMN now maintains the preloaded detail list.
		// It should always be NULL at this point.
		if (NULL != m_pLoader) {
			ASSERT(FALSE);
			ThrowNxException("The loader object is already in use!");
		}

		// (j.jones 2011-04-28 14:39) - PLID 43122 - the loader now requires a provider ID for floating EMR data
		long nProviderIDForFloatingData = GetProviderIDForFloatingData();

		// (c.haag 2007-04-20 09:35) - PLID 25730 - Pass in a connection pointer so that the
		// preload object can do some initial processing
		// (c.haag 2007-04-24 09:23) - PLID 26464 - Now the loader object does all the processing
		// of rsPreloadDetails
		_ConnectionPtr pCon(prsNextRecordset->GetActiveConnection() );
		// (c.haag 2007-05-01 12:38) - PLID 25853 - Include "this" EMN object when constructing the loader
		// (c.haag 2007-05-02 08:59) - PLID 26464 - Add a reference to the loader object immediately
		// to make it impossible to self-delete before all the records have been processed.
		// (c.haag 2007-05-08 12:59) - PLID 25790 - Include the template ID
		// so as few queries as possible are run
		HWND hWndEMN = GetInterface() ? GetInterface()->GetSafeHwnd() : NULL;
		// (a.walling 2013-03-20 16:09) - PLID 55790 - No more loading behavior
		m_pLoader = new CEMNLoader(this, pCon, TRUE, bIsTemplate, nEmrTemplateID, nProviderIDForFloatingData);
		m_pLoader->AddRef();
		// (c.haag 2007-08-31 11:25) - PLID 27268 - Do this twice because we actually have two detail queries
		m_pLoader->PreloadEmrTemplateDetails(GetParentEMR()->GetPatientID(), prsNextRecordset, GetParentEMR());
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		m_pLoader->PreloadEmrTemplateDetails(GetParentEMR()->GetPatientID(), prsNextRecordset, GetParentEMR());
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		// (c.haag 2007-05-02 13:09) - PLID 25881 - rsPreloadTemplateTopics - Preload template topic data
		//DRT 9/25/2007 - PLID 27515 - Added SourceAction SourceID and SourceDataGroupID as -1 because this is the initial
		//	load and they aren't needed.
		m_pLoader->PreloadEmrTemplateTopics(prsNextRecordset, nEmrTemplateID, FALSE, hWndEMN,
			sai, bLoadHiddenTopics, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(),
			// (c.haag 2007-07-26 14:25) - PLID 26824 - Include the parent EMR so that CEMRTopic::LoadFromPreloadedTemplateTopic
			// won't fail if a topic has no parent EMN
			GetParentEMR(), //NULL
			TRUE, -1, -1);

		// (c.haag 2007-05-03 10:08) - PLID 25881 - This code has been depreciated by rsPreloadTemplateTopics
		//now load each topic, which in turn will load its subtopics or EMNDetails
		//prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		//while(!prsNextRecordset->eof) {
			//create and load the topic
		//	CEMRTopic* pNewTopic = new CEMRTopic(this);
			//add the topic to our array
		//	m_arypEMRTopics.Add(pNewTopic);
		//	pNewTopic->LoadFromTemplateTopicFields(prsNextRecordset->Fields, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, nSourceActionID, nSourceDetailID, NULL, bLoadHiddenTopics, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, m_pLoader);
			//TES 2/16/2007 - PLID 24768 - We only want SetNew() to be called at the EMN level, and after we are certain it is
			// completely loaded.
			/*if(bForceAddAsNew) {
				pNewTopic->SetNew();
			}*/

		//	prsNextRecordset->MoveNext();
		//}

		// (c.haag 2011-03-17) - PLID 42895 - Preload common lists
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		m_pLoader->PreloadEmrInfoCommonLists(prsNextRecordset);
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);
		m_pLoader->PreloadEmrInfoCommonListItems(prsNextRecordset);

		// (a.walling 2007-12-26 14:41) - PLID 28443 - Prevent spawning from occurring if we have no interface to post messages to.
		if (!GetInterface()) {
			if (GetParentEMR()) GetParentEMR()->UnlockSpawning();
		}

		// (c.haag 2007-05-02 09:00) - PLID 26464 - Release our reference to the loader object. We
		// created that reference to keep the loader object from self-deleting in the middle of processing
		// data without an interface window
		// (c.haag 2007-08-04 09:34) - PLID 26945 - If the reference count is one, do special handling with it
		// (internal error checking, etc), and then ensure it's deleted.
		if (1 == m_pLoader->GetRefCnt()) {
			RetireInitialLoader();
			ASSERT(NULL == m_pLoader);
		} else {
			m_pLoader->Release();
		}

		if(!m_arypEMRTopics.GetSize()) {
			//TES 2/20/2007 - PLID 24750 - If we have no topics, that means PostTopicLoad() will never get called.  However,
			// since the topics are the only things that are loaded asynchronously, we know now that we are fully loaded,
			// so set our flag.
			SetLoaded();
		}
		prsNextRecordset = prsNextRecordset->NextRecordset(NULL);

		//TES 7/10/2009 - PLID 25154 - If this isn't a template, it's a new EMN, so by default we want to send to HL7
		// (a.wilson 2013-05-21 14:37) - PLID 56763 - check the property for this before assigning.
		m_bSendBillToHL7 = (!bIsTemplate && GetRemotePropertyInt("SendBillingToHL7FromNewEMN", 0, 0, "<None>", true));

		// (a.walling 2008-06-02 12:24) - PLID 22049 - Notify the interface
		if (GetInterface()) {
			GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 0);
		}
	
		// (j.armen 2014-01-28 15:46) - PLID 30574 - If an exception was thrown, we must pass it on to the caller so that they know we have failed to load
	}NxCatchAllThrow("Error in CEMN::LoadFromTemplateRecordsets()");
}

//create a new EMN object with a collection ID
void CEMN::CreateNewTemplateEMN(long nCollectionID)
{
	m_nID = -1;
	m_nTemplateID = -1;
	m_bIsTemplate = TRUE;
	SetInterface(m_pParentEMR->GetInterface());
	m_nEMRCollectionID = nCollectionID;
	m_nVisitTypeID = -1;
	m_strVisitTypeName = "";
	m_strDescription = "[Enter Template Name]";
	m_bAddOnce = FALSE;
	//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
	m_bHideTitleOnPreview = FALSE;

	//add an empty topic
	//TES 4/15/2010 - PLID 24692 - Need to pass in an ID
	AddTopic("[Enter Topic Name]", -1);
}

// (a.walling 2012-03-23 15:27) - PLID 49187 - moved to inline
long CEMN::GetCollectionID()
{
	return m_nEMRCollectionID;
}

CEMR* CEMN::GetParentEMR()
{
	if(!m_pParentEMR) {
		ASSERT(m_bOwnParentEMR);
		// (a.walling 2010-10-18 17:32) - PLID 40260 - Allow using a default connection
		m_pParentEMR = new CEMR(FALSE, GetRemoteData());
		m_pParentEMR->LoadFromEmn(this);
	}
	return m_pParentEMR;
}

void CEMN::SetParentEMR(CEMR* pEMR)
{
	m_pParentEMR = pEMR;
}

// (a.walling 2010-10-18 17:07) - PLID 40260 - Allow using a default connection
ADODB::_ConnectionPtr CEMN::GetRemoteData()
{
	if (!m_pDefaultConnection) {
		if (m_pParentEMR) {
			return m_pParentEMR->GetRemoteData();
		} else {
			return ::GetRemoteData();
		}
	} else {
		return m_pDefaultConnection;
	}
}

void CEMN::SetEMNDate(const COleDateTime& dtDate)
{
	m_dtEMNDate = dtDate;
	//Update narratives to use the new date.
	//TES 1/23/2008 - PLID 24157 - Renamed.
	HandleDetailChange(NULL);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}


void CEMN::UpdatePatientDemographics(CWnd* pParentWnd)
{
	if(m_bIsTemplate) {
		ASSERT(FALSE);
		return;
	}

	//get the latest patient info. from data
	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	_RecordsetPtr rsPatientInfo = CreateParamRecordset("SELECT First, Middle, Last, Gender, BirthDate FROM PersonT WHERE ID = {INT}", GetParentEMR()->GetPatientID());
	if(!rsPatientInfo->eof) {
		//Name
		SetPatientNameFirst(AdoFldString(rsPatientInfo, "First", ""));
		SetPatientNameMiddle(AdoFldString(rsPatientInfo, "Middle", ""));
		SetPatientNameLast(AdoFldString(rsPatientInfo, "Last", ""));
		//Gender
		SetPatientGender(AdoFldByte(rsPatientInfo, "Gender", 0));
		
		//Birthdate
		_variant_t varBirthDate = rsPatientInfo->Fields->Item["BirthDate"]->Value;
		if(varBirthDate.vt == VT_DATE) {

			COleDateTime dtBirthDate = VarDateTime(varBirthDate);
			COleDateTime dtDate = GetEMNDate();

			if(dtDate.m_dt < dtBirthDate.m_dt) {
				//this replicates the feature for when we change the date on an unsaved EMN
				dtDate = COleDateTime::GetCurrentTime();

				// (j.jones 2009-09-24 10:13) - PLID 29718 - added preference to default to the last appt. date
				CString strDate = "today's date";
				if(GetRemotePropertyInt("EMNUseLastApptDate", 0, 0, "<None>", true) == 1) {
					COleDateTime dtLast = GetLastPatientAppointmentDate(GetParentEMR()->GetPatientID());
					//make sure the appt. isn't before the patient's birthdate
					COleDateTime dtBirthDate = GetParentEMR()->GetPatientBirthDate();
					if(dtLast.GetStatus() == COleDateTime::valid
						&& (dtBirthDate.GetStatus() != COleDateTime::valid || dtLast >= dtBirthDate)) {
						dtDate = dtLast;
						strDate = "the patient's last appointment date";
					}
				}

				CString strWarn;
				strWarn.Format("The EMN date is before the patient's birthdate. It has been reset to %s.\n"
					"Please check the date and set it to the appropriate date of service.", strDate);
				pParentWnd->MessageBox(strWarn);

				SetEMNDate(dtDate);
			}
			// (j.dinatale 2010-10-13) - PLID 38575 - need to call GetPatientAgeOnDate which no longer does any validation, 
			//  validation should only be done when bdays are entered/changed
			SetPatientAge(GetPatientAgeOnDate(dtBirthDate, dtDate, TRUE));
		}
		else {
			//we track "no age" as -1
			// (z.manning 2010-01-13 10:51) - PLID 22672 - Age is now a string
			SetPatientAge("");
		}
	}
	else {
		//this should not be possible
		ASSERT(FALSE);
		return;
	}
	rsPatientInfo->Close();

	// (j.jones 2007-10-18 17:49) - PLID 26974 - we need to update any narratives with the changed demographics
	//TES 1/23/2008 - PLID 24157 - Renamed.
	HandleDetailChange(NULL);

	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

// (a.walling 2012-06-11 09:20) - PLID 50495 - EMR Date - Need to update the age in some situations
void CEMN::UpdateEMNDate(COleDateTime dtDate, CWnd* pParentWnd)
{
	// (j.jones 2007-08-07 11:49) - PLID 26974 - disallow changing age on saved EMNs
	if (-1 != GetID()) { // already saved
		SetEMNDate(dtDate);
		return;
	}
	
	COleDateTime dtBirthDate = GetParentEMR()->GetPatientBirthDate();

	if( (dtDate.GetStatus() != COleDateTime::valid) || (dtBirthDate.GetStatus() == COleDateTime::valid && dtDate < dtBirthDate)) {
		pParentWnd->MessageBox("The EMN date cannot be before the patient's birthdate.");
		dtDate = COleDateTime::GetCurrentTime();

		// (j.jones 2009-09-24 10:13) - PLID 29718 - added preference to default to the last appt. date
		if(GetRemotePropertyInt("EMNUseLastApptDate", 0, 0, "<None>", true) == 1) {
			COleDateTime dtLast = GetLastPatientAppointmentDate(GetParentEMR()->GetPatientID());
			//make sure the appt. isn't before the patient's birthdate				
			if(dtLast.GetStatus() != COleDateTime::invalid
				&& (dtBirthDate.GetStatus() == COleDateTime::invalid || dtLast >= dtBirthDate)) {
				dtDate = dtLast;
			}
		}
	}

	SetEMNDate(dtDate);

	//always change the age
	if(dtBirthDate.GetStatus() == COleDateTime::valid) {
		// Use a temporary value so that GetPatientAge doesn't write to our stored member variable
		COleDateTime dtBirthDateTemporary = dtBirthDate;
		// (j.dinatale 2010-10-13) - PLID 38575 - need to call GetPatientAgeOnDate which no longer does any validation, 
		//  validation should only be done when bdays are entered/changed
		SetPatientAge(GetPatientAgeOnDate(dtBirthDateTemporary, dtDate, TRUE));
	}
	else {
		//invalid status, make sure it is empty
		// (z.manning 2010-01-13 10:51) - PLID 22672 - Age is now a string
		SetPatientAge("");
	}
}

// (a.walling 2012-06-07 09:11) - PLID 50920 - Dates - Modified, Created
CString CEMN::GetPatientName() const
{
	CString strName;
	strName.Preallocate(m_strPatNameLast.GetLength() + m_strPatNameMiddle.GetLength() + m_strPatNameFirst.GetLength() + 4);
	if (!m_strPatNameLast.IsEmpty()) {
		strName += m_strPatNameLast;
		strName += ", ";
	}
	strName += m_strPatNameFirst;
	strName += " ";
	strName += m_strPatNameMiddle;

	strName.Replace("  ", " ");
	strName.TrimRight(", ");
	return strName;
}

//DRT 7/13/2007 - PLID 26671 - Get the whole procedure structure array, not just the IDs
void CEMN::GetProcedures(OUT CArray<EMNProcedure, EMNProcedure> &arProcedures)
{
	arProcedures.RemoveAll();
	for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
		//Need to copy these
		EMNProcedure *pCurrentEMN = m_aryProcedures.GetAt(i);
		EMNProcedure pCopy(*pCurrentEMN);
		arProcedures.Add(pCopy);
	}
}

// (z.manning 2011-11-10 15:22) - PLID 37093
void CEMN::GetProcedureIDs(OUT CArray<long,long> *parynProcedureIDs)
{
	for(int nProcIndex = 0; nProcIndex < m_aryProcedures.GetCount(); nProcIndex++)
	{
		EMNProcedure *pProc = m_aryProcedures.GetAt(nProcIndex);
		parynProcedureIDs->Add(pProc->nID);
	}
}

EMNProcedure* CEMN::AddProcedure(EMNProcedure* pProcedure)
{	
	//ensure the procedure isn't already in our list
	for(int i=0;i<m_aryProcedures.GetSize();i++) {
		if(m_aryProcedures.GetAt(i)->nID == pProcedure->nID) {
			return m_aryProcedures.GetAt(i);
		}
	}

	//it's not in our list, so add it
	m_aryProcedures.Add(pProcedure);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();

	// (z.manning, 01/31/2007) - PLID 24468 - Process all procedure based actions.
	if(GetParentEMR()) {
		CArray<long,long> aryProcedureIDs;
		aryProcedureIDs.Add(pProcedure->nID);
		GetParentEMR()->ProcessEmrProcedureActions(aryProcedureIDs, this, FALSE);
	}

	// (z.manning 2011-11-11 10:00) - PLID 37093 - Update procedure narrative fields
	// (j.jones 2012-12-27 15:25) - PLID 54369 - the above item was never finished, and this created broken, half-working code
	//UpdateAllProcedureNarrativeFields();

	return pProcedure;
}

// (z.manning 2009-02-27 10:59) - PLID 33141 - Added an overload that takes a procedure ID and
// name but not source action stuff.
EMNProcedure* CEMN::AddProcedure(long nProcedureID, CString strName)
{
	SourceActionInfo sai;
	return AddProcedure(nProcedureID, strName, sai);
}

//DRT 3/6/2006 - PLID 19564 - Function now returns a pointer to the EMNProcedure.  If the procedure is
//	already in the list, we return a pointer to the established one.
// (z.manning 2009-02-27 10:39) - PLID 33141 - Use the new source action info class
EMNProcedure* CEMN::AddProcedure(long nProcedureID, CString strName, SourceActionInfo &sai)
{
	// (z.manning, 10/03/2007) - PLID 27638 - We need to check for a new procedure before we create a new
	// one or else we end up with memory leaks because we will return the existing one anyway.
	EMNProcedure *pExistingProcedure = GetProcedureByID(nProcedureID);
	if(pExistingProcedure != NULL) {
		return pExistingProcedure;
	}

	EMNProcedure *pProc = new EMNProcedure;
	pProc->nID = nProcedureID;
	pProc->sai = sai;
	pProc->bIsNew = TRUE;
	pProc->strName = strName;

	return AddProcedure(pProc);
}

// (a.walling 2012-03-26 08:55) - PLID 49141 - use const references, ignore set if values are equivalent
void CEMN::SetDescription(const CString& strDescription)
{
	if (!CompareAssign(m_strDescription, strDescription)) {
		return;
	}

	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

CString CEMN::GetTableItemList()
{
	GenerateTableItemList();
	return m_strTableItemList;
}

// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
long CEMN::GetVisitTypeID()
{
	return m_nVisitTypeID;
}

CString CEMN::GetVisitTypeName()
{
	return m_strVisitTypeName;
}

void CEMN::SetVisitType(long nVisitTypeID, CString strVisitTypeName)
{
	m_nVisitTypeID = nVisitTypeID;
	m_strVisitTypeName = strVisitTypeName;
	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	//TES 2/21/2014 - PLID 60972 - Visit Type is on the Codes topic now
	SetCodesUnsaved();
}

//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
bool CEMN::GetHideTitleOnPreview()
{
	return m_bHideTitleOnPreview;
}

//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
void CEMN::SetHideTitleOnPreview(bool bHide)
{
	m_bHideTitleOnPreview = bHide;
	m_bUnsaved = TRUE;
}

CEMRTopic* CEMN::GetTopicByID(long nID)
{
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->GetID() == nID)
			return m_arypEMRTopics[i];
		CEMRTopic *pSubTopic = m_arypEMRTopics[i]->GetSubTopicByID(nID);
		if(pSubTopic)
			return pSubTopic;
	}
	return NULL;
}

//get the count of all the details under all topics for this EMN
long CEMN::GetTotalDetailCount()
{
	// (c.haag 2007-03-16 11:30) - PLID 25239 - If we are still asynchronously loading
	// topics, we cannot rely on the traditional means of getting the detail count. We
	// must instead look to the preloaded detail array, which will always have all of
	// the details for the loading EMN. You must make the following assumptions about
	// the details in this array:
	//
	// - A detail may not have its state loaded yet
	// - A detail may not have its content loaded yet
	// - A detail may not have a parent topic
	//

	// (c.haag 2007-07-10 15:47) - PLID 25239 - During the initial load, we are dependent
	// on the EMN loader to get detail data. If we otherwise drop to the code below, it will force
	// topics to finish loading.
	// (c.haag 2007-08-10 18:25) - PLID 27049 - If the EMN loader is not managing the detail array,
	// use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return m_pLoader->GetInitialLoadDetailCount();
	}

	long nTotal = 0;

	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		nTotal += m_arypEMRTopics.GetAt(i)->GetSubTopicDetailCount();
	}
	return nTotal;
}

//the index here is the calculated placement amongst all items, using the same logic
//as is followed in the GetTotalDetailCount function
CEMNDetail* CEMN::GetDetail(long nIndex)
{
	// (c.haag 2007-03-16 11:30) - PLID 25239 - If we are still asynchronously loading
	// topics, we cannot rely on the traditional means of getting the detail. We
	// must instead look to the preloaded detail array, which will always have all of
	// the details for the loading EMN. You must make the following assumptions about
	// the details in this array:
	//
	// - A detail may not have its state loaded yet
	// - A detail may not have its content loaded yet
	// - A detail may not have a parent topic
	//
	long nCurCount = 0;

	if(nIndex < 0) {
		AfxThrowNxException("CEMN::GetDetail-1() called with invalid index!");
	}

	// (c.haag 2007-07-10 15:47) - PLID 25239 - During the initial load, we are dependent
	// on the EMN loader to get detail data. If we otherwise drop to the code below, it will force
	// topics to finish loading.
	// (c.haag 2007-08-10 18:25) - PLID 27049 - If the EMN loader is not managing the detail array,
	// use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return m_pLoader->GetInitialLoadDetailByIndex(nIndex);
	}

	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		CEMNDetail* pCheck = m_arypEMRTopics.GetAt(i)->GetDetailByGlobalIndex(nIndex, nCurCount);
		//if we have a detail, return
		if(pCheck)
			return pCheck;
	}
	
	if(nIndex < 0) {
		AfxThrowNxException("CEMN::GetDetail-2() called with invalid index!");
	}

	//this should never happen
	AfxThrowNxException("CEMN::GetDetail-3() could not find detail by index!");
	return NULL;
}

CEMNDetail* CEMN::AssignDetail(long nIndex)
{
	// (c.haag 2007-08-10 18:26) - PLID 27049 - This is just like GetDetail except
	// that we are guaranteed a detail that is already fully loaded. If the EMN loader
	// is still managing the detail iteration, then return NULL. This function is only used
	// when assigning linked details, and we must do special handling for those cases.
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return NULL;
	} else {
		return GetDetail(nIndex);
	}
}

// (z.manning 2011-01-25 15:58) - PLID 42336
void CEMN::GetParentDetailsByDetailID(const long nChildDetailID, OUT CEMNDetailArray *paryParentDetails)
{
	if(nChildDetailID == -1) {
		return;
	}

	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		m_pLoader->GetInitialLoadParentDetailsByDetailID(nChildDetailID, paryParentDetails);
		return;
	}

	//recurse through all sub-topics
	for(int nTopicIndex = 0; nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++) {
		m_arypEMRTopics.GetAt(nTopicIndex)->GetParentDetailsByDetailID(nChildDetailID, paryParentDetails);
	}
}

// (z.manning 2011-01-25 15:58) - PLID 42336
void CEMN::GetParentDetailsByTemplateDetailID(const long nChildTemplateDetailID, OUT CEMNDetailArray *paryParentDetails)
{
	if(nChildTemplateDetailID == -1) {
		return;
	}

	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		m_pLoader->GetInitialLoadParentDetailsByTemplateDetailID(nChildTemplateDetailID, paryParentDetails);
		return;
	}

	//recurse through all sub-topics
	for(int nTopicIndex = 0; nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++) {
		m_arypEMRTopics.GetAt(nTopicIndex)->GetParentDetailsByTemplateDetailID(nChildTemplateDetailID, paryParentDetails);
	}
}

CEMNDetail* CEMN::GetDetailByID(long nID)
{
	// (c.haag 2007-03-16 11:30) - PLID 25239 - If we are still asynchronously loading
	// topics, we cannot rely on the traditional means of getting the detail. We
	// must instead look to the preloaded detail array, which will always have all of
	// the details for the loading EMN. You must make the following assumptions about
	// the details in this array:
	//
	// - A detail may not have its state loaded yet
	// - A detail may not have its content loaded yet
	// - A detail may not have a parent topic
	//

	// (c.haag 2007-07-10 15:47) - PLID 25239 - During the initial load, we are dependent
	// on the EMN loader to get detail data. If we otherwise drop to the code below, it will force
	// topics to finish loading.
	// (c.haag 2007-08-10 18:25) - PLID 27049 - If the EMN loader is not managing the detail array,
	// use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return m_pLoader->GetInitialLoadDetailByID(nID);
	}

	//recurse through all sub-topics
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		CEMNDetail* pCheck = m_arypEMRTopics.GetAt(i)->GetDetailByID(nID);
		if(pCheck) {
			//found it, return
			return pCheck;
		}
	}

	//nothing, return NULL
	return NULL;
}

CEMNDetail* CEMN::AssignDetailByID(long nID)
{
	// (c.haag 2007-08-10 18:26) - PLID 27049 - This is just like GetDetail except
	// that we are guaranteed a detail that is already fully loaded. If the EMN loader
	// is still managing the detail iteration, then return NULL. This function is only used
	// when assigning linked details, and we must do special handling for those cases.
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return NULL;
	} else {
		return GetDetailByID(nID);
	}
}

CEMNDetail* CEMN::GetDetailByTemplateDetailID(long nID)
{
	// (c.haag 2007-03-16 11:30) - PLID 25239 - If we are still asynchronously loading
	// topics, we cannot rely on the traditional means of getting the detail. We
	// must instead look to the preloaded detail array, which will always have all of
	// the details for the loading EMN. You must make the following assumptions about
	// the details in this array:
	//
	// - A detail may not have its state loaded yet
	// - A detail may not have its content loaded yet
	// - A detail may not have a parent topic
	//

	// (c.haag 2007-07-10 15:47) - PLID 25239 - During the initial load, we are dependent
	// on the EMN loader to get detail data. If we otherwise drop to the code below, it will force
	// topics to finish loading.
	// (c.haag 2007-08-10 18:25) - PLID 27049 - If the EMN loader is not managing the detail array,
	// use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return m_pLoader->GetInitialLoadDetailByTemplateID(nID);
	}

	//recurse through all sub-topics
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		CEMNDetail* pCheck = m_arypEMRTopics.GetAt(i)->GetDetailByTemplateDetailID(nID);
		if(pCheck) {
			//found it, return
			return pCheck;
		}
	}

	//nothing, return NULL
	return NULL;
}

// (z.manning 2011-01-28 12:26) - PLID 42336 - This function will look for any smart stamp table with the given
// table info master ID as long as it is not already linked to an image with the given image info master ID.
CEMNDetail* CEMN::GetSmartStampTableDetailByInfoMasterID(const long nTableInfoMasterID, const long nImageInfoMasterID)
{
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		// (z.manning 2011-01-28 12:31) - PLID 42336 - Not yet supported calling this during loading.
		return m_pLoader->GetSmartStampTableDetailByInfoMasterID(nTableInfoMasterID, nImageInfoMasterID);
	}

	//recurse through all sub-topics
	for(int nTopicIndex = 0;nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++)
	{
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(nTopicIndex);
		CEMNDetail *pSmartStampTable = pTopic->GetSmartStampTableDetailByInfoMasterID(nTableInfoMasterID, nImageInfoMasterID);
		if(pSmartStampTable != NULL) {
			return pSmartStampTable;
		}
	}

	//nothing, return NULL
	return NULL;
}

// (j.jones 2010-02-12 14:19) - PLID 37318 - added GetSmartStampImageDetail_ByTemplateDetailID which is
// a clone of GetDetailByTemplateDetailID, but only returns a detail where m_pSmartStampTableDetail is NULL
CEMNDetail* CEMN::GetSmartStampImageDetail_ByTemplateDetailID(long nID)
{
	//If the EMN loader is not managing the detail array, use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		//the loader only has one detail by template ID, we will not have more than one
		// (z.manning 2010-07-21 09:33) - PLID 39591 - Use GetIntialLoadSmartStampImageByTemplateID here
		return m_pLoader->GetIntialLoadSmartStampImageByTemplateID(nID);
	}

	//recurse through all sub-topics
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		CEMNDetail* pCheck = m_arypEMRTopics.GetAt(i)->GetSmartStampImageDetail_ByTemplateDetailID(nID);
		if(pCheck) {
			//found it, return
			return pCheck;
		}
	}

	//nothing, return NULL
	return NULL;
}

CEMNDetail* CEMN::AssignDetailByTemplateDetailID(long nID)
{
	// (c.haag 2007-08-10 18:26) - PLID 27049 - This is just like GetDetail except
	// that we are guaranteed a detail that is already fully loaded. If the EMN loader
	// is still managing the detail iteration, then return NULL. This function is only used
	// when assigning linked details, and we must do special handling for those cases.
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		return NULL;
	} else {
		return GetDetailByTemplateDetailID(nID);
	}
}

void CEMN::FillArrayFromSemiColonDelimitedIDList(IN OUT CDWordArray &arydw, IN const CString &strSemiColonDelimitedIDList)
{
	arydw.RemoveAll();
	long nPos = 0;
	while (nPos < strSemiColonDelimitedIDList.GetLength()) {
		// Get the current key and move the index to the beginning of the next key
		long nLen = strSemiColonDelimitedIDList.Find(";", nPos) - nPos;
		if (nLen < 0) {
			nLen = strSemiColonDelimitedIDList.GetLength() - nPos;
		}
		CString strCurID = strSemiColonDelimitedIDList.Mid(nPos, nLen);
		nPos = nPos + nLen + 2;
		// Add it to the array
		arydw.Add(atol(strCurID));
	}
}


// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code

//used when an item is changed from the administrator,
//for all instances of that item in the EMN
void CEMN::MarkItemChanged(long nEMRInfoID)
{
	//go through each subtopic and call its MarkItemChanged function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->MarkItemChanged(nEMRInfoID);
	}
}

//refreshes all details in the EMN
// (j.jones 2007-07-26 09:23) - PLID 24686 - this is a horrible idea that should never occur
/*
void CEMN::RefreshAllItems()
{
	CWaitCursor wc;

	//go through each topic and call its RefreshAllItems function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->RefreshAllItems();
	}
}
*/

// (j.jones 2007-07-26 09:10) - PLID 24686 - converted RefreshContent into two functions,
// accepting an InfoID or a MasterID
void CEMN::RefreshContentByInfoID(long nEMRInfoID, BOOL bSyncContentAndState /*= FALSE*/)
{
	// (c.haag 2004-07-08 13:30) - PLID 13373 - We now force the caller to decide
	// if bSetRegionAndInvalidate is set in RepositionDetailsInTab(). The reason is
	// that setting it to true will reset the positions of some controls. In most
	// cases we never want to do this. In 7600, we will revisit this and see the
	// best way to handle content positioning and sizing.

	// (c.haag 2004-05-28 15:54) - PLID 12289 - The new way of doing this is to
	// set a dirty content flag for all the EMNDetail items, and have 
	// RepositionDetailsInTab examine the flag and deal with it accordingly.

	//go through each Topic and call its RefreshContent function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->RefreshContentByInfoID(nEMRInfoID, bSyncContentAndState);
	}
}

// (j.jones 2007-07-26 09:10) - PLID 24686 - converted RefreshContent into two functions,
// accepting an InfoID or a MasterID
// (c.haag 2008-06-12 22:16) - PLID 27831 - Added papMasterDetails so that the caller may
// optionally get a list of all the details with a matching master ID
void CEMN::RefreshContentByInfoMasterID(long nEMRInfoMasterID, BOOL bSyncContentAndState /*= FALSE*/,
										CArray<CEMNDetail*,CEMNDetail*>* papMasterDetails /*= NULL */)
{
	// (c.haag 2004-07-08 13:30) - PLID 13373 - We now force the caller to decide
	// if bSetRegionAndInvalidate is set in RepositionDetailsInTab(). The reason is
	// that setting it to true will reset the positions of some controls. In most
	// cases we never want to do this. In 7600, we will revisit this and see the
	// best way to handle content positioning and sizing.

	// (c.haag 2004-05-28 15:54) - PLID 12289 - The new way of doing this is to
	// set a dirty content flag for all the EMNDetail items, and have 
	// RepositionDetailsInTab examine the flag and deal with it accordingly.

	//go through each Topic and call its RefreshContent function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->RefreshContentByInfoMasterID(nEMRInfoMasterID, bSyncContentAndState, papMasterDetails);
	}
}

// (a.walling 2008-12-19 09:21) - PLID 29800 - This was only used for images, and only to refresh the custom stamps, which was causing the content
// to be reloaded. This is all unnecessary, and the custom stamps is entirely UI. So let's just do what we need to do, and refresh the custom stamps,
// rather than flag as needed to reload content. This is all controlled by the new bRefreshCustomStampsOnly param. I could have renamed the function
// entirely, but I can see how this might come in handy in the future.
void CEMN::RefreshContentByType(EmrInfoType eitItemType, BOOL bSyncContentAndState, BOOL bRefreshCustomStampsOnly)
{
	// (a.wetta 2007-04-09 13:30) - PLID 25532 - This function refreshes the content
	// all all EMR items of a certain type.

	//go through each Topic and call its RefreshContent function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->RefreshContentByType(eitItemType, bSyncContentAndState, bRefreshCustomStampsOnly);
	}
}

//if editing a locked item creates a new copy, and we have unsaved items
//using the old info item, make them use the new info item
void CEMN::UpdateInfoID(long nOldEMRInfoID, long nNewEMRInfoID, EMRInfoChangedIDMap* pChangedIDMap)
{
	//go through each topic and call its UpdateInfoID function
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->UpdateInfoID(nOldEMRInfoID, nNewEMRInfoID, pChangedIDMap);
	}
}

void CEMN::FindDetailsByMergeFieldName(const CString& strMergeFieldName, CArray<CEMNDetail*,CEMNDetail*>& arypEMNDetail)
{
	//recurse through all topics, which will add to arypEMNDetail
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->FindDetailsByMergeFieldName(strMergeFieldName,arypEMNDetail);
	}
}

void CEMN::TryToOverrideMergeField(CEMNDetail *pDetail, BOOL bOverrideAllWithName /*= TRUE*/)
{
	//TES 12/4/2006 - Don't do this if the detail is locked.
	if(IsLockedAndSaved()) {
		return;
	}

	CString strCurrent = pDetail->GetMergeFieldName(TRUE);

	//If this is part of a spawned group, use the "name" of that group.
	if(pDetail->GetSpawnedGroupID() != -1) {
		pDetail->SetMergeFieldOverride(pDetail->GetLabelText() + " (" + pDetail->GetSpawnedGroupIDName() + ")");

		// (a.walling 2008-06-12 16:44) - PLID 27301 - Let the interface know
		if (GetInterface() != NULL) {
			MergeOverrideChanged moc;
			moc.strOldName = strCurrent;
			moc.strNewName = pDetail->GetMergeFieldName(TRUE);
			// (a.walling 2008-06-13 16:12) - PLID 27301 - Infinite loop protection - only send if we changed
			if (moc.strOldName != moc.strNewName) {
				GetInterface()->SendMessage(NXM_MERGE_OVERRIDE_CHANGED, (WPARAM)pDetail, (LPARAM)&moc);
			}
		}
	}

	CString strNew = pDetail->GetMergeFieldName(TRUE);
	if(strCurrent != strNew) {
		UpdateMergeConflicts(strCurrent);
		UpdateMergeConflicts(strNew);
		pDetail->ReflectCurrentState();
	}

	if(bOverrideAllWithName) {
		//TES 2/10/2006 - We also want to update anything else that had this merge field.
		CArray<CEMNDetail*,CEMNDetail*> arOtherDetails;
		FindDetailsByMergeFieldName(strCurrent, arOtherDetails);
		for(int i = 0; i < arOtherDetails.GetSize(); i++) {
			TryToOverrideMergeField(arOtherDetails[i], FALSE);
		}
	}
}

//invalidates merge buttons across the entire EMN
void CEMN::InvalidateAllDetailMergeButtons()
{
	//recurse through all topics
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->InvalidateAllDetailMergeButtons();
	}
}

// (a.walling 2009-11-17 08:36) - PLID 36365 - Do not include pIgnoreTopic
void CEMN::GenerateTotalEMNDetailArray(CArray<CEMNDetail*,CEMNDetail*> *arypEMNDetails, CEMRTopic* pIgnoreTopic)
{
	// (c.haag 2007-03-16 11:30) - PLID 25239 - If we are still asynchronously loading
	// topics, we cannot rely on the traditional means of getting the detail array. We
	// must instead look to the preloaded detail array, which will always have all of
	// the details for the loading EMN. You must make the following assumptions about
	// the details in this array:
	//
	// - A detail may not have its state loaded yet
	// - A detail may not have its content loaded yet
	// - A detail may not have a parent topic
	//

	// (c.haag 2007-07-10 15:47) - PLID 25239 - During the initial load, we are dependent
	// on the EMN loader to get detail data. If we otherwise drop to the code below, it will force
	// topics to finish loading.
	// (c.haag 2007-08-10 18:25) - PLID 27049 - If the EMN loader is not managing the detail array,
	// use the EMR for detail iterations
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		const int nDetails = m_pLoader->GetInitialLoadDetailCount();
		for (int i=0; i < nDetails; i++) {
			arypEMNDetails->Add( m_pLoader->GetInitialLoadDetailByIndex(i) );
		}
		return;
	}

	//run through each topic and get all the details in one array
	for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
		CEMRTopic* pTopic = m_arypEMRTopics.GetAt(i);
		// (a.walling 2009-11-17 08:37) - PLID 36365
		if (pTopic != pIgnoreTopic) {
			pTopic->GenerateEMNDetailArray(arypEMNDetails, pIgnoreTopic);
		}
	}
}

void CEMN::GenerateTotalEMNDeletedDetailArray(CArray<CEMNDetail*,CEMNDetail*> *arypEMNDeletedDetails)
{
	//run through each topic and get all the deleted details in one array
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;
	for(i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->GenerateEMNDeletedDetailArray(arypEMNDeletedDetails);
	}

	for(i=0;i<m_arypDeletedTopics.GetSize();i++) {
		m_arypDeletedTopics.GetAt(i)->GenerateEMNDetailArray(arypEMNDeletedDetails);
		m_arypDeletedTopics.GetAt(i)->GenerateEMNDeletedDetailArray(arypEMNDeletedDetails);
	}
}

// (c.haag 2008-02-22 10:48) - PLID 29064 - Added optional connection pointer
CString CEMN::GetSentence(CEMNDetail *pEMNDetail, CMergeEngine *pMi, bool bAllowHtml, bool bInHtml,
						  EmrCategoryFormat Format /*= ecfParagraph*/, LPCTSTR szDataOutput /*= NULL*/, CEmrPreviewImageInfo* pPreviewImageInfo /*= NULL*/, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	// (c.haag 2007-03-16 16:36) - PLID 25242 - Include ourself in the call to get sentence
	// (c.haag 2007-03-28 16:04) - PLID 25397 - We also optionally pass in the data output for optimizing the
	// execution of functions that need to get both individually
	if (NULL != pEMNDetail->m_pParentTopic) { ASSERT(this == pEMNDetail->m_pParentTopic->GetParentEMN()); }
	// (a.walling 2011-01-28 10:57) - PLID 40260 - Use EMN's default connection if none specified
	if (!lpCon) {
		lpCon = GetRemoteData();
	}
	return ::GetSentence(pEMNDetail, pMi, bAllowHtml, bInHtml, m_saTempFiles, Format, this, szDataOutput, pPreviewImageInfo, lpCon);
}

// (c.haag 2008-02-22 10:46) - PLID 29064 - Added optional connection pointer
// (a.walling 2010-03-26 18:05) - PLID 37923 - Limit on a single table row
CString CEMN::GetDataOutput(CEMNDetail *pEMNDetail, CMergeEngine *pMi, bool bAllowHtml, bool bInHtml, OPTIONAL OUT bool *pbDataIsHtml /*= NULL*/, EmrCategoryFormat Format /*= ecfParagraph*/, CEmrPreviewImageInfo* pPreviewImageInfo /*= NULL*/, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/, TableRowID* pSingleTableRowID /*= NULL*/)
{
	// (c.haag 2007-03-16 16:36) - PLID 25242 - Include ourself in the call to get sentence
	if (NULL != pEMNDetail->m_pParentTopic) { ASSERT(this == pEMNDetail->m_pParentTopic->GetParentEMN()); }
	// (a.walling 2011-01-28 10:57) - PLID 40260 - Use EMN's default connection if none specified
	if (!lpCon) {
		lpCon = GetRemoteData();
	}
	return ::GetDataOutput(pEMNDetail, pMi, bAllowHtml, bInHtml, m_saTempFiles, pbDataIsHtml, Format, this, pPreviewImageInfo, lpCon, pSingleTableRowID);
}

// (c.haag 2008-02-22 10:46) - PLID 29064 - Added optional connection pointer
// (a.walling 2010-03-26 18:05) - PLID 37923 - Limit on a single table row
// (z.manning 2010-08-09 15:24) - PLID 39842 - Added bAllowHtml
void CEMN::GetTableDataOutput(CEMNDetail *pEMNDetail, EmrMultiSelectFormat emsf, CString strSeparator, CString strSeparatorFinal, CString &strHTML, CString &strNonHTML, bool bAllowHtml, OPTIONAL OUT bool *pbDataIsHtml /*= NULL*/, EmrCategoryFormat Format /*= ecfParagraph*/, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/, TableRowID* pSingleTableRowID /*= NULL*/)
{
	// (a.walling 2011-01-28 10:57) - PLID 40260 - Use EMN's default connection if none specified
	if (!lpCon) {
		lpCon = GetRemoteData();
	}
	//TES 3/22/2012 - PLID 48203 - Just in case this detail hasn't been attached to us yet, let it know that we are going to be its parent.
	::GetTableDataOutput(pEMNDetail, emsf, strSeparator, strSeparatorFinal, strHTML, strNonHTML, NULL, bAllowHtml, m_saTempFiles, pbDataIsHtml, Format, lpCon, pSingleTableRowID, this);
}

CString CEMN::GetElementDataOutput(CEMNDetail *pEMNDetail, long nElementID, CMergeEngine *pMi, bool bAllowHtml, bool bInHtml, OPTIONAL OUT bool *pbDataIsHtml /*= NULL*/)
{
	//This is simply the name of the data item.

	// (j.jones 2006-03-14 17:43) - PLID 19705 - we will have the ListElement array that tells us
	// the data name, so we don't need to query the database unless no detail was passed to us,
	// which I believe should never happen

	if(pEMNDetail) {
		pEMNDetail->LoadContent(); //won't actually load anything if it has already been loaded
		for(int i=0; i<pEMNDetail->GetListElementCount(); i++) {
			ListElement le = pEMNDetail->GetListElement(i);
			if(le.nID == nElementID) {
				return le.strName;
			}
		}
	}

	//DRT 8/28/2007 - PLID 27207 - Parameterized.
	_RecordsetPtr rsData = CreateParamRecordset("SELECT Data FROM EmrDataT WHERE ID = {INT}", nElementID);	
	return AdoFldString(rsData, "Data");
}

CString CEMN::GetElementSentence(CEMNDetail *pEMNDetail, long nElementID, CMergeEngine *pMi, bool bAllowHtml, bool bInHtml)
{
	bool bDataIsHtml = false;
	CString strDataOutput = GetElementDataOutput(pEMNDetail, nElementID, pMi, bAllowHtml, bInHtml, &bDataIsHtml);

	if(strDataOutput.IsEmpty()) {
		//TES 9/2/2004: Don't put the sentence around a blank, it looks silly.
		return strDataOutput;
	}

	// (j.jones 2006-03-16 14:52) - PLID 19704 - we will have the ListElement array that tells us
	// the LongForm, so we don't need to query the database unless no detail was passed to us,
	// which I believe should never happen

	CString strFormatted;

	if(pEMNDetail) {
		pEMNDetail->LoadContent(); //won't actually load anything if it has already been loaded
		for(int i=0; i<pEMNDetail->GetListElementCount(); i++) {
			ListElement le = pEMNDetail->GetListElement(i);
			if(le.nID == nElementID) {
				strFormatted = le.strLongForm;
			}
		}
	}
	else {
		//DRT 8/28/2007 - PLID 27207 - Parameterized.
		_RecordsetPtr rsSentence = CreateParamRecordset("SELECT LongForm FROM EmrDataT WHERE ID = {INT}", nElementID);
		//It's up to our caller to give us a valid id.
		if(rsSentence->eof) {
			ASSERT(FALSE);
			AfxThrowNxException("CEMN::GetElementSentence called with invalid nElementID!");
			return strDataOutput;
		}
		strFormatted = AdoFldString(rsSentence, "LongForm");
	}

	if(strFormatted.IsEmpty()) {
		//OK, go back to using the Item's LongForm.
		if(pEMNDetail) {
			//we cached the LongForm, so use that instead of accessing the database
			pEMNDetail->LoadContent(); //won't actually load anything if it has already been loaded
			strFormatted = pEMNDetail->m_strLongForm;
		}
		else {
			ASSERT(FALSE);
			strFormatted = "<Data>";
		}
	}

	//Replace all "merge fields" with their actual values.
	strFormatted.Replace(DATA_FIELD, strDataOutput);
	
	strFormatted.Replace(AGE_FIELD, m_strPatientAge);

	if(m_cbPatientGender == 1) {
		strFormatted.Replace(GENDER_UPPER_FIELD, "Male");
		strFormatted.Replace(GENDER_LOWER_FIELD, "male");
		strFormatted.Replace(SUBJ_UPPER_FIELD, "He");
		strFormatted.Replace(SUBJ_LOWER_FIELD, "he");
		strFormatted.Replace(OBJ_UPPER_FIELD, "Him");
		strFormatted.Replace(OBJ_LOWER_FIELD, "him");
		strFormatted.Replace(POSS_UPPER_FIELD, "His");
		strFormatted.Replace(POSS_LOWER_FIELD, "his");
	}
	else if(m_cbPatientGender == 2) {
		strFormatted.Replace(GENDER_UPPER_FIELD, "Female");
		strFormatted.Replace(GENDER_LOWER_FIELD, "female");
		strFormatted.Replace(SUBJ_UPPER_FIELD, "She");
		strFormatted.Replace(SUBJ_LOWER_FIELD, "she");
		strFormatted.Replace(OBJ_UPPER_FIELD, "Her");
		strFormatted.Replace(OBJ_LOWER_FIELD, "her");
		strFormatted.Replace(POSS_UPPER_FIELD, "Her");
		strFormatted.Replace(POSS_LOWER_FIELD, "her");
	}
	else {
		strFormatted.Replace(GENDER_UPPER_FIELD, "");
		strFormatted.Replace(GENDER_LOWER_FIELD, "");
		strFormatted.Replace(SUBJ_UPPER_FIELD, "");
		strFormatted.Replace(SUBJ_LOWER_FIELD, "");
		strFormatted.Replace(OBJ_UPPER_FIELD, "");
		strFormatted.Replace(OBJ_LOWER_FIELD, "");
		strFormatted.Replace(POSS_UPPER_FIELD, "");
		strFormatted.Replace(POSS_LOWER_FIELD, "");
	}

	if(strFormatted.Find(SPAWNING_FIELD) != -1) {
		if(pEMNDetail->GetSpawnedGroupID() != -1) {
			//TES 3/18/2010 - PLID 37530 - The action name now depends on the stamp index, if this was spawned by a stamp.

			// (a.walling 2010-05-19 16:08) - PLID 38750 - Pass in the detail stamp id as well
			strFormatted.Replace(SPAWNING_FIELD, GetEmrActionName(pEMNDetail->GetSpawnedGroupID(), pEMNDetail->GetSpawnedGroupStampIndex(), eaoInvalid, -1, pEMNDetail->GetSpawnedGroupSourceActionInfo().GetDetailStampID()));
		}
		strFormatted.Replace(SPAWNING_FIELD, "");
	}

	// (z.manning 2011-11-04 14:04) - PLID 42765 - Handle the spawned items field
	if(strFormatted.Find(SPAWNED_ITEMS_FIELD) != -1)
	{
		ListElement *ple = pEMNDetail->GetListElementByID(nElementID);
		if(ple != NULL)
		{
			SourceActionInfo saiListElement(eaoEmrDataItem, -1, pEMNDetail, NULL);
			CUnspawningSource usListElement(pEMNDetail, *ple);
			CSpawningSourceInfo spawnInfo(&saiListElement, &usListElement);
			// (z.manning 2011-11-07 17:13) - PLID 46309 - Pass in the separator
			CString strSpawnedDetailsSentenceFormats = GetSpawnedDetailsSentenceFormats(&spawnInfo, ple->strSpawnedItemsSeparator, bDataIsHtml);
			strFormatted.Replace(SPAWNED_ITEMS_FIELD, strSpawnedDetailsSentenceFormats);
		}
	}

	if(bDataIsHtml && !bInHtml) {
		//OK, we need to generate an HTML file.
		CString strFilename;
		strFilename.Format("MergeHTML_EMR_List_%d_%d.htm", pEMNDetail->m_nEMRDetailID, m_nID);
		CString strFullPath = GetNxTempPath() ^ strFilename;
		CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);
		CString strHTML = "<html><head></head><body>" + strFormatted + "</body></html>";
		f.WriteString(strHTML);
		f.Close();

		// Add to our temp file list
		m_saTempFiles.Add(strFullPath);

		//Now, return the HTML file as our data.
		strFormatted.Format("{NXRTF %s}", strFullPath);
	}	

	return strFormatted;
}

void CEMN::GenerateTableItemList()
{
	if(!m_bNeedRegenerateTableItemList) return;

	//generate the list from scratch
	m_strTableItemList = "; ;";

	long nTotalDetailCount = GetTotalDetailCount();
	for(int i=0;i<nTotalDetailCount;i++) {
		//generate names of everything but tables and images
		CEMNDetail *pDetail = GetDetail(i);
		if(pDetail->m_EMRInfoType != eitTable && 
			pDetail->m_EMRInfoType != eitImage) {

			CString strValue = pDetail->GetLabelText();

			strValue.Replace(";","");
			CString str;
			str.Format("%s;%s;",pDetail->GetUniqueIdentifierAgainstEMN(),strValue);

			m_strTableItemList += str;
		}
	}

	m_bNeedRegenerateTableItemList = FALSE;
}

//DRT 1/16/2007 - PLID 24177 - Compare a given EMNCharge with data already saved
//	for the same ID.
//Returns TRUE if the diagnosis codes are the same between the given EMNCharge and 
//	the database.  The given charge must have a valid nID.
//Returns FALSE if the given EMNCharge has not been saved or if the lists are different.
//	If the return value is FALSE, strOldValue will be an string that can be used
//	for auditing, a comma separated list of the old codes.
BOOL CEMN::CompareChargeDiagCodes(EMNCharge *pCharge, OUT CString &strOldValue)
{
	//data not allowed for this function
	if(pCharge == NULL || pCharge->nID == -1) {
		ASSERT(FALSE);
		return FALSE;
	}

	//DRT 8/28/2007 - PLID 27207 - Parameterized.
	//TES 2/28/2014 - PLID 61080 - Added ICD-10 fields
	_RecordsetPtr prs = CreateParamRecordset("SELECT DiagCodeID, DiagCodes.CodeNumber, "
		"EmrChargesToDiagCodesT.DiagCodeID_ICD10, DiagCodes_10.CodeNumber AS ICD10CodeNumber "
		"FROM EMRChargesToDiagCodesT "
		"LEFT JOIN DiagCodes ON EMRChargesToDiagCodesT.DiagCodeID = DiagCodes.ID "
		"LEFT JOIN DiagCodes DiagCodes_10 ON EmrChargesToDiagCodesT.DiagCodeID_ICD10 = DiagCodes_10.ID "
		"WHERE ChargeID = {INT}", pCharge->nID);
	if(prs->eof) {
		//There is nothing saved.  Compare for an empty string
		// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs
		//TES 2/28/2014 - PLID 61080 - Renamed to aryDiagIndexes
		if(pCharge->aryDiagIndexes.GetSize() == 0) {
			return TRUE;
		}
		else {
			strOldValue = "";
			return FALSE;
		}
	}

	//Otherwise, there were some already saved to data.  We need to compare this list against 
	//	what is in the current EMNCharge structure.
	CArray<long, long> aryIDs;
	//TES 2/28/2014 - PLID 61080 - Added ICD-10 fields
	CArray<long, long> aryICD10IDs;
	while(!prs->eof) {
		// (j.jones 2009-01-02 09:08) - PLID 32601 - changed to track IDs
		long nID = AdoFldLong(prs, "DiagCodeID", -1);
		CString strCode = AdoFldString(prs, "CodeNumber", "");
		long nICD10ID = AdoFldLong(prs, "DiagCodeID_ICD10", -1);
		CString strICD10Code = AdoFldString(prs, "ICD10CodeNumber", "");
		aryIDs.Add(nID);
		aryICD10IDs.Add(nID);
		//TES 2/28/2014 - PLID 61080 - Use the audit value that checks both codes
		strOldValue += GenerateEMRDiagCodesTAuditValue(strCode, strICD10Code) + ", ";

		prs->MoveNext();
	}
	prs->Close();

	//trim last comma from audit string
	if(strOldValue.GetLength() > 2) {
		strOldValue = strOldValue.Left(strOldValue.GetLength() - 2);
	}

	// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs,
	// which means we can quickly check whether the lists are the same size
	//TES 2/28/2014 - PLID 61080 - Renamed to aryDiagIndexes
	if(pCharge->aryDiagIndexes.GetSize() != aryIDs.GetSize()) {
		return FALSE;
	}


	BOOL bChanged = FALSE;
	{
		//compare whether the lists have the same codes
		// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs
		//TES 2/28/2014 - PLID 61080 - Renamed to aryDiagIndexes
		int i=0;
		for(i=0; i < pCharge->aryDiagIndexes.GetSize() && !bChanged; i++) {
			BOOL bCodeFound = FALSE;

			//Now find this code in the array
			int j = 0;
			for(j=0; j < aryIDs.GetSize() && !bCodeFound; j++) {
				//TES 2/28/2014 - PLID 61080 - Get the code, check both ICD-9 and ICD-10
				EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(pCharge->aryDiagIndexes.GetAt(i));
				if(pDiag->nDiagCodeID == (long)aryIDs.GetAt(j) && pDiag->nDiagCodeID_ICD10 == (long)aryICD10IDs.GetAt(j)) {
					bCodeFound = TRUE;
				}
			}

			if(!bCodeFound) {
				//Code was never found, it must be new.  We can quit right now.
				bChanged = TRUE;
			}
		}
	}


	return !bChanged;
}

//TES 3/26/200 - PLID 33262 - Medications now have associated diagnosis codes, so I added this function, copied from
// CompareChargeDiagCodes above
BOOL CEMN::CompareMedicationDiagCodes(EMNMedication *pMed, OUT CString &strOldValue)
{
	//data not allowed for this function
	if(pMed == NULL || pMed->nID == -1) {
		ASSERT(FALSE);
		return FALSE;
	}

	//DRT 8/28/2007 - PLID 27207 - Parameterized.
	_RecordsetPtr prs = CreateParamRecordset("SELECT DiagCodeID, DiagCodes.CodeNumber "
		"FROM PatientMedicationDiagCodesT "
		"INNER JOIN DiagCodes ON PatientMedicationDiagCodesT.DiagCodeID = DiagCodes.ID "
		"WHERE PatientMedicationDiagCodesT.PatientMedicationID = {INT} "
		"ORDER BY PatientMedicationDiagCodesT.SortOrder", pMed->nID);
	if(prs->eof) {
		//There is nothing saved.  Compare for an empty string
		// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs
		if(pMed->aryDiagnoses.GetSize() == 0) {
			return TRUE;
		}
		else {
			strOldValue = "";
			return FALSE;
		}
	}

	//Otherwise, there were some already saved to data.  We need to compare this list against 
	//	what is in the current EMNCharge structure.
	CArray<long, long> aryIDs;
	while(!prs->eof) {
		// (j.jones 2009-01-02 09:08) - PLID 32601 - changed to track IDs
		long nID = AdoFldLong(prs, "DiagCodeID");
		CString strCode = AdoFldString(prs, "CodeNumber");
		aryIDs.Add(nID);
		strOldValue += strCode + ", ";

		prs->MoveNext();
	}
	prs->Close();

	//trim last comma from audit string
	if(strOldValue.GetLength() > 2) {
		strOldValue = strOldValue.Left(strOldValue.GetLength() - 2);
	}

	// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs,
	// which means we can quickly check whether the lists are the same size
	if(pMed->aryDiagnoses.GetSize() != aryIDs.GetSize()) {
		return FALSE;
	}


	BOOL bChanged = FALSE;
	{
		//compare whether the lists have the same codes
		// (j.jones 2009-01-02 09:01) - PLID 32601 - renamed to aryDiagIDs
		int i=0;
		for(i=0; i < pMed->aryDiagnoses.GetSize() && !bChanged; i++) {
			BOOL bCodeFound = FALSE;

			//TES 3/30/2009 - PLID 33262 - Because the ordering is relevant, we don't have to search through the whole
			// array.  This is only valid if each diagnosis is the same at each index in the array.
			if(pMed->aryDiagnoses[i].nID != aryIDs[i]) {
				bChanged = TRUE;
			}
		}
	}


	return !bChanged;
}

CEMNLoader* CEMN::GetEMNLoader()
{
	// (c.haag 2007-04-26 10:59) - PLID 25790 - Exposes access to the EMN loader
	return m_pLoader;
}

CEMNLoader* CEMN::GetRetiredEMNTemplateLoader()
{
	// (c.haag 2007-09-10 12:52) - PLID 27024 - Returns the retired EMN loader
	return m_pRetiredTemplateLoader;
}

void CEMN::RetireInitialLoader()
{
	// (c.haag 2007-08-04 09:42) - PLID 26945 - This is called when the initial load is done with
	// the EMN loader. We first verify that the load finished as expected (AssertIfPostInitialLoadIssuesExist).
	// If it returns TRUE, that means it's safe to release the loader. If it returns FALSE, then there was
	// a problem, and it is not safe to delete the loader.
	// (c.haag 2007-09-10 11:50) - PLID 27024 - We no longer delete the loader here if it has template-related
	// information regarding this EMN. The information in m_pLoader can be used later when spawning items from
	// EMR templates. We instead delete it in the destructor of CEMN.
	if (m_pLoader->AssertIfPostInitialLoadIssuesExist()) {
		if (m_pLoader->IsLoadingFromTemplate()) {
			m_pRetiredTemplateLoader = m_pLoader;
			// (c.haag 2007-09-10 13:05) - PLID 27340 - "Tell" the EMN loader that it is no longer
			// going to be actively used to add and spawn details to an EMN. Its topics and details,
			// however, may be referenced later on for when the CEMN object does calculations related
			// to spawning items from templates.
			m_pRetiredTemplateLoader->Retire();
		} else {
			m_pLoader->Release();
		}
	} else {
		// If we get here, it means there is a post-initial load issue (and an assertion was already fired).
		// which indicates that it is not safe to delete the loader. So, we suffer a memory leak over a crash.
	}

	// (z.manning, 08/15/2007) - PLID 26809 - We're retiring the loader object, however, this loader may
	// have been used when loading other topics on this EMR (such as when importing topics). So, let's go
	// through the topic load info for our parent EMR and any topic load info object that uses the same
	// loader object needs to "retire" that pointer as well.
	if(GetParentEMR() != NULL) 
	{
		LoadAllTopicsInfo *pLoadTopicsInfo = GetParentEMR()->GetLoadAllTopicsInfo();
		if(pLoadTopicsInfo != NULL) {
			for(int nTopicLoadIndex = 0; nTopicLoadIndex < pLoadTopicsInfo->arTopics.GetSize(); nTopicLoadIndex++) {
				if(pLoadTopicsInfo->arTopics.GetAt(nTopicLoadIndex) != NULL) {
					if(pLoadTopicsInfo->arTopics.GetAt(nTopicLoadIndex)->m_pLoader == m_pLoader) {
						pLoadTopicsInfo->arTopics.GetAt(nTopicLoadIndex)->m_pLoader = NULL;
					}
				}					
			}
		}
	}

	m_pLoader = NULL;
}


//DRT 1/16/2007 - Generate the SaveString data for EMRChargesToDiagCodesT.  Takes an EMNCharge pointer
//	and the ID value, which can be either a hardcoded number (if updating a single charge), or a
//	variable used in the current query (such as @nNewObjectID).  It will reference the ChargeID field.
Nx::Quantum::Batch CEMN::GenerateSaveString_EMRChargesToDiagCodesT(EMNCharge *pCharge, CString strIDValue)
{
	//DRT 1/15/2007 - PLID 24177
	//	Need to add all diagnosis codes that are linked to this charge.  They are saved in a || delimited
	//	list of the code numbers, we need to get the IDs for each of those for inserting (too much possibility for
	//	codes to change otherwise).
	//We will return the string to add into the save batch
	// (a.walling 2014-01-30 00:00) - PLID 60543 - Quantize
	Nx::Quantum::Batch strNewSql;

	boost::container::flat_set<std::pair<long, long>> uniqueDiags;
	uniqueDiags.reserve(pCharge->aryDiagIndexes.GetSize());

	// (j.jones 2009-01-02 09:14) - PLID 32601 - renamed to aryDiagIDs	
	//TES 2/28/2014 - PLID 61080 - Renamed to aryDiagIndexes
	for(int i=0; i<pCharge->aryDiagIndexes.GetSize(); i++) {
		//append a lookup for our code.  @nNewObjectID is our current charge ID
		// (j.jones 2009-01-02 09:13) - PLID 32601 - now we use the real diag ID, but still check the
		// DiagCodes table just incase the diag code was removed before we saved

		// (a.walling 2014-02-13 14:09) - PLID 60810 - ignore if duplicate

		// (a.walling 2014-05-21 08:51) - PLID 62216 - ignore if duplicate, again. This was changed at some point
		// to use the index and check for uniqueness against that... rather than the pair of icd9 and icd10 codes.
		// So that is what we do now -- use a set of pair<long,long>
		long diagIndex = pCharge->aryDiagIndexes.GetAt(i);
		if (diagIndex < 0 || diagIndex >= m_aryDiagCodes.GetSize()) {
			ASSERT(FALSE);
			continue;
		}

		auto pEmnDiag = m_aryDiagCodes[diagIndex];
		if (!pEmnDiag) {
			ASSERT(FALSE);
			continue;
		}
		
		if (!uniqueDiags.insert(std::make_pair(pEmnDiag->nDiagCodeID, pEmnDiag->nDiagCodeID_ICD10)).second) {
			continue;
		}

		// (b.savon 2014-02-28 14:17) - PLID 61056 - UPDATE - Write icd10 selections to data upon save of EMRChargesToDiagCodesT
		//
		// A bit of an explanation is explained here.  The EMNCharge object had an array of diagcodeids, literally the id that is
		// in diagcodes table.  Without changing the EMNCharge structure, that array is now repurposed to be a index into
		// m_aryDiagCodes.  m_aryDiagCodes is an array of EMNDiagCodes that are on the current EMN, which works out beautifully.
		// So now, when we insert into EMRChargesToDiagCodesT we are going to use the diagID as an index into the m_aryDiagCodes
		// array to get the ICD9 and ICD10 pair.  Sweet.
		AddStatementToSqlBatch(
			strNewSql, 
			"INSERT INTO EMRChargesToDiagCodesT "
			"	(ChargeID, DiagCodeID, DiagCodeID_ICD10) "
			"SELECT	%s, (SELECT ID FROM DiagCodes WHERE DiagCodes.ID = %li), (SELECT ID FROM DiagCodes WHERE DiagCodes.ID = %li) ; ",
			strIDValue, 
			pEmnDiag->nDiagCodeID,
			pEmnDiag->nDiagCodeID_ICD10
		);
	}

	return strNewSql;
}

//TES 3/26/2009 - PLID 33262 - Medications now have diagnosis codes, so I added this function, copied from the 
// GenerateSaveString_EMRChargesToDiagCodesT above
// (j.jones 2012-09-28 10:18) - PLID 52820 - now we track a flag if something that contributed to drug interactions has changed,
// in this case, diagnosis codes on a prescription
Nx::Quantum::Batch CEMN::GenerateSaveString_PatientMedicationDiagCodesT(EMNMedication *pMed, CString strIDValue, OUT BOOL &bDrugInteractionsChanged)
{
	//DRT 1/15/2007 - PLID 24177
	//	Need to add all diagnosis codes that are linked to this charge.  They are saved in a || delimited
	//	list of the code numbers, we need to get the IDs for each of those for inserting (too much possibility for
	//	codes to change otherwise).
	//We will return the string to add into the save batch
	// (a.walling 2014-01-30 00:00) - PLID 60543 - Quantize
	Nx::Quantum::Batch strNewSql;

	std::set<std::pair<long,long>> uniqueDiagnoses;

	for(int i=0; i<pMed->aryDiagnoses.GetSize(); i++) {

		// (j.jones 2012-09-28 10:16) - PLID 52820 - adding a diagnosis to a medication contributes to potential
		// drug interactions, so track that this information has changed
		bDrugInteractionsChanged = TRUE;
		
		// (a.walling 2014-02-13 14:09) - PLID 60810 - ignore if duplicate
		if (!uniqueDiagnoses.insert(std::make_pair(pMed->aryDiagnoses.GetAt(i).nID, pMed->aryDiagnoses.GetAt(i).nSortOrder)).second) {
			continue;
		}

		//append a lookup for our code.  @nNewObjectID is our current charge ID
		// (j.jones 2009-01-02 09:13) - PLID 32601 - now we use the real diag ID, but still check the
		// DiagCodes table just incase the diag code was removed before we saved
		AddStatementToSqlBatch(strNewSql, "INSERT INTO PatientMedicationDiagCodesT (PatientMedicationID, DiagCodeID, SortOrder) SELECT %s, ID, %li FROM DiagCodes WHERE DiagCodes.ID = %li;", strIDValue, pMed->aryDiagnoses.GetAt(i).nSortOrder, pMed->aryDiagnoses.GetAt(i).nID);
	}

	return strNewSql;
}

//DRT 2/24/2006 - PLID 19465 - This function is ONLY for use in generating the string to save.  This function should NOT
//	be changing any member variables under the assumption that the save succeeded.  All code that needs to be updated after
//	the save succeeds should be placed in PostSaveUpdate()
// (j.jones 2007-01-11 14:28) - PLID 24027 - tracked strPostSaveSql, for sql statements to occur after the main save
// (c.haag 2007-06-20 12:38) - PLID 26397 - We now store saved objects in a map for fast lookups
// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
// (j.jones 2012-09-27 15:11) - PLID 52820 - now we track a flag if something that contributed to drug interactions has changed,
// such as new or deleted prescriptions, or new or deleted diagnosis codes
// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize
Nx::Quantum::Batch CEMN::GenerateSaveString(long nEMRID, long &nAuditTransactionID, Nx::Quantum::Batch& strPostSaveSql, CStringArray &arystrErrors, IN OUT CMapPtrToPtr& mapSavedObjects, CDWordArray &arynAffectedDetailIDs, OUT BOOL &bDrugInteractionsChanged, BOOL bIsTopLevelSave, BOOL bSaveRecordOnly)
{
	Nx::Quantum::Batch strSaveString;
	_ASSERTE(this->IsWritable());

	// (j.jones 2012-01-31 17:16) - PLID 47878 - this save might be the first notification
	// that the EMN is being changed, if so then we need to know that we've made changes
	if(IsUnsaved()) {
		m_bChangesMadeThisSession = TRUE;
	}

	// (a.walling 2008-05-29 16:27) - PLID 22049 - Verify our write token and revision
	// (a.walling 2008-06-12 11:04) - PLID 22049 - Not needed if we are locked
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	// (a.walling 2012-04-06 12:13) - PLID 49496 - EMN Status - GetStatus now returns the object
	EMNStatus emnStatus = GetStatus();
	if (GetID() != -1 && emnStatus.nID != 2) {
		if (GetWriteToken().IsEmpty()) {
			arystrErrors.Add("Attempted to save EMN without a write token!");
		} else {
			if (!IsTemplate()) {
				AddStatementToSqlBatch(strSaveString, 
					"IF (SELECT Revision FROM EMRMasterT WHERE ID = %li) <> %s BEGIN RAISERROR('EMN cannot save; revision is out of date', 16, 42) ROLLBACK TRAN RETURN END", GetID(), CreateByteStringFromSafeArrayVariant(m_varRevision)
					);
				// (j.jones 2011-10-20 15:40) - PLID 45956 - EMNAccessT can potentially have multiple records per EMN from non-Practice
				// accesses (such as the NexTechAPI). If our access no longer exists, or ANY other access exists, fail. Practice does
				// not support concurrent accesses.
				// (j.gruber 2012-01-09 12:22) - PLID 47371 - add parameters
				AddStatementToSqlBatch(strSaveString, 
					"IF NOT EXISTS (SELECT EMNAccessT.UID FROM EMNAccessT "
					"	INNER JOIN EMRMasterT ON EMNAccessT.EmnID = EMRMasterT.ID "
					"	WHERE EMNAccessT.EmnID = %li AND EMNAccessT.UID = CONVERT(UNIQUEIDENTIFIER, '%s')) "
					"	OR EXISTS (SELECT EMNAccessT.UID FROM EMNAccessT "
					"	INNER JOIN EMRMasterT ON EMNAccessT.EmnID = EMRMasterT.ID "
					"	WHERE EMNAccessT.EmnID = %li AND EMNAccessT.UID <> CONVERT(UNIQUEIDENTIFIER, '%s')) "
					"BEGIN RAISERROR('EMN cannot save; write access has been removed', 16, 43) ROLLBACK TRAN RETURN END", 
					GetID(), GetWriteToken(), GetID(), GetWriteToken()
					);
			} else {
				AddStatementToSqlBatch(strSaveString, 
					"IF (SELECT Revision FROM EMRTemplateT WHERE ID = %li) <> %s BEGIN RAISERROR('Template cannot save; revision is out of date', 16, 42) ROLLBACK TRAN RETURN END", GetID(), CreateByteStringFromSafeArrayVariant(m_varRevision)
					);

				// (j.armen 2013-05-14 11:03) - PLID 56683 - Refactoring EMR Access
				AddStatementToSqlBatch(strSaveString, 
					"IF (\r\n"
					"	SELECT EMNTemplateAccessT.UID\r\n"
					"	FROM EMNTemplateAccessT\r\n"
					"	INNER JOIN EMRTemplateT ON EMNTemplateAccessT.EmnID = EMRTemplateT.ID\r\n"
					"	WHERE EMNTemplateAccessT.EmnID = %li) <> CONVERT(UNIQUEIDENTIFIER, '%s')\r\n"
					"BEGIN\r\n"
					"	RAISERROR('Template cannot save; write access has been removed', 16, 43)\r\n"
					"	ROLLBACK TRAN\r\n"
					"	RETURN\r\n"
					"END", GetID(), GetWriteToken());
			}
		}
	}

	//if this is the initial save string, then we need to generate the parent EMR record
	//bSaveRecordOnly will be true if a child is the top level save
	if(bIsTopLevelSave || bSaveRecordOnly) {
		//tell our parent to save its record, which will propagate upwards
		// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
		strSaveString += GetParentEMR()->GenerateSaveString(nAuditTransactionID, strPostSaveSql, arystrErrors, mapSavedObjects, arynAffectedDetailIDs, bDrugInteractionsChanged, TRUE);
		nEMRID = GetParentEMR()->GetID();
	}

	// (a.walling 2007-07-09 16:33) - PLID 23714 - Ensure that our charts and categories are OK, and will not throw any exceptions
	if (GetChart().nID != -1 || GetCategory().nID != -1) {
		// we have a chart or category we would like to save. First try to check the More Info Dlg (if it exists) since it is listening
		// for these table checkers.
		if (GetInterface()) {
			CEmrTreeWnd* pTreeWnd = GetInterface();

			if (pTreeWnd) {
				CString strChangedMessage;
				// (z.manning 2013-06-05 09:48) - PLID 56962 - This no longer takes a param for output message.
				if (pTreeWnd->UpdateEMNMoreInfoDlgChangedInfo(this)) {
					// We don't need to do anything; all the work has been done in UpdateEMNMoreInfoDlgChangedInfo
				} else {
					// If we get here, pMoreInfoDlg was NULL, so run the legacy logic
					strChangedMessage = pTreeWnd->CheckValidChartsCategories(this);

					if (strChangedMessage.GetLength()) {
						arystrErrors.Add(strChangedMessage);
					}
				}
			}
		}
	}

	// (z.manning, 02/07/2007) - PLID 24599 - We want to delete all template topic records at once to avoid possible
	// foreign key problems. Thus, CTopic::GenerateDeleteString no longer even tries to delete them. Instead, we
	// track all topic IDs, so we can delete all topics at once afterwards.
	CArray<long,long> arynDeletedTemplateTopicIDs;

	//first save the EMN data

	CString strEMRGroupID = "NULL";
	if(nEMRID != -1) {
		strEMRGroupID.Format("%li",nEMRID);
	}
	else {
		strEMRGroupID = "@nEMRGroupID";
	}

	//Description
	//Use m_strDescription

	//LocationID
	//We'll just use m_nLocationID, since it can't be NULL.
	if(m_Location.nID == -1)
		m_Location.nID = GetCurrentLocationID();

	//Date
	//We'll use m_dtEMNDate, since it can't be NULL.

	//PatientGender
	CString strGender = "NULL";
	if(m_cbPatientGender != 0) {
		strGender.Format("%li",m_cbPatientGender);
	}

	//m.hancock - 3/13/2006 - 19579 - Patient demographics shouldn't change after the EMN is locked
	//Patient First Name
	//use m_strPatNameFirst
	//Patient Middle Name
	//use m_strPatNameMiddle
	//Patient Last Name
	//use m_strPatNameLast

	//AdditionalNotes
	CString strAdditionalNotes = m_strNotes;

	CString strEmrCollectionID = "NULL";
	if(m_nEMRCollectionID != -1)
		strEmrCollectionID.Format("%li",m_nEMRCollectionID);

	//Template ID
	CString strTemplateID = "NULL";
	if(m_nTemplateID > 0) {
		strTemplateID.Format("%li", m_nTemplateID);
	}

	// (z.manning 2009-07-07 10:44) - PLID 34078 - We should not be able to unspawn
	// a medication that has been e-prescribed (or even attempted to e-prescribe).
	// If this EMN has any e-prescriptions then erase its source action info so that
	// it's not possible to unspawn the EMN.
	// (a.walling 2010-03-31 14:22) - PLID 38010 - A sheep told me that this was a baaaaaad idea. We'll prevent it in the unspawning code.
	// I need to know where this EMN came from for reasons other than unspawning. I'll leave the SourceActionInfo clearing for medications
	// intact, though.
	/*
	if(this->HasEPrescriptions()) {
		SourceActionInfo saiBlank;
		m_sai = saiBlank;
	}
	*/

	//SourceActionID
	CString strSourceActionID = "NULL";
	if(m_sai.nSourceActionID != -1) {
		strSourceActionID.Format("%li", m_sai.nSourceActionID);
	}

	// (j.jones 2007-01-11 10:30) - PLID 24027 - supported SourceDetailID
	//SourceDetailID
	CString strSourceDetailID = "NULL";
	if(m_sai.nSourceDetailID != -1) {
		strSourceDetailID.Format("%li", m_sai.nSourceDetailID);
	} else if (m_sai.pSourceDetail) {
		LPVOID pDummy = NULL;
		if (m_sai.pSourceDetail->m_nEMRDetailID != -1) {		
			// (a.walling 2010-03-31 11:55) - PLID 38006 - Use the pointer's value if it has not been updated for whatever reason
			strSourceDetailID.Format("%li", m_sai.pSourceDetail->m_nEMRDetailID);
		} else if (mapSavedObjects.Lookup((LPVOID)m_sai.pSourceDetail, pDummy)) {
			// (a.walling 2010-08-13 13:43) - PLID 38006 - Get the ID from the saved objects map		
			strSourceDetailID.Format("(SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotDetail, (long)m_sai.pSourceDetail);
		} else {			
			// (a.walling 2010-08-13 13:43) - PLID 38006 - It really is not available!
			// (a.walling 2010-08-19 16:55) - PLID 38006 - This is expected and OK if the source detail was deleted or unspawned.
		}
	}

	// (z.manning 2009-03-04 14:31) - PLID 33338 - SourceDataGroupID
	CString strSourceDataGroupID = "NULL";
	if(m_sai.GetDataGroupID() != -1) {
		strSourceDataGroupID = AsString(m_sai.GetDataGroupID());
	}

	// (z.manning 2010-02-26 16:17) - PLID 37540 - SourceDetailImageStampID
	CString strSourceDetailImageStampID = "NULL";
	if(m_sai.GetDetailStampID() != -1) {
		strSourceDetailImageStampID.Format("%li", m_sai.GetDetailStampID());
	} else if (m_sai.GetDetailStampPointer()) {
		LPVOID pDummy = NULL;
		if (m_sai.GetDetailStampPointer()->nID != -1) {		
			// (a.walling 2010-03-31 11:55) - PLID 38006 - Use the pointer's value if it has not been updated for whatever reason
			strSourceDetailImageStampID.Format("%li", m_sai.GetDetailStampPointer()->nID);
		} else if (mapSavedObjects.Lookup((LPVOID)m_sai.GetDetailStampPointer(), pDummy)) {
			// (a.walling 2010-08-13 13:43) - PLID 38006 - Get the ID from the saved objects map		
			strSourceDetailImageStampID.Format("(SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotDetailImageStamp, (long)m_sai.GetDetailStampPointer());
		} else {
			// (a.walling 2010-08-13 13:43) - PLID 38006 - It really is not available!
			// (a.walling 2010-08-19 16:55) - PLID 38006 - This is expected and OK if the source detail was deleted or unspawned.
		}
	}

	// (b.eyers 2016-02-22) - PLID 68321 - discharge status, null if doesn't exist
	CString strDischargeStatusID = "NULL";
	if (m_DischargeStatus.nID != -1)
		strDischargeStatusID.Format("%li", m_DischargeStatus.nID);

	// (j.jones 2007-06-14 11:57) - PLID 26276 - added CompletionStatus
	m_ecsCompletionStatus = CalculateCompletionStatus();
	long nCompletionStatus = (long)m_ecsCompletionStatus;

	// (j.jones 2007-08-24 12:39) - PLID 27054 - added Visit Types
	CString strVisitTypeID = "NULL";
	if(m_nVisitTypeID != -1)
		strVisitTypeID.Format("%li",m_nVisitTypeID);

	// (a.walling 2013-01-16 13:04) - PLID 54652 - AppointmentID
	CString strAppointmentID = "NULL";
	if (m_Appointment.nID != -1) {
		strAppointmentID.Format("%li", m_Appointment.nID);
	}

	if(m_bIsTemplate) {
		//save new
		if(m_nID == -1) {
			//save new template record

			// (j.jones 2007-08-24 08:53) - PLID 27054 - added VisitTypeID
			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplateT "
				"(CollectionID, Name, CreatedDate, CreatedLogin, AddOnce, VisitTypeID, HideTitleOnPreview) "
				"VALUES (%s, '%s', GetDate(), '%s', %i, %s, %i)\r\n"
				"SET @nNewObjectID = SCOPE_IDENTITY()\r\n" // (c.haag 2007-06-11 17:15) - PLID 26277 - Use the scope identity function to get the ID of the newly created template record
				,strEmrCollectionID, _Q(m_strDescription), _Q(GetCurrentUserName()), m_bAddOnce?1:0, strVisitTypeID, m_bHideTitleOnPreview?1:0);

			//store that ID
			// (c.haag 2007-06-11 17:15) - PLID 26277 - This is no longer necessary now that we use the scope identity function
			//AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = (SELECT COALESCE(MAX(ID), 0) FROM EMRTemplateT WITH(UPDLOCK, HOLDLOCK))");
			AddNewEMRObjectToSqlBatch(strSaveString, esotEMN, (long)this, mapSavedObjects);

			//with batched saving and batched auditing, we can't actually pull the template ID
			//until the save is complete in the tree, so this audit is handled in PropagateIDs()
		}
		else {

			if(m_bUnsaved || bSaveRecordOnly || m_bMoreInfoUnsaved) {
			
				//update existing template record

				// (j.jones 2007-08-24 08:53) - PLID 27054 - added VisitTypeID
				//TES 1/17/2014 - PLID 60397 - Addded HideTitleOnPreview
				AddStatementToSqlBatch(strSaveString, "UPDATE EMRTemplateT SET Name = '%s', HideTitleOnPreview = %i "
					"WHERE ID = %li", _Q(m_strDescription), m_bHideTitleOnPreview?1:0, m_nID);

				//auditing

				//audit the description
				if(m_strLastSavedDescription != m_strDescription) {
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateDescription, m_nID, m_strLastSavedDescription, m_strDescription, aepMedium, aetChanged);
				}

				// (z.manning, 04/20/2007) - PLID 25731 - Audit chart type.
				if(m_LastSavedChart.nID != m_Chart.nID)
				{
					CString strOldChart = (m_LastSavedChart.nID == -1) ? "{No Chart}" : m_LastSavedChart.strName;
					CString strNewChart = (m_Chart.nID == -1) ? "{No Chart}" : m_Chart.strName;

					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateChart, m_nID, strOldChart, strNewChart, aepMedium, aetChanged);
				}

				// (z.manning, 04/20/2007) - PLID 25731 - Audit category.
				if(m_LastSavedCategory.nID != m_Category.nID)
				{
					CString strOldCategory = (m_LastSavedCategory.nID == -1) ? "{No Category}" : m_LastSavedCategory.strName;
					CString strNewCategory = (m_Category.nID == -1) ? "{No Category}" : m_Category.strName;

					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateCategory, m_nID, strOldCategory, strNewCategory, aepMedium, aetChanged);
				}

				//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
				if(m_bLastSavedHideTitleOnPreview != m_bHideTitleOnPreview) {
					CString strOld = m_bLastSavedHideTitleOnPreview?"Hide":"Do Not Hide";
					CString strNew = m_bHideTitleOnPreview?"Hide":"Do Not Hide";

					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

					AuditEvent(-1, "", nAuditTransactionID, aeiEMRTemplateHideTitleOnPreview, m_nID, strOld, strNew, aepMedium, aetChanged);
				}

				// (d.thompson 2009-05-27) - PLID 29909 - Confidential info cannot be saved on a template, thus no audit
			}
			
			//TES 2/21/2014 - PLID 60972 - Visit Type is on the Codes topic now
			if(m_bUnsaved || bSaveRecordOnly || m_bCodesUnsaved) {
				AddStatementToSqlBatch(strSaveString, "UPDATE EMRTemplateT SET VisitTypeID = %s "
					"WHERE ID = %li", strVisitTypeID, m_nID);

				// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
				if(m_nLastSavedVisitTypeID != m_nVisitTypeID) {

					CString strOld, strNew;
					if(m_nVisitTypeID == -1)
						strNew = "<No Visit Type>";
					else
						strNew = m_strVisitTypeName;

					if(m_nLastSavedVisitTypeID == -1)
						strOld = "<No Visit Type>";
					else
						strOld = m_strLastSavedVisitTypeName;

					if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

					AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateVisitType, m_nID, strOld, strNew, aepMedium, aetChanged);					
				}
			}
		}
	}
	else {
		if(m_nID == -1) {
			//new patient EMN record

			// (j.jones 2012-10-09 15:48) - PLID 53089 - The EMN date has always been date only, no time.
			// If we ever change this, our RememberForPatient logic needs to change because it depends on
			// the fact that EMNs do not have times.
			CString strEMNDate = FormatDateTimeForSql(m_dtEMNDate, dtoDate);

			// (j.armen 2013-05-08 12:09) - PLID 55315 - We still need to set the nEMRGroupID here.
			if(strEMRGroupID == "@nEMRGroupID") {
				AddStatementToSqlBatch(strSaveString, 
					FormatString("SET @nEMRGroupID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMR, (long)GetParentEMR()));
			}

			// (j.jones 2007-06-14 11:56) - PLID 26276 - added CompletionStatus
			// (j.jones 2007-08-24 08:53) - PLID 27054 - added VisitTypeID
			// (z.manning 2009-03-04 14:32) - PLID 33338 - SourceDataGroupID
			// (d.thompson 2009-05-27) - PLID 29909 - Added Confidential Info
			// (z.manning 2010-01-13 11:04) - PLID 22672 - Age is now a string field
			// (z.manning 2010-02-26 16:18) - PLID 37540 - Added SourceDetailImageStampID
			// (a.walling 2010-08-13 14:00) - PLID 38006 - Need to use SELECT so we can use subqueries for the saved objects table if necessary
			// (a.walling 2013-01-16 13:04) - PLID 54652 - AppointmentID saving
			// (j.armen 2013-05-07 15:31) - PLID 55315 - EMRMasterT.ID is now an identity
			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			AddStatementToSqlBatch(strSaveString, 
				"INSERT INTO EMRMasterT ( \r\n"
				"	PatientID, LocationID, Date, InputDate, PatientAge, \r\n"
				"	PatientGender, AdditionalNotes, EmrCollectionID, Status, EMRGroupID, \r\n"
				"	Description, TemplateID, SourceActionID, SourceDetailID, PatientFirst, \r\n"
				"	PatientMiddle, PatientLast, CompletionStatus, VisitTypeID, SourceDataGroupID, \r\n"
				"	ConfidentialInfo, SourceDetailImageStampID, AppointmentID, DischargeStatusID, \r\n"
				"	AdmissionTime, DischargeTime) \r\n"
				"SELECT \r\n"
				"	%li, %li, '%s', GetDate(), '%s', \r\n"
				"	%s, '%s', %s, %li, %s, \r\n"
				"	'%s', %s, %s, %s, '%s', \r\n"
				"	'%s', '%s', %li, %s, %s, \r\n"
				"	'%s', %s, %s, %s, \r\n"
				"	%s, %s \r\n"
				"SELECT @nEMNID = SCOPE_IDENTITY(), @nNewObjectID = SCOPE_IDENTITY() \r\n",
				m_pParentEMR->GetPatientID(), m_Location.nID, strEMNDate, 
				_Q(m_strPatientAge), strGender, _Q(strAdditionalNotes), strEmrCollectionID, emnStatus.nID, 
				strEMRGroupID, _Q(m_strDescription), strTemplateID, strSourceActionID, strSourceDetailID, 
				_Q(m_strPatNameFirst), _Q(m_strPatNameMiddle), _Q(m_strPatNameLast), nCompletionStatus, strVisitTypeID, 
				strSourceDataGroupID, _Q(m_strConfidentialInfo), strSourceDetailImageStampID, strAppointmentID, strDischargeStatusID,
				m_dtAdmissionTime.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(m_dtAdmissionTime)) + "'" : "NULL",
				m_dtDischargeTime.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(m_dtDischargeTime)) + "'" : "NULL");

			// (j.armen 2013-05-07 15:31) - PLID 55315 - Move this below the insert to EMRMasterT as we do not know the ID for the record until we insert it.
			AddNewEMRObjectToSqlBatch(strSaveString, esotEMN, (long)this, mapSavedObjects);

			// (a.walling 2010-08-13 14:04) - PLID 38006 - No longer necessary (cross-EMN IDs handled above, also using the maps, but enforcing save ordering this time)
			// but we will keep it around just in case.
			// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
			// be sure to update SourceDetailID at the end of the save!
			if(strSourceDetailID == "NULL" && m_sai.pSourceDetail && m_sai.nSourceDetailID == -1) {
				// (a.walling 2010-08-13 14:06) - PLID 38006 - In general, only valid for deleted sources

				//find this EMN's ID, find the source detail's ID, and update this EMN's SourceDetailID
				AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotEMN, (long)this);
				AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)m_sai.pSourceDetail);
				AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRMasterT SET SourceDetailID = @nEMRSourceDetailID WHERE ID = @nEMRObjectIDToUpdate");
			}

			// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
			if(strSourceDetailImageStampID == "NULL" && m_sai.GetDetailStampPointer() != NULL && m_sai.GetDetailStampID() == -1) {
				// (a.walling 2010-08-13 14:06) - PLID 38006 - In general, only valid for deleted sources

				AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotEMN, (long)this);
				AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)m_sai.GetDetailStampPointer());
				AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrMasterT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE ID = @nEMRObjectIDToUpdate");
			}

			// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
			// (z.manning 2009-05-22 10:04) - PLID 34297 - Just save links to problems
			AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
			SaveProblemLinkArray(strSaveString, m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
				, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

			//TES 8/8/2006 - PLID 21667 - We don't own the PIC!  It is not our job to update it.
			//AddStatementToSqlBatch(strSaveString, "UPDATE PicT SET IsCommitted = 1 WHERE EMRGroupID = %s AND IsCommitted = 0", strEMRGroupID);

			// (z.manning, 06/27/2006) - PLID 20896 - Need to audit that we crated a new EMN.
			// (j.jones 2006-08-25 09:23) - PLID 22203 - this doesn't show up in the EMN history
			// because we don't have an ID yet. Moved to PropagateIDs().
			//if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
			//AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNCreated, m_nID, m_strOldAuditValue, m_strDescription, aepMedium, aetCreated);	
		}
		else {

			if(m_bUnsaved || m_bMoreInfoUnsaved || bSaveRecordOnly) {

				// (j.jones 2006-08-24 09:09) - PLID 22183 - ensure it's not a locked record

				if(!IsLockedAndSaved()) {

					//update existing patient EMN record

					// (j.jones 2007-06-14 12:10) - PLID 26276 - added CompletionStatus
					// (j.jones 2007-08-24 08:53) - PLID 27054 - added VisitTypeID

					// (a.walling 2008-06-27 16:56) - PLID 30482 - If the parent EMR changed, we must update our EmrGroupID
					// (z.manning 2010-01-13 11:05) - PLID 22672 - Age is now a string
					// (z.manning 2010-02-26 16:20) - PLID 37540 - SourceDetailImageStampID
					// (a.walling 2013-01-16 13:04) - PLID 54652 - AppointmentID saving
					// (j.armen 2014-01-28 10:23) - PLID 60497 - Quantum saving - Place tablenames inline instead of formatting
					// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
					AddStatementToSqlBatch(strSaveString, 
						"UPDATE EMRMasterT SET ModifiedDate = GetDate(), "
						"LocationID = %li, Date = '%s', PatientAge = '%s', PatientGender = %s, "
						"AdditionalNotes = '%s', EmrCollectionID = %s, Status = %li, Description = '%s', SourceActionID = %s, "
						"SourceDetailID = %s, TemplateID = %s, PatientFirst = '%s', PatientMiddle = '%s', PatientLast = '%s', "
						"CompletionStatus = %li, SourceDataGroupID = %s, SourceDetailImageStampID = %s, ConfidentialInfo = '%s', "
						"AppointmentID = %s, VisitTypeID = %s, DischargeStatusID = %s, AdmissionTime = %s, DischargeTime = %s " 
						+ ((m_bParentEMRChanged && nEMRID != -1) ? FormatString(", EmrGroupID = %s", strEMRGroupID) : "") + " "
						"WHERE ID = %li",
						m_Location.nID, FormatDateTimeForSql(m_dtEMNDate, dtoDate), _Q(m_strPatientAge), strGender, 
						_Q(strAdditionalNotes), strEmrCollectionID, emnStatus.nID, _Q(m_strDescription), strSourceActionID, 
						strSourceDetailID, strTemplateID, _Q(m_strPatNameFirst), _Q(m_strPatNameMiddle), _Q(m_strPatNameLast),
						nCompletionStatus, strSourceDataGroupID, strSourceDetailImageStampID, _Q(m_strConfidentialInfo), 
						strAppointmentID, strVisitTypeID, strDischargeStatusID, 
						m_dtAdmissionTime.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(m_dtAdmissionTime)) + "'" : "NULL",
						m_dtDischargeTime.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(m_dtDischargeTime)) + "'" : "NULL", m_nID);

					// (c.haag 2008-06-24 12:38) - PLID 17244 - Update EMN todo alarm text because the EMN description is included in it
					if(m_strLastSavedDescription != m_strDescription) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Flatten parameterized query
						// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize
						AddStatementToSqlBatch(strSaveString, TodoGetEmrDetailAlarmUpdateQ(m_nID, -1));
						AddStatementToSqlBatch(strSaveString, TodoGetEmnAlarmUpdateQ(m_nID));
					}

					// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
					// (z.manning 2009-05-22 10:07) - PLID 34297 - Just save links to problems
					SaveProblemLinkArray(strSaveString, m_apEmrProblemLinks, AsString(m_nID), mapSavedObjects
						, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));
				}

				//Auditing
				//if locked, use this same code to not audit, but to log what we tried to change

				//Date
				if(m_dtLastSavedDate != m_dtEMNDate) {
					//TES 7/6/2009 - PLID 34629 - If the date changed, that means that all the EMR details need to 
					// be re-checked against Wellness Criteria.
					long nDetailCount = GetTotalDetailCount();
					for(long i = 0; i < nDetailCount; i++) {
						long nDetailID = GetDetail(i)->m_nEMRDetailID;
						if(nDetailID != -1) {
							arynAffectedDetailIDs.Add(nDetailID);
						}
					}

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNDate, m_nID, FormatDateTimeForSql(m_dtLastSavedDate), FormatDateTimeForSql(m_dtEMNDate), aepMedium, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the date on a locked EMN from %s to %s.", FormatDateTimeForInterface(m_dtLastSavedDate, dtoDate), FormatDateTimeForInterface(m_dtEMNDate, dtoDate));
						arystrErrors.Add(str);
					}
				}

				//Location
				if(m_LastSavedLocation.nID != m_Location.nID) {
					// (z.manning, 05/07/2007) - PLID 25925 - We used to load both location names from data here.
					// Now we load and track location names as soon as the EMN is loaded.
					CString strOldLocation = (m_LastSavedLocation.nID == -1) ? "<None>" : m_LastSavedLocation.strName;
					CString strNewLocation = (m_Location.nID == -1) ? "<None>" : m_Location.strName;

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNLocation, m_nID, strOldLocation, strNewLocation, aepMedium, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the location on a locked EMN from '%s' to '%s'.",strOldLocation,strNewLocation);
						arystrErrors.Add(str);
					}
				}

				//Appointment
				if(m_LastSavedAppointment != m_Appointment) {
					// (a.walling 2013-01-16 16:41) - PLID 54652 - Audit changes

					CString strOld = m_LastSavedAppointment.GetAuditString();
					CString strNew = m_Appointment.GetAuditString();

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNAppointment, m_nID, strOld, strNew, aepMedium, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the appointment associated with a locked EMN from '%s' to '%s'.",strOld,strNew);
						arystrErrors.Add(str);
					}
				}

				//Status
				// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
				if(m_LastSavedStatus.nID != m_Status.nID) {
					AuditEventPriorities aep = aepMedium;
					CString strOldStatus = m_LastSavedStatus.strName;
					CString strNewStatus = m_Status.strName;
					if(m_Status.nID == 2) {
						aep = aepHigh;
					}

					if(!IsLockedAndSaved()) {			
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNStatus, m_nID, strOldStatus, strNewStatus, aep, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the status of a locked EMN from '%s' to '%s'.", strOldStatus, strNewStatus);
						arystrErrors.Add(str);
					}
				}

				//Notes
				if(m_strLastSavedNotes != m_strNotes) {

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNNotes, m_nID, m_strLastSavedNotes, m_strNotes, aepMedium, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the notes on a locked EMN from '%s' to '%s'.", m_strLastSavedNotes, m_strNotes);
						arystrErrors.Add(str);
					}
				}

				//Description
				if(m_strLastSavedDescription != m_strDescription) {

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNDescription, m_nID, m_strLastSavedDescription, m_strDescription, aepMedium, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the description on a locked EMN from '%s' to '%s'.", m_strLastSavedDescription, m_strDescription);
						arystrErrors.Add(str);
					}
				}

				// (z.manning, 04/19/2007) - PLID 25714 - Chart
				if(m_LastSavedChart.nID != m_Chart.nID)
				{
					// (z.manning, 04/19/2007) - PLID 25714 - I know it wouldn't seem like we need to access the db
					// here, but we don't know that more info has been loaded so we can't get it there and the only
					// other alternative is to load and track the chart name all the time, however, that requires 
					// another 2 joins in the loading queries among other things and would end up being slower than
					// this anyway. Also, we only even get here if the chart changed.
					CString strOldChart = (m_LastSavedChart.nID == -1) ? "{No Chart}" : m_LastSavedChart.strName;
					CString strNewChart = (m_Chart.nID == -1) ? "{No Chart}" : m_Chart.strName;

					// (z.manning, 04/19/2007) - PLID 25714 - It is allowable to change the chart of a locked EMN, so
					// we don't bother checking for that here.
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNChart, m_nID, strOldChart, strNewChart, aepMedium, aetChanged);
				}

				// (z.manning, 04/19/2007) - PLID 25714 - Category
				if(m_LastSavedCategory.nID != m_Category.nID)
				{
					// (z.manning, 04/19/2007) - PLID 25714 - I know it wouldn't seem like we need to access the db
					// here, but we don't know that more info has been loaded so we can't get it there and the only
					// other alternative is to load and track the category name all the time, however, that requires 
					// another 2 joins in the loading queries among other things and would end up being slower than
					// this anyway. Also, we only even get here if the Category changed.
					CString strOldCategory = (m_LastSavedCategory.nID == -1) ? "{No Category}" : m_LastSavedCategory.strName;
					CString strNewCategory = (m_Category.nID == -1) ? "{No Category}" : m_Category.strName;

					// (z.manning, 04/19/2007) - PLID 25714 - It is allowable to change the category of a locked EMN, so
					// we don't bother checking for that here.
					if(nAuditTransactionID == -1) { nAuditTransactionID = BeginAuditTransaction(); }
					AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNCategory, m_nID, strOldCategory, strNewCategory, aepMedium, aetChanged);
				}

				// (b.eyers 2016-02-22) - PLID 68321 - audit discharge status
				if (m_LastSavedDischargeStatus.nID != m_DischargeStatus.nID) {

					CString strOldStatus = (m_LastSavedDischargeStatus.nID == -1) ? "<None>" : m_LastSavedDischargeStatus.strDesc;
					CString strNewStatus = (m_DischargeStatus.nID == -1) ? "<None>" : m_DischargeStatus.strDesc;

					if (!IsLockedAndSaved()) {
						if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNDischargeStatus, m_nID, strOldStatus, strNewStatus, aepMedium, aetChanged);
					}
					else {
						CString str;
						str.Format("Attempted to change the discharge status on a locked EMN from '%s' to '%s'.", strOldStatus, strNewStatus);
						arystrErrors.Add(str);
					}
				}

				// (b.eyers 2016-02-22) - PLID 68321 - audit admission time
				if (m_dtLastSavedAdmissionTime != m_dtAdmissionTime) {
					
					if (!IsLockedAndSaved()) {
						if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNAdmissionTime, m_nID, FormatDateTimeForInterface(m_dtLastSavedAdmissionTime, DTF_STRIP_SECONDS, dtoTime), FormatDateTimeForInterface(m_dtAdmissionTime, DTF_STRIP_SECONDS, dtoTime), aepMedium, aetChanged);
					}
					else {
						CString str;
						str.Format("Attempted to change the admission time on a locked EMN from %s to %s.", FormatDateTimeForInterface(m_dtLastSavedAdmissionTime, dtoTime), FormatDateTimeForInterface(m_dtAdmissionTime, dtoTime));
						arystrErrors.Add(str);
					}
				}

				// (b.eyers 2016-02-22) - PLID 68321 - audit discharge time
				if (m_dtLastSavedDischargeTime != m_dtDischargeTime) {

					if (!IsLockedAndSaved()) {
						if (nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNDischargeTime, m_nID, FormatDateTimeForInterface(m_dtLastSavedDischargeTime, DTF_STRIP_SECONDS, dtoTime), FormatDateTimeForInterface(m_dtDischargeTime, DTF_STRIP_SECONDS, dtoTime), aepMedium, aetChanged);
					}
					else {
						CString str;
						str.Format("Attempted to change the discharge time on a locked EMN from %s to %s.", FormatDateTimeForInterface(m_dtLastSavedDischargeTime, dtoTime), FormatDateTimeForInterface(m_dtDischargeTime, dtoTime));
						arystrErrors.Add(str);
					}
				}

				// (j.jones 2007-08-06 16:15) - PLID 26974 - audit changes to patient demographics, if any
				if(m_strLastSavedPatNameFirst != m_strPatNameFirst) {

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNPatientFirstName, m_nID, m_strLastSavedPatNameFirst, m_strPatNameFirst, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the patient first name on a locked EMN from %s to %s.", m_strLastSavedPatNameFirst, m_strPatNameFirst);
						arystrErrors.Add(str);
					}
				}

				if(m_strLastSavedPatNameMiddle != m_strPatNameMiddle) {

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNPatientMiddleName, m_nID, m_strLastSavedPatNameMiddle, m_strPatNameMiddle, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the patient middle name on a locked EMN from %s to %s.", m_strLastSavedPatNameMiddle, m_strPatNameMiddle);
						arystrErrors.Add(str);
					}
				}

				if(m_strLastSavedPatNameLast != m_strPatNameLast) {

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNPatientLastName, m_nID, m_strLastSavedPatNameLast, m_strPatNameLast, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the patient last name on a locked EMN from %s to %s.", m_strLastSavedPatNameLast, m_strPatNameLast);
						arystrErrors.Add(str);
					}
				}

				if(m_cbLastSavedPatientGender != m_cbPatientGender) {

					CString strOld, strNew;
					if(m_cbPatientGender == 1)
						strNew = "Male";
					else if(m_cbPatientGender == 2)
						strNew = "Female";
					else
						strNew = "Unspecified";

					if(m_cbLastSavedPatientGender == 1)
						strOld = "Male";
					else if(m_cbLastSavedPatientGender == 2)
						strOld = "Female";
					else
						strOld = "Unspecified";

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNPatientGender, m_nID, strOld, strNew, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the patient gender on a locked EMN from %s to %s.", strOld, strNew);
						arystrErrors.Add(str);
					}
				}

				if(m_strLastSavedPatientAge != m_strPatientAge) {

					CString strOld, strNew;
					strNew = m_strPatientAge;
					strOld = m_strLastSavedPatientAge;

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNPatientAge, m_nID, strOld, strNew, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the patient age on a locked EMN from %s to %s.", strOld, strNew);
						arystrErrors.Add(str);
					}
				}

				// (d.thompson 2009-05-27) - PLID 29909 - Audit confidential info.  Note that we do not audit
				//	the data that changed, otherwise it wouldn't be confidential anymore!
				if(m_bConfidentialInfoChanged) {
					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNConfidentialInfoChanged, m_nID, "Confidential Info Changed", "", aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						arystrErrors.Add("Attempted to change the confidential info on a locked EMN!");
					}
				}
			}
			// (z.manning, 03/10/2008) - PLID 29243 - Since completion status is more of a calulated field than
			// raw data we have decided you can change it on locked EMNs, so I removed that check here.
			// (a.walling 2013-02-06 17:05) - PLID 55043 - Do not try to update the completion status if locked
			else if(!IsLockedAndSaved() && m_ecsCompletionStatus != m_ecsLastSavedCompletionStatus) {
				// (j.jones 2007-06-14 12:11) - PLID 26276 - even if nothing else on the EMN changed,
				// if the completion status changed, we have to save it (provided the EMN is unlocked)
				AddStatementToSqlBatch(strSaveString, "UPDATE EMRMasterT SET CompletionStatus = %li WHERE ID = %li",
						nCompletionStatus, m_nID);
			}

			//TES 2/21/2014 - PLID 60972 - Visit Type is on the Codes topic now
			if(m_bUnsaved || m_bCodesUnsaved || bSaveRecordOnly) {
				if(!IsLockedAndSaved()) {
					//update existing patient EMN record
					AddStatementToSqlBatch(strSaveString, 
						"UPDATE EMRMasterT SET ModifiedDate = GetDate(), "
						"VisitTypeID = %s" 
						+ ((m_bParentEMRChanged && nEMRID != -1) ? FormatString(", EmrGroupID = %s", strEMRGroupID) : "") + " "
						"WHERE ID = %li",
						strVisitTypeID, m_nID);
				}

				// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
				if(m_nLastSavedVisitTypeID != m_nVisitTypeID) {

					CString strOld, strNew;
					if(m_nVisitTypeID == -1)
						strNew = "<No Visit Type>";
					else
						strNew = m_strVisitTypeName;

					if(m_nLastSavedVisitTypeID == -1)
						strOld = "<No Visit Type>";
					else
						strOld = m_strLastSavedVisitTypeName;

					if(!IsLockedAndSaved()) {
						if(nAuditTransactionID == -1) nAuditTransactionID = BeginAuditTransaction();

						AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNVisitType, m_nID, strOld, strNew, aepHigh, aetChanged);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the visit type on a locked EMN from %s to %s.", strOld, strNew);
						arystrErrors.Add(str);
					}
				}
			}

		}
	}

	//if saving the record only, do not save the MoreInfo)
	//used to reduce the calls to the #NewObjectsT table
	BOOL bReferenceIDDefined = FALSE;

	if(!bSaveRecordOnly && (m_nID == -1 || m_bMoreInfoUnsaved)) {

		//now save the More Info data		

		//Procedures
		if(m_bIsTemplate) {
			//save procedures to a new EMN

			if(m_nID == -1) {
				//add to EMRTemplateProceduresT
				if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}

				for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplateProceduresT (EMRTemplateID, ProcedureID) "
						"VALUES (@nEMRTemplateID, %li)", m_aryProcedures[i]->nID);

					//don't audit here because we're creating the template
				}
			}
			else {
				//update EMRTemplateProceduresT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the procedures we've removed
				for(i = 0; i < m_aryDeletedProcedures.GetSize(); i++) {
					//TES 2/8/2012 - PLID 19441 - We now store the struct, so we have the ID and the Name in memory
					EMNProcedure *pProc = m_aryDeletedProcedures.GetAt(i);
					AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRTemplateProceduresT WHERE EMRTemplateID = %li AND ProcedureID = %li", m_nID, pProc->nID);

					//auditing (using transactions)
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateProcedureRemoved, m_nID, pProc->strName, "<Deleted>", aepMedium, aetDeleted);					

					//TES 2/8/2012 - PLID 19441 - Cleanup
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete pProc;
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedProcedures.RemoveAll();

				for(i = 0; i < m_aryProcedures.GetSize(); i++) {
					//only insert new procedures
					//DRT 3/3/2006 - PLID 19441 - To improve auditing, we added the name of the procedure to the EMNProcedure structure, 
					//	so use that instead of a database query.
					EMNProcedure* pProc = m_aryProcedures.GetAt(i);

					if(pProc->bIsNew) {

						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplateProceduresT (EMRTemplateID, ProcedureID) "
							"VALUES (%li, %li)", m_nID, pProc->nID);
						
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateProcedureAdded, m_nID, "", pProc->strName, aepMedium, aetCreated);						
					}
				}
			}
		}
		else {
			//update procedures to an existing EMN		

			if(m_nID == -1) {
				//add to EMRProcedureT
				// (c.haag 2007-06-11 17:26) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/
				for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
					EMNProcedure *pProc = m_aryProcedures.GetAt(i);
					long nID = m_aryProcedures[i]->nID;
					CString strSourceActionID = "NULL";
					if(m_aryProcedures[i]->sai.nSourceActionID != -1)
						strSourceActionID.Format("%li", m_aryProcedures[i]->sai.nSourceActionID);
					// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
					CString strSourceDetailID = "NULL";
					if(m_aryProcedures[i]->sai.nSourceDetailID != -1)
						strSourceDetailID.Format("%li", m_aryProcedures[i]->sai.nSourceDetailID);					
					// (z.manning 2009-02-27 10:41) - PLID 33141 - SourceDataGroupID
					CString strSourceDataGroupID = "NULL";
					if(pProc->sai.GetDataGroupID() != -1) {
						strSourceDataGroupID = AsString(pProc->sai.GetDataGroupID());
					}
					// (z.manning 2010-02-26 16:25) - PLID 37540
					CString strSourceDetailImageStampID = "NULL";
					if(pProc->sai.GetDetailStampID() != -1) {
						strSourceDetailImageStampID = AsString(pProc->sai.GetDetailStampID());
					}

					AddStatementToSqlBatch(strSaveString, 
						"INSERT INTO EmrProcedureT (EMRID, ProcedureID, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID) "
						"VALUES (@nEMNID, %li, %s, %s, %s, %s)"
						, m_aryProcedures.GetAt(i)->nID, strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID);

					// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
					// be sure to update SourceDetailID at the end of the save!
					if(m_aryProcedures[i]->sai.pSourceDetail && m_aryProcedures[i]->sai.nSourceDetailID == -1) {
						//get the EMN ID, and the source detail ID, and update this procedure's SourceDetailID
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(m_aryProcedures[i]->sai.pSourceDetail));
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRProcedureT SET SourceDetailID = @nEMRSourceDetailID WHERE ProcedureID = %li AND EMRID = @nEMRObjectIDToUpdate", m_aryProcedures.GetAt(i)->nID);
					}

					// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
					if(m_aryProcedures[i]->sai.GetDetailStampPointer() != NULL && m_aryProcedures[i]->sai.GetDetailStampID() == -1) {
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotEMN, (long)this);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)m_aryProcedures[i]->sai.GetDetailStampPointer());
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrProcedureT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE EMRID = @nEMRObjectIDToUpdate AND ProcedureID = %li", m_aryProcedures.GetAt(i)->nID);
					}

					//don't audit here because we're creating the EMN
				}
				
			}
			else {
				//update EMRProcedureT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the procedures we've removed
				for(i = 0; i < m_aryDeletedProcedures.GetSize(); i++) {
					//TES 2/8/2012 - PLID 19441 - We now store the struct, so we have the ID and the Name in memory
					EMNProcedure *pProc = m_aryDeletedProcedures.GetAt(i);
					// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
					if(!IsLockedAndSaved()) {
						//AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRProcedureT WHERE EMRID = %li AND ProcedureID = %li", m_nID, m_aryDeletedProcedures.GetAt(i));
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrProcedureT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EMRID = %li AND ProcedureID = %li", _Q(GetCurrentUserName()), m_nID, pProc->nID);
					}

					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNProcedureRemoved, m_nID, pProc->strName, "<Deleted>", aepMedium, aetDeleted);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete procedure '%s' from a locked EMN.", pProc->strName);
						arystrErrors.Add(str);
					}

					//TES 2/8/2012 - PLID 19441 - Cleanup
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete pProc;
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedProcedures.RemoveAll();

				for(i = 0; i < m_aryProcedures.GetSize(); i++) {

					//only insert new procedures
					//DRT 3/3/2006 - PLID 19441 - To improve auditing, we added the name of the procedure to the EMNProcedure structure, 
					//	so use that instead of a database query.
					EMNProcedure* pProc = m_aryProcedures.GetAt(i);

					if(pProc->bIsNew) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							long nID = pProc->nID;
							CString strSourceActionID = "NULL";
							if(pProc->sai.nSourceActionID != -1)
								strSourceActionID.Format("%li", pProc->sai.nSourceActionID);
							// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
							CString strSourceDetailID = "NULL";
							if(pProc->sai.nSourceDetailID != -1)
								strSourceDetailID.Format("%li", pProc->sai.nSourceDetailID);	
							// (z.manning 2009-02-27 10:44) - PLID 33141 - SourceDataGroupID
							CString strSourceDataGroupID = "NULL";
							if(pProc->sai.GetDataGroupID() != -1) {
								strSourceDataGroupID = AsString(pProc->sai.GetDataGroupID());
							}
							// (z.manning 2010-02-26 16:26) - PLID 37540
							CString strSourceDetailImageStampID = "NULL";
							if(pProc->sai.GetDetailStampID() != -1) {
								strSourceDetailImageStampID = AsString(pProc->sai.GetDetailStampID());
							}

							AddStatementToSqlBatch(strSaveString, 
								"INSERT INTO EmrProcedureT (EMRID, ProcedureID, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID) "
								"VALUES (%li, %li, %s, %s, %s, %s)"
								, m_nID, pProc->nID, strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID);

							// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
							// be sure to update SourceDetailID at the end of the save!
							if(pProc->sai.pSourceDetail && pProc->sai.nSourceDetailID == -1) {
								//find the source detail's ID, and update this topic's SourceDetailID
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pProc->sai.pSourceDetail));
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRProcedureT SET SourceDetailID = @nEMRSourceDetailID WHERE ProcedureID = %li AND EMRID = %li", pProc->nID, m_nID);
							}

							// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
							if(pProc->sai.GetDetailStampPointer() != NULL && pProc->sai.GetDetailStampID() == -1) {
								AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pProc->sai.GetDetailStampPointer());
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRProcedureT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE ProcedureID = %li AND EMRID = %li", pProc->nID, m_nID);
							}

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNProcedureAdded, m_nID, "", pProc->strName, aepMedium, aetCreated);
							
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							//TES 2/8/2012 - PLID 19441 - Just get the name out of the struct
							str.Format("Attempted to add procedure '%s' to a locked EMN.", pProc->strName);
							arystrErrors.Add(str);
						}
					}
				}
			}
		}

		//Medications
		if(m_bIsTemplate) {
			//save medications to a new EMN

			if(m_nID == -1) {
				//update EMRTemplatePrescriptionsT

				for(int i = 0; i < m_aryMedications.GetSize(); i++) {

					EMNMedication *pMedication = m_aryMedications.GetAt(i);

					if(!bReferenceIDDefined) {
						CString str;
						str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
						AddStatementToSqlBatch(strSaveString, str);
						bReferenceIDDefined = TRUE;
					}

					// (c.haag 2007-06-14 10:50) - PLID 26277 - Get the new ID from EMRTemplatePrescriptionsT using scope_identity
					//TES 2/11/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
					//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
					//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
					//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplatePrescriptionsT "
						"(EMRTemplateID, MedicationID, PatientExplanation, Quantity, RefillsAllowed, Unit, "
						"DaysSupply, NoteToPharmacist, AllowSubstitutions) "
						"VALUES (@nEMRTemplateID, %li, '%s', '%s', '%s', '%s', %s, '%s', %i)\r\n"
						"SET @nNewObjectID = SCOPE_IDENTITY()"
						, pMedication->nMedicationID,
						_Q(pMedication->strPatientExplanation),
						_Q(pMedication->strQuantity),
						_Q(pMedication->strRefillsAllowed), 
						_Q(pMedication->strUnit),
						pMedication->nDaysSupply == -1 ? "NULL" : AsString(pMedication->nDaysSupply),
						_Q(pMedication->strNoteToPharmacist),
						pMedication->bAllowSubstitutions ? 1 : 0);

					// (c.haag 2007-06-14 10:51) - PLID 26277 - This is no longer necessary since we got @nNewObjectID earlier
					//AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = (SELECT COALESCE(MAX(ID), 0) FROM EMRTemplatePrescriptionsT WITH(UPDLOCK, HOLDLOCK))");
					AddNewEMRObjectToSqlBatch(strSaveString, esotPrescription, (long)pMedication, mapSavedObjects);

					//don't audit here, because we don't need to audit for new templates
				}
			}
			else {
				//update EMRTemplatePrescriptionsT
				
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//first run through the list of deleted prescriptions and mark them as such
				// (c.haag 2008-07-23 13:47) - PLID 30820 - We now store deleted medications in the form of objects, not ID's
				for(i = 0; i < m_aryDeletedMedications.GetSize(); i++) {
					//TES 2/8/2012 - PLID 19441 - Pull the info, so we can read the name out of memory rather than running a recordset.
					EMNMedication *pMed = m_aryDeletedMedications.GetAt(i);
					long nMedicationID = pMed->nID;

					if(nMedicationID != -1) {

						AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRTemplatePrescriptionsT WHERE ID = %li", nMedicationID);

						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescriptionRemoved, m_nID, pMed->m_strDrugName, "<Deleted>", aepMedium, aetDeleted);
					}

					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedMedications[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedMedications.RemoveAll();

				for(i = 0; i < m_aryMedications.GetSize(); i++) {

					EMNMedication *pMedication = m_aryMedications.GetAt(i);
					
					// (j.jones 2006-01-19 14:10) - insert new prescriptions, and update existing prescriptions

					if(pMedication->nID == -1) {
						//new prescription				
						// (c.haag 2007-06-14 10:50) - PLID 26277 - Get the new ID from EMRTemplatePrescriptionsT using scope_identity
						//TES 2/11/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
						//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
						//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
						//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplatePrescriptionsT "
							"(EMRTemplateID, MedicationID, PatientExplanation, Quantity, RefillsAllowed, Unit, "
							"DaysSupply, NoteToPharmacist, AllowSubstitutions) "
							"VALUES (%li, %li, '%s', '%s', '%s', '%s', %s, '%s', %i)\r\n"
							"SET @nNewObjectID = SCOPE_IDENTITY()"
							, m_nID, pMedication->nMedicationID,
							_Q(pMedication->strPatientExplanation),
							_Q(pMedication->strQuantity),
							_Q(pMedication->strRefillsAllowed), 
							_Q(pMedication->strUnit),
							pMedication->nDaysSupply == -1 ? "NULL" : AsString(pMedication->nDaysSupply),
							_Q(pMedication->strNoteToPharmacist),
							pMedication->bAllowSubstitutions ? 1 : 0);

						// (c.haag 2007-06-14 10:53) - PLID 26277 - This is now redundant
						//AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = (SELECT COALESCE(MAX(ID), 0) FROM EMRTemplatePrescriptionsT WITH(UPDLOCK, HOLDLOCK))");
						AddNewEMRObjectToSqlBatch(strSaveString, esotPrescription, (long)pMedication, mapSavedObjects);

						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescriptionAdded, m_nID, "", pMedication->m_strDrugName, aepMedium, aetDeleted);
					}
					else {
						//existing prescription

						//TES 2/11/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
						//TES 2/17/2009 - PLID 33034 - Added Strength and DosageForm
						//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
						//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
						AddStatementToSqlBatch(strSaveString, "UPDATE EMRTemplatePrescriptionsT "
							"SET PatientExplanation = '%s', Quantity = '%s', RefillsAllowed = '%s', Unit = '%s', "
							"DaysSupply = %s, NoteToPharmacist = '%s', "
							"AllowSubstitutions = %i "
							"WHERE ID = %li", 	_Q(pMedication->strPatientExplanation), _Q(pMedication->strQuantity),
							_Q(pMedication->strRefillsAllowed), _Q(pMedication->strUnit), 
							pMedication->nDaysSupply == -1 ? "NULL" : AsString(pMedication->nDaysSupply), 
							_Q(pMedication->strNoteToPharmacist), pMedication->bAllowSubstitutions?1:0, pMedication->nID);

						//get old data for auditing
						//DRT 8/28/2007 - PLID 27207 - Parameterized.
						//TES 2/11/2009 - PLID 33034 - Renamed Description to PatientExplanation, PillsPerBottle to Quantity
						//TES 2/17/2009 - PLID 33034 - Added Strength and DosageForm
						//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
						//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
						_RecordsetPtr rs = CreateParamRecordset("SELECT PatientExplanation, Quantity, RefillsAllowed, Unit, "
							"DaysSupply, NoteToPharmacist, AllowSubstitutions "
							"FROM EMRTemplatePrescriptionsT "
							"WHERE EmrTemplatePrescriptionsT.ID = {INT}", pMedication->nID);
						if(!rs->eof) {
							CString strDescription = AdoFldString(rs, "PatientExplanation","");
							CString strQuantity = AdoFldString(rs, "Quantity","");
							CString strRefills = AdoFldString(rs, "RefillsAllowed","");
							CString strUnit = AdoFldString(rs, "Unit","");
							long nDaysSupply = AdoFldLong(rs, "DaysSupply", -1);
							CString strNoteToPharmacist = AdoFldString(rs, "NoteToPharmacist", "");
							BOOL bAllowSubstitutions = AdoFldBool(rs, "AllowSubstitutions", TRUE);

							//auditing (using transactions)
							if(strDescription != pMedication->strPatientExplanation) {							
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescDesc, m_nID, strDescription, pMedication->strPatientExplanation, aepMedium, aetChanged);
							}
							if(strQuantity != pMedication->strQuantity) {							
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescPills, m_nID, strQuantity, pMedication->strQuantity, aepMedium, aetChanged);
							}
							if(strRefills != pMedication->strRefillsAllowed) {							
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescRefills, m_nID, strRefills, pMedication->strRefillsAllowed, aepMedium, aetChanged);
							}
							if(strUnit != pMedication->strUnit) {							
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePrescUnits, m_nID, strUnit, pMedication->strUnit, aepMedium, aetChanged);
							}
							if(nDaysSupply != pMedication->nDaysSupply) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePresDaysSupply, m_nID, nDaysSupply == -1 ? "" : AsString(nDaysSupply), pMedication->nDaysSupply == -1 ? "" : AsString(pMedication->nDaysSupply), aepMedium, aetChanged);
							}
							if(strNoteToPharmacist != pMedication->strNoteToPharmacist) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePresNoteToPharmacist, m_nID, strNoteToPharmacist, pMedication->strNoteToPharmacist, aepMedium, aetChanged);
							}
							if(bAllowSubstitutions != pMedication->bAllowSubstitutions) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplatePresAllowSubstitutions, m_nID, bAllowSubstitutions?"Yes":"No", pMedication->bAllowSubstitutions?"Yes":"No", aepMedium, aetChanged);
							}
						}
						rs->Close();
					}
				}
			}
		}
		else {
			//update medications to an existing EMN		

			if(m_nID == -1) {
				//update PatientMedications
				for(int i = 0; i < m_aryMedications.GetSize(); i++) {

					EMNMedication *pMedication = m_aryMedications[i];

					// (z.manning 2009-07-07 10:44) - PLID 34078 - We should not be able to unspawn
					// a medication that has been e-prescribed (or even attempted to e-prescribe).
					// To accomplish that, we simply set the medication source info to nothing so
					// it thinks it was never spawned in the first place.
					if(pMedication->bEPrescribe) {
						SourceActionInfo saiBlank;
						pMedication->sai = saiBlank;
					}

					CString strSourceActionID = (pMedication->sai.nSourceActionID != -1)
						? AsString(pMedication->sai.nSourceActionID) : "NULL";

					// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
					CString strSourceDetailID = (pMedication->sai.nSourceDetailID != -1)
						? AsString(pMedication->sai.nSourceDetailID) : "NULL";

					// (z.manning 2009-02-26 16:43) - PLID 33141 - SourceDataGroupID
					CString strSourceDataGroupID = (pMedication->sai.GetDataGroupID() != -1)
						? AsString(pMedication->sai.GetDataGroupID()) : "NULL";

					// (z.manning 2010-02-26 16:32) - PLID 37540
					CString strSourceDetailImageStampID = (pMedication->sai.GetDetailStampID() != -1)
						? AsString(pMedication->sai.GetDetailStampID()) : "NULL";

					// (j.jones 2012-09-27 15:11) - PLID 52820 - adding a new prescription contributes to potential
					// drug interactions, so track that this information has changed
					bDrugInteractionsChanged = TRUE;

					//new medication

					//TES 2/10/2009 - PLID 33034 - Changed Description to PatientExplanation, PillsPerBottle to Quantity
					//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
					//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
					//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields					
					// (a.walling 2009-04-22 11:22) - PLID 33948 - Support EPrescribe
					//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
					// (a.walling 2009-07-01 13:35) - PLID 34052 - Added AgentID, SupervisorID
					// (j.jones 2010-01-22 11:31) - PLID 37016 - supported InputByUserID
					// (b.savon 2013-01-16 16:05) - PLID 54656 - Removed AgentID
					// (s.dhole 2013-03-07 12:01) - PLID 55509 Added Strength , StrengthUnitID, DosageFormID ,QuantityUnitID
					// (s.dhole 2013-03-07 12:01) - PLID 55509 Remove unit
					// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
					//"RefillsAllowed, Quantity, Unit, ProviderID, LocationID, PharmacyID, "

					const long& nPatID = GetParentEMR()->GetPatientID();
					const long& nMedID = pMedication->nMedicationID;
					const CString& strPatExplanation = pMedication->strPatientExplanation;
					const CString& strEngDescription = pMedication->strEnglishDescription;
					const COleDateTime& dtPrescriptionDate = pMedication->dtPrescriptionDate;
					const CString& strRefillsAllowed = pMedication->strRefillsAllowed;
					const CString& strQuantity = pMedication->strQuantity;
					// (j.jones 2008-05-20 14:14) - PLID 30079 - EMN medications now track the provider,
					// location, date, and pharmacy, so pull from the medication, not from the EMN		
					const _variant_t vtProviderID = (pMedication->nProviderID == -1) ? g_cvarNull : pMedication->nProviderID;
					const _variant_t vtLocationID = (pMedication->nLocationID == -1) ? g_cvarNull : pMedication->nLocationID;
					const _variant_t vtPharmacyID = (pMedication->nPharmacyID == -1) ? g_cvarNull : pMedication->nPharmacyID;
					const _variant_t vtDaysSupply = (pMedication->nDaysSupply == -1) ? g_cvarNull : pMedication->nDaysSupply;
					const CString& strNoteToPharm = pMedication->strNoteToPharmacist;
					const bool bAllowSubstitutions = !!pMedication->bAllowSubstitutions;
					const CString& strPriorAuth = pMedication->strPriorAuthorization;
					const bool bPriorAuthIsSample = !!pMedication->bPriorAuthIsSample;
					const bool bEPrescribe = !!pMedication->bEPrescribe;
					const _variant_t vtSampleExpirationDate = (pMedication->dtSampleExpirationDate.GetStatus() != COleDateTime::valid) ? g_cvarNull : vtSampleExpirationDate;
					const _variant_t vtSupervisorID = (pMedication->nSupervisorID == -1) ? g_cvarNull : pMedication->nSupervisorID;
					const long& nCurUserID = GetCurrentUserID();
					const CString& strStrength = pMedication->strStrength;
					// (s.dhole 2013-03-15 16:34) - PLID 55509  Set value
					const _variant_t vtStrengthUnitID = (pMedication->nStrengthUnitID == -1) ? g_cvarNull : pMedication->nStrengthUnitID;
					const _variant_t vtDosageFormID = (pMedication->nDosageFormID == -1) ? g_cvarNull : pMedication->nDosageFormID;
					const _variant_t vtQuantityUnitID = (pMedication->nQuantityUnitID == -1) ? g_cvarNull : pMedication->nQuantityUnitID;
					// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
					const _variant_t vtDosageUnitID = (pMedication->nDosageUnitID == -1) ? g_cvarNull : pMedication->nDosageUnitID;
					const _variant_t vtDosageRouteID = (pMedication->nDosageRouteID == -1) ? g_cvarNull : pMedication->nDosageRouteID;
					const CString& strDosageQuantity = pMedication->strDosageQuantity;
					const CString& strDosageFrequency = pMedication->strDosageFrequency;
					
					// (j.armen 2013-05-24 15:22) - PLID 56863 - Patient Medications has an identity.
					//	Note that we just flatten the sql fragment here.  maybe someday this will be a param batch
					// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize - Your dream has come true, albeit in a likely unexpected fashion

					AddStatementToSqlBatch(strSaveString, CSqlFragment(
						"INSERT INTO PatientMedications (\r\n"
						"	PatientID, MedicationID, PatientExplanation, EnglishDescription, PrescriptionDate,\r\n"
						"	RefillsAllowed, Quantity, ProviderID, LocationID, PharmacyID,\r\n"
						"	DaysSupply, NoteToPharmacist, AllowSubstitutions, PriorAuthorization, PriorAuthorizationIsSample,\r\n"
						"	EPrescribe, SampleExpirationDate, SupervisorID, InputByUserID, Strength,\r\n"
						"	StrengthUnitID, DosageFormID, QuantityUnitID, DosageUnitID, DosageRouteID,\r\n"
						"	DosageQuantity, DosageFrequency)\r\n"
						"VALUES (\r\n"
						"	{INT}, {INT}, {STRING}, {STRING}, dbo.AsDateNoTime({OLEDATETIME}),\r\n"
						"	{STRING}, {STRING}, {VT_I4}, {VT_I4}, {VT_I4},\r\n"
						"	{VT_I4}, {STRING}, {BOOL}, {STRING}, {BOOL},\r\n"
						"	{BOOL}, {VT_DATE}, {VT_I4}, {INT}, {STRING},\r\n"
						"	{VT_I4}, {VT_I4}, {VT_I4}, {VT_I4}, {VT_I4},\r\n"
						"	{STRING}, {STRING})",
						nPatID, nMedID, strPatExplanation, strEngDescription, dtPrescriptionDate,
						strRefillsAllowed, strQuantity, vtProviderID, vtLocationID, vtPharmacyID,
						vtDaysSupply, strNoteToPharm, bAllowSubstitutions, strPriorAuth, bPriorAuthIsSample,
						bEPrescribe, vtSampleExpirationDate, vtSupervisorID, nCurUserID, strStrength,
						vtStrengthUnitID, vtDosageFormID, vtQuantityUnitID, vtDosageUnitID, vtDosageRouteID,
						strDosageQuantity, strDosageFrequency));

					AddStatementToSqlBatch(strSaveString, "SELECT @nNewObjectID = SCOPE_IDENTITY()");
					AddNewEMRObjectToSqlBatch(strSaveString, esotPrescription, (long)pMedication, mapSavedObjects);

					// (z.manning 2009-02-26 16:43) - PLID 33141 - Added SourceDataGroupID
					AddStatementToSqlBatch(strSaveString, 
						"INSERT INTO EmrMedicationsT (EmrID, MedicationID, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID) "
						"VALUES (@nEMNID, @nNewObjectID, %s, %s, %s, %s)"
						, strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID);

					// (j.jones 2008-10-13 11:39) - PLID 17235 - try to save to favorite pharmacies
					if(pMedication->nPharmacyID > -1) {
						AddStatementToSqlBatch(strSaveString, "IF NOT EXISTS "
							"(SELECT PharmacyID FROM FavoritePharmaciesT WHERE PatientID = %li AND PharmacyID = %li) "
							"BEGIN \r\n"
							"	UPDATE FavoritePharmaciesT SET OrderIndex = OrderIndex + 1 WHERE PatientID = %li \r\n"
							"	INSERT INTO FavoritePharmaciesT (PatientID, PharmacyID, OrderIndex) "
							"	VALUES (%li, %li, 1) \r\n"
							"END ", GetParentEMR()->GetPatientID(), pMedication->nPharmacyID,
							GetParentEMR()->GetPatientID(),
							GetParentEMR()->GetPatientID(), pMedication->nPharmacyID);
					}

					// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
					// be sure to update SourceDetailID at the end of the save!
					if(pMedication->sai.pSourceDetail && pMedication->sai.nSourceDetailID == -1) {
						//find this medication's ID, find the source detail's ID, and update this medication's SourceDetailID
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotPrescription, (long)pMedication);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pMedication->sai.pSourceDetail));
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrMedicationsT SET SourceDetailID = @nEMRSourceDetailID WHERE MedicationID = @nEMRObjectIDToUpdate");
					}

					// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
					if(pMedication->sai.GetDetailStampPointer() != NULL && pMedication->sai.GetDetailStampID() == -1) {
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotPrescription, (long)pMedication);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pMedication->sai.GetDetailStampPointer());
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrMedicationsT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE MedicationID = @nEMRObjectIDToUpdate");
					}

					// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
					// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
					AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
					SaveProblemLinkArray(strSaveString, pMedication->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
						, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

					//TES 3/26/2009 - PLID 33262 - We also need to save any diagnosis codes associated with this
					// prescription.
					AddStatementToSqlBatch(strSaveString, GenerateSaveString_PatientMedicationDiagCodesT(pMedication, "@nNewObjectID", bDrugInteractionsChanged));

					//we audit even though it's a new EMN, because we're adding a prescription to the patient's account

					//auditing (using transactions)
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					//audit for both patient and EMR
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescriptionCreated, GetParentEMR()->GetPatientID(), "", pMedication->m_strDrugName, aepMedium, aetCreated);
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescriptionAdded, m_nID, "", pMedication->m_strDrugName, aepMedium, aetCreated);
				}
			}
			else {
				//update PatientMedications
				
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//first run through the list of deleted prescriptions and mark them as such
				// (c.haag 2008-07-23 13:47) - PLID 30820 - We now store deleted medications in the form of objects, not ID's
				for(i = 0; i < m_aryDeletedMedications.GetSize(); i++) {

					// (j.jones 2012-11-14 14:21) - PLID 52819 - this should no longer be possible, we do this in the API
					ThrowNxException("GenerateSaveString attempted to delete a prescription incorrectly.");

					//TES 2/8/2012 - PLID 19441 - Pull the info, so we can read the name out of memory rather than running a recordset.
					EMNMedication *pMed = m_aryDeletedMedications.GetAt(i);
					long nMedicationID = pMed->nID;

					if(nMedicationID != -1) {

						// (c.haag 2009-07-02 11:52) - PLID 34102 - Do not save if the patient medication is in SureScriptsMessagesT
						// (j.jones 2012-10-29 14:45) - PLID 53259 - also cannot delete if the prescription status is E-Prescribed
						if(ReturnsRecordsParam("SELECT TOP 1 SureScriptsMessagesT.ID "
							"FROM SureScriptsMessagesT "
							"WHERE PatientMedicationID = {INT} "
							"UNION SELECT TOP 1 PatientMedications.ID "
							"FROM PatientMedications "
							"WHERE PatientMedications.ID = {INT} AND PatientMedications.QueueStatus IN ({SQL})",
							nMedicationID, nMedicationID, GetERxStatusFilter())) {

							CString str;
							// (b.savon 2013-09-23 07:31) - PLID 58486 - Changed the wording
							// (b.eyers 2016-02-05) - PLID 67980 - added dispensed in house
							str.Format("Attempted to delete medication '%s', but it has been printed, voided, electronically prescribed, or dispensed in-house.", pMed->m_strDrugName);
							arystrErrors.Add(str);
						}
						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						else if(!IsLockedAndSaved()) {
							//AddStatementToSqlBatch(strSaveString, "DELETE FROM EmrMedicationsT WHERE MedicationID = %li", nMedicationID);
							AddStatementToSqlBatch(strSaveString, "UPDATE EmrMedicationsT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE MedicationID = %li", _Q(GetCurrentUserName()), nMedicationID);
							AddStatementToSqlBatch(strSaveString, "UPDATE PatientMedications SET Deleted = 1 WHERE ID = %li", nMedicationID);
							// (c.haag 2008-07-28 10:00) - PLID 30853 - Also delete problems
							// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
							// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
							AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRProblemLinkT WHERE EmrRegardingType = %d AND EmrRegardingID = %d", eprtEmrMedication, nMedicationID);

							// (a.walling 2009-04-22 18:01) - PLID 34046
							SureScripts::DeletePendingNewRxInEMRBatch(strSaveString, nMedicationID);

							// (j.jones 2012-09-27 15:11) - PLID 52820 - removing a prescription contributes to potential
							// drug interactions, so track that this information has changed
							bDrugInteractionsChanged = TRUE;

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							//audit for both patient and EMR
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescDelete, GetParentEMR()->GetPatientID(), pMed->m_strDrugName, "<Deleted>", aepMedium, aetDeleted);
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescriptionRemoved, m_nID, pMed->m_strDrugName, "<Deleted>", aepMedium, aetDeleted);
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to delete medication '%s' from a locked EMN.", pMed->m_strDrugName);
							arystrErrors.Add(str);
						}
					}

					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedMedications[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedMedications.RemoveAll();

				for(i = 0; i < m_aryMedications.GetSize(); i++) {

					EMNMedication *pMedication = m_aryMedications.GetAt(i);

					//now insert or update, based on whether it's a new prescription or not

					if(pMedication->nID == -1) {
						//new prescription

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							EMNMedication *pMedication = m_aryMedications[i];

							// (z.manning 2009-07-07 10:44) - PLID 34078 - We should not be able to unspawn
							// a medication that has been e-prescribed (or even attempted to e-prescribe).
							// To accomplish that, we simply set the medication source info to nothing so
							// it thinks it was never spawned in the first place.
							if(pMedication->bEPrescribe) {
								SourceActionInfo saiBlank;
								pMedication->sai = saiBlank;
							}

							CString strSourceActionID = (pMedication->sai.nSourceActionID != -1)
								? AsString(pMedication->sai.nSourceActionID) : "NULL";

							// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
							CString strSourceDetailID = (pMedication->sai.nSourceDetailID != -1)
								? AsString(pMedication->sai.nSourceDetailID) : "NULL";

							// (z.manning 2009-02-26 16:43) - PLID 33141 - SourceDataGroupID
							CString strSourceDataGroupID = (pMedication->sai.GetDataGroupID() != -1)
								? AsString(pMedication->sai.GetDataGroupID()) : "NULL";

							// (z.manning 2010-02-26 16:32) - PLID 37540
							CString strSourceDetailImageStampID = (pMedication->sai.GetDetailStampID() != -1)
								? AsString(pMedication->sai.GetDetailStampID()) : "NULL";

							// (j.jones 2012-09-27 15:11) - PLID 52820 - adding a new prescription contributes to potential
							// drug interactions, so track that this information has changed
							bDrugInteractionsChanged = TRUE;

							//new medication

							//TES 2/10/2009 - PLID 33034 - Changed Description to PatientExplanation, PillsPerBottle to Quantity
							//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
							//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
							//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields					
							// (a.walling 2009-04-22 11:22) - PLID 33948 - Support EPrescribe
							//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
							// (a.walling 2009-07-01 13:35) - PLID 34052 - Added AgentID, SupervisorID
							// (j.jones 2010-01-22 11:31) - PLID 37016 - supported InputByUserID
							// (b.savon 2013-01-16 16:05) - PLID 54656 - Removed AgentID
							// (s.dhole 2013-03-07 12:01) - PLID 55509 Added Strength , StrengthUnitID, DosageFormID ,QuantityUnitID
							// (s.dhole 2013-03-07 12:01) - PLID 55509 Remove unit
							// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
							//"RefillsAllowed, Quantity, Unit, ProviderID, LocationID, PharmacyID, "

							const long& nPatID = GetParentEMR()->GetPatientID();
							const long& nMedID = pMedication->nMedicationID;
							const CString& strPatExplanation = pMedication->strPatientExplanation;
							const CString& strEngDescription = pMedication->strEnglishDescription;
							const COleDateTime& dtPrescriptionDate = pMedication->dtPrescriptionDate;
							const CString& strRefillsAllowed = pMedication->strRefillsAllowed;
							const CString& strQuantity = pMedication->strQuantity;
							// (j.jones 2008-05-20 14:14) - PLID 30079 - EMN medications now track the provider,
							// location, date, and pharmacy, so pull from the medication, not from the EMN		
							const _variant_t vtProviderID = (pMedication->nProviderID == -1) ? g_cvarNull : pMedication->nProviderID;
							const _variant_t vtLocationID = (pMedication->nLocationID == -1) ? g_cvarNull : pMedication->nLocationID;
							const _variant_t vtPharmacyID = (pMedication->nPharmacyID == -1) ? g_cvarNull : pMedication->nPharmacyID;
							const _variant_t vtDaysSupply = (pMedication->nDaysSupply == -1) ? g_cvarNull : pMedication->nDaysSupply;
							const CString& strNoteToPharm = pMedication->strNoteToPharmacist;
							const bool bAllowSubstitutions = !!pMedication->bAllowSubstitutions;
							const CString& strPriorAuth = pMedication->strPriorAuthorization;
							const bool bPriorAuthIsSample = !!pMedication->bPriorAuthIsSample;
							const bool bEPrescribe = !!pMedication->bEPrescribe;
							const _variant_t vtSampleExpirationDate = (pMedication->dtSampleExpirationDate.GetStatus() != COleDateTime::valid) ? g_cvarNull : vtSampleExpirationDate;
							const _variant_t vtSupervisorID = (pMedication->nSupervisorID == -1) ? g_cvarNull : pMedication->nSupervisorID;
							const long& nCurUserID = GetCurrentUserID();
							const CString& strStrength = pMedication->strStrength;
							// (s.dhole 2013-03-15 16:34) - PLID 55509  Set value
							const _variant_t vtStrengthUnitID = (pMedication->nStrengthUnitID == -1) ? g_cvarNull : pMedication->nStrengthUnitID;
							const _variant_t vtDosageFormID = (pMedication->nDosageFormID == -1) ? g_cvarNull : pMedication->nDosageFormID;
							const _variant_t vtQuantityUnitID = (pMedication->nQuantityUnitID == -1) ? g_cvarNull : pMedication->nQuantityUnitID;
							// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
							const _variant_t vtDosageUnitID = (pMedication->nDosageUnitID == -1) ? g_cvarNull : pMedication->nDosageUnitID;
							const _variant_t vtDosageRouteID = (pMedication->nDosageRouteID == -1) ? g_cvarNull : pMedication->nDosageRouteID;
							const CString& strDosageQuantity = pMedication->strDosageQuantity;
							const CString& strDosageFrequency = pMedication->strDosageFrequency;
							
							// (j.armen 2013-05-24 15:22) - PLID 56863 - Patient Medications has an identity.
							//	Note that we just flatten the sql fragment here.  maybe someday this will be a param batch
							// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize - Your dream has come true, albeit in a likely unexpected fashion
							AddStatementToSqlBatch(strSaveString, CSqlFragment(
								"INSERT INTO PatientMedications (\r\n"
								"	PatientID, MedicationID, PatientExplanation, EnglishDescription, PrescriptionDate,\r\n"
								"	RefillsAllowed, Quantity, ProviderID, LocationID, PharmacyID,\r\n"
								"	DaysSupply, NoteToPharmacist, AllowSubstitutions, PriorAuthorization, PriorAuthorizationIsSample,\r\n"
								"	EPrescribe, SampleExpirationDate, SupervisorID, InputByUserID, Strength,\r\n"
								"	StrengthUnitID, DosageFormID, QuantityUnitID, DosageUnitID, DosageRouteID,\r\n"
								"	DosageQuantity, DosageFrequency)\r\n"
								"VALUES (\r\n"
								"	{INT}, {INT}, {STRING}, {STRING}, dbo.AsDateNoTime({OLEDATETIME}),\r\n"
								"	{STRING}, {STRING}, {VT_I4}, {VT_I4}, {VT_I4},\r\n"
								"	{VT_I4}, {STRING}, {BOOL}, {STRING}, {BOOL},\r\n"
								"	{BOOL}, {VT_DATE}, {VT_I4}, {INT}, {STRING},\r\n"
								"	{VT_I4}, {VT_I4}, {VT_I4}, {VT_I4}, {VT_I4},\r\n"
								"	{STRING}, {STRING})",
								nPatID, nMedID, strPatExplanation, strEngDescription, dtPrescriptionDate,
								strRefillsAllowed, strQuantity, vtProviderID, vtLocationID, vtPharmacyID,
								vtDaysSupply, strNoteToPharm, bAllowSubstitutions, strPriorAuth, bPriorAuthIsSample,
								bEPrescribe, vtSampleExpirationDate, vtSupervisorID, nCurUserID, strStrength,
								vtStrengthUnitID, vtDosageFormID, vtQuantityUnitID, vtDosageUnitID, vtDosageRouteID,
								strDosageQuantity, strDosageFrequency));

							AddStatementToSqlBatch(strSaveString, "SELECT @nNewObjectID = SCOPE_IDENTITY()");
							AddNewEMRObjectToSqlBatch(strSaveString, esotPrescription, (long)pMedication, mapSavedObjects);

							// (z.manning 2009-02-26 17:11) - PLID 33141 - Added SourceDataGroupID
							AddStatementToSqlBatch(strSaveString, 
								"INSERT INTO EmrMedicationsT (EmrID, MedicationID, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID) "
								"VALUES (%li, @nNewObjectID, %s, %s, %s, %s) "
								, m_nID, strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID);

							// (j.jones 2008-10-13 11:39) - PLID 17235 - try to save to favorite pharmacies
							if(pMedication->nPharmacyID > -1) {
								AddStatementToSqlBatch(strSaveString, "IF NOT EXISTS "
									"(SELECT PharmacyID FROM FavoritePharmaciesT WHERE PatientID = %li AND PharmacyID = %li) "
									"BEGIN \r\n"
									"	UPDATE FavoritePharmaciesT SET OrderIndex = OrderIndex + 1 WHERE PatientID = %li \r\n"
									"	INSERT INTO FavoritePharmaciesT (PatientID, PharmacyID, OrderIndex) "
									"	VALUES (%li, %li, 1) \r\n"
									"END ", GetParentEMR()->GetPatientID(), pMedication->nPharmacyID,
									GetParentEMR()->GetPatientID(),
									GetParentEMR()->GetPatientID(), pMedication->nPharmacyID);
							}

							// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
							// be sure to update SourceDetailID at the end of the save!
							if(pMedication->sai.pSourceDetail && pMedication->sai.nSourceDetailID == -1) {
								//find this medication's ID, find the source detail's ID, and update this medication's SourceDetailID
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotPrescription, (long)pMedication);
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pMedication->sai.pSourceDetail));
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrMedicationsT SET SourceDetailID = @nEMRSourceDetailID WHERE MedicationID = @nEMRObjectIDToUpdate");
							}

							// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
							if(pMedication->sai.GetDetailStampPointer() != NULL && pMedication->sai.GetDetailStampID() == -1) {
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotPrescription, (long)pMedication);
								AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pMedication->sai.GetDetailStampPointer());
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EmrMedicationsT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE MedicationID = @nEMRObjectIDToUpdate");
							}

							// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
							// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
							AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
							SaveProblemLinkArray(strSaveString, pMedication->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
								, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

							//TES 3/26/2009 - PLID 33262 - Need to save any diagnosis codes associated with the medication as well.
							AddStatementToSqlBatch(strSaveString, GenerateSaveString_PatientMedicationDiagCodesT(pMedication, "@nNewObjectID", bDrugInteractionsChanged));

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							//audit for both patient and EMR
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescriptionCreated, GetParentEMR()->GetPatientID(), "", pMedication->m_strDrugName, aepMedium, aetCreated);
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescriptionAdded, m_nID, "", pMedication->m_strDrugName, aepMedium, aetCreated);
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add medication '%s' to a locked EMN.", pMedication->m_strDrugName);
							arystrErrors.Add(str);
						}
					}
					else if (pMedication->HasChanged_Deprecated()) {
						// (a.walling 2009-04-22 12:57) - PLID 34044 - Only update if we actually changed						

						//TES 3/26/2009 - PLID 33262 - For auditing, we'll need to track whether any of the diagnosis
						// codes associated with this prescription changed.  I also rearranged this code a bit.
						CString strOldMedDiagCodesValue;
						bool bMedDiagCodesChanged = !CompareMedicationDiagCodes(pMedication, strOldMedDiagCodesValue);

						// (j.jones 2013-01-07 16:48) - PLID 52819 - This should no longer be possible, we do this in the API.
						// It would, however, be possible if something other than the prescription editor updated the medication.
						// This really should not happen. Find the source and fix it, or remove the assertion if we conclude this is ok.
						// Currently the only known, and currently acceptable, way to get here is if diag. codes were removed
						// from the EMN, which would also unlink them from the medication, flagging it as changed.
						ASSERT(bMedDiagCodesChanged);

						//update existing prescription
						CString strSql;

						//get old data for auditing
						//or for determining what changed on a locked EMN
						// (c.haag 2007-02-02 18:08) - PLID 24561 - We now store medication names in EmrDataT.Data rather than DrugList.Name
						//DRT 8/28/2007 - PLID 27207 - Parameterized.
						//TES 2/10/2009 - PLID 33034 - Changed Description to PatientExplanation, PillsPerBottle to Quantity
						//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
						//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
						//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
						//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
						// (s.dhole 2013-03-07 12:22) - PLID 55509 Added QuantityUnitID 
						_RecordsetPtr rs = CreateParamRecordset("SELECT EMRDataT.Data AS Name, PatientMedications.PatientExplanation, "
							"PatientMedications.Quantity, PatientMedications.RefillsAllowed, "
							" CASE WHEN  DrugStrengthUnitsT.ID IS NOT NULL THEN  DrugStrengthUnitsT.name ELSE  PatientMedications.Unit END AS Unit , "
							"PatientMedications.DaysSupply, PatientMedications.NoteToPharmacist, PatientMedications.AllowSubstitutions, "
							"PatientMedications.PriorAuthorization, PatientMedications.PriorAuthorizationIsSample, "
							"PatientMedications.SampleExpirationDate "
							"FROM PatientMedications "
							"INNER JOIN DrugList ON PatientMedications.MedicationID = DrugList.ID "
							"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
							"LEFT JOIN DrugStrengthUnitsT ON DrugStrengthUnitsT.ID =PatientMedications.QuantityUnitID "
							"WHERE PatientMedications.ID = {INT}", pMedication->nID);
						if(!rs->eof) {
							CString strName = AdoFldString(rs, "Name","");
							CString strPatientExplanation = AdoFldString(rs, "PatientExplanation","");
							CString strQuantity = AdoFldString(rs, "Quantity","");
							CString strRefills = AdoFldString(rs, "RefillsAllowed","");
							CString strUnit = AdoFldString(rs, "Unit","");
							long nDaysSupply = AdoFldLong(rs, "DaysSupply", -1);
							CString strNoteToPharmacist = AdoFldString(rs, "NoteToPharmacist","");
							BOOL bAllowSubstitutions = AdoFldBool(rs, "AllowSubstitutions", TRUE);
							CString strPriorAuthorization = AdoFldString(rs, "PriorAuthorization", "");
							BOOL bPriorAuthIsSample = AdoFldBool(rs, "PriorAuthorizationIsSample", FALSE);
							COleDateTime dtInvalid;
							dtInvalid.SetStatus(COleDateTime::invalid);
							COleDateTime dtSampleExpirationDate = AdoFldDateTime(rs, "SampleExpirationDate", dtInvalid);

							//auditing (using transactions)
							if(strPatientExplanation != pMedication->strPatientExplanation) {
								
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescDesc, GetParentEMR()->GetPatientID(), strPatientExplanation, pMedication->strPatientExplanation, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescDesc, m_nID, strPatientExplanation, pMedication->strPatientExplanation, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the description of medication '%s' from '%s' to '%s' on a locked EMN.", strName, strPatientExplanation, pMedication->strPatientExplanation);
									arystrErrors.Add(str);
								}
							}
							if(strQuantity != pMedication->strQuantity) {
								
								if(!IsLockedAndSaved()) {								
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescPills, GetParentEMR()->GetPatientID(), strQuantity, pMedication->strQuantity, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescPills, m_nID, strQuantity, pMedication->strQuantity, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the quantity for medication '%s' from '%s' to '%s' on a locked EMN.", strName, strQuantity, pMedication->strQuantity);
									arystrErrors.Add(str);
								}
							}
							if(strRefills != pMedication->strRefillsAllowed) {
								
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescRefills, GetParentEMR()->GetPatientID(), strRefills, pMedication->strRefillsAllowed, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescRefills, m_nID, strRefills, pMedication->strRefillsAllowed, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the count of refills of medication '%s' from '%s' to '%s' on a locked EMN.", strName, strRefills, pMedication->strRefillsAllowed);
									arystrErrors.Add(str);
								}
							}
							if(strUnit != pMedication->strUnit) {
								
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescUnits, GetParentEMR()->GetPatientID(), strUnit, pMedication->strUnit, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescUnits, m_nID, strUnit, pMedication->strUnit, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the units of medication '%s' from '%s' to '%s' on a locked EMN.", strName, strUnit, pMedication->strUnit);
									arystrErrors.Add(str);
								}
							}

							//TES 2/12/2009 - PLID 33034 - Added Strength
							//TES 3/31/2009 - PLID 33750 - Removed Strengtu

							//TES 2/12/2009 - PLID 33034 - Added Dosage Form
							//TES 3/31/2009 - PLID 33750 - Removed Dosage Form
							
							//TES 2/17/2009 - PLID 33140 - Added DaysSupply
							if(nDaysSupply != pMedication->nDaysSupply) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									CString strOld, strNew;
									//TES 5/13/2009 - PLID 34229 - The old and new values were flipped
									if(pMedication->nDaysSupply != -1) {
										strOld = AsString(nDaysSupply);
									}
									if(nDaysSupply != -1) {
										strNew = AsString(pMedication->nDaysSupply);
									}
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescDaysSupply, GetParentEMR()->GetPatientID(), strOld, strNew, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescDaysSupply, m_nID, strOld, strNew, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Days Supply of medication '%s' from %li to %li on a locked EMN.", strName, nDaysSupply, pMedication->nDaysSupply);
									arystrErrors.Add(str);
								}
							}
							//TES 2/17/2009 - PLID 33140 - Added NoteToPharmacist
							if(strNoteToPharmacist != pMedication->strNoteToPharmacist) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescNoteToPharmacist, GetParentEMR()->GetPatientID(), strNoteToPharmacist, pMedication->strNoteToPharmacist, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescNoteToPharmacist, m_nID, strNoteToPharmacist, pMedication->strNoteToPharmacist, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Note To Pharmacist for medication '%s' from '%s' to '%s' on a locked EMN.", strName, strNoteToPharmacist, pMedication->strNoteToPharmacist);
									arystrErrors.Add(str);
								}
							}
							//TES 2/17/2009 - PLID 33140 - Added AllowSubstitutions
							if(bAllowSubstitutions != pMedication->bAllowSubstitutions) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									CString strOld, strNew;
									//TES 5/13/2009 - PLID 34229 - The old and new values were flipped
									strOld = bAllowSubstitutions?"Yes":"No";
									strNew = pMedication->bAllowSubstitutions?"Yes":"No";
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescAllowSubstitutions, GetParentEMR()->GetPatientID(), strOld, strNew, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescAllowSubstitutions, m_nID, strOld, strNew, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Allow Substitutions value of medication '%s' from %s to %s on a locked EMN.", strName, bAllowSubstitutions?"Yes":"No", pMedication->bAllowSubstitutions?"Yes":"No");
									arystrErrors.Add(str);
								}
							}
							//TES 2/17/2009 - PLID 33140 - Added PriorAuthorization
							if(strPriorAuthorization != pMedication->strPriorAuthorization) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescPriorAuthorization, GetParentEMR()->GetPatientID(), strPriorAuthorization, pMedication->strPriorAuthorization, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescPriorAuthorization, m_nID, strPriorAuthorization, pMedication->strPriorAuthorization, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Prior Authorization for medication '%s' from '%s' to '%s' on a locked EMN.", strName, strPriorAuthorization, pMedication->strPriorAuthorization);
									arystrErrors.Add(str);
								}
							}
							//TES 2/17/2009 - PLID 33140 - Added PriorAuthIsSample
							if(bPriorAuthIsSample != pMedication->bPriorAuthIsSample) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									//TES 5/13/2009 - PLID 34229 - The old and new values were flipped
									CString strOld, strNew;
									strOld = bPriorAuthIsSample?"Yes":"No";
									strNew = pMedication->bPriorAuthIsSample?"Yes":"No";
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescPriorAuthorizationIsSample, GetParentEMR()->GetPatientID(), strOld, strNew, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescPriorAuthorizationIsSample, m_nID, strOld, strNew, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Prior Authorization Type value of medication '%s' from %s to %s on a locked EMN.", strName, bPriorAuthIsSample?"Yes":"No", pMedication->bPriorAuthIsSample?"Yes":"No");
									arystrErrors.Add(str);
								}
							}
							//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
							if(dtSampleExpirationDate.GetStatus() != pMedication->dtSampleExpirationDate.GetStatus() ||
								(dtSampleExpirationDate.GetStatus() == COleDateTime::valid && dtSampleExpirationDate != pMedication->dtSampleExpirationDate)) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									//audit for both patient and EMR
									CString strOld, strNew;
									if(dtSampleExpirationDate.GetStatus() == COleDateTime::valid) {
										strOld = FormatDateTimeForInterface(dtSampleExpirationDate);
									}
									if(pMedication->dtSampleExpirationDate.GetStatus() == COleDateTime::valid) {
										strNew = FormatDateTimeForInterface(pMedication->dtSampleExpirationDate);
									}
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescSampleExpDate, GetParentEMR()->GetPatientID(), strOld, strNew, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescSampleExpDate, m_nID, strOld, strNew, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the Sample Expiration Date value of medication '%s' from %s to %s on a locked EMN.", strName, dtSampleExpirationDate.GetStatus() == COleDateTime::valid?FormatDateTimeForInterface(dtSampleExpirationDate):"", pMedication->dtSampleExpirationDate.GetStatus() == COleDateTime::valid?FormatDateTimeForInterface(pMedication->dtSampleExpirationDate):"");
									arystrErrors.Add(str);
								}
							}

							//TES 3/26/2009 - PLID 33262 - Now do any auditing for any diagnosis codes that may have changed.
							if(bMedDiagCodesChanged) {
								if(!IsLockedAndSaved()) {
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();
									CString strCodes;
									for(int i = 0; i < pMedication->aryDiagnoses.GetSize(); i++) {
										strCodes += pMedication->aryDiagnoses[i].strCodeNumber + ",";
									}
									strCodes.TrimRight(",");
									if(strCodes.IsEmpty()) strCodes = "<None>";
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiPatientPrescDiagCodes, GetParentEMR()->GetPatientID(), strOldMedDiagCodesValue, strCodes, aepMedium, aetChanged);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNPrescDiagCodes, m_nID, strOldMedDiagCodesValue, strCodes, aepMedium, aetChanged);
								}
								else {
									//we tried to change this on a locked EMN!
									CString str;
									str.Format("Attempted to update the WhichCodes selections of medication '%s' on a locked EMN.", strName);
									arystrErrors.Add(str);
								}
							}
						}
						rs->Close();

						if(!IsLockedAndSaved()) {

							// (j.jones 2008-05-20 14:14) - PLID 30079 - EMN medications now track the provider,
							// location, date, and pharmacy, so pull from the medication, not from the EMN
							
							CString strProviderID = "NULL";
							if(pMedication->nProviderID != -1) {
								strProviderID.Format("%li", pMedication->nProviderID);
							}

							CString strLocationID = "NULL";
							if(pMedication->nLocationID != -1) {
								strLocationID.Format("%li", pMedication->nLocationID);
							}

							CString strPharmacyID = "NULL";
							if(pMedication->nPharmacyID != -1) {
								strPharmacyID.Format("%li", pMedication->nPharmacyID);
							}

							//TES 2/10/2009 - PLID 33034 - Changed Description to PatientExplanation, PillsPerBottle to Quantity
							//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
							//TES 3/31/2009 - PLID 33750 - Removed Strength and DosageFormID
							//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
							// (a.walling 2009-04-22 11:22) - PLID 33948 - Support EPrescribe
							//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
							// (a.walling 2009-07-01 13:35) - PLID 34052 - Added AgentID, SupervisorID
							// (b.savon 2013-01-16 16:08) - PLID 54656 - Removed AgentID
							AddStatementToSqlBatch(strSaveString, "UPDATE PatientMedications SET "
								"PatientExplanation = '%s', EnglishDescription = '%s', "
								"RefillsAllowed = '%s', Quantity = '%s', Unit = '%s', "
								"PrescriptionDate = '%s', ProviderID = %s, LocationID = %s, PharmacyID = %s, "
								"DaysSupply = %s, NoteToPharmacist = '%s', "
								"AllowSubstitutions = %i, PriorAuthorization = '%s', PriorAuthorizationIsSample = %i, EPrescribe = %i, "
								"SampleExpirationDate = %s, SupervisorID = %s "
								"WHERE ID = %li",
								_Q(pMedication->strPatientExplanation), _Q(pMedication->strEnglishDescription), 
								_Q(pMedication->strRefillsAllowed), _Q(pMedication->strQuantity), _Q(pMedication->strUnit), 
								_Q(FormatDateTimeForSql(pMedication->dtPrescriptionDate, dtoDate)),
								strProviderID, strLocationID, strPharmacyID,
								pMedication->nDaysSupply == -1 ? "NULL" : AsString(pMedication->nDaysSupply),
								_Q(pMedication->strNoteToPharmacist), pMedication->bAllowSubstitutions ? 1 : 0,
								_Q(pMedication->strPriorAuthorization), pMedication->bPriorAuthIsSample ? 1 : 0,
								pMedication->bEPrescribe ? 1 : 0,
								pMedication->dtSampleExpirationDate.GetStatus() == COleDateTime::valid ? "'" + FormatDateTimeForSql(pMedication->dtSampleExpirationDate) + "'":"NULL",
								pMedication->nSupervisorID == -1 ? "NULL" : AsString(pMedication->nSupervisorID),
								pMedication->nID);

							if(bMedDiagCodesChanged) {
								//TES 3/26/2009 - PLID 33262 - Our associated diagnosis codes changed, so we need to save them.
								// It will be easiest to just delete them out and re-add all of them.
								AddStatementToSqlBatch(strSaveString, "DELETE FROM PatientMedicationDiagCodesT WHERE PatientMedicationID = %li;", pMedication->nID);
								CString strID;	strID.Format("%li", pMedication->nID);
								AddStatementToSqlBatch(strSaveString, GenerateSaveString_PatientMedicationDiagCodesT(pMedication, strID, bDrugInteractionsChanged));

								// (j.jones 2012-09-28 10:16) - PLID 52820 - Medication diagnoses contribute to potential
								// drug interactions, so track that this information has changed. This line is needed
								// incase we removed diagnoses and didn't add new ones.
								bDrugInteractionsChanged = TRUE;
							}
						}
					} 
					
					// (j.jones 2013-01-07 16:29) - PLID 52819 - unified the code for updating problems on existing medications
					if (pMedication->nID != -1 && (pMedication->HasUnsavedProblemLinks() || pMedication->HasChangedProblems())) {	
						// (a.walling 2009-04-22 14:09) - PLID 34044 - Save the problems if they have changed
						if(!IsLockedAndSaved()) {
							// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
							// (z.manning 2009-05-22 10:23) - PLID 34297 - Save problem links
							SaveProblemLinkArray(strSaveString, pMedication->m_apEmrProblemLinks, AsString(pMedication->nID), mapSavedObjects
								, nAuditTransactionID, GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()));
						} // no locked EMN warning as per above
					}
				}
			}
		}
		//TES 12/26/2006 - PLID 23400 - Providers
		if(m_bIsTemplate) {
			//Providers aren't saved on templates.
		}
		else {
			if(m_nID == -1) {
				//New EMN
				//add to EmrProvidersT
				// (c.haag 2007-06-11 17:28) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/
				for(int i = 0; i < m_aryProviders.GetSize(); i++) {
					long nID = m_aryProviders[i]->nID;
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrProvidersT (EMRID, ProviderID) "
						"VALUES (@nEMNID, %li)", m_aryProviders.GetAt(i)->nID);

					//don't audit here because we're creating the EMN
				}

				// (j.gruber 2007-01-08 10:47) - PLID 23399 - EMRSecondaryProviders
				// (c.haag 2007-06-11 17:28) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/
				for(int j = 0; j < m_arySecondaryProviders.GetSize(); j++) {
					long nID = m_arySecondaryProviders[j]->nID;
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrSecondaryProvidersT (EMRID, ProviderID) "
						"VALUES (@nEMNID, %li)", m_arySecondaryProviders.GetAt(j)->nID);

					//don't audit here because we're creating the EMN
				}

				// (d.lange 2011-03-23 10:45) - PLID 42136 - Assistant/Technician
				for(int j = 0; j < m_aryTechnicians.GetSize(); j++) {
					long nID = m_aryTechnicians[j]->nID;
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrTechniciansT (EMRID, PersonID) "
						"VALUES (@nEMNID, %li)", m_aryTechnicians.GetAt(j)->nID);
				}

				// (j.gruber 2009-05-07 16:50) - PLID 33688 - Other Providers
				for(int j = 0; j < m_aryOtherProviders.GetSize(); j++) {
					long nID = m_aryOtherProviders[j]->nID;
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrOtherProvidersT (EMRID, ProviderID, ProvTypeID) "
						"VALUES (@nEMNID, %li, %s)", m_aryOtherProviders.GetAt(j)->nID,
						m_aryOtherProviders.GetAt(j)->nTypeID == -1 ? "NULL" : AsString(m_aryOtherProviders.GetAt(j)->nTypeID)
						);

					//don't audit here because we're creating the EMN
				}
				
			}
			else {
				//update EmrProvidersT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the providers we've removed
				for(i = 0; i < m_aryDeletedProviders.GetSize(); i++) {
					//TES 2/8/2012 - PLID 19441 - We now store the struct, so we have the ID and the Name in memory
					EMNProvider *pProv = m_aryDeletedProviders.GetAt(i);

					// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
					if(!IsLockedAndSaved()) {
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrProvidersT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EMRID = %li AND ProviderID = %li", _Q(GetCurrentUserName()), m_nID, pProv->nID);
					}

					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNProviderRemoved, m_nID, pProv->strName, "<Deleted>", aepMedium, aetDeleted);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete provider '%s' from a locked EMN.", pProv->strName);
						arystrErrors.Add(str);
					}
					//TES 2/8/2012 - PLID 19441 - Cleanup
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete pProv;
				}
				//m_aryDeletedProviders.RemoveAll();

				for(i = 0; i < m_aryProviders.GetSize(); i++) {

					//only insert new providers
					EMNProvider* pProv = m_aryProviders.GetAt(i);

					if(pProv->bIsNew) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							long nID = pProv->nID;
							AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrProvidersT (EMRID, ProviderID) "
								"VALUES (%li, %li)", m_nID, pProv->nID);

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNProviderAdded, m_nID, "", pProv->strName, aepMedium, aetCreated);
							
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add provider '%s' to a locked EMN.", pProv->strName);
							arystrErrors.Add(str);
						}
					}
				}

				
				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int j = 0;

				// (j.gruber 2007-01-08 10:50) - PLID 23399 - Secondary Providers
				//delete the providers we've removed
				for(j = 0; j < m_aryDeletedSecondaryProviders.GetSize(); j++) {
					//TES 2/8/2012 - PLID 19441 - We now store the struct, so we have the ID and the Name in memory
					EMNProvider *pProv = m_aryDeletedSecondaryProviders.GetAt(j);

					if(!IsLockedAndSaved()) {
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrSecondaryProvidersT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EMRID = %li AND ProviderID = %li", _Q(GetCurrentUserName()), m_nID, pProv->nID);
					}

					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNSecondaryProviderRemoved, m_nID, pProv->strName, "<Deleted>", aepMedium, aetDeleted);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete secondary provider '%s' from a locked EMN.", pProv->strName);
						arystrErrors.Add(str);
					}

					//TES 2/8/2012 - PLID 19441 - Cleanup
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete pProv;
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedSecondaryProviders.RemoveAll();

				for(j = 0; j < m_arySecondaryProviders.GetSize(); j++) {

					//only insert new providers
					EMNProvider* pProv = m_arySecondaryProviders.GetAt(j);

					if(pProv->bIsNew) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							long nID = pProv->nID;
							
							AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrSecondaryProvidersT (EMRID, ProviderID) "
								"VALUES (%li, %li)", m_nID, pProv->nID);
							

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNSecondaryProviderAdded, m_nID, "", pProv->strName, aepMedium, aetCreated);
							
							
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add secondary provider '%s' to a locked EMN.", pProv->strName);
							arystrErrors.Add(str);
						}
					}
				}

				// (d.lange 2011-03-23 10:49) - PLID 42136 - Update Assistant/Technician
				for(j = 0; j < m_aryDeletedTechnicians.GetSize(); j++) {
					//TES 2/8/2012 - PLID 19441 - We now store the struct, so we have the ID and the Name in memory
					EMNProvider *pProv = m_aryDeletedTechnicians.GetAt(j);

					if(!IsLockedAndSaved()) {
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrTechniciansT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EMRID = %li AND PersonID = %li", _Q(GetCurrentUserName()), m_nID, pProv->nID);
					}

					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNTechnicianRemoved, m_nID, pProv->strName, "<Deleted>", aepMedium, aetDeleted);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete assistant/technician '%s' from a locked EMN.", pProv->strName);
						arystrErrors.Add(str);
					}
					//TES 2/8/2012 - PLID 19441 - Cleanup
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete pProv;
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedTechnicians.RemoveAll();

				for(j = 0; j < m_aryTechnicians.GetSize(); j++) {
					//only insert new technicians
					EMNProvider* pTech = m_aryTechnicians.GetAt(j);

					if(pTech->bIsNew) {

						if(!IsLockedAndSaved()) {

							long nID = pTech->nID;
							
							AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrTechniciansT (EMRID, PersonID) "
								"VALUES (%li, %li)", m_nID, pTech->nID);
							

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNTechnicianAdded, m_nID, "", pTech->strName, aepMedium, aetCreated);
							
							
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add assistant/technician '%s' to a locked EMN.", pTech->strName);
							arystrErrors.Add(str);
						}
					}
				}

				// (j.gruber 2009-05-07 16:53) - PLID 33688 - Other Providers
				//delete the providers we've removed
				for(j = 0; j < m_aryDeletedOtherProviders.GetSize(); j++) {

					if(!IsLockedAndSaved()) {
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrOtherProvidersT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' "
							" WHERE EMRID = %li AND ProviderID = %li AND ProvTypeID = %li AND Deleted = 0", 
							_Q(GetCurrentUserName()), m_nID, m_aryDeletedOtherProviders.GetAt(j)->nID, m_aryDeletedOtherProviders.GetAt(j)->nTypeID);
					}

					//get the provider name
					CString strName;
					//DRT 8/28/2007 - PLID 27207 - Parameterized.
					EMNProvider *pProv = m_aryDeletedOtherProviders.GetAt(j);
					/*_RecordsetPtr rs = CreateParamRecordset("SELECT Last + ', ' + First + ' ' + Middle AS Name FROM PersonT WHERE ID = {INT}", m_aryDeletedOtherProviders.GetAt(j)->nID);
					if(!rs->eof) {
						strName = AdoFldString(rs, "Name","");
					}
					rs->Close();*/

					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						CString strOldAudit = pProv->strName + " - " + pProv->strTypeName;
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNOtherProviderRemoved, m_nID, strOldAudit, "<Deleted>", aepMedium, aetDeleted);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete other provider '%s' from a locked EMN.", strName);
						arystrErrors.Add(str);
					}
				}
				//delete
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				/*
				for (int h = m_aryDeletedOtherProviders.GetSize() - 1; h >= 0; h--) {
					EMNProvider *pProv = m_aryDeletedOtherProviders.GetAt(h);
					delete pProv;
					m_aryDeletedOtherProviders.RemoveAt(h);
				}
				*/

				for(j = 0; j < m_aryOtherProviders.GetSize(); j++) {

					//only insert new providers
					EMNProvider* pProv = m_aryOtherProviders.GetAt(j);

					if(pProv->bIsNew) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							long nID = pProv->nID;
							
							AddStatementToSqlBatch(strSaveString, "INSERT INTO EmrOtherProvidersT (EMRID, ProviderID, ProvTypeID) "
								"VALUES (%li, %li, %s)", m_nID, pProv->nID,
								pProv->nTypeID == -1 ? "NULL" : AsString(pProv->nTypeID));
							

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNOtherProviderAdded, m_nID, "", pProv->strName + " - " + pProv->strTypeName, aepMedium, aetCreated);
							
							
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add other provider '%s' to a locked EMN.", pProv->strName);
							arystrErrors.Add(str);
						}
					}
				}
			}
		}

		if (m_bIsTemplate) {
			// (z.manning, 04/12/2007) - PLID 25600 - Save the Category ID for the template.
			CString strEmnTemplateID;
			if(m_nID == -1) {
				if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}
				strEmnTemplateID = "@nEMRTemplateID";
			}
			else {
				strEmnTemplateID = AsString(m_nID);
			}

			CString strCategoryID;
			if(m_Category.nID == -1) {
				strCategoryID = "NULL";
			}
			else {
				strCategoryID = AsString(m_Category.nID);
			}

			AddStatementToSqlBatch(strSaveString, "UPDATE EmrTemplateT SET EmnTabCategoryID = %s WHERE ID = %s", strCategoryID, strEmnTemplateID);
		}
		// EMN Category ID
		else {
			// (a.wetta 2007-01-09 13:38) - PLID 14635 - Update the EMN category if there is a new one
			// (z.manning, 04/11/2007) - PLID 25569 - Update it no matter what now that it's an option in more info.
			
			CString strEmnID;
			if (m_nID == -1) {
				// (c.haag 2007-06-11 17:28) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/

				strEmnID = "@nEMNID";
			}
			else {
				strEmnID = AsString(m_nID);
			}

			if(m_Category.nID != -1) {
				// (z.manning, 04/23/2007) - PLID 25569 - Ok, we have a valid category ID, did we have one before?
				if(m_LastSavedCategory.nID == -1) {
					// No, need to insert.
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMNTabCategoriesLinkT (EMNID, EMNTabCategoryID) VALUES (%s, %li)",
						strEmnID, m_Category.nID);
				}
				else {
					// Yes, just update the existing record.
					AddStatementToSqlBatch(strSaveString, "UPDATE EMNTabCategoriesLinkT SET EMNTabCategoryID = %li WHERE EMNID = %s",
						m_Category.nID, strEmnID);
				}
			}
			else {
				// (z.manning, 04/23/2007) - PLID 25569 - No category is selected. If we had one before, make sure
				// we clear it out.
				if(m_LastSavedCategory.nID != -1) {
					AddStatementToSqlBatch(strSaveString, "DELETE FROM EMNTabCategoriesLinkT WHERE EMNID = %s", strEmnID);
				}
			}

		}


		if (m_bIsTemplate) {
			// (z.manning, 04/12/2007) - PLID 25600 - Save the chart ID for the template.
			CString strEmnTemplateID;
			if(m_nID == -1) {
				if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}
				strEmnTemplateID = "@nEMRTemplateID";
			}
			else {
				strEmnTemplateID = AsString(m_nID);
			}

			CString strChartID;
			if(m_Chart.nID == -1) {
				strChartID = "NULL";
			}
			else {
				strChartID = AsString(m_Chart.nID);
			}

			AddStatementToSqlBatch(strSaveString, "UPDATE EmrTemplateT SET EmnTabChartID = %s WHERE ID = %s", strChartID, strEmnTemplateID);
		}
		// (z.manning, 04/11/2007) - PLID 25569 - EMN Chart ID
		else {
			CString strEmnID;
			if (m_nID == -1) {
				// (c.haag 2007-06-11 17:28) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/

				strEmnID = "@nEMNID";
			}
			else {
				strEmnID = AsString(m_nID);
			}

			if(m_Chart.nID != -1) {
				// (z.manning, 04/23/2007) - PLID 25569 - Ok, we have a valid chart ID, did we have one before?
				if(m_LastSavedChart.nID == -1) {
					// No, need to insert.
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMNTabChartsLinkT (EMNID, EMNTabChartID) VALUES (%s, %li)",
						strEmnID, m_Chart.nID);
				}
				else {
					// Yes, just update the existing record.
					AddStatementToSqlBatch(strSaveString, "UPDATE EMNTabChartsLinkT SET EMNTabChartID = %li WHERE EMNID = %s",
						m_Chart.nID, strEmnID);
				}
			}
			else {
				// (z.manning, 04/23/2007) - PLID 25569 - No chart is selected. If we had one before, make sure
				// we clear it out.
				if(m_LastSavedChart.nID != -1) {
					AddStatementToSqlBatch(strSaveString, "DELETE FROM EMNTabChartsLinkT WHERE EMNID = %s", strEmnID);
				}
			}
		}
	}

	//TES 2/21/2014 - PLID 60972 - Diagnosis Codes and Charges are now on the Codes topic
	if(!bSaveRecordOnly && (m_nID == -1 || m_bCodesUnsaved)) {
		//Diag Codes
		if(m_bIsTemplate) {
			//save diag codes to a new EMN

			if(m_nID == -1) {
				//update EMRTemplateDiagCodesT
				
				if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}

				for(int i = 0; i < m_aryDiagCodes.GetSize(); i++) {	
					// (b.savon 2014-02-27 10:18) - PLID 61057 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT
					CString strDiagCodeID = "NULL";
					if( m_aryDiagCodes.GetAt(i)->nDiagCodeID != -1 ){
						strDiagCodeID.Format("%li", m_aryDiagCodes.GetAt(i)->nDiagCodeID);
					}

					CString strDiagCodeID_ICD10 = "NULL";
					if( m_aryDiagCodes.GetAt(i)->nDiagCodeID_ICD10 != -1 ){
						strDiagCodeID_ICD10.Format("%li", m_aryDiagCodes.GetAt(i)->nDiagCodeID_ICD10);
					}
					// (s.dhole 2014-03-06 12:44) - PLID 60825 Save NexGEMMatchType 
					AddStatementToSqlBatch(
						strSaveString, 
						"INSERT INTO EMRTemplateDiagCodesT "
						"	(EMRTemplateID, DiagCodeID, OrderIndex, DiagCodeID_ICD10,NexGEMMatchType) "
						"VALUES "
						"	(@nEMRTemplateID, %s, %li, %s, %li)\r\n",
						strDiagCodeID, 
						m_aryDiagCodes.GetAt(i)->nOrderIndex,
						strDiagCodeID_ICD10,
						m_aryDiagCodes.GetAt(i)->MatchType 
					);
						//"SET @nNewObjectID = SCOPE_IDENTITY()"

					// (j.jones 2008-07-23 11:12) - PLID 30819 - required so we can get the diagnosis ID
					// (a.walling 2008-09-08 17:09) - PLID 31268 - There are no IDs for the template diagcodes, therefore this
					// was causing failures when updating IDs (SCOPE_IDENTITY() would return NULL)
					//AddNewEMRObjectToSqlBatch(strSaveString, esotDiagCode, (long)m_aryDiagCodes.GetAt(i), mapSavedObjects);

					//don't audit here because it is a new template
				}
			}
			else {
				//update EMRTemplateDiagCodesT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the codes we've removed
				// (c.haag 2008-07-23 13:42) - PLID 30820 - We now store deleted diag codes in their fullest form, not as ID's
				for(i = 0; i < m_aryDeletedDiagCodes.GetSize(); i++) {

					// (b.savon 2014-02-27 10:49) - PLID 61057 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT
					CString strDiagCodeID = "NULL";
					if( m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID != -1 ){
						strDiagCodeID.Format("%li", m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID);
					}

					CString strDiagCodeID_ICD10 = "NULL";
					if( m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID_ICD10 != -1 ){
						strDiagCodeID_ICD10.Format("%li", m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID_ICD10);
					}

					AddStatementToSqlBatch(
						strSaveString, 
						"DELETE FROM EMRTemplateDiagCodesT "
						"WHERE EMRTemplateID = %li AND %s", 
						m_nID, 
						GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
					);

					//get the code number
					//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
					CString strName = m_aryDeletedDiagCodes.GetAt(i)->strCode;
					// (b.savon 2014-02-27 15:31) - PLID 61066 - Get save the 10 code from mem
					CString strName_ICD10 = m_aryDeletedDiagCodes.GetAt(i)->strCode_ICD10;
					
					//auditing (using transactions)
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();

					// (b.savon 2014-02-27 15:31) - PLID 61066 - Replace strName with GenerateEMRDiagCodesTAuditValue(...)
					AuditEvent(
						-1, 
						"", 
						nAuditTransactionID, 
						aeiEMNTemplateDiagCodeRemoved, 
						m_nID, 
						GenerateEMRDiagCodesTAuditValue(strName, strName_ICD10), 
						"<Deleted>", 
						aepMedium, 
						aetDeleted
					);

					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedDiagCodes[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedDiagCodes.RemoveAll();

				for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {

					//only insert new codes
					//DRT 3/3/2006 - PLID 19565 - Removed a database access by moving the code info to the EMNDiagCode structure.
					EMNDiagCode* pDiag = m_aryDiagCodes.GetAt(i);
					
					// (b.savon 2014-02-27 10:18) - PLID 61057 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT
					CString strDiagCodeID = "NULL";
					if( pDiag->nDiagCodeID != -1 ){
						strDiagCodeID.Format("%li", pDiag->nDiagCodeID);
					}

					CString strDiagCodeID_ICD10 = "NULL";
					if( pDiag->nDiagCodeID_ICD10 != -1 ){
						strDiagCodeID_ICD10.Format("%li", pDiag->nDiagCodeID_ICD10);
					}

					if(pDiag->bIsNew) {

						// (b.savon 2014-02-27 10:18) - PLID 61057 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT
						// (s.dhole 2014-03-06 12:44) - PLID 60825 Save NexGEMMatchType 
						AddStatementToSqlBatch(
							strSaveString, 
							"INSERT INTO EMRTemplateDiagCodesT "
							"	(EMRTemplateID, DiagCodeID, OrderIndex, DiagCodeID_ICD10,NexGEMMatchType) "
							"VALUES "
							"	(%li, %s, %li, %s, %li)", 
							m_nID, 
							strDiagCodeID, 
							pDiag->nOrderIndex,
							strDiagCodeID_ICD10,
							 pDiag->MatchType 
						);

						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();

						// (b.savon 2014-02-27 15:31) - PLID 61066 - Replace pDiag->strCode with GenerateEMRDiagCodesTAuditValue(...)
						AuditEvent(
							-1, 
							"", 
							nAuditTransactionID, 
							aeiEMNTemplateDiagCodeAdded, 
							m_nID, 
							"", 
							GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10), 
							aepMedium, 
							aetCreated
						);
					}
					else {

						if(pDiag->bChanged) {

							// (j.jones 2007-01-05 09:54) - PLID 24070 - update the order index
							// (b.savon 2014-02-27 10:47) - PLID 61057 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT
							AddStatementToSqlBatch(
								strSaveString, 
								"UPDATE EMRTemplateDiagCodesT SET OrderIndex = %li "
								"WHERE EMRTemplateID = %li AND %s",
								pDiag->nOrderIndex, 
								m_nID,
								GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
							);

							// (j.jones 2007-01-05 14:29) - PLID 24070 - use pDiag->bHasMoved to audit
							//only the rows that the use moved, as opposed to all changed indices

							if(pDiag->bHasMoved) {

								//find the old diag code placement
								//DRT 8/28/2007 - PLID 27207 - Parameterized.
								// (b.savon 2014-03-03 14:57) - PLID 61066 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT - Auditing
								_RecordsetPtr rsAudit = CreateParamRecordset(
									"SELECT OrderIndex, CodeNumber FROM EMRTemplateDiagCodesT "
									"INNER JOIN DiagCodes ON EMRTemplateDiagCodesT.DiagCodeID = DiagCodes.ID "
									"WHERE EMRTemplateID = {INT} AND {CONST_STRING}",
									m_nID,
									GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
								);
								if(!rsAudit->eof) {

									long nOldIndex = AdoFldLong(rsAudit, "OrderIndex",-1);
									if(nOldIndex != pDiag->nOrderIndex) {
										// (b.savon 2014-02-27 15:34) - PLID 61066 - As far as I can tell, this is pointless
										//CString strCode = AdoFldString(rsAudit, "CodeNumber","");

										CString strOld, strNew;
										// (b.savon 2014-02-27 15:34) - PLID 61066 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT - Auditing
										strOld.Format(
											"'%s' was Index %li", 
											GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10), 
											nOldIndex
										);
										// (b.savon 2014-02-27 15:34) - PLID 61066 - UPDATE - Write icd10 selections to data upon save of EMRTemplateDiagCodesT - Auditing
										strNew.Format(
											"'%s' is now Index %li", 
											GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10), 
											pDiag->nOrderIndex
										);

										//auditing (using transactions)
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateDiagCodeOrderChanged, m_nID, strOld, strNew, aepMedium, aetChanged);
									}
								}
								rsAudit->Close();
							}
						}
					}
				}
			}
		}
		else {
			//update diag codes to an existing EMN
			if(m_nID == -1) {
				//update EMRDiagCodesT
				// (c.haag 2007-06-11 17:28) - PLID 26280 - This is no longer necessary. We assign nEMNID when the record is created in NewObjectsT.
				/*if(!bReferenceIDDefined) {
					CString str;
					str.Format("SET @nEMNID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
					AddStatementToSqlBatch(strSaveString, str);
					bReferenceIDDefined = TRUE;
				}*/

				for(int i = 0; i < m_aryDiagCodes.GetSize(); i++) {

					EMNDiagCode *pDiag = m_aryDiagCodes[i];

					// (b.savon 2014-02-27 07:14) - PLID 60808 - Now that both the DiagCodeID columns
					// can be NULL, we need to make sure we're not saving -1 (the initialized variable
					// in Practice) to data, but rather, NULL
					CString strDiagCodeID = "NULL";
					if( pDiag->nDiagCodeID != -1 ){
						strDiagCodeID.Format("%li", pDiag->nDiagCodeID);
					}
	
					// (b.savon 2014-02-27 07:07) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN
					CString strDiagCodeID_ICD10 = "NULL";
					if( pDiag->nDiagCodeID_ICD10 != -1 ){
						strDiagCodeID_ICD10.Format("%li", pDiag->nDiagCodeID_ICD10);
					}

					CString strSourceActionID = "NULL";
					if(pDiag->sai.nSourceActionID != -1) {
						strSourceActionID.Format("%li", pDiag->sai.nSourceActionID);
					}
					// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
					CString strSourceDetailID = "NULL";
					if(pDiag->sai.nSourceDetailID != -1)
						strSourceDetailID.Format("%li", pDiag->sai.nSourceDetailID);
					// (z.manning 2009-02-26 12:10) - PLID 33141 - SourceDataGroupID
					CString strSourceDataGroupID = "NULL";
					if(pDiag->sai.GetDataGroupID() != -1) {
						strSourceDataGroupID = AsString(pDiag->sai.GetDataGroupID());
					}
					// (z.manning 2010-02-26 16:27) - PLID 37540
					CString strSourceDetailImageStampID = "NULL";
					if(pDiag->sai.GetDetailStampID() != -1) {
						strSourceDetailImageStampID = AsString(pDiag->sai.GetDetailStampID());
					}
										
					// (j.jones 2012-09-27 15:20) - PLID 52869 - adding a diagnosis contributes to potential
					// drug interactions, so track that this information has changed
					bDrugInteractionsChanged = TRUE;

					// (b.savon 2014-02-27 07:07) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN; change DiagCodeID to allow NULL too
					// (s.dhole 2014-03-06 12:44) - PLID 60825 Save EmrDiagCodesT.NexGEMMatchType 
					AddStatementToSqlBatch(
						strSaveString, 
						"INSERT INTO EMRDiagCodesT "
						"	(EMRID, DiagCodeID, SourceActionID, SourceDetailID, OrderIndex, SourceDataGroupID, SourceDetailImageStampID, DiagCodeID_ICD10,NexGEMMatchType) \r\n"
						"VALUES "
						"	(@nEMNID, %s, %s, %s, %li, %s, %s, %s,%li)\r\n"
						"SET @nNewObjectID = SCOPE_IDENTITY()", 
						strDiagCodeID, 
						strSourceActionID, 
						strSourceDetailID, 
						m_aryDiagCodes.GetAt(i)->nOrderIndex, 
						strSourceDataGroupID, 
						strSourceDetailImageStampID,
						strDiagCodeID_ICD10,
						pDiag->MatchType
					);

					// (j.jones 2008-07-23 11:12) - PLID 30819 - required so we can get the diagnosis ID
					AddNewEMRObjectToSqlBatch(strSaveString, esotDiagCode, (long)pDiag, mapSavedObjects);

					// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
					// be sure to update SourceDetailID at the end of the save!
					if(pDiag->sai.pSourceDetail && pDiag->sai.nSourceDetailID == -1) {
						//find this EMN's ID, find the source detail's ID, and update this diag.code's SourceDetailID
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pDiag->sai.pSourceDetail));
						// (b.savon 2014-02-27 07:31) - PLID 60808 - Make sure we're updating properly too
						AddStatementToSqlBatch(
							strPostSaveSql, 
							"UPDATE EMRDiagCodesT SET SourceDetailID = @nEMRSourceDetailID "
							"WHERE EMRID = @nEMRObjectIDToUpdate AND %s",
							GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
						);
					}

					// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
					if(pDiag->sai.GetDetailStampPointer() != NULL && pDiag->sai.GetDetailStampID() == -1) {
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotEMN, (long)this);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pDiag->sai.GetDetailStampPointer());
						// (b.savon 2014-02-27 07:31) - PLID 60808 - Make sure we're updating properly too
						AddStatementToSqlBatch(
							strPostSaveSql, 
							"UPDATE EMRDiagCodesT SET SourceDetailImageStampID = @nSourceDetailImageStampID "
							"WHERE EMRID = @nEMRObjectIDToUpdate AND %s", 
							GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
						);
					}

					// (j.jones 2008-07-22 15:06) - PLID 30792 - save all our problems
					// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
					AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
					SaveProblemLinkArray(strSaveString, pDiag->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
						, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));
				}
			}
			else {
				//update EMRDiagCodesT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the codes we've removed
				// (c.haag 2008-07-23 13:42) - PLID 30820 - We now store deleted diag codes in their fullest form, not as ID's
				for(i = 0; i < m_aryDeletedDiagCodes.GetSize(); i++) {

					// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
					if(!IsLockedAndSaved()) {
						//AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRDiagCodesT WHERE EMRID = %li AND DiagCodeID = %li", m_nID, m_aryDeletedDiagCodes.GetAt(i));
						
						// (b.savon 2014-02-27 07:14) - PLID 60808 - Now that both the DiagCodeID columns
						// can be NULL, we need to make sure we're not saving -1 (the initialized variable
						// in Practice) to data, but rather, NULL
						CString strDiagCodeID = "NULL";
						if( m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID != -1 ){
							strDiagCodeID.Format("%li", m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID);
						}
		
						// (b.savon 2014-02-27 07:07) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN
						CString strDiagCodeID_ICD10 = "NULL";
						if( m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID_ICD10 != -1 ){
							strDiagCodeID_ICD10.Format("%li", m_aryDeletedDiagCodes.GetAt(i)->nDiagCodeID_ICD10);
						}

						// (b.savon 2014-02-27 07:31) - PLID 60808 - Make sure we're updating properly too
						AddStatementToSqlBatch(
							strSaveString, 
							"UPDATE EmrDiagCodesT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' "
							"WHERE EMRID = %li AND %s", 
							_Q(GetCurrentUserName()), 
							m_nID, 
							GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
						);

						// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the diagnosis code
						// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
						// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
						AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRProblemLinkT WHERE EMRRegardingType = %li AND EMRRegardingID = %li", eprtEmrDiag, m_aryDeletedDiagCodes.GetAt(i)->nID);
					}

					// (j.jones 2012-09-27 15:20) - PLID 52869 - removing a diagnosis contributes to potential
					// drug interactions, so track that this information has changed
					bDrugInteractionsChanged = TRUE;

					//get the code number
					//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
					CString strName = m_aryDeletedDiagCodes.GetAt(i)->strCode;
					// (b.savon 2014-02-27 14:39) - PLID 61065 - UPDATE - Write icd10 selections to data upon save of EMN - Auditing
					CString strName_ICD10 = m_aryDeletedDiagCodes.GetAt(i)->strCode_ICD10;
					
					if(!IsLockedAndSaved()) {
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();

						// (b.savon 2014-02-27 14:40) - PLID 61065 - Replaced strCode with GenerateEMRDiagCodesTAuditValue(...)
						AuditEvent(
							GetParentEMR()->GetPatientID(), 
							GetExistingPatientName(GetParentEMR()->GetPatientID()), 
							nAuditTransactionID, 
							aeiEMNDiagCodeRemoved, 
							m_nID, 
							GenerateEMRDiagCodesTAuditValue(strName, strName_ICD10), 
							"<Deleted>", 
							aepMedium, 
							aetDeleted
						);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to delete diagnosis code '%s' from a locked EMN.", strName);
						arystrErrors.Add(str);
					}
					
					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedDiagCodes[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedDiagCodes.RemoveAll();

				for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {

					//only insert new codes
					//DRT 3/3/2006 - PLID 19565 - Removed a database access by moving the code info to the EMNDiagCode structure.
					EMNDiagCode* pDiag = m_aryDiagCodes.GetAt(i);

					if(pDiag->bIsNew) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {

							// (b.savon 2014-02-27 07:14) - PLID 60808 - Now that both the DiagCodeID columns
							// can be NULL, we need to make sure we're not saving -1 (the initialized variable
							// in Practice) to data, but rather, NULL
							CString strDiagCodeID = "NULL";
							if( pDiag->nDiagCodeID != -1 ){
								strDiagCodeID.Format("%li", pDiag->nDiagCodeID);
							}
			
							// (b.savon 2014-02-27 07:07) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN
							CString strDiagCodeID_ICD10 = "NULL";
							if( pDiag->nDiagCodeID_ICD10 != -1 ){
								strDiagCodeID_ICD10.Format("%li", pDiag->nDiagCodeID_ICD10);
							}

							CString strSourceActionID = "NULL";
							if(pDiag->sai.nSourceActionID != -1) {
								strSourceActionID.Format("%li", pDiag->sai.nSourceActionID);
							}
							// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
							CString strSourceDetailID = "NULL";
							if(pDiag->sai.nSourceDetailID != -1)
								strSourceDetailID.Format("%li", pDiag->sai.nSourceDetailID);
							// (z.manning 2009-02-26 12:12) - PLID 33141 - SourceDataGroupID
							CString strSourceDataGroupID = "NULL";
							if(pDiag->sai.GetDataGroupID() != -1) {
								strSourceDataGroupID = AsString(pDiag->sai.GetDataGroupID());
							}
							// (z.manning 2010-02-26 16:28) - PLID 37540
							CString strSourceDetailImageStampID = "NULL";
							if(pDiag->sai.GetDetailStampID() != -1) {
								strSourceDetailImageStampID = AsString(pDiag->sai.GetDetailStampID());
							}
														
							// (j.jones 2012-09-27 15:20) - PLID 52869 - adding a diagnosis contributes to potential
							// drug interactions, so track that this information has changed
							bDrugInteractionsChanged = TRUE;
							// (s.dhole 2014-03-06 12:44) - PLID 60825 Save EmrDiagCodesT.NexGEMMatchType 
							// (b.savon 2014-02-27 07:07) - PLID 60808 - UPDATE - Write icd10 selections to data upon save of EMN; change DiagCodeID to allow NULL too
							AddStatementToSqlBatch(
								strSaveString, 
								"INSERT INTO EMRDiagCodesT "
								"	(EMRID, DiagCodeID, SourceActionID, SourceDetailID, OrderIndex, SourceDataGroupID, SourceDetailImageStampID, DiagCodeID_ICD10,NexGEMMatchType) "
								"VALUES "
								"	(%li, %s, %s, %s, %li, %s, %s, %s, %li)\r\n"
								"SET @nNewObjectID = SCOPE_IDENTITY()", 
								m_nID, 
								strDiagCodeID, 
								strSourceActionID, 
								strSourceDetailID, 
								pDiag->nOrderIndex, 
								strSourceDataGroupID, 
								strSourceDetailImageStampID,
								strDiagCodeID_ICD10,
								pDiag->MatchType
							);

							// (j.jones 2008-07-23 11:12) - PLID 30819 - required so we can get the diagnosis ID
							AddNewEMRObjectToSqlBatch(strSaveString, esotDiagCode, (long)pDiag, mapSavedObjects);

							// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
							// be sure to update SourceDetailID at the end of the save!
							if(pDiag->sai.pSourceDetail && pDiag->sai.nSourceDetailID == -1) {
								//find the source detail's ID, and update this topic's SourceDetailID
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pDiag->sai.pSourceDetail));
								// (b.savon 2014-02-27 07:31) - PLID 60808 - Make sure we're updating properly too
								AddStatementToSqlBatch(
									strPostSaveSql, 
									"UPDATE EMRDiagCodesT SET SourceDetailID = @nEMRSourceDetailID "
									"WHERE EMRID = %li AND %s", 
									m_nID, 
									GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
								);
							}

							// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
							if(pDiag->sai.GetDetailStampPointer() != NULL && pDiag->sai.GetDetailStampID() == -1) {
								AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pDiag->sai.GetDetailStampPointer());
								// (b.savon 2014-02-27 07:31) - PLID 60808 - Make sure we're updating properly too
								AddStatementToSqlBatch(
									strPostSaveSql, 
									"UPDATE EMRDiagCodesT SET SourceDetailImageStampID = @nSourceDetailImageStampID "
									"WHERE EMRID = %li AND %s", 
									m_nID, 
									GenerateEMRDiagCodesTWhereCondition(strDiagCodeID, strDiagCodeID_ICD10)
								);
							}

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();

							// (b.savon 2014-02-27 14:40) - PLID 61065 - Replaced strCode with GenerateEMRDiagCodesTAuditValue(...)
							AuditEvent(
								GetParentEMR()->GetPatientID(), 
								GetExistingPatientName(GetParentEMR()->GetPatientID()), 
								nAuditTransactionID, 
								aeiEMNDiagCodeAdded, 
								m_nID, 
								"", 
								GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10), 
								aepMedium, 
								aetCreated
							);

							// (j.jones 2008-07-22 15:06) - PLID 30792 - save all our problems
							// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
							AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
							SaveProblemLinkArray(strSaveString, pDiag->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
								, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;

							//get the code number
							//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
							CString strName = pDiag->strCode;
							
							str.Format("Attempted to add diagnosis code '%s' to a locked EMN.", strName);
							arystrErrors.Add(str);
						}
					}
					else {

						if(!IsLockedAndSaved() && pDiag->bChanged) {

							// (j.jones 2007-01-05 09:54) - PLID 24070 - update the order index
							// (j.jones 2008-07-23 10:20) - PLID 30819 - changed the original nID to nDiagCodeID,
							// then added a new nID for the actual record ID
							// (b.savon 2014-03-10 09:24) - PLID 60824 - Write to data
							CString strDiagCodeID_ICD10;
							if( pDiag->nDiagCodeID_ICD10 != -1 ){
								strDiagCodeID_ICD10.Format(", DiagCodeID_ICD10 = %li", pDiag->nDiagCodeID_ICD10);
							}else {
								// (r.farnworth 2014-03-18 14:52) - PLID 61380 - Needed to save properly when the user is re-searching for an ICD-10
								strDiagCodeID_ICD10 = ", DiagCodeID_ICD10 = NULL";
							}

							AddStatementToSqlBatch(
								strSaveString, 
								"UPDATE EMRDiagCodesT SET DiagCodeID = %s, OrderIndex = %li, NexGEMMatchType = %li %s WHERE ID = %li",
								(pDiag->nDiagCodeID == -1)?"NULL":AsString(pDiag->nDiagCodeID), // (r.farnworth 2014-04-02 09:13) - PLID 61608 - Need to update ICD-9 changes as well
								pDiag->nOrderIndex,
								(long)pDiag->MatchType,
								strDiagCodeID_ICD10,
								pDiag->nID
							);

							// (b.savon 2014-03-19 13:33) - PLID 61315 - Audit NexCode and ManyMatch selections in <Codes> pane for EMR
							//Get old value
							_RecordsetPtr rsAudit = CreateParamRecordset(
								"SELECT COALESCE(ICD9.CodeNumber, '') AS ICD9Code, "
								"		COALESCE(ICD10.CodeNumber, '') AS ICD10Code, "
								"		EMRDiagCodesT.OrderIndex "
								"FROM	EMRDiagCodesT "
								"	LEFT JOIN DiagCodes AS ICD9 ON EMRDiagCodesT.DiagCodeID = ICD9.ID "
								"	LEFT JOIN DiagCodes AS ICD10 ON EMRDiagCodesT.DiagCodeID_ICD10 = ICD10.ID "
								"WHERE	EMRDiagCodesT.ID = {INT}",
								pDiag->nID
							);

							// (j.jones 2007-01-05 14:29) - PLID 24070 - use pDiag->bHasMoved to audit
							//only the rows that the use moved, as opposed to all changed indices

							if(pDiag->bHasMoved) {

								if(!rsAudit->eof) {

									long nOldIndex = AdoFldLong(rsAudit, "OrderIndex",-1);
									if(nOldIndex != pDiag->nOrderIndex) {
										//As far as I can tell, this is pointless
										//CString strCode = AdoFldString(rsAudit, "CodeNumber","");

										CString strOld, strNew;
										// (b.savon 2014-02-27 14:44) - PLID 61065 - UPDATE - Write icd10 selections to data upon save of EMN - Auditing
										strOld.Format(
											"'%s' was Index %li", 
											GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10),
											nOldIndex
										);

										// (b.savon 2014-02-27 14:44) - PLID 61065 - UPDATE - Write icd10 selections to data upon save of EMN - Auditing
										strNew.Format(
											"'%s' is now Index %li", 
											GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10),
											pDiag->nOrderIndex
										);

										//auditing (using transactions)
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNDiagCodeOrderChanged, m_nID, strOld, strNew, aepMedium, aetChanged);
									}
								}
							}

							// (b.savon 2014-03-19 14:04) - PLID 61315 - Audit NexCode and ManyMatch selections in <Codes> pane for EMR
							if(!rsAudit->eof) {

								CString strICD9Code = AdoFldString(rsAudit, "ICD9Code", "");
								CString strICD10Code = AdoFldString(rsAudit, "ICD10Code", "");

								if( GenerateEMRDiagCodesTAuditValue(strICD9Code, strICD10Code).CompareNoCase(GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10)) != 0 ){

									AuditEventItems aei = pDiag->bReplaced ? aeiEMNDiagCodeReplaced : aeiEMNDiagCodeMatched;

									//auditing (using transactions)
									if(nAuditTransactionID == -1)
										nAuditTransactionID = BeginAuditTransaction();

									AuditEvent(
										GetParentEMR()->GetPatientID(), 
										GetExistingPatientName(GetParentEMR()->GetPatientID()), 
										nAuditTransactionID, 
										aei,
										m_nID, 
										GenerateEMRDiagCodesTAuditValue(strICD9Code, strICD10Code), 
										GenerateEMRDiagCodesTAuditValue(pDiag->strCode, pDiag->strCode_ICD10), 
										pDiag->bReplaced ? aepHigh : aepMedium,
										aetChanged
									);
								}
							}

							rsAudit->Close();
						}

						// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
						// (z.manning 2009-05-22 10:21) - PLID 34297 - Just save links to problems
						SaveProblemLinkArray(strSaveString, pDiag->m_apEmrProblemLinks, AsString(pDiag->nID), mapSavedObjects
							, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));
					}
				}
			}
		}

		//Charges
		if(m_bIsTemplate) {
			//save charges to a new EMN

			if(m_nID == -1) {
				//add to EMRTemplateChargesT

				for(int i = 0; i < m_aryCharges.GetSize(); i++) {

					EMNCharge *pCharge = m_aryCharges.GetAt(i);

					CString strMod1 = "NULL", strMod2 = "NULL", strMod3 = "NULL", strMod4 = "NULL";
					if(!pCharge->strMod1.IsEmpty())
						strMod1 = "'" + pCharge->strMod1 + "'";

					if(!pCharge->strMod2.IsEmpty())
						strMod2 = "'" + pCharge->strMod2 + "'";

					if(!pCharge->strMod3.IsEmpty())
						strMod3 = "'" + pCharge->strMod3 + "'";

					if(!pCharge->strMod4.IsEmpty())
						strMod4 = "'" + pCharge->strMod4 + "'";

					if(!bReferenceIDDefined) {
						CString str;
						str.Format("SET @nEMRTemplateID = (SELECT COALESCE(MAX(ID), 0) FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li)", esotEMN, (long)this);
						AddStatementToSqlBatch(strSaveString, str);
						bReferenceIDDefined = TRUE;
					}

					// (c.haag 2007-06-14 10:52) - PLID 26277 - Get the new ID from EMRTemplateChargesT using scope_identity
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplateChargesT (EMRTemplateID, ServiceID, Description, "
							"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, Quantity, UnitCost) "
							"VALUES (@nEMRTemplateID, %li, '%s', %s, %s, %s, %s, %g, CONVERT(MONEY, '%s'))\r\n"
							"SET @nNewObjectID = SCOPE_IDENTITY()"
							, pCharge->nServiceID, _Q(pCharge->strDescription),
							strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
							FormatCurrencyForSql(pCharge->cyUnitCost));

					// (c.haag 2007-06-14 10:53) - PLID 26277 - This is now redundant
					//AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = (SELECT COALESCE(MAX(ID), 0) FROM EMRTemplateChargesT WITH(UPDLOCK, HOLDLOCK))");
					AddNewEMRObjectToSqlBatch(strSaveString, esotCharge, (long)pCharge, mapSavedObjects);

					//don't audit here because it is a new template
				}
			}
			else {
				//update EMRTemplateChargesT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the charges we've removed
				// (c.haag 2008-07-23 13:42) - PLID 30820 - We now store deleted charges in their fullest form, not as ID's
				for(i = 0; i < m_aryDeletedCharges.GetSize(); i++) {

					if(m_aryDeletedCharges.GetAt(i)->nID != -1) {

						AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRTemplateChargesT WHERE ID = %li", m_aryDeletedCharges.GetAt(i)->nID);

						//get the service code or product name
						//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
						CString strName = m_aryDeletedCharges.GetAt(i)->strCode;
						if(strName.IsEmpty()) {
							strName = m_aryDeletedCharges.GetAt(i)->strDescription;
						}
						
						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeRemoved, m_nID, strName, "<Deleted>", aepMedium, aetDeleted);
					}

					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedCharges[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedCharges.RemoveAll();

				for(i = 0; i < m_aryCharges.GetSize(); i++) {

					EMNCharge *pCharge = m_aryCharges.GetAt(i);

					// (j.jones 2006-01-19 15:53) - insert new charges, and update existing charges

					CString strMod1 = "NULL", strMod2 = "NULL", strMod3 = "NULL", strMod4 = "NULL";
					if(!pCharge->strMod1.IsEmpty())
						strMod1 = "'" + pCharge->strMod1 + "'";

					if(!pCharge->strMod2.IsEmpty())
						strMod2 = "'" + pCharge->strMod2 + "'";

					if(!pCharge->strMod3.IsEmpty())
						strMod3 = "'" + pCharge->strMod3 + "'";

					if(!pCharge->strMod4.IsEmpty())
						strMod4 = "'" + pCharge->strMod4 + "'";

					if(pCharge->nID == -1) {

						//insert new charge				

						// (c.haag 2007-06-14 10:49) - PLID 26277 - Get the new ID from EMRTemplateChargesT using scope_identity
						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRTemplateChargesT (EMRTemplateID, ServiceID, Description, "
								"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, "
								"Quantity, UnitCost) VALUES (%li, %li, '%s', %s, %s, %s, %s, %g, CONVERT(MONEY, '%s'))\r\n"
								"SET @nNewObjectID = SCOPE_IDENTITY()"
								, m_nID, pCharge->nServiceID, _Q(pCharge->strDescription),
								strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
								FormatCurrencyForSql(pCharge->cyUnitCost));

						// (c.haag 2007-06-14 10:49) - PLID 26277 - This is unnecessary now that we use scope_identity
						//AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = (SELECT COALESCE(MAX(ID), 0) FROM EMRTemplateChargesT WITH(UPDLOCK, HOLDLOCK))");
						AddNewEMRObjectToSqlBatch(strSaveString, esotCharge, (long)pCharge, mapSavedObjects);

						//get the service code or product name
						//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
						CString strName = pCharge->strCode;
						if(strName.IsEmpty()) {
							strName = pCharge->strDescription;
						}

						//auditing (using transactions)
						if(nAuditTransactionID == -1)
							nAuditTransactionID = BeginAuditTransaction();
						AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeAdded, m_nID, "", strName, aepMedium, aetCreated);
					}
					else {

						//update existing charge

						AddStatementToSqlBatch(strSaveString, "UPDATE EMRTemplateChargesT SET Description = '%s', "
								"CPTModifier1 = %s, CPTModifier2 = %s, CPTModifier3 = %s, CPTModifier4 = %s, "
								"Quantity = %g, UnitCost = %s WHERE ID = %li", _Q(pCharge->strDescription), 
								strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
								FormatCurrencyForSql(pCharge->cyUnitCost), pCharge->nID);

						//get old data for auditing
						//DRT 8/28/2007 - PLID 27207 - Parameterized.
						_RecordsetPtr rs = CreateParamRecordset("SELECT Description, CPTModifier1, CPTModifier2, "
							"CPTModifier3, CPTModifier4, Quantity, UnitCost "
							"FROM EMRTemplateChargesT WHERE ID = {INT}", pCharge->nID);
						if(!rs->eof) {
							CString strDescription = AdoFldString(rs, "Description","");
							CString strOldMod1 = AdoFldString(rs, "CPTModifier1","");
							CString strOldMod2 = AdoFldString(rs, "CPTModifier2","");
							CString strOldMod3 = AdoFldString(rs, "CPTModifier3","");
							CString strOldMod4 = AdoFldString(rs, "CPTModifier4","");
							double dblQuantity = AdoFldDouble(rs, "Quantity",0.0);
							COleCurrency cyUnitCost = AdoFldCurrency(rs, "UnitCost",COleCurrency(0,0));

							//auditing (using transactions)
							if(strDescription != pCharge->strDescription) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeDescription, m_nID, strDescription, pCharge->strDescription, aepMedium, aetChanged);
							}
							if(dblQuantity != pCharge->dblQuantity) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeQuantity, m_nID, AsString(dblQuantity), AsString(pCharge->dblQuantity), aepMedium, aetChanged);
							}
							if(strOldMod1 != pCharge->strMod1) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeMod1, m_nID, strOldMod1, pCharge->strMod1, aepMedium, aetChanged);
							}
							if(strOldMod2 != pCharge->strMod2) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeMod2, m_nID, strOldMod2, pCharge->strMod2, aepMedium, aetChanged);
							}
							if(strOldMod3 != pCharge->strMod3) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeMod3, m_nID, strOldMod3, pCharge->strMod3, aepMedium, aetChanged);
							}
							if(strOldMod4 != pCharge->strMod4) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeMod4, m_nID, strOldMod4, pCharge->strMod4, aepMedium, aetChanged);
							}
							if(cyUnitCost != pCharge->cyUnitCost) {
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateServiceCodeUnitCost, m_nID, FormatCurrencyForInterface(cyUnitCost,TRUE,TRUE), FormatCurrencyForInterface(pCharge->cyUnitCost,TRUE,TRUE), aepMedium, aetChanged);
							}
						}
						rs->Close();
					}
				}
			}
		}
		else {
			//update charges to an existing EMN		

			if(m_nID == -1) {
				//add to EMRChargesT

				for(int i = 0; i < m_aryCharges.GetSize(); i++) {

					EMNCharge *pCharge = m_aryCharges.GetAt(i);

					CString strMod1 = "NULL", strMod2 = "NULL", strMod3 = "NULL", strMod4 = "NULL";
					if(!pCharge->strMod1.IsEmpty())
						strMod1 = "'" + pCharge->strMod1 + "'";

					if(!pCharge->strMod2.IsEmpty())
						strMod2 = "'" + pCharge->strMod2 + "'";

					if(!pCharge->strMod3.IsEmpty())
						strMod3 = "'" + pCharge->strMod3 + "'";

					if(!pCharge->strMod4.IsEmpty())
						strMod4 = "'" + pCharge->strMod4 + "'";

					CString strSourceActionID = "NULL";
					if(pCharge->sai.nSourceActionID != -1) {
						strSourceActionID.Format("%li", pCharge->sai.nSourceActionID);
					}

					// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
					CString strSourceDetailID = "NULL";
					if(pCharge->sai.nSourceDetailID != -1)
						strSourceDetailID.Format("%li", pCharge->sai.nSourceDetailID);
					// (z.manning 2009-02-26 11:37) - PLID 33141 - SourceDataGroupID
					CString strSourceDataGroupID = "NULL";
					if(pCharge->sai.GetDataGroupID() != -1) {
						strSourceDataGroupID = AsString(pCharge->sai.GetDataGroupID());
					}
					// (z.manning 2010-02-26 16:29) - PLID 37540
					CString strSourceDetailImageStampID = "NULL";
					if(pCharge->sai.GetDetailStampID() != -1) {
						strSourceDetailImageStampID = AsString(pCharge->sai.GetDetailStampID());
					}
					// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
					CString strCategory = "NULL";
					if (pCharge->nCategoryID != -1){
						strCategory = AsString(pCharge->nCategoryID);
					}
					// (j.armen 2013-06-27 14:46) - PLID 57354 - Idenitate EMRChargesT
					AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRChargesT (EMRID, ServiceID, Description, "
							"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, "
							"Quantity, UnitCost, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID, Category) VALUES ( "
							"@nEMNID, %li, '%s', %s, %s, %s, %s, %g, CONVERT(MONEY, '%s'), %s, %s, %s, %s, %s)",
							pCharge->nServiceID, _Q(pCharge->strDescription),
							strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
							FormatCurrencyForSql(pCharge->cyUnitCost), strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID, strCategory);

					AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = SCOPE_IDENTITY()");
					AddNewEMRObjectToSqlBatch(strSaveString, esotCharge, (long)pCharge, mapSavedObjects);

					// (j.dinatale 2012-01-05 11:00) - PLID 39451 - if this charge is assigned to patient resp or some other resp, we need to insert it into the EMRChargeRespT table
					if(pCharge->nInsuredPartyID != -2){
						CString strValue = (pCharge->nInsuredPartyID == -1) ? "NULL" : AsString(pCharge->nInsuredPartyID);
						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRChargeRespT (EMRChargeID, InsuredPartyID) VALUES (@nNewObjectID, %s)", strValue);
					}

					// (j.jones 2008-06-04 16:28) - PLID 30255 - add the EMRQuotedChargesT record if necessary
					if(pCharge->nQuoteChargeID != -1) {
						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRQuotedChargesT (EMRChargeID, ChargeID) "
							"VALUES (@nNewObjectID, %li)", pCharge->nQuoteChargeID);
					}

					//DRT 1/15/2007 - PLID 24177 - Generate the WhichCodes data
					AddStatementToSqlBatch(strSaveString, GenerateSaveString_EMRChargesToDiagCodesT(pCharge, "@nNewObjectID"));

					// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
					// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
					AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
					SaveProblemLinkArray(strSaveString, pCharge->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
						, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

					// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
					// be sure to update SourceDetailID at the end of the save!
					if(pCharge->sai.pSourceDetail && pCharge->sai.nSourceDetailID == -1) {
						//find this charge's ID, find the source detail's ID, and update this charge's SourceDetailID
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotCharge, (long)pCharge);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)pCharge->sai.pSourceDetail);
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRChargesT SET SourceDetailID = @nEMRSourceDetailID WHERE ID = @nEMRObjectIDToUpdate");
					}

					// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
					if(pCharge->sai.GetDetailStampPointer() != NULL && pCharge->sai.GetDetailStampID() == -1) {
						AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotCharge, (long)pCharge);
						AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pCharge->sai.GetDetailStampPointer());
						AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRChargesT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE ID = @nEMRObjectIDToUpdate");
					}

					//don't audit here because it is a new EMN

					
					// (j.jones 2007-08-30 12:11) - PLID 27211 - track that this charge was created on a new EMN
					pCharge->m_bCreatedOnNewEMN = TRUE;
				}
				
			}
			else {
				//update EMRChargesT

				// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
				int i = 0;

				//delete the charges we've removed
				// (c.haag 2008-07-23 13:42) - PLID 30820 - We now store deleted charges in their fullest form, not as ID's
				for(i = 0; i < m_aryDeletedCharges.GetSize(); i++) {

					if(m_aryDeletedCharges.GetAt(i)->nID != -1) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {
							//AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRChargesT WHERE ID = %li", m_aryDeletedCharges.GetAt(i));
							AddStatementToSqlBatch(strSaveString, "UPDATE EmrChargesT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE ID = %li", _Q(GetCurrentUserName()), m_aryDeletedCharges.GetAt(i)->nID);
							// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the charge
							// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
							// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
							AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRProblemLinkT WHERE EMRRegardingType = %li AND EMRRegardingID = %li", eprtEmrCharge, m_aryDeletedCharges.GetAt(i)->nID);

							//DRT 1/15/2007 - PLID 24177 - Do not need to do anything here, we're linked to this charge, so we leave our data as it sits.
						}

						//get the service code or product name
						//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database
						CString strName = m_aryDeletedCharges.GetAt(i)->strCode;
						if(strName.IsEmpty()) {
							strName = m_aryDeletedCharges.GetAt(i)->strDescription;
						}
						
						if(!IsLockedAndSaved()) {
							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeRemoved, m_nID, strName, "<Deleted>", aepMedium, aetDeleted);

							// (j.jones 2011-07-14 08:56) - PLID 44509 - if removed by a coding group, audit as such
							long nCodingGroupID = -1;
							if(m_mapChargeIDsTo_RemovedByCodingGroupID.Lookup(m_aryDeletedCharges.GetAt(i)->nID, nCodingGroupID) && nCodingGroupID != -1) {
								CString strNewValue;
								strNewValue.Format("%s: Removed Code %s", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(nCodingGroupID), strName);
								AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupRemovedCharge, m_nID, "", strNewValue, aepMedium, aetDeleted);
							}
							// (a.wilson 2013-06-13 15:15) - PLID 57165 - set flag that charges have changed.
							SetChargesChanged(true);
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to delete a charge '%s' from a locked EMN.", strName);
							arystrErrors.Add(str);
						}
					}

					// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
					//delete m_aryDeletedCharges[i];
				}
				// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in PostSaveUpdate
				//m_aryDeletedCharges.RemoveAll();

				for(i = 0; i < m_aryCharges.GetSize(); i++) {

					EMNCharge *pCharge = m_aryCharges.GetAt(i);

					// (j.jones 2006-01-19 15:53) - insert new charges, and update existing charges

					CString strMod1 = "NULL", strMod2 = "NULL", strMod3 = "NULL", strMod4 = "NULL";
					if(!pCharge->strMod1.IsEmpty())
						strMod1 = "'" + pCharge->strMod1 + "'";

					if(!pCharge->strMod2.IsEmpty())
						strMod2 = "'" + pCharge->strMod2 + "'";

					if(!pCharge->strMod3.IsEmpty())
						strMod3 = "'" + pCharge->strMod3 + "'";

					if(!pCharge->strMod4.IsEmpty())
						strMod4 = "'" + pCharge->strMod4 + "'";

					CString strSourceActionID = "NULL";
					if(pCharge->sai.nSourceActionID != -1) {
						strSourceActionID.Format("%li", pCharge->sai.nSourceActionID);
					}

					// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
					CString strSourceDetailID = "NULL";
					if(pCharge->sai.nSourceDetailID != -1)
						strSourceDetailID.Format("%li", pCharge->sai.nSourceDetailID);
					// (z.manning 2009-02-26 11:39) - PLID 33141
					CString strSourceDataGroupID = "NULL";
					if(pCharge->sai.GetDataGroupID() != -1) {
						strSourceDataGroupID = AsString(pCharge->sai.GetDataGroupID());
					}
					// (z.manning 2010-02-26 16:31) - PLID 37540
					CString strSourceDetailImageStampID = "NULL";
					if(pCharge->sai.GetDetailStampID() != -1) {
						strSourceDetailImageStampID = AsString(pCharge->sai.GetDetailStampID());
					}

					//get the service code or product name
					//TES 6/26/2012 - PLID 27615 - We already have this information in memory, no need to access the database.
					CString strName = pCharge->strCode.IsEmpty() ? pCharge->strDescription : pCharge->strCode;

					

					if(pCharge->nID == -1) {

						// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
						if(!IsLockedAndSaved()) {
							// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
							CString strCategoryID = (pCharge->nCategoryID == -1) ? "NULL" : AsString(pCharge->nCategoryID);
							//insert new charge
							// (j.armen 2013-06-27 14:46) - PLID 57354 - Idenitate EMRChargesT 
							AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRChargesT (EMRID, ServiceID, Description, "
									"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, "
									"Quantity, UnitCost, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID, Category) VALUES ( %li, "
									"%li, '%s', %s, %s, %s, %s, %g, CONVERT(MONEY, '%s'), %s, %s, %s, %s, %s)",
									m_nID, pCharge->nServiceID, _Q(pCharge->strDescription),
									strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
									FormatCurrencyForSql(pCharge->cyUnitCost), strSourceActionID, strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID ,strCategoryID);

							AddStatementToSqlBatch(strSaveString, "SET @nNewObjectID = SCOPE_IDENTITY()");
							AddNewEMRObjectToSqlBatch(strSaveString, esotCharge, (long)pCharge, mapSavedObjects);

							// (j.dinatale 2012-01-05 11:00) - PLID 39451 - if this charge is assigned to patient resp or some other resp, we need to insert it into the EMRChargeRespT table
							if(pCharge->nInsuredPartyID != -2){
								CString strValue = (pCharge->nInsuredPartyID == -1) ? "NULL" : AsString(pCharge->nInsuredPartyID);
								AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRChargeRespT (EMRChargeID, InsuredPartyID) VALUES (@nNewObjectID, %s)", strValue);
							}

							// (j.jones 2008-06-04 16:28) - PLID 30255 - add the EMRQuotedChargesT record if necessary
							if(pCharge->nQuoteChargeID != -1) {
								AddStatementToSqlBatch(strSaveString, "INSERT INTO EMRQuotedChargesT (EMRChargeID, ChargeID) "
									"VALUES (@nNewObjectID, %li)", pCharge->nQuoteChargeID);
							}

							//DRT 1/15/2007 - PLID 24177 - Generate data for new WhichCodes
							AddStatementToSqlBatch(strSaveString, GenerateSaveString_EMRChargesToDiagCodesT(pCharge, "@nNewObjectID"));

							// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
							// (z.manning 2009-05-22 10:10) - PLID 34297 - Save problem links
							AddStatementToSqlBatch(strSaveString, "SET @nNewObjectIDForProblems = @nNewObjectID");
							SaveProblemLinkArray(strSaveString, pCharge->m_apEmrProblemLinks, "@nNewObjectIDForProblems", mapSavedObjects
								, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

							// (j.jones 2007-01-11 14:41) - PLID 24027 - if our source detail ID is -1, then
							// be sure to update SourceDetailID at the end of the save!
							if(pCharge->sai.pSourceDetail && pCharge->sai.nSourceDetailID == -1) {
								//find this charge's ID, find the source detail's ID, and update this charge's SourceDetailID
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotCharge, (long)pCharge);
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)pCharge->sai.pSourceDetail);
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRChargesT SET SourceDetailID = @nEMRSourceDetailID WHERE ID = @nEMRObjectIDToUpdate");
							}

							// (z.manning 2010-02-26 17:12) - PLID 37540 - Handle source detail stamp pointer
							if(pCharge->sai.GetDetailStampPointer() != NULL && pCharge->sai.GetDetailStampID() == -1) {
								AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRObjectIDToUpdate = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), -1)", esotCharge, (long)pCharge);
								AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = COALESCE((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)pCharge->sai.GetDetailStampPointer());
								AddStatementToSqlBatch(strPostSaveSql, "UPDATE EMRChargesT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE ID = @nEMRObjectIDToUpdate");
							}

							//auditing (using transactions)
							if(nAuditTransactionID == -1)
								nAuditTransactionID = BeginAuditTransaction();
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeAdded, m_nID, "", strName, aepMedium, aetCreated);

							// (j.jones 2007-08-30 11:41) - PLID 27221 - audit all pending E/M checklist audits
							// (a.walling 2009-06-05 10:57) - PLID 34495 - Fix infinite loop due to outer for loop's 'i' variable being reset here
							for(int j=0; j < pCharge->aryPendingEMAuditInfo.GetSize(); j++) {
								CPendingAuditInfo* pInfo = (CPendingAuditInfo*)(pCharge->aryPendingEMAuditInfo.GetAt(j));
								//ensure our record ID is the current EMN ID
								AuditPendingEvent(nAuditTransactionID, pInfo, m_nID);
							}

							// (j.jones 2011-07-14 08:56) - PLID 44509 - if added by a coding group, audit as such
							long nCodingGroupID = -1;
							if(m_mapChargesTo_CreatedByCodingGroupID.Lookup(pCharge, nCodingGroupID) && nCodingGroupID != -1) {

								if(nAuditTransactionID == -1) {
									nAuditTransactionID = BeginAuditTransaction();
								}

								CString strNewValue;
								strNewValue.Format("%s: Added Code %s", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(nCodingGroupID), pCharge->strCode);
								AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupAddedCharge, m_nID, "", strNewValue, aepMedium, aetCreated);
							}
							// (a.wilson 2013-06-13 15:15) - PLID 57165 - set flag that charges have changed.
							SetChargesChanged(true);
						}
						else {
							//we tried to change this on a locked EMN!
							CString str;
							str.Format("Attempted to add a charge '%s' to a locked EMN.", strName);
							arystrErrors.Add(str);
						}
					}
					else {

						// (z.manning, 09/11/2006) - PLID 22278 - Yes, the EMNCharge struct has a bChanged member,
						// but it wasn't being set reliably, so rather than relying on it and since we're already
						// comparing the old data to the new for auding, let's just use that to see if we even
						// need to bother saving this charge.
						// (c.haag 2016-06-09 14:54) - PLID-66502 - The change check is now in WasChargeModified
						BOOL bChargeChanged = WasChargeChanged(pCharge);
						//DRT 1/16/2007 - PLID 24177 - Only need to save our diag codes if they have changed
						BOOL bChargeDiagCodesChanged = FALSE;

						//TES 6/15/2012 - PLID 50983 - If the charge changed, then save it.  At this point we will compare against the 
						// database, so that the auditing is accurate
						if(bChargeChanged) {
							//get old data for auditing
							//or for determining what changed on the locked EMN
							//DRT 2/2/2007 - PLID 24234 - Added ServiceID and Servicename, which is the CPT code, or if a product, the product name.
							//DRT 8/28/2007 - PLID 27207 - Parameterized.
							// (z.manning 2009-02-26 11:41) - PLID 33141 - Added SourceDataGroupID
							// (z.manning 2010-02-25 10:11) - PLID 37532 - SourceDetailImageStampID
							// (j.dinatale 2012-01-05 11:08) - PLID 39451 - Added InsuredPartyID
							// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
							_RecordsetPtr rs = CreateParamRecordset("SELECT Description, CPTModifier1, CPTModifier2, "
								"CPTModifier3, CPTModifier4, Quantity, UnitCost, SourceActionID, SourceDetailID, SourceDataGroupID, SourceDetailImageStampID, "
								"EMRChargesT.ServiceID, EMRChargesT.Category, CASE WHEN CPTCodeT.ID IS NULL THEN ServiceT.Name ELSE CPTCodeT.Code END AS ServiceName, "
								"EMRChargeRespT.EMRChargeID AS RespChargeID, EMRChargeRespT.InsuredPartyID AS InsuredPartyID, "
								"InsPartyInfoQ.Name AS InsCoName, InsPartyInfoQ.TypeName AS RespTypeName ,EMRChargesT.Category,CategoriesT.Name as CategoryName "
								"FROM EMRChargesT "
								"LEFT JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID "
								"LEFT JOIN ServiceT ON EMRChargesT.ServiceID = ServiceT.ID "
								"LEFT JOIN CPTCodeT ON EMRChargesT.ServiceID = CPTCodeT.ID "
								"LEFT JOIN CategoriesT ON EMRChargesT.Category = CategoriesT.ID "
								"LEFT JOIN ( "
								"	SELECT InsuredPartyT.PersonID AS InsPartyID, InsuranceCoT.Name AS Name, RespTypeT.TypeName AS TypeName "
								"	FROM InsuredPartyT "
								"	INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
								"	INNER JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
								")	InsPartyInfoQ ON EMRChargeRespT.InsuredPartyID = InsPartyInfoQ.InsPartyID "
								"WHERE EMRChargesT.ID = {INT}", pCharge->nID);
							if(!rs->eof) {
								CString strDescription = AdoFldString(rs, "Description","");
								long nOldCategoryID = AdoFldLong(rs, "Category", -1);
								CString strOldCategory = AdoFldString(rs, "CategoryName","");
								CString strOldMod1 = AdoFldString(rs, "CPTModifier1","");
								CString strOldMod2 = AdoFldString(rs, "CPTModifier2","");
								CString strOldMod3 = AdoFldString(rs, "CPTModifier3","");
								CString strOldMod4 = AdoFldString(rs, "CPTModifier4","");
								double dblQuantity = AdoFldDouble(rs, "Quantity",0.0);
								COleCurrency cyUnitCost = AdoFldCurrency(rs, "UnitCost",COleCurrency(0,0));
								long nSourceActionID = AdoFldLong(rs, "SourceActionID", -1);
								long nSourceDetailID = AdoFldLong(rs, "SourceDetailID", -1);
								long nServiceID = AdoFldLong(rs, "ServiceID");
								CString strServiceName = AdoFldString(rs, "ServiceName", "");
								long nSourceDataGroupID = AdoFldLong(rs->GetFields(), "SourceDataGroupID", -1);
								long nSourceDetailImageStampID = AdoFldLong(rs->GetFields(), "SourceDetailImageStampID", -1);

								// (j.dinatale 2012-01-10 14:16) - PLID 39451 - if there is nothing in EMRChargeRespT for this charge,
								// then we know we have an unassigned charge. If there is something in EMRChargeRespT and the InsuredPartyID
								// is null, then we have a patient resp. If the InsuredPartyID is not null, then we have some other resp.
								long nOldInsuredPartyID = -2;
								if(AdoFldLong(rs, "RespChargeID", -1) != -1){
									nOldInsuredPartyID = AdoFldLong(rs, "InsuredPartyID", -1);
								}

								// (j.dinatale 2012-01-10 14:27) - PLID 39451 - get the insurance company name and resp type
								CString strInsCoName = AdoFldString(rs, "InsCoName", "");
								CString strInsRespType = AdoFldString(rs, "RespTypeName", "");

								//auditing (using transactions)
								if(nServiceID != pCharge->nServiceID) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										//DRT 2/2/2007 - PLID 24234 - I can't find a way to get this info short of querying.  However, currently the only
										//	way to change the service ID is through office visit upgrades, which cannot happen with products.  So this
										//	code should never actually be executed, I leave it as a catch all just in case.
										//If it's a CPT code, we can just show the code.
										//TES 2/8/2012 - PLID 19441 - Just get it out of memory rather than the database, the code and description are both stored
										CString strNewServiceName = pCharge->strCode;
										if(strNewServiceName.IsEmpty()) {
											strNewServiceName = pCharge->strDescription;
										}
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceIDChanged, m_nID, strServiceName, strNewServiceName, aepMedium, aetChanged);
									}
									else {
										//tried to change a locked EMN
										CString str;
										str.Format("Attempted to update the service on charge '%s' on a locked EMN.", strName);
										arystrErrors.Add(str);
									}
								}
								if(strDescription != pCharge->strDescription) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeDescription, m_nID, strDescription, pCharge->strDescription, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the description of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strDescription, pCharge->strDescription);
										arystrErrors.Add(str);
									}
								}
								if(dblQuantity != pCharge->dblQuantity) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeQuantity, m_nID, AsString(dblQuantity), AsString(pCharge->dblQuantity), aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the quantity of charge '%s' from %f to %f on a locked EMN.", strName, dblQuantity, pCharge->dblQuantity);
										arystrErrors.Add(str);
									}
								}
								// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
								if(nOldCategoryID != pCharge->nCategoryID) {
									_RecordsetPtr rsCat = CreateParamRecordset("Select Name From categoriesT where ID = {INT} ", pCharge->nCategoryID);
									CString strNewCategory ="";
										if (!rsCat->eof){
											strNewCategory = AdoFldString(rsCat, "Name", "");
										}
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCptCategory, m_nID, strOldCategory, strNewCategory, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the Charge Category of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strOldCategory, strNewCategory);
										arystrErrors.Add(str);
									}
								}
								if(strOldMod1 != pCharge->strMod1) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeMod1, m_nID, strOldMod1, pCharge->strMod1, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the Modifier 1 of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strOldMod1, pCharge->strMod1);
										arystrErrors.Add(str);
									}
								}
								if(strOldMod2 != pCharge->strMod2) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeMod2, m_nID, strOldMod2, pCharge->strMod2, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the Modifier 2 of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strOldMod2, pCharge->strMod2);
										arystrErrors.Add(str);
									}
								}
								if(strOldMod3 != pCharge->strMod3) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeMod3, m_nID, strOldMod3, pCharge->strMod3, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the Modifier 3 of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strOldMod3, pCharge->strMod3);
										arystrErrors.Add(str);
									}
								}
								if(strOldMod4 != pCharge->strMod4) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeMod4, m_nID, strOldMod4, pCharge->strMod4, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the Modifier 4 of charge '%s' from '%s' to '%s' on a locked EMN.", strName, strOldMod4, pCharge->strMod4);
										arystrErrors.Add(str);
									}
								}
								if(cyUnitCost != pCharge->cyUnitCost) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeUnitCost, m_nID, FormatCurrencyForInterface(cyUnitCost,TRUE,TRUE), FormatCurrencyForInterface(pCharge->cyUnitCost,TRUE,TRUE), aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the cost of charge '%s' from '%s' to '%s' on a locked EMN.", strName, FormatCurrencyForInterface(cyUnitCost,TRUE,TRUE), FormatCurrencyForInterface(pCharge->cyUnitCost,TRUE,TRUE));
										arystrErrors.Add(str);
									}
								}
								//DRT 1/15/2007 - PLID 24177 - Need to see if the WhichCodes field changed.  We must query for this, as it's a separate table..
								CString strOldValue;
								bChargeDiagCodesChanged = !CompareChargeDiagCodes(pCharge, strOldValue);
								if(bChargeDiagCodesChanged) {
									if(!IsLockedAndSaved()) {
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();
										// (j.jones 2009-01-02 09:16) - PLID 32601 - changed to strDiagCodeList
										CString strNewValue = pCharge->strDiagCodeList;
										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeWhichCodes, m_nID, strOldValue, strNewValue, aepMedium, aetChanged);
									}
									else {
										//we tried to change this on a locked EMN!
										CString str;
										str.Format("Attempted to update the WhichCodes selections of charge '%s'.", strName);
										arystrErrors.Add(str);
									}
								}

								// (j.dinatale 2012-01-05 11:18) - PLID 39451 - audit if Insured Party ID changes
								if(nOldInsuredPartyID != pCharge->nInsuredPartyID){
									if(!IsLockedAndSaved()) {
										// add auditing
										if(nAuditTransactionID == -1)
											nAuditTransactionID = BeginAuditTransaction();								

										CString strOldID, strNewID;

										if(nOldInsuredPartyID == -2){
											strOldID = "< Unassigned >";
										}else{
											if(nOldInsuredPartyID == -1){
												strOldID = "Patient Resp.";
											}else{
												strOldID.Format("%s (%s)", strInsCoName, strInsRespType);
											}
										}

										if(pCharge->nInsuredPartyID == -2){
											strNewID = "< Unassigned >";
										}else{
											if(pCharge->nInsuredPartyID == -1){
												strNewID = "Patient Resp.";
											}else{
												_RecordsetPtr rsNewIns = CreateParamRecordset(
													"SELECT InsuranceCoT.Name AS Name, RespTypeT.TypeName AS TypeName "
													"FROM InsuredPartyT "
													"INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
													"INNER JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
													"WHERE InsuredPartyT.PersonID = {INT} ", pCharge->nInsuredPartyID);

												if(!rsNewIns->eof){
													strNewID.Format("%s (%s)", AdoFldString(rsNewIns, "Name", ""), AdoFldString(rsNewIns, "TypeName", ""));
												}
											}
										}

										AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNServiceCodeAssignedRespChanged, m_nID, strOldID, strNewID, aepMedium, aetChanged);
									}
								}
							}

							// (j.jones 2006-08-24 09:28) - PLID 22183 - do not save if the EMN is locked
							// (s.tullis 2015-04-01 14:09) - PLID 64978 - Added Charge Category
							if(!IsLockedAndSaved()) {
								CString strCategory = pCharge->nCategoryID == -1 ? "NULL" : AsString(pCharge->nCategoryID);
								//DRT 2/2/2007 - PLID 24234 - Added ServiceID to save updates
								AddStatementToSqlBatch(strSaveString, "UPDATE EMRChargesT SET Description = '%s',"
										"CPTModifier1 = %s, CPTModifier2 = %s, CPTModifier3 = %s, CPTModifier4 = %s, "
										"Quantity = %g, UnitCost = CONVERT(MONEY, '%s'), SourceActionID = %s, SourceDetailID = %s, "
										"SourceDataGroupID = %s, SourceDetailImageStampID = %s, ServiceID = %li , Category = %s "
										"WHERE ID = %li", _Q(pCharge->strDescription),
										strMod1, strMod2, strMod3, strMod4, pCharge->dblQuantity,
										FormatCurrencyForSql(pCharge->cyUnitCost), strSourceActionID,
										strSourceDetailID, strSourceDataGroupID, strSourceDetailImageStampID, pCharge->nServiceID, strCategory,
										pCharge->nID);

								// (j.dinatale 2012-01-05 11:00) - PLID 39451 - if this charge is assigned to patient resp or some other resp, we need to insert it into the EMRChargeRespT table
								if(pCharge->nInsuredPartyID != -2){
									CString strValue = (pCharge->nInsuredPartyID == -1) ? "NULL" : AsString(pCharge->nInsuredPartyID);
									AddStatementToSqlBatch(strSaveString, 
										"IF EXISTS(SELECT TOP 1 1 FROM EMRChargeRespT WHERE EMRChargeID = %li) BEGIN "
										"	UPDATE EMRChargeRespT SET InsuredPartyID = %s WHERE EMRChargeID = %li "
										"END "
										"ELSE BEGIN "
										"	INSERT INTO EMRChargeRespT (EMRChargeID, InsuredPartyID) VALUES (%li, %s) "
										"END ", pCharge->nID, strValue, pCharge->nID, pCharge->nID, strValue);
								}else{
									AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRChargeRespT WHERE EMRChargeID = %li", pCharge->nID);
								}

								//DRT 1/15/2007 - PLID 24177 - We are updating an existing charge.  However, due to the nature of
								//	the Whichcodes data, it's actually more efficient to just wipe out all the existing data and
								//	reinsert it.  We only need to do this if our diag codes actually changed.
								if(bChargeDiagCodesChanged) {
									AddStatementToSqlBatch(strSaveString, "DELETE FROM EMRChargesToDiagCodesT WHERE ChargeID = %li;", pCharge->nID);
									CString strID;	strID.Format("%li", pCharge->nID);
									AddStatementToSqlBatch(strSaveString, GenerateSaveString_EMRChargesToDiagCodesT(pCharge, strID));
								}

								// (j.jones 2008-07-22 15:06) - PLID 30789 - save all our problems
								// (z.manning 2009-05-22 10:21) - PLID 34297 - Just save links to problems
								SaveProblemLinkArray(strSaveString, pCharge->m_apEmrProblemLinks, AsString(pCharge->nID), mapSavedObjects
									, nAuditTransactionID, m_pParentEMR->GetPatientID(), GetExistingPatientName(m_pParentEMR->GetPatientID()));

								// (j.jones 2011-07-14 08:56) - PLID 44509 - if modified by a coding group, audit as such
								long nCodingGroupID = -1;
								if(m_mapChargeIDsTo_ModifiedByCodingGroupID.Lookup(pCharge->nID, nCodingGroupID) && nCodingGroupID != -1) {

									if(nAuditTransactionID == -1) {
										nAuditTransactionID = BeginAuditTransaction();
									}

									CString strNewValue;
									strNewValue.Format("%s: Updated Code %s", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(nCodingGroupID), pCharge->strCode);
									AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupModifiedCharge, m_nID, "", strNewValue, aepMedium, aetChanged);
								}

								// (a.wilson 2013-06-13 15:15) - PLID 57165 - set flag that charges have changed.
								SetChargesChanged(true);
							}

							rs->Close();
						}
					}
				}
			}
		}
		
		// (j.jones 2011-07-11 14:23) - PLID 44509 - save our coding group usage in EMNCodingGroupLinkT
		if(!m_bIsTemplate && !IsLockedAndSaved()) {

			CString strEmnID;
			if (m_nID == -1) {
				strEmnID = "@nEMNID";
			}
			else {
				strEmnID = AsString(m_nID);
			}

			for(int i=0; i<m_arypCodingGroups.GetSize(); i++) {
				CEmnCodingGroupInfo *pEMNGroupInfo = (CEmnCodingGroupInfo*)m_arypCodingGroups.GetAt(i);
				//quantity 0 would be deleted, so in turn do not try to create a group with quantity 0
				if(pEMNGroupInfo->m_bIsNew) {
					if(pEMNGroupInfo->m_nGroupQuantity > 0) {
						AddStatementToSqlBatch(strSaveString, "INSERT INTO EMNCodingGroupLinkT (EMNID, EMRCodingGroupID, GroupQuantity) "
							"VALUES (%s, %li, %li)", strEmnID, pEMNGroupInfo->m_nEmrCodingGroupID, pEMNGroupInfo->m_nGroupQuantity);

						//if this is a new EMN, we will audit coding groups in PropagateNewID when we audit
						//the creation of the new EMN
						if(m_nID != -1) {		
							if(nAuditTransactionID == -1) {
								nAuditTransactionID = BeginAuditTransaction();
							}
							CString strNewValue;
							strNewValue.Format("%s: %li", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(pEMNGroupInfo->m_nEmrCodingGroupID), pEMNGroupInfo->m_nGroupQuantity);
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupQuantity, m_nID, "", strNewValue, aepMedium, aetCreated);
						}
					}
				}
				else if(pEMNGroupInfo->m_bIsModified) {
					//if the quantity is zero (or less), we need to delete the group
					if(pEMNGroupInfo->m_nGroupQuantity <= 0) {
						AddStatementToSqlBatch(strSaveString, "DELETE FROM EMNCodingGroupLinkT "
							"WHERE EMNID = %li AND EMRCodingGroupID = %li",
							m_nID, pEMNGroupInfo->m_nEmrCodingGroupID);

						if(nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOldValue;
						strOldValue.Format("%s: %li", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(pEMNGroupInfo->m_nEmrCodingGroupID), pEMNGroupInfo->m_nOldQuantity);
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupQuantity, m_nID, strOldValue, "0", aepMedium, aetDeleted);
					}
					else {
						AddStatementToSqlBatch(strSaveString, "UPDATE EMNCodingGroupLinkT "
							"SET GroupQuantity = %li "
							"WHERE EMNID = %li AND EMRCodingGroupID = %li",
							pEMNGroupInfo->m_nGroupQuantity,
							m_nID, pEMNGroupInfo->m_nEmrCodingGroupID);

						if(nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOldValue;
						strOldValue.Format("%s: %li", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(pEMNGroupInfo->m_nEmrCodingGroupID), pEMNGroupInfo->m_nOldQuantity);
						AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupQuantity, m_nID, strOldValue, AsString(pEMNGroupInfo->m_nGroupQuantity), aepMedium, aetChanged);
					}
				}
			}
		}
	}

	// (z.manning 2008-10-06 11:37) - Labs
	if(!m_bIsTemplate)
	{
		for(int i = 0; i < m_aryLabs.GetSize(); i++)
		{
			EMNLab *pLab = m_aryLabs.GetAt(i);
			if(pLab->bIsNew)
			{
				ASSERT(pLab->sai.nSourceActionID != -1);
				if(pLab->sai.nSourceDetailID != -1) {
					// (z.manning 2008-10-06 15:15) - PLID 21094 - We have a valid SourceDetailID for this
					// spawned lab, so set the value in LabsT.
					AddStatementToSqlBatch(strSaveString,
						"UPDATE LabsT SET SourceDetailID = %li WHERE ID = %li"
						, pLab->sai.nSourceDetailID, pLab->nID);
				}
				else if(pLab->sai.pSourceDetail != NULL) {
					// (z.manning 2008-10-06 15:15) - PLID 21094 - The source detail is not saved yet,
					// so make sure we update the lab's SourceDetailID in the post-save update.
					AddStatementToSqlBatch(strPostSaveSql, "SET @nEMRSourceDetailID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetail, (long)(pLab->sai.pSourceDetail));
					AddStatementToSqlBatch(strPostSaveSql, "UPDATE LabsT SET SourceDetailID = @nEMRSourceDetailID WHERE ID = %li", pLab->nID);
				}
				else {
					// (z.manning 2008-10-07 09:11) - It should not be possible to have a lab without
					// a valid source detail ID or if it's a new detail then we should have a valid
					// pSourceDetail pointer. If we get here, something isn't right.
					// (j.jones 2010-09-01 11:54) - PLID 40344 - not true, we may have deleted
					// the lab's parent, kept the lab, and added more labs to it, so it
					// is possible to get here, we just don't update the lab's source detail ID,
					// because there isn't one.					
				}

				// (z.manning 2010-02-26 17:44) - PLID 37540 - Handle labs SourceDetailImageStampID
				if(pLab->sai.GetDetailStampID() != -1) {
					AddStatementToSqlBatch(strSaveString,
						"UPDATE LabsT SET SourceDetailImageStampID = %li WHERE ID = %li"
						, pLab->sai.GetDetailStampID(), pLab->nID);
				}
				else if(pLab->sai.GetDetailStampPointer() != NULL) {
					AddStatementToSqlBatch(strPostSaveSql, "SET @nSourceDetailImageStampID = Coalesce((SELECT ID FROM #NewObjectsT WHERE Type = %li AND ObjectPtr = %li), NULL)", esotDetailImageStamp, (long)(pLab->sai.GetDetailStampPointer()));
					AddStatementToSqlBatch(strPostSaveSql, "UPDATE LabsT SET SourceDetailImageStampID = @nSourceDetailImageStampID WHERE ID = %li", pLab->nID);
				}
			}
		}
	}

	// (c.haag 2008-07-07 17:27) - PLID 30632 - If we are locking this EMN, make a copy of all EMN todos into a special 
	// table where we retain copies of the todos, unchanged, forever.
	// (c.haag 2008-07-08 10:24) - Added support for EMRLockedTodoAssignToT
	// (c.haag 2008-07-11 13:26) - PLID 30689 - Also lock todo's linked with EMN's (but not details necessarily)
	// (c.haag 2008-07-11 15:26) - PLID 30689 - Now we only get the first 1000 chars of the todo assignees. Otherwise, we
	// balloon the row size to the point where we start to get warnings.
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	if (m_nID != -1 && !m_bIsTemplate && m_LastSavedStatus.nID != m_Status.nID && m_Status.nID == 2) {
		// (a.walling 2014-01-31 15:41) - PLID 60551 - NxAutoQuantum - GetEMRLockTodoAlarmSql now returns a self-contained call to sp_executesql - AddRaw
		strSaveString.AddRaw(GetEMRLockTodoAlarmSql(m_nID));
	}

	// (j.jones 2007-10-04 10:10) - PLID 27444 - delete topics prior to saving topics,
	// which replicates the way EMRTopics save

	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//Now, deleted topics.
	for(i=m_arypDeletedTopics.GetSize() - 1; i >= 0; i--) {
		// (z.manning, 02/07/2007) - PLID 24599 - Pass the array to keep track of any deleted template topic IDs.
		// (b.cardillo 2007-09-26 16:02) - PLID 27512 - By calling the AddSqlBatchToSqlBatch() function instead of 
		// the CString operator+= function, we benefit from the performance improvements on large strings.
		// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
		AddSqlBatchToSqlBatch(strSaveString, m_arypDeletedTopics[i]->GenerateDeleteString(nAuditTransactionID, arystrErrors, arynDeletedTemplateTopicIDs, arynAffectedDetailIDs));
//		delete m_arypDeletedTopics.GetAt(i); // (a.walling 2007-02-06 15:01) - PLID 24602
		// these CEMNTopics are referred to in other GenerateSaveStrings, so this is causing a crash.
		// Instead I am moving these deletions to PostSaveUpdate() as per instructions in the function header.
	}
//	m_arypDeletedTopics.RemoveAll();

	//now save all sub-topics

	// (j.jones 2006-02-21 09:02) - PLID 19341 - Detect whether or not any details
	// have switched topics. If so, determine the proper topic saving order, then
	// save other topics first if necessary

	CArray<CEMRTopic*,CEMRTopic*> aryEMRTopicsInOrder;

	//TES 2/21/2014 - PLID 60972 - Added m_bCodesUnsaved; I suspect that neither it nor m_bMoreInfoUnsaved are actually needed here, but 
	// it's not really hurting anything
	if((m_nID == -1 || m_bUnsaved || m_bMoreInfoUnsaved || m_bCodesUnsaved || bSaveRecordOnly) && GetDetailsHaveMoved()) {
		//this will calculate if we need to save topics in a given order,
		//and populates the array with that desired saving order

		for(i=0;i<m_arypEMRTopics.GetSize();i++) {
			
			CEMRTopic *pTopic = m_arypEMRTopics.GetAt(i);
			CArray<CEMRTopic*,CEMRTopic*> aryEMRTopicsToSave;
			
			if(pTopic->CalculateTopicSavingOrderNeeded(aryEMRTopicsToSave)) {
				
				//these are not necessarily top-level topics, so we need to find their top-level topics
				
				for(int j=0; j<aryEMRTopicsToSave.GetSize(); j++) {

					//get the top-level parent topic
					CEMRTopic *pTopicToSave = aryEMRTopicsToSave.GetAt(j);
					CEMRTopic *pTopMost = pTopicToSave->GetTopMostParentTopic();

					//ensure we are only adding unique topics
					BOOL bFound = FALSE;					
					for(int k=0; k<aryEMRTopicsInOrder.GetSize() && !bFound; k++) {
						if(pTopMost == aryEMRTopicsInOrder.GetAt(k))
							bFound = TRUE;
					}
					
					if(!bFound) {
						aryEMRTopicsInOrder.Add(pTopMost);

						// (j.jones 2006-08-31 10:01) - PLID 22325 - remember that PostSaveUpdate()
						// needs to run for these topics later
						m_arypOtherSavedTopics.Add(pTopMost);
					}
				}
			}
		}
	}

	//if saving the record only, we have to save the "required" topics so far, so we can save just those,
	//but otherwise we are saving everything and need to add the remaining topics
	if(!bSaveRecordOnly) {

		//aryEMRTopicsInOrder may or may not be populated at this point,
		//so add all the top-level topics that aren't in aryEMRTopicsInOrder
		for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
			
			CEMRTopic *pTopic = m_arypEMRTopics.GetAt(i);

			BOOL bFound = FALSE;		
			for(int j=0; j<aryEMRTopicsInOrder.GetSize() && !bFound; j++) {
				if(pTopic == aryEMRTopicsInOrder.GetAt(j))
					bFound = TRUE;
			}
			
			if(!bFound) {
				aryEMRTopicsInOrder.Add(pTopic);
			}
		}
	}

	//TES 4/15/2010 - PLID 24692 - The topic ordering isn't handled by the topics any more, so we don't need to do this.
	// (z.manning 2010-03-24 16:26) - PLID 37867 - Before saving this EMN's topics, make sure we first fix
	// the order index for all of them to ensure that new topics have the correct value too.
	/*if(m_bTopicArrayChanged) {
		for(int nTopicIndex = 0; nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++) {
			CEMRTopic *pTopic = m_arypEMRTopics.GetAt(nTopicIndex);
			pTopic->SetTopicOrderIndex(nTopicIndex);
		}
	}*/

	//TES 4/15/2010 - PLID 24692 - Save our topic orders from our linked list of positions.
	// (z.manning 2010-04-19 17:36) - PLID 24692 - Added a check here to make sure we don't save
	// this on locked EMNs, but I let Tom know of the overall issue with saving and he may end
	// up changing this later.
	if(m_pTopicPositionHead && emnStatus.nID != 2) {
		AddSqlBatchToSqlBatch(strSaveString, m_pTopicPositionHead->GenerateSaveString(m_bIsTemplate));
	}

	//now save in order of aryEMRTopicsInOrder, which may or may not have been rearranged
	//from the initial topic order (this won't affect the OrderIndex)
	//this can also be empty or less than the total topic count if bSaveRecordOnly is TRUE
	for(i=0;i<aryEMRTopicsInOrder.GetSize();i++) {
		// (z.manning, 02/07/2007) - PLID 24599 - Pass the array to keep track of any deleted template topic IDs.
		// (b.cardillo 2007-09-26 16:02) - PLID 27512 - By calling the AddSqlBatchToSqlBatch() function instead of 
		// the CString operator+= function, we benefit from the performance improvements on large strings.
		// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
		AddSqlBatchToSqlBatch(strSaveString, aryEMRTopicsInOrder.GetAt(i)->GenerateSaveString(nAuditTransactionID, strPostSaveSql, arystrErrors, mapSavedObjects, arynAffectedDetailIDs, bDrugInteractionsChanged, arynDeletedTemplateTopicIDs, FALSE, FALSE));
	}

	//TES 4/15/2010 - PLID 24692 - Our linked list handled this, so we don't need this code any more.
	/*//TES 6/22/2006 - Now set the order of the topics, if we need to.
	if(m_bTopicArrayChanged) {
		for(int i=0; i < m_arypEMRTopics.GetSize(); i++) {
			// (j.jones 2007-03-02 17:03) - PLID 25048 - don't try to update a nonexistent topic!
			long nTopicID = m_arypEMRTopics[i]->GetID();
			if(nTopicID != -1) {
				if(m_bIsTemplate) {
					// (c.haag 2007-06-11 09:17) - PLID 26268 - Make sure the update statement properly goes into the batch
					AddStatementToSqlBatch(strSaveString, "UPDATE EmrTemplateTopicsT SET OrderIndex = %li WHERE ID = %li", i, nTopicID);
					// (z.manning 2010-03-24 16:23) - PLID 37867 - We already updated topic sort order
					//m_arypEMRTopics[i]->SetTopicOrderIndex(i);
				}
				else {
					if(!IsLockedAndSaved()) {
						// (c.haag 2007-06-11 09:18) - PLID 26268 - Make sure the update statement properly goes into the batch
						AddStatementToSqlBatch(strSaveString, "UPDATE EmrTopicsT SET OrderIndex = %li WHERE ID = %li", i, nTopicID);
						// (z.manning 2010-03-24 16:23) - PLID 37867 - We already updated topic sort order
						//m_arypEMRTopics[i]->SetTopicOrderIndex(i);
					}
					else {
						//we tried to change this on a locked EMN!
						CString str;
						str.Format("Attempted to change the order index of topic '%s' to %li on a locked EMN.", m_arypEMRTopics[i]->GetName(), i);
						arystrErrors.Add(str);
					}
				}

				// (j.jones 2006-10-16 11:56) - PLID 23084 - restored the OrderIndex audit ability

				//OrderIndex audit
				if(m_arypEMRTopics[i]->GetHasMoved() && m_arypEMRTopics[i]->GetLastSavedTopicOrderIndex() != m_arypEMRTopics[i]->GetTopicOrderIndex()) {
					CString strOldIndex, strNewIndex;
					CString strOldParent, strNewParent;

					strOldParent = m_arypEMRTopics[i]->GetLastSavedParentTopicName();
					if(strOldParent.IsEmpty())
						strOldParent = "Top-Level";

					if(m_arypEMRTopics[i]->GetParentTopic())
						strNewParent = m_arypEMRTopics[i]->GetParentTopic()->GetName();
					else
						strNewParent = "Top-Level";

					strOldIndex.Format("%s was Topic %li (%s)", m_arypEMRTopics[i]->GetName(), m_arypEMRTopics[i]->GetLastSavedTopicOrderIndex()+1, strOldParent);
					strNewIndex.Format("%s is now Topic %li (%s)", m_arypEMRTopics[i]->GetName(), m_arypEMRTopics[i]->GetTopicOrderIndex()+1, strNewParent);
					if(nAuditTransactionID == -1)
						nAuditTransactionID = BeginAuditTransaction();
					AuditEvent(-1, "", nAuditTransactionID, m_bIsTemplate ? aeiEMNTemplateTopicMoved : aeiEMNTopicMoved, m_nID, strOldIndex, strNewIndex, aepMedium, aetChanged);
				}
			}
		}
	}*/

	//TES 5/3/2010 - PLID 24692 - Restore just the auditing part of the above code.
	for(int i=0; i < m_arypEMRTopics.GetSize(); i++) {
		long nTopicID = m_arypEMRTopics[i]->GetID();
		if(nTopicID != -1) {
			// (j.jones 2006-10-16 11:56) - PLID 23084 - restored the OrderIndex audit ability

			//OrderIndex audit
			TopicPositionEntry * tpe = m_arypEMRTopics[i]->GetTopicPositionEntry();
			//TES 5/20/2010 - PLID 24692 - Restored the original behavior, where this would only audit if it had been manually moved.
			if(m_arypEMRTopics[i]->GetHasMoved() && tpe->nLastSavedOrderIndex != tpe->GetSortOrder()) {
				CString strOldIndex, strNewIndex;
				CString strOldParent, strNewParent;

				strOldParent = m_arypEMRTopics[i]->GetLastSavedParentTopicName();
				if(strOldParent.IsEmpty())
					strOldParent = "Top-Level";

				if(m_arypEMRTopics[i]->GetParentTopic())
					strNewParent = m_arypEMRTopics[i]->GetParentTopic()->GetName();
				else
					strNewParent = "Top-Level";

				strOldIndex.Format("%s was Topic %li (%s)", m_arypEMRTopics[i]->GetName(), tpe->nLastSavedOrderIndex+1, strOldParent);
				strNewIndex.Format("%s is now Topic %li (%s)", m_arypEMRTopics[i]->GetName(), tpe->GetSortOrder()+1, strNewParent);
				if(nAuditTransactionID == -1)
					nAuditTransactionID = BeginAuditTransaction();
				//TES 5/12/2010 - PLID 38470 - If this is an EMN, include the patient ID and name.
				AuditEvent(m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), m_bIsTemplate ? "" : GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, m_bIsTemplate ? aeiEMNTemplateTopicMoved : aeiEMNTopicMoved, m_nID, strOldIndex, strNewIndex, aepMedium, aetChanged);
			}
		}
	}

	// (z.manning, 02/07/2007) - PLID 24599 - Ok, we're done saving and deleting topics, so if we have any
	// deleted template topic IDs, let's now delete those records from EmrTemplateTopicsT.
	if(arynDeletedTemplateTopicIDs.GetSize() > 0) {
		ASSERT(IsTemplate());
		AddStatementToSqlBatch(strSaveString, "DELETE FROM EmrTemplateTopicsT WHERE ID IN (%s)", ArrayAsString(arynDeletedTemplateTopicIDs));
	}

	//if we saved the entire EMN, then we can reset the "details have moved" boolean to false
	if(!bSaveRecordOnly)
		SetDetailsHaveMoved(FALSE);

	// (j.jones 2006-08-29 09:00) - PLID 22250 - update the EMN/Template modified date
	if(IsUnsaved() && m_nID != -1) {
		if(m_bIsTemplate) {
			AddStatementToSqlBatch(strSaveString, "UPDATE EMRTemplateT SET ModifiedDate = GetDate(), ModifiedLogin = '%s' WHERE ID = %li", _Q(GetCurrentUserName()), m_nID);
		}
		//don't update the patient's EMN here, we did it earlier
	}

	//We have now had our save string generated.
	mapSavedObjects[this] = this;
	return strSaveString;
}

// (c.haag 2016-06-09 14:54) - PLID-66502 - Write pertinent information about this EMR object to NxLog. This is used to help pin down save errors.
void CEMN::LogEmrObjectData(int nIndent, BOOL bForceDeletedFlagTrue, BOOL bInEMRPendingDeleteEMNsAry)
{
	BOOL bDeleted = bForceDeletedFlagTrue;

	// Log this object
	::LogEmrObjectData(nIndent, m_nID, this, bDeleted ? esotDeletedEMN : esotEMN, (m_nID == -1), IsUnsaved(), bDeleted, m_strDescription,
		"m_dtEMNDate = %s  m_Status.nID = %d  m_bIsTemplate = %d  bInEMRPendingDeleteEMNsAry = %d  sourceActionID = %d  sourceDetailID = %d  sourceDataGroupID = %d  sourceDetailImageStampID = %d"
		, FormatDateTimeForInterface(m_dtEMNDate, 0, dtoDate, false)
		, m_Status.nID
		, m_bIsTemplate
		, bInEMRPendingDeleteEMNsAry
		, m_sai.nSourceActionID
		, m_sai.GetSourceDetailID()
		, m_sai.GetDataGroupID()
		, m_sai.GetDetailStampID()
	);

	// Log everyone who has access to it and when it was last modified
	if (m_nID > 0)
	{
		CString strIndent;
		for (int i = 0; i < nIndent; i++, strIndent += " ");

		_RecordsetPtr prs = CreateParamRecordset(R"(select emnaccesst.Date, UserID, modifieddate
from emnaccesst
inner join emrmastert on emrmastert.id = emnaccesst.emnid
left join userlogintokenst on userlogintokenst.id = userlogintokenid
where emnaccesst.emnid = {INT})"
, m_nID);
		while (!prs->eof)
		{
			Log("%sEMN Access Info: Access Date = %s  Access UserID = %d  EMN ModifiedDate = %s"
				, strIndent
				, FormatDateTimeForInterface(AdoFldDateTime(prs, "Date"))
				, AdoFldLong(prs, "UserID", -1)
				, FormatDateTimeForInterface(AdoFldDateTime(prs, "ModifiedDate"))
			);
			prs->MoveNext();
		}
	}

	// Log problems and problem links
	for (auto l : m_apEmrProblemLinks)
	{
		if (nullptr != l)
		{
			CEmrProblem* p = l->GetProblem();
			if (nullptr != p)
			{
				p->LogEmrObjectData(nIndent + 1);
			}
			if (nullptr != l)
			{
				l->LogEmrObjectData(nIndent + 1);
			}
		}
	}

	// Charges: void LogEmrObjectData(int nIndent, BOOL bModified, BOOL bDeleted)
	for (auto c : m_aryCharges)
	{
		c->LogEmrObjectData(nIndent + 1, WasChargeChanged(c), FALSE);
	}
	for (auto c : m_aryDeletedCharges)
	{
		c->LogEmrObjectData(nIndent + 1, FALSE, TRUE);
	}

	// Prescriptions: void LogEmrObjectData(int nIndent, BOOL bDeleted)
	for (auto m : m_aryMedications)
	{
		m->LogEmrObjectData(nIndent + 1, FALSE);
	}
	for (auto m : m_aryDeletedMedications)
	{
		m->LogEmrObjectData(nIndent + 1, TRUE);
	}

	// Diagnosis codes: void LogEmrObjectData(int nIndent, BOOL bDeleted)
	for (auto d : m_aryDiagCodes)
	{
		d->LogEmrObjectData(nIndent + 1, FALSE);
	}
	for (auto d : m_aryDeletedDiagCodes)
	{
		d->LogEmrObjectData(nIndent + 1, TRUE);
	}

	// Topics
	for (auto t : m_arypEMRTopics)
	{
		t->LogEmrObjectData(nIndent + 1, FALSE);
	}
	for (auto t : m_arypDeletedTopics)
	{
		t->LogEmrObjectData(nIndent + 1, TRUE);
	}
}

//DRT 2/24/2006 - PLID 19465 - This is a notification function that lets us know a save has just taken place.  This function
//	should contain any code that updates members, etc based on the successful save, not GenerateSaveString()
// (a.walling 2007-10-18 16:34) - PLID 27664 - Added array to gather all topics affected in the PostSaveUpdate cascade.
void CEMN::PostSaveUpdate(CShowProgressFeedbackDlg* pProgressDlg, BOOL bTopLevelUpdate /*= FALSE*/, BOOL bUpdateRecordOnly /*= FALSE*/, CArray<CEMRTopic*, CEMRTopic*> *parTopicsAffected /*= NULL*/)
{
	int i = 0;

	//If this is the top level, or we are only doing this level, let our parent process the update.
	if(bTopLevelUpdate || bUpdateRecordOnly) {
		// (a.walling 2007-10-18 16:36) - PLID 27664 - Pass the array to gather all affected topics
		//tell our parent to process the save, but only for themselves, and not their other children
		GetParentEMR()->PostSaveUpdate(pProgressDlg, TRUE, parTopicsAffected);
	}



	////////////////////////////
	//Put all code for handling the update here

	// (a.walling 2007-10-15 16:33) - PLID 27664 - Refresh our last saved info
	// (a.walling 2007-10-18 15:30) - PLID 27664 - if we are not a template
	// (a.walling 2013-05-01 10:33) - PLID 55632 - Removed all the last saved html (m_strLastSavedMoreInfoHTML, m_strLastSavedHeaderHTML)

	//At this point, we've saved all our fields.
	// (c.haag 2008-07-15 15:56) - PLID 17244 - If the description had changed, make sure
	// we refresh all related todo alarms
	// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Support Ex todos
	if (m_nID > 0 && m_strLastSavedDescription != m_strDescription) {
		_RecordsetPtr prs = CreateParamRecordset(FormatString(
			"SELECT TaskID, dbo.GetTodoAssignToIDString(ToDoList.TaskID) as AssignedIDs, RegardingType FROM TodoList WHERE "
			"(RegardingType = %d AND RegardingID = {INT}) "
			"OR "
			"(RegardingType = %d AND RegardingID IN (SELECT ID FROM EmrDetailsT WHERE EMRID = {INT})) "
			,ttEMN, ttEMNDetail), m_nID, m_nID);
		FieldsPtr f = prs->Fields;
		if (!prs->eof) {
			// Update the more info topic immediately
			CEmrTreeWnd* pTreeWnd = GetInterface();
			if (NULL != pTreeWnd) {
				pTreeWnd->PostMessage(NXM_EMN_TODO_REFRESH_LIST, (WPARAM)this);
			}
			while (!prs->eof) {
				// Update the Practice universe
				// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Ex Todo
				CString strAssignedIDs = AdoFldString(f, "AssignedIDs", "");
				CArray < long, long> arrAssignedID;
				ParseDelimitedStringToLongArray(strAssignedIDs, " ", arrAssignedID);

				if (arrAssignedID.GetSize() == 1){
					CClient::RefreshTodoTable(AdoFldLong(f, "TaskID", -1), GetParentEMR()->GetPatientID(), arrAssignedID[0], TableCheckerDetailIndex::tddisChanged);
				}
				else{
					CClient::RefreshTodoTable(AdoFldLong(f, "TaskID", -1), GetParentEMR()->GetPatientID(), -1, TableCheckerDetailIndex::tddisChanged);
				}
					
				
				prs->MoveNext();
			}
		}
	}

	m_dtLastSavedDate = m_dtEMNDate;	
	// (a.walling 2012-06-07 08:53) - PLID 50920 - Dates - Modified, Created
	// (z.manning 2012-09-11 14:45) - PLID 52543 - This wasn't as accurate as it could have been. We now use the
	// exact modified date from data in SaveEMRObject.
	//m_dtEMNModifiedDate = COleDateTime::GetCurrentTime();
	m_LastSavedLocation.nID = m_Location.nID;
	m_LastSavedLocation.strName = m_Location.strName; // (z.manning, 05/07/2007) - PLID 25925
	m_LastSavedLocation.strLogo = m_Location.strLogo; // (a.walling 2008-07-01 15:01) - PLID 30586
	m_LastSavedLocation.nLogoWidth = m_Location.nLogoWidth; // (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width
	// (a.walling 2013-01-16 13:30) - PLID 54652 - Last saved appointment
	m_LastSavedAppointment = m_Appointment;
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	m_LastSavedStatus = m_Status;
	m_strLastSavedNotes = m_strNotes;
	m_strLastSavedDescription = m_strDescription;
	// (z.manning, 04/19/2007) - PLID 25714
	m_LastSavedChart.nID = m_Chart.nID;
	m_LastSavedCategory.nID = m_Category.nID;
	// (z.manning, 05/07/2007) - PLID 25731
	m_LastSavedChart.strName = m_Chart.strName;
	m_LastSavedCategory.strName = m_Category.strName;
	// (j.jones 2007-06-14 11:43) - PLID 26276 - Completion Status
	m_ecsLastSavedCompletionStatus = m_ecsCompletionStatus;
	// (j.jones 2007-08-06 16:08) - PLID 26974 - Patient Demographics
	m_strLastSavedPatNameFirst = m_strPatNameFirst;
	m_strLastSavedPatNameMiddle = m_strPatNameMiddle;
	m_strLastSavedPatNameLast = m_strPatNameLast;
	m_cbLastSavedPatientGender = m_cbPatientGender;
	m_strLastSavedPatientAge = m_strPatientAge;
	// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
	m_nLastSavedVisitTypeID = m_nVisitTypeID;
	m_strLastSavedVisitTypeName = m_strVisitTypeName;
	//TES 1/17/2014 - PLID 60397 - Option to hide the EMN title on the preview pane, per template
	m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview;
	// (d.thompson 2009-05-27) - PLID 29909 - Confidential Info is now saved
	m_bConfidentialInfoChanged = false;

	// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
	m_LastSavedDischargeStatus.nID = m_DischargeStatus.nID;
	m_LastSavedDischargeStatus.strCode = m_DischargeStatus.strCode;
	m_LastSavedDischargeStatus.strDesc = m_DischargeStatus.strDesc;
	m_dtLastSavedAdmissionTime = m_dtAdmissionTime;
	m_dtLastSavedDischargeTime = m_dtDischargeTime;
	
	// (a.walling 2008-06-27 16:56) - PLID 30482 - The parent EMR changed, reset the flag.
	m_bParentEMRChanged = FALSE;

	// (c.haag 2008-07-14 11:24) - PLID 30696 - Now that the EMN is saved, We need to flush
	// m_apCreatedTodosWhileUnsaved. Here's what we know:
	//
	// - The EMN was just saved, but not assigned an ID if it's new
	// - All todo alarms that m_apCreatedTodosWhileUnsaved points to have -1 RegardingID's.
	//
	// Here, we need to do two things:
	// 1. For all records in m_apCreatedTodosWhileUnsaved, update the todo RegardingID's to
	// the ID of its corresponding EMR entity (EMN or EMN Detail) if it's not -1
	// 2. Empty m_apCreatedTodosWhileUnsaved

	// (c.haag 2012-10-17) - PLID 52863 - Moved the code to UpdateUnsavedTodos() and it's now called
	// after PropagateNewID()

	//we may have just saved the EMN record but not its details
	if(!bUpdateRecordOnly) {
		
		// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
		for(i = 0; i < m_aryProcedures.GetSize(); i++) {
			m_aryProcedures[i]->bIsNew = FALSE;
		}

		for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
			m_aryDiagCodes[i]->bIsNew = FALSE;
			m_aryDiagCodes[i]->bHasMoved = FALSE;
			m_aryDiagCodes[i]->bChanged = FALSE;
			// (j.jones 2014-12-23 15:07) - PLID 64491 - added bReplaced
			m_aryDiagCodes[i]->bReplaced = FALSE;
		}

		for(i = 0; i < m_aryCharges.GetSize(); i++) {
			m_aryCharges[i]->bChanged = FALSE;
		}

		// (j.jones 2011-07-14 08:37) - PLID 44509 - clear the maps for auditing charges by coding group
		m_mapChargeIDsTo_RemovedByCodingGroupID.RemoveAll();
		m_mapChargeIDsTo_ModifiedByCodingGroupID.RemoveAll();
		//if a new EMN, we can't clear this map until PropagateNewID has been called
		if(m_nID != -1) {
			m_mapChargesTo_CreatedByCodingGroupID.RemoveAll();
		}

		for(i = 0; i < m_aryMedications.GetSize(); i++) {
			m_aryMedications[i]->SetUnchanged();
		}

		for(i = 0; i < m_aryProviders.GetSize(); i++) {
			m_aryProviders[i]->bIsNew = FALSE;
		}

		for(i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
			m_arySecondaryProviders[i]->bIsNew = FALSE;
		}

		// (j.gruber 2009-05-08 09:13) - PLID 33688 - other providers
		for(i = 0; i < m_aryOtherProviders.GetSize(); i++) {
			m_aryOtherProviders[i]->bIsNew = FALSE;
		}

		// (d.lange 2011-03-25 17:31) - PLID 42136 - Assistant/Technician have been saved, let's mark them as not being new so we
		// don't go adding them again
		for(i = 0; i < m_aryTechnicians.GetSize(); i++) {
			m_aryTechnicians[i]->bIsNew = FALSE;
		}

		// (j.jones 2011-07-11 14:23) - PLID 44509 - update our coding groups
		for(i=m_arypCodingGroups.GetSize()-1; i>=0; i--) {
			CEmnCodingGroupInfo *pEMNGroupInfo = (CEmnCodingGroupInfo*)m_arypCodingGroups.GetAt(i);
			pEMNGroupInfo->m_bIsNew = FALSE;
			pEMNGroupInfo->m_bIsModified = FALSE;
			pEMNGroupInfo->m_nOldQuantity = pEMNGroupInfo->m_nGroupQuantity;
			
			//if the quantity is zero (or less), we need to delete the group
			if(pEMNGroupInfo->m_nGroupQuantity <= 0) {
				delete pEMNGroupInfo;
				m_arypCodingGroups.RemoveAt(i);
			}
		}

		// (j.jones 2012-12-31 13:59) - PLID 22340 - clear our deleted arrays
		for(i = 0; i < m_aryDeletedProcedures.GetSize(); i++) {
			EMNProcedure *pProc = m_aryDeletedProcedures.GetAt(i);
			delete pProc;
		}
		m_aryDeletedProcedures.RemoveAll();

		for(i = 0; i < m_aryDeletedDiagCodes.GetSize(); i++) {
			EMNDiagCode *pDiag = m_aryDeletedDiagCodes.GetAt(i);
			delete pDiag;
		}
		m_aryDeletedDiagCodes.RemoveAll();

		for(i = 0; i < m_aryDeletedCharges.GetSize(); i++) {
			EMNCharge *pCharge = m_aryDeletedCharges.GetAt(i);
			delete pCharge;
		}
		m_aryDeletedCharges.RemoveAll();

		for(i = 0; i < m_aryDeletedMedications.GetSize(); i++) {
			EMNMedication *pMed = m_aryDeletedMedications.GetAt(i);
			delete pMed;
		}
		m_aryDeletedMedications.RemoveAll();

		for(i = 0; i < m_aryDeletedProviders.GetSize(); i++) {
			EMNProvider *pProv = m_aryDeletedProviders.GetAt(i);
			delete pProv;
		}
		m_aryDeletedProviders.RemoveAll();

		for(i = 0; i < m_aryDeletedSecondaryProviders.GetSize(); i++) {
			EMNProvider *pProv = m_aryDeletedSecondaryProviders.GetAt(i);
			delete pProv;
		}
		m_aryDeletedSecondaryProviders.RemoveAll();

		for(i = 0; i < m_aryDeletedTechnicians.GetSize(); i++) {
			EMNProvider *pProv = m_aryDeletedTechnicians.GetAt(i);
			delete pProv;
		}
		m_aryDeletedTechnicians.RemoveAll();

		for(i = 0; i < m_aryDeletedOtherProviders.GetSize(); i++) {
			EMNProvider *pProv = m_aryDeletedOtherProviders.GetAt(i);
			delete pProv;
		}
		m_aryDeletedOtherProviders.RemoveAll();
	}

	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	for(i=0;i<m_arypEMRTopics.GetSize();i++) {
		m_arypEMRTopics.GetAt(i)->SetHasMoved(FALSE);
	}

	
	//Handle deleted sub-topics.
	// (a.walling 2007-02-06 15:01) - PLID 24602
	// These delete statements used to be in GenerateSaveString; however the objects are referred to in
	// other GenerateSaveStrings further down the call stack. This of course led to a crash. So here they
	// are, since our save was successful, and all strings have been generated.
	for(i=0; i < m_arypDeletedTopics.GetSize(); i++) {
		delete m_arypDeletedTopics.GetAt(i); 
	}
	m_arypDeletedTopics.RemoveAll();


	//End all code for handling the update
	////////////////////////////

	/////////////////////////
	//Now call the update on all sub-topics

	if(!bUpdateRecordOnly) {
		for(int i=0;i<m_arypEMRTopics.GetSize();i++) {
			// (a.walling 2007-10-18 16:37) - PLID 27664 - Pass the array to gather all affected topics
			m_arypEMRTopics.GetAt(i)->PostSaveUpdate(FALSE, FALSE, parTopicsAffected);
		}
	}
	else {
		// (j.jones 2006-08-31 10:02) - PLID 22325 - PostSaveUpdate does not
		// maintain the order of saving, so we need to reference
		// m_arypOtherSavedTopics in order to ensure we call PostSaveUpdate
		// for all saved topics
		for(int i=0;i<m_arypOtherSavedTopics.GetSize();i++) {
			// (a.walling 2007-10-18 16:37) - PLID 27664 - Pass the array to gather all affected topics
			m_arypOtherSavedTopics.GetAt(i)->PostSaveUpdate(FALSE, FALSE, parTopicsAffected);
		}		
	}
	//do not delete the pointers, just clear the array
	m_arypOtherSavedTopics.RemoveAll();

	// (c.haag 2008-08-14 16:22) - PLID 30820 - We need to delete any problems flagged as deleted.
	{
		// (z.manning 2009-05-22 11:56) - PLID 34332 - Update problem links instead
		for(int nProblemLinkIndex = 0; nProblemLinkIndex < m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++)
		{
			CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
			if(pProblemLink != NULL && (pProblemLink->GetIsDeleted() || (pProblemLink->GetProblem() != NULL && pProblemLink->GetProblem()->m_bIsDeleted))) {
				m_apEmrProblemLinks.RemoveAt(nProblemLinkIndex--);
				delete pProblemLink;
			}
		}

		for(i = 0; i < m_aryCharges.GetSize(); i++)
		{
			EMNCharge *pCharge = (EMNCharge*)m_aryCharges.GetAt(i);
			if(pCharge) {
				//find each problem
				// (z.manning 2009-05-22 12:17) - PLID 34332 - Handle problem links instead
				for(int nProblemLinkIndex = 0; nProblemLinkIndex < pCharge->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++)
				{
					CEmrProblemLink *pProblemLink = pCharge->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
					if(pProblemLink != NULL && (pProblemLink->GetIsDeleted() || (pProblemLink->GetProblem() != NULL && pProblemLink->GetProblem()->m_bIsDeleted))) {
						pCharge->m_apEmrProblemLinks.RemoveAt(nProblemLinkIndex--);
						delete pProblemLink;
					}
				}
			}
		}

		//TES 6/15/2012 - PLID 50983 - Update our original charges array to be whatever we just saved
		m_aryOriginalCharges.Clear();
		for(i = 0; i < m_aryCharges.GetSize(); i++) {
			//TES 6/21/2012 - PLID 50983 - Don't copy new charges, we'll add them in PropagateNewID()
			if(m_aryCharges[i]->nID != -1) {
				EMNCharge *pOriginalCharge = new EMNCharge;
				*pOriginalCharge = *(m_aryCharges[i]);
				m_aryOriginalCharges.Add(pOriginalCharge);
			}
		}

		for(i = 0; i < m_aryDiagCodes.GetSize(); i++)
		{
			EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDiagCodes.GetAt(i);
			if(pDiag) {
				//find each problem
				// (z.manning 2009-05-22 12:17) - PLID 34332 - Handle problem links instead
				for(int nProblemLinkIndex = 0; nProblemLinkIndex < pDiag->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++)
				{
					CEmrProblemLink *pProblemLink = pDiag->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
					if(pProblemLink != NULL && (pProblemLink->GetIsDeleted() || (pProblemLink->GetProblem() != NULL && pProblemLink->GetProblem()->m_bIsDeleted))) {
						pDiag->m_apEmrProblemLinks.RemoveAt(nProblemLinkIndex--);
						delete pProblemLink;
					}
				}
			}
		}

		for(i = 0; i < m_aryMedications.GetSize(); i++)
		{
			EMNMedication *pMed = (EMNMedication*)m_aryMedications.GetAt(i);
			if(pMed) {
				//find each problem
				// (z.manning 2009-05-22 12:17) - PLID 34332 - Handle problem links instead
				for(int nProblemLinkIndex = 0; nProblemLinkIndex < pMed->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++)
				{
					CEmrProblemLink *pProblemLink = pMed->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
					if(pProblemLink != NULL && (pProblemLink->GetIsDeleted() || (pProblemLink->GetProblem() != NULL && pProblemLink->GetProblem()->m_bIsDeleted))) {
						pMed->m_apEmrProblemLinks.RemoveAt(nProblemLinkIndex--);
						delete pProblemLink;
					}
				}
			}
		}
	}

	// (c.haag 2008-07-11 16:20) - PLID 30607 - If this EMN is locked, refresh the more info todo list so that
	// the colors, if any, are washed away.
	if(2 == m_Status.nID) {
		if (GetInterface()) {
			GetInterface()->PostMessage(NXM_EMN_TODO_REFRESH_LIST, (WPARAM)this);
		}
	}

	// (a.walling 2007-04-05 16:44) - PLID 25454 - All saving is done either in the Pic container when closing, opening, or in SaveEMRObject.
			}

// (c.haag 2012-10-17) - PLID 52863 - This must be called after PropagateNewID for all ID's so that we can assign ID values to EMRTodosT.
void CEMN::UpdateUnsavedTodos()
{
	// (c.haag 2008-07-14 11:24) - PLID 30696 - Now that the EMN is saved, We need to flush
	// m_apCreatedTodosWhileUnsaved. Here's what we know:
	//
	// - The EMN was just saved, but not assigned an ID if it's new
	// - All todo alarms that m_apCreatedTodosWhileUnsaved points to have -1 RegardingID's.
	//
	// Here, we need to do two things:
	// 1. For all records in m_apCreatedTodosWhileUnsaved, update the todo RegardingID's to
	// the ID of its corresponding EMR entity (EMN or EMN Detail) if it's not -1
	// 2. Empty m_apCreatedTodosWhileUnsaved
	//
	int i;
	if (m_nID != -1 && m_apCreatedTodosWhileUnsaved.GetSize() > 0)
	{
		CString strIDs;
		for (i=0; i < m_apCreatedTodosWhileUnsaved.GetSize(); i++) {
			EMNTodo* p = m_apCreatedTodosWhileUnsaved[i];
			if (ttEMN == (TodoType)VarLong(p->vRegardingType)) {
				strIDs += FormatString("%d," ,p->nTodoID);
				delete p;
				m_apCreatedTodosWhileUnsaved.RemoveAt(i--);
			}
			else if (ttEMNDetail == (TodoType)VarLong(p->vRegardingType) && p->sai.pSourceDetail->GetID() != -1) {
				ExecuteParamSql(FormatString("UPDATE TodoList SET RegardingID = {INT} WHERE RegardingType = %d AND TaskID = {INT}",
					ttEMNDetail), p->sai.pSourceDetail->GetID(), p->nTodoID);

				// (c.haag 2012-10-17) - PLID 52863 - Update the smart stamp detail action field in EMRTodosT.
				// (c.haag 2012-10-31) - PLID 53440 - Use GetDetailImageStampID(). We expect the TableRowID object to return the
				// properly propogated detail image stamp ID.
				_variant_t vSmartStampDetailID = g_cvarNull;
				if (NULL != p->sai.GetTableRow() && NULL != p->sai.GetTableRow()->m_ID.GetDetailImageStampObject())
				{
					vSmartStampDetailID = p->sai.GetTableRow()->m_ID.GetDetailImageStampID();
				}
				// We always want to update this value even if it's NULL so that we're completely certain that the SourceDetailImageStampID
				// is accurate.
				ExecuteParamSql("UPDATE EMRTodosT SET SourceDetailImageStampID = {VT_I4} WHERE TaskID = {INT}"
					,vSmartStampDetailID, p->nTodoID);

				delete p;
				m_apCreatedTodosWhileUnsaved.RemoveAt(i--);
			}
			else {
				// This might be a todo alarm linked with a detail that was just created. This will be handled
				// in PropagateNew...()
			}
		}
		if (!strIDs.IsEmpty()) {
			strIDs.TrimRight(",");
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			ExecuteParamSql("UPDATE TodoList SET RegardingID = {INT} WHERE RegardingType = {CONST} AND TaskID IN ({INTSTRING})",
				m_nID, ttEMN, strIDs);
		}
	}

	// (c.haag 2008-07-14 15:06) - PLID 30607 - Clear the deleted todo list
	for (i=0; i < m_apDeletedTodosWhileUnsaved.GetSize(); i++) {
		delete m_apDeletedTodosWhileUnsaved[i];
	}
	m_apDeletedTodosWhileUnsaved.RemoveAll();
}

// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
void CEMN::SetStatus(EMNStatus emnStatus)
{
	m_Status = emnStatus;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

// (z.manning 2009-11-19 09:21) - PLID 35810
BYTE CEMN::GetPatientCreatedStatus()
{
	return m_nPatientCreatedStatus;
}

//(e.lally 2011-12-14) PLID 46968
void CEMN::SetPatientCreatedStatus(CEMN::EPatientCreatedStatus ePatientCreatedStatus)
{
	m_nPatientCreatedStatus = (BYTE)ePatientCreatedStatus;
}

// (a.walling 2010-04-05 13:15) - PLID 38060 - Also look for the spawned group table row
// (a.walling 2010-04-05 13:50) - PLID 38060 - Now will only fallback to TemplateTopicIDOnly when necessary
CEMRTopic* CEMN::GetTopicByTemplateTopicID(long nTemplateTopicID, long nSpawnedGroupID, CEMNDetail *pSourceDetail, SourceActionInfo* pSpawnedGroupSourceActionInfo)
{
	CEMRTopic* pTopic = NULL;
	if (pSpawnedGroupSourceActionInfo && !pSpawnedGroupSourceActionInfo->IsBlank()) {
		pTopic = GetTopicByTemplateTopicID_Internal(nTemplateTopicID, nSpawnedGroupID, pSourceDetail, pSpawnedGroupSourceActionInfo);
	}
	
	// if we don't get anything above, or we were not passed in a table row, then check without one
	if (!pTopic) {
		pTopic = GetTopicByTemplateTopicID_Internal(nTemplateTopicID, nSpawnedGroupID, pSourceDetail, NULL);
	}

	// if nothing that way, then just lookup by the ID
	if (!pTopic) {
		pTopic = GetTopicByTemplateTopicIDOnly(nTemplateTopicID);
	}

	return pTopic;
}

// (a.walling 2010-04-05 13:50) - PLID 38060 - Actually performs the lookup
CEMRTopic* CEMN::GetTopicByTemplateTopicID_Internal(long nTemplateTopicID, long nSpawnedGroupID, CEMNDetail *pSourceDetail, SourceActionInfo* pSpawnedGroupSourceActionInfo )
{
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//First, try to match both.
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		//Check this topic.

		// (j.jones 2007-01-12 12:31) - PLID 24027 - I simplified this into booleans.
		// bSourceDetailOK means that we have no source detail object, or that they match

		BOOL bTemplateTopicIDsMatch = (m_arypEMRTopics[i]->GetTemplateTopicID() == nTemplateTopicID);
		BOOL bSpawnedGroupIDsMatch = (m_arypEMRTopics[i]->GetSpawnedGroupID() == nSpawnedGroupID);
		// (a.walling 2010-04-05 13:22) - PLID 38060
		BOOL bSpawnedGroupSourceActionInfoMatches = pSpawnedGroupSourceActionInfo ? FALSE : TRUE;
		BOOL bSourceDetailOK = FALSE;

		//if we have an object, see that the pointer matches the topic source,
		//or that the source detail IDs match
		if(pSourceDetail) {
			
			if(m_arypEMRTopics[i]->GetSourceDetail()) {
				if(pSourceDetail == m_arypEMRTopics[i]->GetSourceDetail()) {
					bSourceDetailOK = TRUE;
				}
			}

			if(m_arypEMRTopics[i]->GetSourceDetailID() != -1) {
				if(m_arypEMRTopics[i]->GetSourceDetailID() == (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
					bSourceDetailOK = TRUE;
				}
			}
		}
		else {
			//no pointer, well that's ok, we just won't search by it
			bSourceDetailOK = TRUE;
		}

		// (a.walling 2010-04-05 13:23) - PLID 38060
		if (pSpawnedGroupSourceActionInfo) {
			SourceActionInfo saiCheck = m_arypEMRTopics[i]->GetSourceActionInfo();

			if (pSpawnedGroupSourceActionInfo->eaoSourceType == eaoEmrTableDropDownItem &&
				pSpawnedGroupSourceActionInfo->eaoSourceType == saiCheck.eaoSourceType &&
				pSpawnedGroupSourceActionInfo->TableRowMatches(saiCheck)) {

				bSpawnedGroupSourceActionInfoMatches = TRUE;
			}
		}

		if(bTemplateTopicIDsMatch && bSpawnedGroupIDsMatch && bSourceDetailOK && bSpawnedGroupSourceActionInfoMatches)
			return m_arypEMRTopics[i];

		//It wasn't this topic, was it one of the subtopics?
		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByTemplateTopicIDAndSpawnedGroupID(nTemplateTopicID, nSpawnedGroupID, pSourceDetail, pSpawnedGroupSourceActionInfo);
		if(pTmp)
			return pTmp;
	}
	//None of the topics came directly from this template topic, maybe one of them came originally from it.
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {

		// (j.jones 2007-01-12 12:31) - PLID 24027 - I simplified this into booleans.
		// bSourceDetailOK means that we have no source detail object, or that they match

		BOOL bOriginalTemplateTopicIDsMatch = (m_arypEMRTopics[i]->GetOriginalTemplateTopicID() == nTemplateTopicID);
		BOOL bSpawnedGroupIDsMatch = (m_arypEMRTopics[i]->GetSpawnedGroupID() == nSpawnedGroupID);
		// (a.walling 2010-04-05 13:22) - PLID 38060
		BOOL bSpawnedGroupSourceActionInfoMatches = pSpawnedGroupSourceActionInfo ? FALSE : TRUE;
		BOOL bSourceDetailOK = FALSE;

		//if we have an object, see that the pointer matches the topic source,
		//or that the source detail IDs match
		if(pSourceDetail) {
			
			if(m_arypEMRTopics[i]->GetSourceDetail()) {
				if(pSourceDetail == m_arypEMRTopics[i]->GetSourceDetail()) {
					bSourceDetailOK = TRUE;
				}
			}

			if(m_arypEMRTopics[i]->GetSourceDetailID() != -1) {
				if(m_arypEMRTopics[i]->GetSourceDetailID() == (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
					bSourceDetailOK = TRUE;
				}
			}
		}
		else {
			//no pointer, well that's ok, we just won't search by it
			bSourceDetailOK = TRUE;
		}

		// (a.walling 2010-04-05 13:23) - PLID 38060
		if (pSpawnedGroupSourceActionInfo) {
			SourceActionInfo saiCheck = m_arypEMRTopics[i]->GetSourceActionInfo();

			if (pSpawnedGroupSourceActionInfo->eaoSourceType == eaoEmrTableDropDownItem &&
				pSpawnedGroupSourceActionInfo->eaoSourceType == saiCheck.eaoSourceType &&
				pSpawnedGroupSourceActionInfo->TableRowMatches(saiCheck)) {

				bSpawnedGroupSourceActionInfoMatches = TRUE;
			}
		}

		if(bOriginalTemplateTopicIDsMatch && bSpawnedGroupIDsMatch && bSourceDetailOK && bSpawnedGroupSourceActionInfoMatches)
			return m_arypEMRTopics[i];

		//It wasn't this topic, was it one of the subtopics?
		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByOriginalTemplateTopicIDAndSpawnedGroupID(nTemplateTopicID, nSpawnedGroupID, pSourceDetail, pSpawnedGroupSourceActionInfo);
		if(pTmp) {
			return pTmp;
		}
	}
	//Not found so far, try matching just nTemplateTopicID.
	// (a.walling 2010-04-05 11:09) - PLID 38060
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		// (a.walling 2010-04-05 13:22) - PLID 38060
		BOOL bSpawnedGroupSourceActionInfoMatches = pSpawnedGroupSourceActionInfo ? FALSE : TRUE;

		if(m_arypEMRTopics[i]->GetTemplateTopicID() == nTemplateTopicID) {
			

			// (a.walling 2010-04-05 13:23) - PLID 38060
			if (pSpawnedGroupSourceActionInfo) {
				SourceActionInfo saiCheck = m_arypEMRTopics[i]->GetSourceActionInfo();

				if (pSpawnedGroupSourceActionInfo->eaoSourceType == eaoEmrTableDropDownItem &&
					pSpawnedGroupSourceActionInfo->eaoSourceType == saiCheck.eaoSourceType &&
					pSpawnedGroupSourceActionInfo->TableRowMatches(saiCheck)) {

					bSpawnedGroupSourceActionInfoMatches = TRUE;
				}
			}

			if (bSpawnedGroupSourceActionInfoMatches) {
				return m_arypEMRTopics[i];
			}
		}

		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		// (a.walling 2010-04-05 11:09) - PLID 38060
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByTemplateTopicIDAndSpawnedGroupIDOnly(nTemplateTopicID, nSpawnedGroupID, pSpawnedGroupSourceActionInfo);
		if(pTmp) {
			return pTmp;
		}
	}
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		// (a.walling 2010-04-05 13:22) - PLID 38060
		BOOL bSpawnedGroupSourceActionInfoMatches = pSpawnedGroupSourceActionInfo ? FALSE : TRUE;

		if(m_arypEMRTopics[i]->GetOriginalTemplateTopicID() == nTemplateTopicID) {


			// (a.walling 2010-04-05 13:23) - PLID 38060
			if (pSpawnedGroupSourceActionInfo) {
				SourceActionInfo saiCheck = m_arypEMRTopics[i]->GetSourceActionInfo();

				if (pSpawnedGroupSourceActionInfo->eaoSourceType == eaoEmrTableDropDownItem &&
					pSpawnedGroupSourceActionInfo->eaoSourceType == saiCheck.eaoSourceType &&
					pSpawnedGroupSourceActionInfo->TableRowMatches(saiCheck)) {

					bSpawnedGroupSourceActionInfoMatches = TRUE;
				}
			}

			if (bSpawnedGroupSourceActionInfoMatches) {
				return m_arypEMRTopics[i];
			}
		}

		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		// (a.walling 2010-04-05 11:09) - PLID 38060
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByOriginalTemplateTopicIDAndSpawnedGroupIDOnly(nTemplateTopicID, nSpawnedGroupID, pSpawnedGroupSourceActionInfo);
		if(pTmp) {
			return pTmp;
		}
	}
	//Not found!
	return NULL;
}

// (a.walling 2010-04-05 13:50) - PLID 38060 - Fallback if nothing found above
CEMRTopic* CEMN::GetTopicByTemplateTopicIDOnly(long nTemplateTopicID)
{
	int i = 0;
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->GetTemplateTopicID() == nTemplateTopicID) {
			return m_arypEMRTopics[i];
		}

		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByTemplateTopicIDOnly(nTemplateTopicID);
		if(pTmp) {
			return pTmp;
		}
	}
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->GetOriginalTemplateTopicID() == nTemplateTopicID) {
			return m_arypEMRTopics[i];
		}

		// (z.manning 2008-09-03 12:56) - PLID 31235 - GetSubTopicByTemplateTopicID was split into 4 functions
		CEMRTopic *pTmp = m_arypEMRTopics[i]->GetSubTopicByOriginalTemplateTopicIDOnly(nTemplateTopicID);
		if(pTmp) {
			return pTmp;
		}
	}
	//Not found!
	return NULL;
}

//TES 4/15/2010 - PLID 24692 - Added nTopicID parameter
CEMRTopic* CEMN::AddTopic(CString strTopicName, long nTopicID)
{
	SourceActionInfo saiBlank;
	return AddTopic(strTopicName, saiBlank, nTopicID);
}

//TES 4/15/2010 - PLID 24692 - Added nTopicID parameter
CEMRTopic* CEMN::AddTopic(CString strTopicName, SourceActionInfo &sai, long nTopicID)
{
	//TES 4/15/2010 - PLID 24692 - Need to assign this to a position in our linked list; either attach it to an existing entry, if any,
	// or create a new entry
	TopicPositionEntry *tpeNew = NULL;
	if(nTopicID != -1) {
		tpeNew = GetTopicPositionEntryByID(nTopicID);
	}
	if(tpeNew == NULL) {
		tpeNew = new TopicPositionEntry;
		tpeNew->nTopicID = nTopicID;
	}
	//TES 4/15/2010 - PLID 24692 - Now we've got it, make sure it gets put at the end, where our topic is going.
	m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpeNew, -1);
	CEMRTopic *pTopic = new CEMRTopic(this, tpeNew);
	pTopic->SetName(strTopicName);
	//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
	pTopic->SetSourceActionInfo(sai);
	m_arypEMRTopics.Add(pTopic);
	m_bTopicArrayChanged = TRUE;
	return pTopic;
}

int CEMN::GetDiagCodeCount()
{
	return m_aryDiagCodes.GetSize();
}

EMNDiagCode* CEMN::GetDiagCode(int nIndex)
{
	return m_aryDiagCodes[nIndex];
}

void CEMN::AddDiagCode(EMNDiagCode* pCode)
{
	// (j.jones 2007-01-05 10:07) - PLID 24070 - if OrderIndex is -1, auto-generate it
	if(pCode->nOrderIndex == -1)
		pCode->nOrderIndex = m_aryDiagCodes.GetSize() + 1;

	m_aryDiagCodes.Add(pCode);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	//TES 2/21/2014 - PLID 60972 - Diagnosis Codes are on the Codes topic now
	SetCodesUnsaved();
}

//TES 2/26/2014 - PLID 60807 - Added ICD10
void CEMN::RemoveDiagCode(long nICD9DiagID, long nICD10DiagID)
{
	for(int i = m_aryDiagCodes.GetSize()-1; i >= 0; i--) {
		if(m_aryDiagCodes[i]->nDiagCodeID == nICD9DiagID && m_aryDiagCodes[i]->nDiagCodeID_ICD10 == nICD10DiagID) {
			RemoveDiagCodeByIndex(i);

			// (j.jones 2012-10-01 15:50) - PLID 52869 - this function will check their preference
			// to save the EMN and warn about drug interactions
			if(!m_bIsTemplate && !IsLoading()) {
				CheckSaveEMNForDrugInteractions(FALSE);
			}
		}
	}
}

// (j.jones 2014-12-23 15:40) - PLID 64491 - exposed this publicly
void CEMN::AddDeletedDiagCode(EMNDiagCode *pDeletedCode)
{
	m_aryDeletedDiagCodes.Add(pDeletedCode);
}

void CEMN::RemoveDiagCodeByIndex(int nIndex)
{
	long nDiagCodeID = m_aryDiagCodes[nIndex]->nDiagCodeID;
	long nDiagCodeID_ICD10 = m_aryDiagCodes[nIndex]->nDiagCodeID_ICD10;
	BOOL bIsNewDiag = m_aryDiagCodes[nIndex]->bIsNew;
	long nOrderIndex = m_aryDiagCodes[nIndex]->nOrderIndex;

	// (c.haag 2008-07-23 13:42) - PLID 30820 - We now store deleted diag codes in their fullest form, not as ID's
	//TES 3/3/2014 - PLID 61079 - Check both IDs
	if((nDiagCodeID != -1 || nDiagCodeID_ICD10 != -1) && bIsNewDiag == FALSE) {
		m_aryDeletedDiagCodes.Add(m_aryDiagCodes[nIndex]);
	} else {
		delete m_aryDiagCodes[nIndex];
	}
	m_aryDiagCodes.RemoveAt(nIndex);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	//TES 2/21/2014 - PLID 60972 - Diagnosis Codes are on the Codes topic now
	SetCodesUnsaved();

	// (j.jones 2007-01-05 11:49) - PLID 24070 - now update the order index of remaining diag codes
	for(int i=0;i<m_aryDiagCodes.GetSize();i++) {
		if(m_aryDiagCodes.GetAt(i)->nOrderIndex > nOrderIndex) {
			m_aryDiagCodes.GetAt(i)->nOrderIndex--;
			// (r.farnworth 2014-03-27 07:49) - PLID 61554 - OrderIndex in EMRDiagCodesT was not properly updating resulting in bad data
			m_aryDiagCodes.GetAt(i)->bChanged = TRUE;
		}
	}

	//TES 3/3/2014 - PLID 61080 - Charges now link to codes based on their index in m_aryDiagCodes, so update them accordingly
	for(int nCharge = 0; nCharge < m_aryCharges.GetSize(); nCharge++) {
		EMNCharge* pCharge = m_aryCharges[nCharge];
		for(int nDiag = 0; nDiag < pCharge->aryDiagIndexes.GetSize(); nDiag++) {
			long nDiagIndex = pCharge->aryDiagIndexes[nDiag];
			if(nDiagIndex == nIndex) {
				pCharge->aryDiagIndexes.RemoveAt(nDiag);
				nDiag--;
			}
			else if(nDiagIndex > nIndex) {
				pCharge->aryDiagIndexes.SetAt(nDiag, nDiagIndex-1);
			}
		}
	}
}	

int CEMN::GetChargeCount()
{
	return m_aryCharges.GetSize();
}

//DRT 1/11/2007 - PLID 24220 - Replaced the previous function that returned
//	an object by reference with this version that returns the object pointer 
//	in the array.
EMNCharge* CEMN::GetCharge(int nIndex)
{
	//Ensure that the index is in bounds
	if(nIndex < 0 || nIndex >= m_aryCharges.GetSize()) {
		//Out of bounds
		ASSERT(FALSE);
		return NULL;
	}

	return m_aryCharges[nIndex];
}

//DRT 1/11/2007 - PLID 24220 - Removed SetCharge altogether.  Since GetCharge
//	now returns a pointer to the actual object, there's no need to load it
//	into the array again.  This does however require that the user change the 
//	bChanged flag in the EMNCharge structure.
//
//void CEMN::SetCharge(int nIndex, IN EMNCharge ec)
//

void CEMN::AddCharge(EMNCharge *pCharge)
{
	m_aryCharges.Add(pCharge);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	//TES 2/21/2014 - PLID 60972 - Charges are on the Codes topic now
	SetCodesUnsaved();
}

// (c.haag 2010-07-01 11:52) - PLID 36061
void CEMN::AddLab(EMNLab* pLab)
{
	m_aryLabs.Add(pLab);
}

//DRT 1/10/2007 - PLID 24182 - Added optional fields for qty and 4 modifiers, since we now support defaults
//	per action in the administrator setup.
// (j.jones 2008-06-04 16:20) - PLID 30255 - added nQuoteChargeID
// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
EMNCharge* CEMN::AddCharge(EmrAction *pSourceAction, SourceActionInfo &sai)
{
	// (j.jones 2011-07-11 09:34) - PLID 38366 - if this service is part of a coding group,
	// then TryUpdateCodingGroup will automatically handle adding the correct charge, otherwise
	// we need to add it ourselves
	if(!m_bIsTemplate) {
		if(TryUpdateCodingGroupByServiceID(pSourceAction->nDestID, (!IsLoading() && pSourceAction->bPrompt))) {
			//the addition has been handled per the coding group rules,
			//and we do not need to do anything further, so send NULL
			//as a return value
			return NULL;
		}
	}

	// (j.jones 2012-03-27 15:10) - PLID 44763 - warn if we're under a global period
	if(GetParentEMR() && GetParentEMR()->GetInterface()) {
		GetParentEMR()->GetInterface()->CheckWarnGlobalPeriod_EMR(m_dtEMNDate);
	}

	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	// (j.jones 2011-03-28 14:45) - PLID 42575 - loaded Billable
	// (s.tullis 2015-03-31 17:46) - PLID 64979 -Need to support spawning and setting the Emr Charge Category
	_RecordsetPtr rs = CreateParamRecordset("SELECT ServiceT.ID, Code, SubCode, Name, Price, Billable,COALESCE(ServiceT.Category, -1 ) AS DefaultCategory ,COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount "
		"FROM ServiceT "
		"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
		"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
		"LEFT JOIN (Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount "
		"           FROM ServiceMultiCategoryT "
		"			Group BY ServiceID ) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ServiceT.ID "
		"WHERE ServiceT.ID = {INT}", pSourceAction->nDestID);

	EMNCharge *pCharge = new EMNCharge;
	pCharge->nID = -1;
	pCharge->nServiceID = pSourceAction->nDestID;
	pCharge->nCategoryID = AdoFldLong(rs, "DefaultCategory", -1);
	pCharge->nCategoryCount = AdoFldLong(rs,"CategoryCount", 0);
	pCharge->strDescription = AdoFldString(rs, "Name");
	pCharge->dblQuantity = pSourceAction->dblDefaultQuantity;
	pCharge->cyUnitCost = AdoFldCurrency(rs, "Price", COleCurrency(0,0));
	pCharge->bChanged = TRUE;
	pCharge->strSubCode = AdoFldString(rs, "SubCode", "");
	pCharge->strCode = AdoFldString(rs, "Code", "");
	pCharge->strMod1 = pSourceAction->strMod1;
	pCharge->strMod2 = pSourceAction->strMod2;
	pCharge->strMod3 = pSourceAction->strMod3;
	pCharge->strMod4 = pSourceAction->strMod4;
	// (j.jones 2011-03-28 14:45) - PLID 42575 - added Billable flag
	pCharge->bBillable = AdoFldBool(rs, "Billable", TRUE);

	// (z.manning 2009-02-24 17:57) - PLID 33141 - We use the source action info class for all the
	// source detail and source action stuff.
	pCharge->sai = sai;

	// (j.jones 2012-08-22 09:23) - PLID 50486 - set the default insured party ID
	pCharge->nInsuredPartyID = GetParentEMR()->GetDefaultChargeInsuredPartyID();

	//DRT 1/11/2007 - PLID 24182 - Additionally, ANY charge that is added that is set to prompt, or has a default quantity
	//	that is not 1.0, or has any default modifier must prompt with those changes, and allow the user to make any other
	//	changes they wish.  This allows them ease in setting up their coding while working through the EMR, instead of having
	//	to remember it all to review at the <More Info> stage.
	//DRT 8/16/2007 - PLID 26495 - Do not popup if we are in the initial load.
	// (z.manning 2010-04-29 16:24) - PLID 37638 - We no longer prompt for non 1.0 default quantity or default modifiers.
	if(!IsLoading() && pSourceAction->bPrompt) {
		//Must prompt
		// (a.walling 2007-09-07 09:15) - PLID 24371 - Ensure that the dialog has a proper parent window.
		//TES 1/29/2008 - PLID 24157 - If we have an open multipopup dialog, use that.
		CWnd *pParent = NULL;
		CEMRItemAdvMultiPopupDlg *pDlg = GetOpenMultiPopupDlg();
		if(pDlg) {
			pParent = pDlg;
		}
		else {
			pParent = GetParentEMR() ? GetParentEMR()->GetInterface() : NULL;
		}
		CEMNChargeArray arypCharges;
		arypCharges.Add(pCharge);
		// (j.jones 2012-01-26 11:19) - PLID 47700 - added patient ID, and an optional EMNID,
		// both are -1 if this is a template, EMNID is -1 if unsaved
		CEMRChargePromptDlg dlg(pParent, m_bIsTemplate ? -1 : m_pParentEMR->GetPatientID(), &arypCharges, m_bIsTemplate ? -1 : GetID());
		if(dlg.DoModal() == IDOK) {
			// (z.manning 2011-07-07 16:31) - PLID 44469 - So yeah, all this was doing is setting a pointer to itself.
			// Whether or not the changes get applied is handled in CEMRChargePromptDlg::OnOK.
			//pCharge = dlg.m_pCharge;
		}
		else {
			//The cancel button is phrased that it will not commit their changes, but the spawn will still happen.  We may
			//	in the future decide a "Cancel the Spawn" makes sense, but for now, we don't feel it would ever be wanted.
		}
	}

	AddCharge(pCharge);
	return pCharge;
}

void CEMN::RemoveCharge(long nServiceID)
{
	for(int i = m_aryCharges.GetSize()-1; i >= 0; i--) {
		if(m_aryCharges[i]->nServiceID == nServiceID) {
			RemoveChargeByIndex(i);
		}
	}
}

//DRT 1/11/2007 - PLID 24220 - Fixed the charge array to always work
//	by pointer, so now we need a way to remove them by pointer.
void CEMN::RemoveCharge(EMNCharge *pCharge)
{
	//Loop through all charges until we find the one
	for(int i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge *pTest = m_aryCharges.GetAt(i);

		if(pTest == pCharge) {
			//Use the existing functionality
			RemoveChargeByIndex(i);
			return;	//There can be only one
		}
	}

	//Not found.  I would assert here, but the other approaches don't seem to, 
	//	and it may be relied upon somewhere.
}

void CEMN::RemoveChargeByIndex(int nIndex)
{
	long nID = m_aryCharges[nIndex]->nID;

	// (j.jones 2007-08-30 10:15) - PLID 27221 - added a pending audit info array, for E/M Checklist purposes
	for(int i=m_aryCharges[nIndex]->aryPendingEMAuditInfo.GetSize()-1; i>=0; i--) {
		delete (CPendingAuditInfo*)m_aryCharges[nIndex]->aryPendingEMAuditInfo.GetAt(i);
	}
	m_aryCharges[nIndex]->aryPendingEMAuditInfo.RemoveAll();

	// (j.jones 2011-07-14 09:26) - PLID 44509 - if this charge was in either coding group map, remove it
	m_mapChargeIDsTo_ModifiedByCodingGroupID.RemoveKey(nID);
	m_mapChargesTo_CreatedByCodingGroupID.RemoveKey(m_aryCharges[nIndex]);

	// (c.haag 2008-07-23 13:43) - PLID 30820 - Transfer the charge object to the deleted charge array
	if(nID != -1) {
		m_aryDeletedCharges.Add(m_aryCharges[nIndex]);
	} else {
		delete m_aryCharges[nIndex];
	}

	m_aryCharges.RemoveAt(nIndex);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	//TES 2/21/2014 - PLID 60972 - Charges are on the Codes topic now
	SetCodesUnsaved();
}

int CEMN::GetMedicationCount()
{
	return m_aryMedications.GetSize();
}

// (a.walling 2007-10-01 08:43) - PLID 27568 - return a pointer to the medication
EMNMedication* CEMN::GetMedicationPtr(int nIndex)
{
	return m_aryMedications[nIndex];
}

void CEMN::AddMedication(EMNMedication *pMedication)
{
	m_aryMedications.Add(pMedication);
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

// (a.walling 2007-10-01 08:54) - PLID 27568 - Remove medications by pointer so there can be no ambiguity
void CEMN::RemoveMedication(EMNMedication* pMed)
{
	for(int i = m_aryMedications.GetSize()-1; i >= 0; i--) {
		if(m_aryMedications[i] == pMed) {
			RemoveMedicationByIndex(i);

			// (j.jones 2012-10-01 08:48) - PLID 52922 - this function will check their preference
			// to save the EMN and warn about drug interactions
			if(!m_bIsTemplate && !IsLoading()) {
				// (j.jones 2012-11-13 10:10) - PLID 52869 - changed to be a posted message
				// (j.jones 2013-02-06 16:28) - PLID 55045 - Medication changes save immediately now,
				// so pass in TRUE for the lParam to tell this function that we already saved the changes
				// and the interactions should open if it was otherwise waiting for a save to succeed.
				CheckSaveEMNForDrugInteractions(TRUE);
			}
		}
	}
}

void CEMN::RemoveMedicationByIndex(int nIndex)
{
	long nID = m_aryMedications[nIndex]->nID;
	// (c.haag 2008-07-23 13:47) - PLID 30820 - We now store deleted medications in the form of objects, not ID's
	if(nID != -1) {
		//m_aryDeletedMedications.Add(m_aryMedications[nIndex]);

		// (j.jones 2012-11-14 16:47) - PLID 52819 - use the API to delete immediately
		CArray<NexTech_Accessor::_QueuePrescriptionPtr,NexTech_Accessor::_QueuePrescriptionPtr> aryPrescriptions;
		NexTech_Accessor::_QueuePrescriptionPtr pPrescription(__uuidof(NexTech_Accessor::QueuePrescription));
		// (j.fouts 2013-02-06 17:53) - PLID 51712 - Changed ID fields to be passed as strings
		CString strPrescriptionID;
		strPrescriptionID.Format("%li", nID);
		pPrescription->PrescriptionID = _bstr_t(strPrescriptionID);
		// (j.jones 2012-11-21 12:21) - PLID 53818 - must set the template flag so the API knows this
		// is a template prescription ID, not a patient prescription ID
		// (b.savon 2013-03-08 13:16) - PLID 55518 - Change to use EMNSpawnSource obj
		NexTech_Accessor::_EMNSpawnSourcePtr pEMRPrescriptionSource(__uuidof(NexTech_Accessor::EMNSpawnSource));
		pEMRPrescriptionSource->IsEMRTemplate = m_bIsTemplate;
		pPrescription->EMRPrescriptionSource = pEMRPrescriptionSource;

		//Send our current prescription to the API
		aryPrescriptions.Add(pPrescription);
		Nx::SafeArray<IUnknown *> saryPrescriptions = Nx::SafeArray<IUnknown *>::From(aryPrescriptions);
		NexTech_Accessor::_UpdatePresQueueExpectedResultsPtr pRequest(__uuidof(NexTech_Accessor::UpdatePresQueueExpectedResults));

		//delete this prescription
		pRequest->Action = NexTech_Accessor::UpdatePresQueueAction_Delete;
		//Deleting can change interactions
		pRequest->DrugDrugInteracts = TRUE;
		// (b.savon 2014-01-28 10:31) - PLID 60499 - Don't return monograph data when updating the queue and doing drug interaction checks
		pRequest->ExcludeMonographInformation = VARIANT_TRUE;
		pRequest->DrugAllergyInteracts = TRUE;
		pRequest->DrugDiagnosisInteracts = TRUE;
		pRequest->RequeryQueue = FALSE;

		// (b.savon 2013-03-12 12:59) - PLID 55518 - Use new object to pass and remove last parameter
		pRequest->PrescriptionsToDelete = saryPrescriptions;

		// (j.fouts 2013-04-24 16:54) - PLID 52906 - Cleaned up the UpdatePrescriptionQueue PersonID Parameter
		GetAPI()->UpdatePrescriptionQueue(
			GetAPISubkey(), GetAPILoginToken(), _bstr_t(FormatString("%li", GetParentEMR()->GetPatientID())), pRequest);

		//clear the memory object
		delete m_aryMedications[nIndex];
	} else {
		delete m_aryMedications[nIndex];
	}
	m_aryMedications.RemoveAt(nIndex);	
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	// (j.jones 2012-11-14 16:47) - PLID 52819 - we've already saved in the API, so we don't need to save again
	//SetMoreInfoUnsaved();
}

void CEMN::RemoveTopic(CEMRTopic *pTopic)
{
	for(int i = m_arypEMRTopics.GetSize() - 1; i >= 0 ; i--) {
		if(m_arypEMRTopics[i] == pTopic) {
			//We have to revoke all the actions for this topic's details.
			//DRT 7/30/2007 - PLID 26876 - Instead of looping through every detail and removing it singly, just
			//	run 1 function that will delete everything.  This keeps us from having to do a bunch of time
			//	consuming overhead, like updating narratives, shifting around topic member variables, etc.  We
			// will let this function do that all once.
			pTopic->RemoveThisTopicAndSubTopics();

			//TES 4/15/2010 - PLID 24692 - Need to remove this topic from our linked list of topic positions.
			// (z.manning 2010-04-19 10:28) - PLID 24692 - Handle this after we remove subtopics because they
			// need to reference their topic position pointers.
			TopicPositionEntry *tpeDoomed = pTopic->GetTopicPositionEntry();
			m_pTopicPositionHead = DetachTopicPositionEntry(m_pTopicPositionHead, tpeDoomed);
			//TES 4/15/2010 - PLID 24692 - Now clean up its memory.
			tpeDoomed->FreeDescendants();
			delete tpeDoomed;

			if(m_arypEMRTopics.GetSize() <= i ||
				m_arypEMRTopics[i] != pTopic) {
				//the topic list has been decremented and we don't match anymore!
				//restart
				i = m_arypEMRTopics.GetSize() - 1;
				continue;
			}
			m_arypDeletedTopics.Add(pTopic);
			m_arypEMRTopics.RemoveAt(i);
			m_bTopicArrayChanged = TRUE;
			return;
		}
	}
}

int CEMN::GetProcedureCount()
{
	return m_aryProcedures.GetSize();
}

EMNProcedure* CEMN::GetProcedure(int nIndex)
{
	return m_aryProcedures[nIndex];
}

void CEMN::RemoveProcedure(long nProcedureID)
{
	for(int i = m_aryProcedures.GetSize()-1; i >= 0; i--) {
		if(m_aryProcedures[i]->nID == nProcedureID) {
			RemoveProcedureByIndex(i);
		}
	}
}

void CEMN::RemoveProcedureByIndex(int nIndex)
{
	EMNProcedure *pProc = m_aryProcedures[nIndex];
	long nID = pProc->nID;
	m_aryProcedures.RemoveAt(nIndex);
	//TES 2/8/2012 - PLID 19441 - The deleted list now stores the pointer, not just the ID, so either add to that list, or clean up the pointer.
	if(pProc->nID != -1 && !pProc->bIsNew) {
		m_aryDeletedProcedures.Add(pProc);
	}
	else {
		delete pProc;
	}
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();

	// (z.manning, 01/31/2007) - PLID 24468 - Revoke any actions this procedure spawned.
	if(GetParentEMR()) {
		CArray<long,long> aryProcedureIDs;
		aryProcedureIDs.Add(nID);
		GetParentEMR()->RevokeEMRProcedureActions(aryProcedureIDs, this);
	}

	// (z.manning 2011-11-11 10:00) - PLID 37093 - Update procedure narrative fields
	// (j.jones 2012-12-27 15:25) - PLID 54369 - the above item was never finished, and this created broken, half-working code
	//UpdateAllProcedureNarrativeFields();
}

// (z.manning 2008-10-29 12:42) - PLID 31613 - Returns the lab object for the given ID
EMNLab* CEMN::GetLabByID(const long nLabID)
{
	for(int nLabIndex = 0; nLabIndex < m_aryLabs.GetSize(); nLabIndex++)
	{
		EMNLab *pLab = m_aryLabs.GetAt(nLabIndex);
		if(pLab->nID == nLabID) {
			return pLab;
		}
	}

	return NULL;
}

// (z.manning 2008-10-24 14:04) - PLID 23688 - Removes a lab from the EMN
void CEMN::RemoveLab(const long nLabID)
{
	for(int nLabIndex = 0; nLabIndex < m_aryLabs.GetSize(); nLabIndex++) {
		EMNLab *pLab = m_aryLabs.GetAt(nLabIndex);
		if(pLab->nID == nLabID) {
			delete pLab;
			m_aryLabs.RemoveAt(nLabIndex);
			nLabIndex--;
		}
	}
}

void CEMN::UpdateTableItemList()
{
	m_bNeedRegenerateTableItemList = TRUE;
}

// (z.manning 2009-03-04 15:59) - PLID 33338 - Replaced the calls to GetSource<whatever> with this
SourceActionInfo CEMN::GetSourceActionInfo()
{
	return m_sai;
}

//TES 2/15/2007 - PLID 24717 - Josh added tables with linked details to this function two years ago, it's time that the name
// of the function reflected that.
//TES 1/23/2008 - PLID 24157 - Renamed from UpdateNarrativesAndLinkedTables() to HandleDetailChange(), which is a more
// accurate description of the role of this function.  Also took out bCreate, which was always FALSE.
void CEMN::HandleDetailChange(CEMNDetail *pInfo, BOOL bRemovingItem /*= FALSE*/)
{
	if (pInfo == NULL) {
		// (a.walling 2009-11-19 15:08) - PLID 36365 - generic info may have changed. Need to reload.
		LoadGenericNarrativeFields(m_mapGenericMergeFields);
		LoadEmnNarrativeFields(m_mapGenericMergeFields);
	}

	// (z.manning, 07/11/2006) - PLID 19291 - Something (e.g. mass action processes) may
	// not want us to do this, so let's just get out if that's the case.
	if(m_nDetailChangeLocks > 0) {
		//TES 2/15/2007 - PLID 24717 - We need to remember what was requested, so we can process it efficiently.
		PendingChangedDetail pcd;
		pcd.pDetail = pInfo;
		//Lock the detail so it doesn't get deleted before we've processed it.
		GetParentEMR()->AddEMNDetailReference(pInfo);
		pcd.bRemovingItem = bRemovingItem;
		m_arPendingChangedDetails.Add(pcd);
		
		//TES 4/11/2007 - PLID 25456 - If one of our details is currently popped up, and it's a narrative, update it, because
		// whatever change we're updating was almost certainly caused by the user clicking on a field in this popped-up
		// narrative.
		// (a.walling 2007-08-23 11:28) - PLID 27160 - It is possible for multiple items to be popped up
		POSITION pos = m_lstPoppedUpDetails.GetHeadPosition();
		while (pos) {
			CEMNDetail* pPoppedUpDetail = m_lstPoppedUpDetails.GetNext(pos);
				if(pPoppedUpDetail && pPoppedUpDetail->m_EMRInfoType == eitNarrative) {

					// (c.haag 2007-07-30 15:15) - PLID 26858 - If we get here, we mean to only update
					// a single detail's narrative. To ensure that no other details are affected, we will
					// break this detail's dependency on its parent EMN for maintaining its narrative
					// merge field list
					// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated
					/*
					if (pPoppedUpDetail->GetUsingParentEMNMergeFieldMap()) {
						pPoppedUpDetail->SetUsingParentEMNMergeFieldMap(FALSE);
					}
					*/
					UpdateNarrative(pInfo, pPoppedUpDetail, bRemovingItem);
				}
		}

		return;
	}

	CEMNDetail *pSpawningDetail = NULL;
	if(pInfo != NULL)
	{
		pSpawningDetail = pInfo->FindSpawningItem(false);

		if(pSpawningDetail != NULL)
		{
			// (z.manning 2011-11-29 17:24) - PLID 42765 - If the spawning item of the detail being updated is a table
			// then we need to refresh the table's cached output in case anything (e.g. a narrative) is outputting this
			// table. This is necessary because of the Spawned Items fields that's available in table items' sentence formats.
			if(pSpawningDetail->m_EMRInfoType == eitTable && IsDetailLinkableOnTable(pInfo)) {
				if(pSpawningDetail->HasSpawnedItemsField()) {
					pSpawningDetail->UpdateTableDataOutput();
				}
			}
		}
	}

	// (j.jones 2005-03-21 14:42) - I hijacked this function to also update the "linked"
	// column types in tables, which are like mini-narratives
	
	//TES 2/24/2006 - First off, make sure our list of items for the linked tables is up to date.
	UpdateTableItemList();

	//TES 1/3/2006 - Allowing pInfo to be NULL, for when something like the provider or date changes.

	//if not an image or a table (neither are supported in Narratives or Table "Linked Detail" columns
	// (a.walling 2009-11-18 12:04) - PLID 36365 - Also exclude narratives
	//TES 2/25/2010 - PLID 37535 - Allow tables that use the Smart Stamp format to be in narratives
	BOOL bLinkableItem = IsDetailLinkable(pInfo);

	long nTotalDetailCount = 0;
	if(!pInfo || bLinkableItem) {
		nTotalDetailCount = GetTotalDetailCount();

		//update all our narratives and tables

		//TES 3/24/2006 -If we're removing this detail, but another detail with the same name exists on this EMN, then update
		//our narratives to use that detail.
		if(bRemovingItem) {
			CEMNDetail *pDuplicate = NULL;
			for(int i = 0; i < nTotalDetailCount && !pDuplicate; i++) {
				CEMNDetail *pDetail = GetDetail(i);
				if(pDetail != pInfo && pDetail->GetLabelText() == pInfo->GetLabelText() && 
					pDetail->GetSpawnedGroupID() == pInfo->GetSpawnedGroupID() && pDetail->m_EMRInfoType != eitNarrative) {
					pDuplicate = pDetail;
				}
			}
			if(pDuplicate) {
				//Note how this can't be an infinite recursion, because we're passing FALSE for bRemovingItem.
				HandleDetailChange(pDuplicate);
				return;
			}
		}

		// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code
		// (a.walling 2009-11-18 12:05) - PLID 36365 - We already know this is not a narrative, image, or table
		//if (!pInfo || pInfo->m_EMRInfoType != eitNarrative) {
		{
			for(int i = 0; i < nTotalDetailCount; i++) {
				//if is a narrative (and our current item causing the update is not)
				CEMNDetail *pDetail = GetDetail(i);
				
				if(pDetail->m_EMRInfoType == eitNarrative) {
					// (a.walling 2009-11-19 14:55) - PLID 36369 - Only update if this narrative may actually have this detail
					if (!pInfo || pDetail->NarrativeMayHaveDetailField(pInfo)) {
						pDetail->UpdateNarrativeFields();
					} else if (pInfo) {
						// (a.walling 2010-04-01 14:49) - PLID 38013 - Need to see if this is used as an Item Spawning Text field
						SourceActionInfo saiDummy;
						if (pInfo && pDetail->NarrativeMayHaveDetailField(NFIELD_ITEM_SPAWNING_TEXT) && pInfo == pDetail->FindSpawningItem(false, saiDummy)) {
							pDetail->UpdateNarrativeFields();
						} else if (pInfo && pDetail->NarrativeMayHaveDetailField(NFIELD_ITEM_SPAWNING_TEXT_FURTHEST) && pInfo == pDetail->FindSpawningItem(true, saiDummy)) {
							pDetail->UpdateNarrativeFields();
						}
					}
				}
			}
		}

		// (a.walling 2010-03-29 11:02) - PLID 37923 - Attempt to update any narratives on other EMNs if applicable
		if (pInfo && bLinkableItem && !bRemovingItem) {
			try {
				CEMR* pEMR = GetParentEMR();
				if (pEMR) {				
					CStringArray saErrors;

					for (int i = 0; i < pEMR->GetEMNCount(); i++) {
						CEMN* pOtherEMN = pEMR->GetEMN(i);

						if (pOtherEMN && pOtherEMN != this && !pOtherEMN->IsLockedAndSaved() && !pOtherEMN->IsLoading()) {
							SourceActionInfo sai = pOtherEMN->GetSourceActionInfo();

							if (sai.pSourceDetail == pInfo || 
								(sai.pSourceDetail && sai.pSourceDetail->IsSmartStampImage() && sai.pSourceDetail->GetSmartStampTableDetail() == pInfo) || 
								(sai.nSourceDetailID != -1 && sai.nSourceDetailID == pInfo->GetID()))
							{
								if (pOtherEMN->EnsureSpawningEMNTextMergeField()) {	
									pOtherEMN->UpdateSpawningEMNTextMergeFieldNarratives(saErrors);
								}
							}
						}
					}
						
					// (a.walling 2008-08-11 17:36) - PLID 30515 - Warn the user if any EMNs could not be updated.
					if (saErrors.GetSize() > 0) {
						CString strErrors = "The following errors occurred updating narratives in other EMNs due to conflicts of write access: \r\n\r\n";
						for (int f = 0; f < saErrors.GetSize(); f++) {
							strErrors += saErrors[f] + "\r\n";
						}
						strErrors += "\r\nThe narratives will be updated the next time the EMNs are loaded.";

						// don't display any errors if we don't have an interface for some reason
						// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
						if (pInfo->m_pParentTopic && pInfo->m_pParentTopic->GetInterfaceWnd()) {
							pInfo->m_pParentTopic->GetInterfaceWnd()->MessageBox(strErrors, NULL, MB_ICONEXCLAMATION);
						}
					}
				}
			} NxCatchAll("Error updating narratives on other EMNs");
		}
	}

	// (a.walling 2009-11-24 16:45) - PLID 36365 - Need to update our fields if we are not already doing so
	if (pInfo && pInfo->m_EMRInfoType == eitNarrative && !pInfo->IsUpdatingNarrativeFields()) {
		pInfo->UpdateNarrativeFields();
	}

	// (a.walling 2009-11-18 12:06) - PLID 36365 - Always go to the popup, let it decide what to handle.
	//TES 6/3/2008 - PLID 29098 - Always do popups first, since they are what the user is currently interacting with.
	//TES 1/23/2008 - PLID 24157 - We also need to update this detail on our multipopup dialog, if we have one.
	if(m_pMultiPopupDlg) {
		// (a.walling 2010-03-25 08:19) - PLID 37802 - Pass in bRemovingItem to the multipopup so it can handle it properly
		m_pMultiPopupDlg->HandleDetailChange(pInfo, bRemovingItem);
	}
	
	if(!pInfo || bLinkableItem) {
		for(int i = 0; i < nTotalDetailCount; i++) {
			//if is a narrative (and our current item causing the update is not)
			CEMNDetail *pDetail = GetDetail(i);
			
			//TES 2/25/2010 - PLID 37535 - Don't allow tables on tables (even if they use the Smart Stamp format)
			if(pDetail->m_EMRInfoType == eitTable && IsDetailLinkableOnTable(pInfo)) {
				pDetail->UpdateTable(pInfo, bRemovingItem);
			}
		}
	}

	// (z.manning 2011-11-03 17:42) - PLID 42765 - Items' sentence formats can now reference the items they spawned.
	// So if this item was spawned we need to update the spawning item's setence format.
	if(pSpawningDetail != NULL)
	{
		if(GetInterface() != NULL) {
			GetInterface()->SendMessage(NXM_UPDATE_EMR_PREVIEW, (WPARAM)FALSE, (LPARAM)pSpawningDetail);
		}
	}
}

void CEMN::UpdateSpawningEMNTextMergeFieldNarratives(CStringArray& saErrors)
{	
	CArray<CEMNDetail*, CEMNDetail*> arNarrativesWithEMNSpawningText;
	long nTotalDetailCount = GetTotalDetailCount();
	for (int j = 0; j < nTotalDetailCount; j++) {
		CEMNDetail* pDetail = GetDetail(j);
		if(pDetail->m_EMRInfoType == eitNarrative) {
			// (a.walling 2009-11-19 14:55) - PLID 36369 - Only update if this narrative may actually have this detail
			// (a.walling 2010-04-01 10:44) - PLID 38013 - Consolidating some constant text strings
			if (pDetail->NarrativeMayHaveDetailField(NFIELD_EMN_SPAWNING_TEXT)) {
				arNarrativesWithEMNSpawningText.Add(pDetail);
			}
		}
	}

	if (!arNarrativesWithEMNSpawningText.IsEmpty() && !IsWritable()) {
		CWriteTokenInfo wtInfo;
		if (!RequestWriteToken(wtInfo))
		{
			// (j.armen 2013-05-14 11:09) - PLID 56680 - Write Token Info keeps track of external status
			CString strMessage = FormatString("'%s': ", GetDescription());

			if (wtInfo.bIsOldRevision)
				strMessage += "The loaded EMN has been modified by another user since it was initially opened.";
			else if (wtInfo.bIsDeleted)
				strMessage += "The loaded EMN has been deleted by another user.";
			else if (wtInfo.bIsExternal)
				strMessage += FormatString("The EMN is currently held for editing by the user '%s' %s at %s (using an external device, identified as %s).", wtInfo.strHeldByUserName, FormatDateTimeForInterface(wtInfo.dtHeld, NULL, dtoDateWithToday), FormatDateTimeForInterface(wtInfo.dtHeld, 0, dtoTime), wtInfo.strDeviceInfo);
			else
				strMessage += FormatString("The EMN is currently held for editing by the user '%s' %s at %s (using workstation %s).", wtInfo.strHeldByUserName, FormatDateTimeForInterface(wtInfo.dtHeld, NULL, dtoDateWithToday), FormatDateTimeForInterface(wtInfo.dtHeld, 0, dtoTime), wtInfo.strDeviceInfo);

			saErrors.Add(strMessage);
		}
	}
	if (!arNarrativesWithEMNSpawningText.IsEmpty() && IsWritable()) {
		for (int j = 0; j < arNarrativesWithEMNSpawningText.GetSize(); j++) {
			CEMNDetail* pDetail = arNarrativesWithEMNSpawningText.GetAt(j);
			pDetail->UpdateNarrativeFields();
		}
	}
}

//TES 1/23/2008 - PLID 24157 - Took out bCreate, it was never actually used, it was always FALSE.
void CEMN::UpdateNarrative(CEMNDetail *pInfo, CEMNDetail *pNarrative, BOOL bRemovingItem)
{
	//It is up to our caller to pass in a narrative-type detail.
	ASSERT(pNarrative->m_EMRInfoType == eitNarrative);

	//TES 6/11/2007 - PLID 25456 - For this PLID, I added a call to this function that didn't check for
	// whether pInfo was one of the types that aren't valid for narratives (Image, Narrative, Table).  But there's
	// no reason a calling function should necessarily need to know which types are valid, so let's check for those 
	// invalid types here, and abort if necessary.
	//TES 2/25/2010 - PLID 37535 - Allow tables that use the Smart Stamp format to be in narratives
	if(!IsDetailLinkable(pInfo)) {
		return;
	}

	//If this narrative and this item both have a spawned group id, and they are different, don't update.
	if(pNarrative->GetSpawnedGroupID() != -1 && pInfo->GetSpawnedGroupID() != -1 &&
		pNarrative->GetSpawnedGroupID() != pInfo->GetSpawnedGroupID()) {
		return;
	}

	pNarrative->UpdateNarrativeFields();
	/*
	if(bRemovingItem) {
		pNarrative->RemoveMergeField(pInfo->GetLabelText(), TRUE);
	}
	else {
		if(!m_bIsTemplate && pInfo->IsStateSet()) {
			// (c.haag 2007-03-28 15:45) - PLID 25397 - GetSentence calls GetDataOutput, so pass in
			// the result of our call to GetDataOutput to GetSentence to avoid that redundant call
			CString strDataOutput = GetDataOutput(pInfo, NULL, false, false);
			pNarrative->AddFilledMergeField(pInfo->GetLabelText(), strDataOutput, GetSentence(pInfo, NULL, false, false, ecfParagraph, strDataOutput), true, true, false, ub);
		}
		else {
			pNarrative->AddAvailableMergeField(pInfo->GetLabelText(), true, true, false, ub);
			pNarrative->ClearMergeField(pInfo->GetLabelText()); 
		}
	}
	//If it's a list type, add fields for the list elements.
	if(!bRemovingItem && (pInfo->m_EMRInfoType == eitSingleList || pInfo->m_EMRInfoType == eitMultiList)) {
		for(int i = 0; i < pInfo->GetListElementCount(); i++) {
			ListElement le = pInfo->GetListElement(i);
			if(!m_bIsTemplate) {
				if(le.bIsSelected) {
					pNarrative->AddFilledMergeField(pInfo->GetLabelText() + " - " + le.strName, GetElementDataOutput(pInfo, le.nID, NULL, false, false), GetElementSentence(pInfo, le.nID, NULL, false, false), true, true, true, ub);
				}
				else {
					pNarrative->AddFilledMergeField(pInfo->GetLabelText() + " - " + le.strName, "", "", true, true, true, ub);
				}
			}
			else {
				pNarrative->AddAvailableMergeField(pInfo->GetLabelText() + " - " + le.strName, true, true, true, ub);
			}
		}
	}

	if(!bRemovingItem)
		pNarrative->EndAddMergeFields();
	*/
}

void CEMN::DetachTopic(CEMRTopic *pTopic)
{
	pTopic->SetParentEMN(NULL);

	//TES 7/6/06 - While we are now unsaved, the topic itself isn't necessarily (when topics are re-arranged, the EMN is considered
	// to be modified, not the topics.
	//pTopic->SetUnsaved();

	for(int i = m_arypEMRTopics.GetSize()-1; i >= 0; i--) {
		if(m_arypEMRTopics[i] == pTopic) {
			//TES 4/15/2010 - PLID 24692 - Detach from our linked list.
			TopicPositionEntry *tpeDoomed = pTopic->GetTopicPositionEntry();
			m_pTopicPositionHead = DetachTopicPositionEntry(m_pTopicPositionHead, tpeDoomed);			
			m_arypEMRTopics.RemoveAt(i);
		}
	}

	m_bTopicArrayChanged = TRUE;
	m_bUnsaved = TRUE;
}

//TES 10/5/2009 - PLID 35755 - Added a parameter for whether this insertion should cause the topic order indexes
// to be recalculated when saving.
void CEMN::InsertTopic(CEMRTopic *pTopicToInsert, CEMRTopic *pInsertBefore, BOOL bIsInitialLoad, BOOL bTopicArrayChanged)
{
	pTopicToInsert->SetParentEMN(this);
	
	//TES 4/15/2010 - PLID 24692 - If the topic array isn't changed, then our linked list already has the correct position.
	// Otherwise, tell our list to move this entry as specified.
	//TES 4/29/2010 - PLID 24692 - Also, if we don't have this entry at all, make sure it gets added.
	if(bTopicArrayChanged || m_pTopicPositionHead == NULL || !m_pTopicPositionHead->HasEntry(pTopicToInsert->GetTopicPositionEntry())) {
		if(pInsertBefore) {
			m_pTopicPositionHead = InsertTopicPositionEntry(m_pTopicPositionHead, pTopicToInsert->GetTopicPositionEntry(), pInsertBefore->GetTopicPositionEntry());
			if(!m_pTopicPositionHead->HasEntry(pTopicToInsert->GetTopicPositionEntry())) {
				//TES 5/11/2010 - PLID 24692 - We must have been asked to insert before something that isn't in the list.  So, add to the end,
				// since that's what the topic insertion logic below will do.
				m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, pTopicToInsert->GetTopicPositionEntry(), -1);
			}
		}
		else {
			m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, pTopicToInsert->GetTopicPositionEntry(), -1);
		}
	}
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i] == pInsertBefore) {
			m_arypEMRTopics.InsertAt(i, pTopicToInsert);
			if(!bIsInitialLoad) {
				m_bUnsaved = TRUE;
				//TES 10/5/2009 - PLID 35755 - Only update this if our flag was set
				if(bTopicArrayChanged) {
					m_bTopicArrayChanged = TRUE;
				}
			}
			return;
		}
	}
	m_arypEMRTopics.Add(pTopicToInsert);
	if(!bIsInitialLoad) {
		if(bTopicArrayChanged) {
			//TES 10/5/2009 - PLID 35755 - Only update this if our flag was set.
			m_bTopicArrayChanged = TRUE;
		}
		m_bUnsaved = TRUE;
	}
}

void CEMN::AddTopicToList(CEMRTopic *pTopic, CArray<CEMRTopic*,CEMRTopic*> &arTopics)
{
	arTopics.Add(pTopic);
	for(int i = 0; i < pTopic->GetSubTopicCount(); i++) {
		AddTopicToList(pTopic->GetSubTopic(i), arTopics);
	}
}

void CEMN::AddDeletedTopicToList(CEMRTopic *pTopicToCheck, CArray<CEMRTopic*,CEMRTopic*> &arDeletedTopics)
{
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	for(i = 0; i < pTopicToCheck->GetSubTopicCount(); i++) {
		AddDeletedTopicToList(pTopicToCheck->GetSubTopic(i), arDeletedTopics);
	}
	for(i = 0; i < pTopicToCheck->GetDeletedSubTopicCount(); i++) {
		AddDeletedTopicToList(pTopicToCheck->GetDeletedSubTopic(i), arDeletedTopics);
	}
}

void CEMN::GetAllTopics(CArray<CEMRTopic*,CEMRTopic*> &arTopics)
{
	// (a.walling 2013-03-20 16:09) - PLID 55790 - No more loading behavior
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		AddTopicToList(m_arypEMRTopics[i], arTopics);
	}
}

void CEMN::GetAllDeletedTopics(CArray<CEMRTopic*,CEMRTopic*> &arDeletedTopics)
{
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		AddDeletedTopicToList(m_arypEMRTopics[i], arDeletedTopics);
	}
	for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
		AddTopicToList(m_arypDeletedTopics[i], arDeletedTopics);
		AddDeletedTopicToList(m_arypDeletedTopics[i], arDeletedTopics);
	}
}

int CEMN::GetTopicIndex(CEMRTopic *pTopic)
{
	CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
	GetAllTopics(arAllTopics);
	for(int i = 0; i < arAllTopics.GetSize(); i++) {
		if(arAllTopics[i] == pTopic) return i;
	}
	ASSERT(FALSE);
	return -1;
}

// (z.manning 2009-06-23 15:20) - PLID 34692 - This function will go through each non-new topic
// (m_nID != -1) and ensure it's not deleted on the current EMN.
void CEMN::EnsureTopicsNotDeletedIfNotNew(CArray<CEMRTopic*,CEMRTopic*> &arypTopics)
{
	for(int nTopicIndex = 0; nTopicIndex < arypTopics.GetSize(); nTopicIndex++)
	{
		CEMRTopic *pTopic = arypTopics.GetAt(nTopicIndex);
		if(pTopic != NULL && pTopic->GetID() != -1) {
			EnsureTopicNotDeleted(pTopic->GetID());
		}
	}
}

// (z.manning 2009-06-23 14:53) - PLID 34692 - Function to go through all topics on the EMN
// and make sure that a topic with the given ID is not in any of the deleted topic arrays.
void CEMN::EnsureTopicNotDeleted(const long nTopicID)
{
	for(int nTopicIndex = 0; nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++)
	{
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(nTopicIndex);
		if(pTopic != NULL) {
			pTopic->EnsureTopicNotDeleted(nTopicID);
		}
	}

	for(int nDeletedTopicIndex = m_arypDeletedTopics.GetSize() - 1; nDeletedTopicIndex >= 0; nDeletedTopicIndex--)
	{
		CEMRTopic *pDeletedTopic = m_arypDeletedTopics.GetAt(nDeletedTopicIndex);
		if(pDeletedTopic->GetID() == nTopicID) {
			m_arypDeletedTopics.RemoveAt(nDeletedTopicIndex);
		}
	}
}

// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize
Nx::Quantum::Batch CEMN::GenerateDeleteString(long &nAuditTransactionID, CStringArray &arystrErrors, CDWordArray &arynAffectedDetailIDs)
{
	ASSERT(!m_bIsTemplate);
	//Delete all our topics
	Nx::Quantum::Batch strDelete;

	// (z.manning, 02/07/2007) - PLID 24599 - We want to delete all template topic records at once to avoid possible
	// foreign key problems. Thus, CTopic::GenerateDeleteString no longer even tries to delete them. Instead, we
	// track all topic IDs, so we can delete all topics at once afterwards.
	CArray<long,long> arynDeletedTemplateTopicIDs;
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	int i = 0;
	for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
		// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
		strDelete += m_arypDeletedTopics[i]->GenerateDeleteString(nAuditTransactionID, arystrErrors, arynDeletedTemplateTopicIDs, arynAffectedDetailIDs);
		// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in both PostSaveUpdate and ~CEMN, in this case
		// the deletion will be hit in ~CEMN
		//delete m_arypDeletedTopics[i];
	}
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		// (b.cardillo 2009-06-03 15:10) - PLID 34370 - Keep track of all updated or deleted EMRDetailIDs
		strDelete += m_arypEMRTopics[i]->GenerateDeleteString(nAuditTransactionID, arystrErrors, arynDeletedTemplateTopicIDs, arynAffectedDetailIDs);
	}
	// (j.jones 2012-12-31 13:49) - PLID 22340 - this is in both PostSaveUpdate and ~CEMN, in this case
		// the deletion will be hit in ~CEMN
	//m_arypDeletedTopics.RemoveAll();

	// (z.manning, 02/07/2007) - PLID 24599 - Ok, we know what topics need to be deleted, so let's delete them.
	// (a.walling 2014-01-30 00:00) - PLID 60542 - Quantize
	foreach (long id, arynDeletedTemplateTopicIDs) {
		AddStatementToSqlBatch(strDelete, "DELETE FROM EmrTemplateTopicsT WHERE ID = %li ", id);
	}

	// (c.haag 2008-07-15 10:15) - PLID 30694 - If this is a patient chart, check to see if any todo alarms are associated
	// with it. If there are, the user needs to decide what to do with them.
	if (!m_bIsTemplate && !IsLockedAndSaved()) {
		CArray<long,long> anTaskIDs;

		// Gather from data
		if (m_nID > -1) {
			_RecordsetPtr prsTodos = CreateParamRecordset(FormatString(
				"SELECT TaskID FROM TodoList WHERE "
				"(RegardingType = %d AND RegardingID = {INT}) "
				"OR "
				"(RegardingType = %d AND RegardingID IN (SELECT ID FROM EMRDetailsT WHERE EMRID = {INT})) "
				,ttEMN, ttEMNDetail), m_nID, m_nID);
			FieldsPtr f = prsTodos->Fields;
			while (!prsTodos->eof) {
				anTaskIDs.Add(AdoFldLong(f, "TaskID"));
				prsTodos->MoveNext();
			}
		} // if (m_nID > -1) {


		// Gather from memory
		for (int i=0; i < m_apCreatedTodosWhileUnsaved.GetSize(); i++) {
			anTaskIDs.Add( m_apCreatedTodosWhileUnsaved[i]->nTodoID );
		}

		if (anTaskIDs.GetSize() > 0) {
			CEMRDeleteTodosDlg dlg(GetInterface());
			dlg.m_anInputTodoIDs.Copy(anTaskIDs);
			dlg.DoModal();
			CArray<long,long>& anTodoIDsToDelete = dlg.m_anTodoIDsToDelete;
			if (anTodoIDsToDelete.GetSize() > 0) {
				AddStatementToSqlBatch(strDelete, "DELETE FROM TodoAssignToT WHERE TaskID IN (%s)", ArrayAsString(anTodoIDsToDelete));
				AddStatementToSqlBatch(strDelete, "DELETE FROM EMRTodosT WHERE TaskID IN (%s)", ArrayAsString(anTodoIDsToDelete));
				AddStatementToSqlBatch(strDelete, "DELETE FROM TodoList WHERE TaskID IN (%s)", ArrayAsString(anTodoIDsToDelete));
			}
		}
	}

	//don't need to delete it if the item doesn't exist,
	//but this does need to be after the previous code so we can clean out the child lists
	if(m_nID == -1)
		return strDelete;

	if(IsLockedAndSaved()) {
		//this is locked! add a warning and return
		CString str;
		str.Format("Attempted to delete the locked EMN '%s'.", m_strDescription);
		arystrErrors.Add(str);
		return strDelete;
	}

	// (j.jones 2006-04-26 09:37) - PLID 20064 - we now simply mark these records as being deleted
	//AddStatementToSqlBatch(strDelete, "DELETE FROM EmrProcedureT WHERE EmrID = %li", m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE EmrProcedureT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EmrID = %li", _Q(GetCurrentUserName()), m_nID);
	//AddStatementToSqlBatch(strDelete, "DELETE FROM EmrChargesT WHERE EmrID = %li", m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE EmrChargesT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EmrID = %li", _Q(GetCurrentUserName()), m_nID);
	// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the charges.
	// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
	// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
	AddStatementToSqlBatch(strDelete, "DELETE FROM EMRProblemLinkT WHERE EMRRegardingType = %li AND EMRRegardingID IN (SELECT ID FROM EmrChargesT WHERE EmrID = %li)", eprtEmrCharge, m_nID);
	//AddStatementToSqlBatch(strDelete, "DELETE FROM EmrDiagCodesT WHERE EmrId = %li", m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE EmrDiagCodesT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EmrID = %li", _Q(GetCurrentUserName()), m_nID);
	// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the diagnosis code
	// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
	// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
	AddStatementToSqlBatch(strDelete, "DELETE FROM EMRProblemLinkT WHERE EMRRegardingType = %li AND EMRRegardingID IN (SELECT ID FROM EmrDiagCodesT WHERE EmrID = %li) ", eprtEmrDiag, m_nID);
	//AddStatementToSqlBatch(strDelete, "DELETE FROM EmrMedicationsT WHERE EmrID = %li", m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE EmrMedicationsT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s' WHERE EmrID = %li", _Q(GetCurrentUserName()), m_nID);
	// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the medications
	// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
	// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
	AddStatementToSqlBatch(strDelete, "DELETE FROM EMRProblemLinkT WHERE EMRRegardingType = %li AND EMRRegardingID IN (SELECT MedicationID FROM EmrMedicationsT WHERE EmrID = %li) ", eprtEmrMedication, m_nID);
	//AddStatementToSqlBatch(strDelete, "DELETE FROM BilledEMNsT WHERE EMNID = %li", m_nID);
	//AddStatementToSqlBatch(strDelete, "DELETE FROM EmrMasterT WHERE ID = %li", m_nID);
	// (a.walling 2013-02-15 11:14) - PLID 54651 - Unset linked appointment
	AddStatementToSqlBatch(strDelete, "UPDATE EmrMasterT SET Deleted = 1, DeleteDate = GetDate(), DeletedBy = '%s', AppointmentID = NULL WHERE ID = %li", _Q(GetCurrentUserName()), m_nID);
	// (c.haag 2008-07-28 09:42) - PLID 30853 - Delete all problems linked directly with the EMN. Note that we don't do this for topics and detail
	// as well; this is because they are not marked as deleted.
	// (c.haag 2009-05-12 09:12) - PLID 28494 - Use the new EMR problem linking table
	// (j.jones 2009-06-02 12:14) - PLID 34301 - only delete links right now, the parent should know to delete problems
	AddStatementToSqlBatch(strDelete, "DELETE FROM EMRProblemLinKT WHERE EMRRegardingType = %li AND EMRRegardingID = %li", eprtEmrEMN, m_nID);

	// (c.haag 2008-06-24 13:20) - PLID 17244 - Delete linked todo alarms
	// (c.haag 2008-07-10 15:32) - PLID 30674 - Also EMR todo list table
	// (c.haag 2008-07-15 11:07) - PLID 30694 - Now the user chooses what todos to delete. By the time we get here, those todos have been deleted. As for the rest of
	// these, convert them to general todos and break off their relations with EMRTodos.
	AddStatementToSqlBatch(strDelete, "DELETE FROM EMRTodosT WHERE TaskID IN (SELECT TaskID FROM TodoList WHERE RegardingType = %d AND RegardingID IN (SELECT ID FROM EmrDetailsT WHERE EMRID = %d))", (long)ttEMNDetail, m_nID);
	// (c.haag 2008-07-15 12:00) - PLID 30694 - We also need to clear out the EMN: and EMN Detail: out of the notes.
	AddStatementToSqlBatch(strDelete, "UPDATE TodoList SET Notes = Right(Notes, Len(Notes) - (CHARINDEX(char(10), Notes, CHARINDEX(char(10), Notes) + 1))) "
		"WHERE RegardingType = %d AND RegardingID IN (SELECT ID FROM EmrDetailsT WHERE EMRID = %d) "
		"AND CHARINDEX(char(10), Notes) > 0 "
		"AND CHARINDEX(char(10), Notes, CHARINDEX(char(10), Notes) + 1) > 0 "
		"AND Len(Notes) > 3 "
		"AND Left(Notes,4) = 'EMN:' "
		"AND SUBSTRING(Notes, CHARINDEX(char(10), Notes) + 1, 7) = 'Detail:' "
		,(long)ttEMNDetail, m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE TodoList SET RegardingType = %d, RegardingID = %d WHERE RegardingType = %d AND RegardingID IN (SELECT ID FROM EmrDetailsT WHERE EMRID = %d)", (long)ttPatientContact, GetParentEMR()->GetPatientID(), (long)ttEMNDetail, m_nID);
	// (c.haag 2008-07-11 10:57) - PLID 30550 - Also delete EMN-specific alarms (as opposed to EMN detail)
	// (c.haag 2008-07-15 12:00) - PLID 30694 - Now the user chooses what todos to delete. By the time we get here, those todos have been deleted. As for the rest of
	// these, convert them to general todos and break off their relations with EMRTodos.
	// (c.haag 2008-07-15 12:00) - PLID 30694 - We also need to clear out the EMN: out of the notes
	AddStatementToSqlBatch(strDelete, "UPDATE TodoList SET Notes = Right(Notes, Len(Notes) - (CHARINDEX(char(10), Notes))) "
		"WHERE RegardingType = %d AND RegardingID = %d "
		"AND CHARINDEX(char(10), Notes) > 0 "
		"AND Len(Notes) > 3 "
		"AND Left(Notes,4) = 'EMN:' "
		,(long)ttEMN, m_nID);
	AddStatementToSqlBatch(strDelete, "UPDATE TodoList SET RegardingType = %d, RegardingID = %d WHERE RegardingType = %d AND RegardingID = %d", (long)ttPatientContact, GetParentEMR()->GetPatientID(), (long)ttEMN, m_nID);

	// (a.walling 2013-03-14 11:05) - PLID 55652 - Get the object pointer as well since we use that as a primary key in #NewObjectsT
	AddDeletedEMRObjectToSqlBatch(strDelete, esotDeletedEMN, (long)this, m_nID);

	if(m_bIsTemplate) {
		//this shouldn't be allowed, but handle it anyways if we do get here
		
		//only audit if the EMN is not new
		if(m_nID != -1) {
			//auditing (using transactions)
			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateDeleted, m_nID, m_strDescription, "<Deleted>", aepHigh, aetDeleted);
		}
	}
	else {
		//only audit if the EMN is not new
		if(m_nID != -1) {
			//auditing (using transactions)
			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()),
				nAuditTransactionID, aeiEMNDeleted, m_nID, m_strDescription, "<Deleted>", aepHigh, aetDeleted);
		}
	}

	return strDelete;
}

CEMNLoader* CEMN::CreateMintItemsLoader(const EmrAction& ea, CEMN* pEMN, SourceActionInfo &sai)
{
	//
	// (c.haag 2007-08-16 16:53) - PLID 27024 - This function creates an EMN loader object 
	// to only be used during spawning
	//

	// (j.jones 2011-04-28 14:39) - PLID 43122 - the loader now requires a provider ID for floating EMR data
	long nProviderIDForFloatingData = GetProviderIDForFloatingData();

	CEMNLoader* pEMNLoader = new CEMNLoader(pEMN, GetRemoteData(), TRUE, m_bIsTemplate, ea.nDestID, nProviderIDForFloatingData);
	// (c.haag 2007-07-30 10:28) - PLID 26871 - Now a parameter query
	CString strSqlLoader = GetrsPreloadDetailsBasicQDeclarations();
	// (c.haag 2007-08-31 11:21) - PLID 27268 - We now pull the detail subquery from outside this function.
	// We don't pull the topic one because it's different from the one in the initial load
	AppendTemplateLoadSubQuery_rsPreloadDetails(strSqlLoader);
	strSqlLoader += FormatString(
		//rsPreloadTemplateTopics
		// (c.haag 2007-05-02 13:09) - PLID 25881 - Preload all template topics and figure out how they will show up later.
		// Note that the original topic query calculated the topic name. We do not do that in our query; the calculation
		// is done in code.
		"SELECT \r\n"
		//		Important fields
		"EMRTemplateTopicsT.ID AS EMRTemplateTopicID, EMRTemplateTopicsT.TemplateID, \r\n"
		"EMRTemplateTopicsT.SourceTemplateTopicID, \r\n"
		//		Non-calculated fields used in CEMRTopic::LoadTemplateTopicFields
		//DRT 9/25/2007 - PLID 27515 - Added SourceAction SourceID and SourceDataGroupID
		"EMRTemplateTopicsT.SourceActionID, SourceEMRActionsT.SourceID AS SourceActionSourceID, SourceEmrDataT.EMRDataGroupID AS SourceActionSourceDataGroupID, \r\n"
		"EMRTemplateTopicsT.SourceDetailID, \r\n"
		//		Non-calculated fields used in CEMNLoader::LoadEMRTopic and CEMRTopic::LoadTemplateTopicFields
		"EMRTemplateTopicsT.EMRParentTemplateTopicID, EMRTemplateTopicsT.ShowIfEmpty, EMRTemplateTopicsT.Name, \r\n"
		//		Non-calculated fields used in CEMNLoader::LoadEMRTopic
		"EMRTemplateTopicsT.OrderIndex, \r\n"
		"EMRTemplateTopicsT.HideOnEMN, \r\n"
		// (j.jones 2007-07-30 11:25) - PLID 26874 - include the template's "AddOnce" field
		"EMRTemplateT.AddOnce, \r\n"
		// (c.haag 2007-07-24 12:00) - PLID 26344 - If this topic was spawned by a detail in the same template,
		// SourceEMRTemplateTopicsT will pertain to that spawned topic's original template
		"SourceEMRTemplateTopicsT.TemplateID AS OriginalTemplateID, \r\n"
		"SourceEMRTemplateTopicsT.Name AS OriginalTopicName, \r\n"
		"SourceEMRTemplateTopicsT.ShowIfEmpty AS OriginalShowIfEmpty, \r\n"
		//		Calculated action fields used in CEMNLoader::LoadEMRTopic
		//TES 2/17/2010 - PLID 37298 - Added SourceActionName info for HotSpots
		//TES 3/18/2010 - PLID 37530 - Added SourceActionName info for Smart Stamps
		// (a.walling 2010-04-02 18:13) - PLID 38059 - Gather the action name for table dropdown spawns
		"CASE WHEN EmrActionsT.SourceType = %d THEN EmrInfoT.Name WHEN EmrActionsT.SourceType = %d THEN EmrDataT.Data WHEN EmrActionsT.SourceType = %d THEN ProcedureT.Name WHEN EmrActionsT.SourceType = %d THEN EmrImageHotSpotQ.AnatomicLocation "
		" WHEN EmrActionsT.SourceType = %d THEN (SELECT StampText FROM EmrImageStampsT WHERE ID = ?) + ' - ' + convert(nvarchar(50),?) WHEN EmrActionsT.SourceType = 13 THEN EmrTableDropdownQ.DropdownData + ' - ' + EmrTableDropdownRowQ.Data + ' - ' + EmrTableDropdownQ.DropdownTableColumn ELSE '' END AS EmrActionName, "
		"EmrActionsT.DestType AS EmrActionDestType, EmrActionsT.ID AS EmrActionID, EmrSpotGroupID, \r\n"
		// (a.walling 2008-07-01 13:00) - PLID 29271
		// (z.manning 2009-02-13 09:50) - PLID 33070 - Added SourceActionSourceTableDropdownGroupID
		"EMRTemplateTopicsT.PreviewFlags, EmrTableDropdownQ.DropdownGroupID AS SourceActionSourceTableDropdownGroupID, \r\n"
		// (z.manning 2009-03-05 15:38) - PLID 33338 - SourceDataGroupID
		//TES 3/17/2010 - PLID 37530 - Added SourceStampID and SourceStampIndex
		"EMRTemplateTopicsT.SourceDataGroupID, SourceEmrActionsT.SourceType, EMRTemplateTopicsT.SourceStampID, EMRTemplateTopicsT.SourceStampIndex "
		"FROM EMRTemplateTopicsT \r\n"
		"LEFT JOIN EMRTemplateT ON EMRTemplateTopicsT.TemplateID = EMRTemplateT.ID \r\n"
		"LEFT JOIN EMRTemplateTopicsT AS SourceEMRTemplateTopicsT ON EMRTemplateTopicsT.SourceTemplateTopicID = SourceEMRTemplateTopicsT.ID \r\n"
		"LEFT JOIN EmrActionsT ON EmrActionsT.ID = ? \r\n"
		// (a.walling 2010-04-06 08:16) - PLID 38061 - Filtered these on their appropriate source types
		"LEFT JOIN EmrInfoT ON EmrInfoT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 3  \r\n"
		"LEFT JOIN EmrDataT ON EmrDataT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 4  \r\n"
		"LEFT JOIN ProcedureT ON ProcedureT.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = 5 \r\n"
		//DRT 9/26/2007 - PLID 27515 - This join is to the EMRActionsT.SourceID... which is not the same
		//	as the EMRActionsT join filtered on this function's parameter action ID.  We have to do this because
		//	the Loader is actually reading out EMRTemplateTopicsT.SourceActionID, NOT EMRActionsT.ID.
		"LEFT JOIN EmrActionsT SourceEmrActionsT ON EmrTemplateTopicsT.SourceActionID = SourceEmrActionsT.ID \r\n"
		// (j.jones 2011-01-18 15:37) - PLID 29039 - ensured we force a join only on data item actions
		"LEFT JOIN EmrDataT SourceEmrDataT ON SourceEmrActionsT.SourceID = SourceEmrDataT.ID AND EmrActionsT.SourceType = %li \r\n"
		"LEFT JOIN (SELECT EmrImageHotSpotsT.ID, EmrImageHotSpotsT.EmrSpotGroupID, "
		// (z.manning 2010-04-30 16:29) - PLID 37553 - Pull anatomic location from a view
		"EmrHotSpotAnatomicLocationQ.AnatomicLocation "
		"FROM EmrImageHotSpotsT  "
		"LEFT JOIN EmrHotSpotAnatomicLocationQ ON EmrImageHotSpotsT.ID = EmrHotSpotAnatomicLocationQ.EmrHotSpotID) AS EmrImageHotSpotQ ON EmrActionsT.SourceID = EmrImageHotSpotQ.ID AND EmrActionsT.SourceType = %i \r\n"
		// (a.walling 2010-04-02 18:15) - PLID 38059
		"LEFT JOIN (SELECT EmrTableDropdownInfoT.ID, EmrTableDropdownInfoT.DropdownGroupID, EmrTableDropdownInfoT.Data AS DropdownData, EMRDataTableColumnQ.Data AS DropdownTableColumn, EMRDataTableColumnQ.EMRInfoID AS TableEMRInfoID "
			"FROM EmrTableDropdownInfoT "
			"INNER JOIN EMRDataT EMRDataTableColumnQ ON EMRTableDropdownInfoT.EMRDataID = EMRDataTableColumnQ.ID "
			"AND EMRDataTableColumnQ.ListType IN (3,4) " // (a.walling 2013-02-28 17:35) - PLID 55391 - This eliminates thousands of seeks!
			") AS EmrTableDropdownQ ON EmrTableDropdownQ.ID = EmrActionsT.SourceID AND EmrActionsT.SourceType = %i \r\n"
		// (a.walling 2010-04-02 18:15) - PLID 38059
		"LEFT JOIN EMRDataT EmrTableDropdownRowQ ON EMRTableDropdownRowQ.EmrDataGroupID = ? AND EmrTableDropdownRowQ.EMRInfoID = EmrTableDropdownQ.TableEMRInfoID AND EmrActionsT.SourceType = 13 \r\n"
		//		Include all topics for this template
		"WHERE EMRTemplateTopicsT.TemplateID = ? \r\n"
		//		Also include all source topics
		"OR EMRTemplateTopicsT.ID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = ?) "
		"ORDER BY (CASE WHEN EMRTemplateTopicsT.EMRParentTemplateTopicID IS NULL THEN -1 ELSE 1 END), EmrTemplateTopicsT.OrderIndex"
		"; \r\n",
		eaoEmrItem, eaoEmrDataItem, eaoProcedure, eaoEmrImageHotSpot, eaoSmartStamp, eaoEmrDataItem, eaoEmrImageHotSpot, eaoEmrTableDropDownItem
		);

	// (c.haag 2007-07-30 10:45) - PLID 26871 - The prsLoader query is now parameterized
	_CommandPtr pCmdLoader = OpenParamQuery(strSqlLoader);
	AddParameterLong(pCmdLoader, "TemplateID", ea.nDestID); // template details
	AddParameterLong(pCmdLoader, "TemplateID", ea.nDestID);
	AddParameterLong(pCmdLoader, "TemplateID", ea.nDestID);
	// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
	AddParameterLong(pCmdLoader, "StampID", sai.GetStampID());
	AddParameterLong(pCmdLoader, "StampIndex", sai.GetStampIndexInDetailByType());
	AddParameterLong(pCmdLoader, "ActionID", ea.nID);			
	// (a.walling 2010-04-02 18:15) - PLID 38059 - Pass in our data group id
	AddParameterLong(pCmdLoader, "DataGroupID", sai.GetDataGroupID()); // template topics
	AddParameterLong(pCmdLoader, "TemplateID", ea.nDestID); // template topics
	AddParameterLong(pCmdLoader, "TemplateID", ea.nDestID);
	_RecordsetPtr prsLoader = CreateRecordset(pCmdLoader);

	// Load in the template details
	// (c.haag 2007-08-31 11:25) - PLID 27268 - Do this twice because we actually have two detail queries
	pEMNLoader->PreloadEmrTemplateDetails(GetParentEMR()->GetPatientID(), prsLoader, GetParentEMR());
	prsLoader = prsLoader->NextRecordset(NULL);
	pEMNLoader->PreloadEmrTemplateDetails(GetParentEMR()->GetPatientID(), prsLoader, GetParentEMR());

	// Load in the template topics
	// (c.haag 2007-05-31 12:56) - PLID 26175 - The last "FALSE" parameter tells the CEMNLoader not to load all
	// root level topics. We will tell it to load all the topics later on.
	//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is a "live" spawn, we can get away
	//	without needing the data group ID.
	prsLoader = prsLoader->NextRecordset(NULL);
	pEMNLoader->PreloadEmrTemplateTopics(prsLoader, ea.nDestID, TRUE, GetInterface()?GetInterface()->GetSafeHwnd():NULL,
		sai, FALSE, GetParentEMR()->GetPatientID(), GetParentEMR(),
		FALSE, ea.nSourceID, -1);
	return pEMNLoader;
}

// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
void CEMN::ProcessEmrAction_eaoCpt(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */)
{
	//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
	long nActionCount = paryActionsToSpawn->GetSize();
	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();

		if(!m_bIsTemplate) {
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			//Add to memory

			//DRT 1/12/2007 - PLID 24178, 24182 - Several popups are possible during this phase.  We will hide the progress window and re-show it after
			//	all the charge stuff has been dealt with.
			// (z.manning, 02/01/2007) - PLID 24524 - The progress parameter may get 'lost' over the many functions
			// that may can get called during the loading/spawning process, so let's go straight to the source to 
			// hide/show the progress bar.
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_HIDE);
			}

			//DRT 1/10/2007 - PLID 24182 - Add new charge fields to the EMNCharge object
			// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
			EMNCharge *pCharge = AddCharge(&ea, sai);
			if(pProgress) pProgress->SetProgress(0,2,1);
			//Add to interface.
			// (j.jones 2011-07-11 09:33) - PLID 38366 - AddCharge might skip the spawned
			// charge in lieu of coding group rules, and have already added charges and
			// notified the interface. If so, pCharge will be NULL, and we do not need
			// to process it further.
			if(GetInterface() != NULL && pCharge != NULL) {
				GetInterface()->SendMessage(NXM_EMN_CHARGE_ADDED, (WPARAM)pCharge, (LPARAM)pSourceEmn);
			}
			if(pProgress) pProgress->SetProgress(0,2,2);

			//DRT 1/12/2007 - PLID 24178, 24182 - Re-show the window.
			// (a.walling 2007-09-07 09:42) - PLID 24371 - Show but do not activate
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_SHOWNA);
			}

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}
	}
}


// (r.farnworth 2014-03-06 10:00) - PLID 60820 - Function that loops through the safe array of ICD-10 Codes and finds a matching ICD-9 Code
// (a.walling 2014-04-01 3:38) - PLID 61334 - Does not need to be a member function; put in anonymous namespace
namespace {
NexTech_Accessor::_NexGEMMatchResultPtr FindMatchingDiagCode(Nx::SafeArray<IUnknown*> codeResults, long nDiagToMatch)
{
	for each(NexTech_Accessor::_NexGEMMatchResultPtr pResult in codeResults)
	{
		if (atol(pResult->ICD9->ID) == nDiagToMatch)
			return pResult;
	}

	return NULL;
}
}

//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
void CEMN::ProcessEmrAction_eaoDiagnosis(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */)
{
	//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
	long nActionCount = paryActionsToSpawn->GetSize();

	// (r.farnworth 2014-03-10 16:02) - PLID 60820 - We don't want to search for potential 10s if we are in ICD-9 mode
	DiagCodeSearchStyle ICDPreference = DiagSearchUtils::GetPreferenceSearchStyle();

	// (r.farnworth 2014-03-05 15:01) - PLID 60820 - Call the API function that looks for potential ICD-10 matches
	// (j.gruber 2014-04-24 11:24) - PLID 61899 - moved up further for declaration
	NexTech_Accessor::_NexGEMMatchResultsPtr codeMatchResults = NULL;

	// (j.gruber 2014-04-24 11:19) - PLID 61899 - we only need to match if we are not in ICD-9 mode
	if (ICDPreference != eManagedICD9_Search) 
	{

		// (r.farnworth 2014-03-05 15:01) - PLID 60820 - Use the ICD-9 Code information to find matching ICD-10 codes
		Nx::SafeArray<BSTR> saICD9CodeIDs;
		bool bNeedToSearchNexGEMs = false;
		for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
			EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
			// (b.savon 2014-07-22 13:32) - PLID 62709 - Use the new struct and only add if we don't have a matching 10
			long nDiagCodeID_ICD9 = ea.diaDiagnosis.nDiagCodeID_ICD9;		
			if (nDiagCodeID_ICD9 != -1 && ea.diaDiagnosis.nDiagCodeID_ICD10 == -1){
				saICD9CodeIDs.Add(AsString(nDiagCodeID_ICD9));
				bNeedToSearchNexGEMs = true;
			}
		}

		// (r.farnworth 2014-03-05 15:01) - PLID 60820 - Call the API function that looks for potential ICD-10 matches
		// (b.savon 2014-07-22 13:34) - PLID 62709 - Only do this if we actually have 9-codes that need potential matching
		if (bNeedToSearchNexGEMs){
			codeMatchResults = GetAPI()->GetNexGEMMatchesFromICD9s(GetAPISubkey(), GetAPILoginToken(), saICD9CodeIDs);
		}
	}

	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();

		if(!m_bIsTemplate) {
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			//Add to memory
			BOOL bDuplicate = FALSE;
			
			// (j.gruber 2014-04-24 11:25) - PLID 61899 - only do this if we aren't in ICD-9 mode
			NexTech_Accessor::_NexGEMMatchResultPtr matchedResult = NULL;
			long nDiagCodeID_ICD10 = -1;
			bool bKeepICD9 = false; // (b.savon 2014-10-29 15:46) - PLID 62710
			if (ICDPreference != eManagedICD9_Search) {
				if (codeMatchResults) {
					// (r.farnworth 2014-03-06 09:55) - PLID 60820 - Call a function that will loop and find our matching diagnosis code
					// (b.savon 2014-07-22 13:40) - PLID 62709 - Use the new struct
					matchedResult = FindMatchingDiagCode(codeMatchResults->match, ea.diaDiagnosis.nDiagCodeID_ICD9);
				}
			}			

			if(matchedResult)
			{
				if(MapMatchStatus(matchedResult->matchStatus) == nexgemtDone) {
					nDiagCodeID_ICD10 = atol(matchedResult->exactMatchedICD10->ID);
					// (b.savon 2014-10-29 15:46) - PLID 62710 - Handle spawning tuples of diagnosis codes when in ICD-10 global search mode
					if (ICDPreference == eManagedICD10_Search){
						bKeepICD9 = true;
					}
				}
			}

			long nDiagCodeID_ICD10_Official = (nDiagCodeID_ICD10 == -1 ? ea.diaDiagnosis.nDiagCodeID_ICD10 : nDiagCodeID_ICD10);

			if(pProgress) pProgress->SetProgress(0,4,1);
			EMNDiagCode *pDiag = new EMNDiagCode;
			// (j.jones 2008-07-23 10:20) - PLID 30819 - changed the original nID to nDiagCodeID,
			// then added a new nID for the actual record ID
			pDiag->nID = -1;
			// (b.savon 2014-07-22 13:42) - PLID 62709 - Use the new struct
			switch (ICDPreference){
				case eManagedICD9_Search:
				{
					// (b.savon 2014-07-23 11:40) - PLID 62708 - Handle spawning tuples of diagnosis codes when in ICD-9 global search mode
					pDiag->nDiagCodeID = ea.diaDiagnosis.nDiagCodeID_ICD9;
					if (ea.diaDiagnosis.nDiagCodeID_ICD9 == -1){
						pDiag->nDiagCodeID_ICD10 = nDiagCodeID_ICD10_Official;
					}
					else{
						pDiag->nDiagCodeID_ICD10 = -1;
					}
				}
				break;
				case eICD9_10_Crosswalk:
				{
					pDiag->nDiagCodeID = ea.diaDiagnosis.nDiagCodeID_ICD9;
					pDiag->nDiagCodeID_ICD10 = nDiagCodeID_ICD10_Official;
				}
				break;
				case eManagedICD10_Search:
				{
					// (b.savon 2014-07-23 11:40) - PLID 62710 - Handle spawning tuples of diagnosis codes when in ICD-10 global search mode
					if (nDiagCodeID_ICD10_Official == -1 || bKeepICD9){
						pDiag->nDiagCodeID = ea.diaDiagnosis.nDiagCodeID_ICD9;
					}
					else{
						pDiag->nDiagCodeID = -1;
					}
					pDiag->nDiagCodeID_ICD10 = nDiagCodeID_ICD10_Official;
				}
				break;
			}

			// (r.farnworth 2014-03-10 16:07) - PLID 60820 - We don't want to look for matches if we are in ICD-9 mode
			if(ICDPreference != eManagedICD9_Search && nDiagCodeID_ICD10_Official == -1)
			{
				if(matchedResult)
				{
					pDiag->MatchType = MapMatchStatus(matchedResult->matchStatus);
					if(pDiag->MatchType == nexgemtDone) {
						pDiag->nDiagCodeID_ICD10 = atol(matchedResult->exactMatchedICD10->ID);
					}
				}
			}

			// (b.savon 2014-07-24 15:07) - PLID 63024 - Check for dupes after all the preference manipulations
			for (int i = 0; i < m_aryDiagCodes.GetSize(); i++) {
				if (m_aryDiagCodes[i]->nDiagCodeID == pDiag->nDiagCodeID && m_aryDiagCodes[i]->nDiagCodeID_ICD10 == pDiag->nDiagCodeID_ICD10){
					bDuplicate = TRUE;
				}
			}

			//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
			if (bDuplicate) {
				//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
				pSourceEmn->GetParentEMR()->UnlockAction(ea);
				continue;
			}

			// (z.manning 2009-02-26 12:31) - PLID 33141 - Use the new SourceActionInfo class
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);
			pDiag->sai = sai;
			pDiag->bIsNew = TRUE;
			// (j.jones 2007-01-05 10:07) - PLID 24070 - if -1, AddDiagCode will auto-generate it
			pDiag->nOrderIndex = -1;
			pDiag->bHasMoved = FALSE;
			pDiag->bChanged = FALSE;
			// (j.jones 2014-12-23 15:07) - PLID 64491 - added bReplaced
			pDiag->bReplaced = FALSE;

			// (b.savon 2014-09-10 09:41) - PLID 62712 - Handle the ToDo creation preference when spawning diagnosis tuples in a different search mode
			//The EMN isn't saved yet.  Save our EMR Action in an array to process later
			if (GetID() == -1){
				m_aryDiagnosisActionsHeldForPostSaveProcessing.Add(ea);
			}
			else{
				ProcessSpawnedDiagnosisForTodoCreationInMisalignedModes(ea);
			}

			//DRT 3/3/2006 - PLID 19565 - For efficiency, the more info dialog has a list of all
			//	diag codes, so we can update our code number from there instead of checking the
			//	database.
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_UPDATE_CODE_EMNDIAGCODE, (WPARAM)pDiag, (LPARAM)pSourceEmn);
			}
			if(pProgress) pProgress->SetProgress(0,4,2);
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
			AddDiagCode(pDiag);
			if(pProgress) pProgress->SetProgress(0,4,3);

			//DRT 1/15/2007 - PLID 24179 - It is now likely that popups will happen during the processing of
			//	spawned diagnosis codes.  We will briefly hide the progress window and re-show it afterwards.
			// (z.manning, 02/01/2007) - PLID 24524 - The progress parameter may get 'lost' over the many functions
			// that may can get called during the loading/spawning process, so let's go straight to the source to 
			// hide/show the progress bar.
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_HIDE);
			}

			//Add to interface
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_EMN_DIAG_ADDED, (WPARAM)pDiag, (LPARAM)pSourceEmn);
			}

			//DRT 1/15/2007 - PLID 24179 - Reshow the progress window
			// (a.walling 2007-09-07 09:42) - PLID 24371 - Show but do not activate
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_SHOWNA);
			}

			if(pProgress) pProgress->SetProgress(0,4,4);

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);

			// (j.jones 2012-10-01 15:44) - PLID 52869 - This function will check their preference
			// to save the EMN and warn about drug interactions.
			// We should not do this if the EMN is loading. This function will be called again
			// when loading is finished, if diag. codes exist.
			if(!m_bIsTemplate && !IsLoading()) {
				CheckSaveEMNForDrugInteractions(FALSE);
			}
		}
	}
}

//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
// (j.jones 2013-01-09 09:58) - PLID 45446 - we now track the new prescription IDs
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoMedication(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */, long *pnNewPrescriptionID /*= NULL*/)
{
	//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
	long nActionCount = paryActionsToSpawn->GetSize();

	// (j.jones 2013-01-09 10:02) - PLID 45446 - Before we do anything, make sure that ppNewPrescription is -1.
	if (pnNewPrescriptionID) {
		*pnNewPrescriptionID = -1;
	}

	BOOL bAddedAnUnsavedMedication = FALSE;
	CArray<long, long> aryNewPrescriptionIDs;

	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();

		if(!m_bIsTemplate) {
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);
			
			// (z.manning, 02/01/2007) - PLID 24524 - The progress parameter may get 'lost' over the many functions
			// that may can get called during the loading/spawning process, so let's go straight to the source to 
			// hide/show the progress bar.
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_HIDE);
			}

			//Add to memory
			// (j.jones 2008-05-20 11:18) - PLID 30079 - for now this is NOT showing the prescription editor, though it will in PLID 28957
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);

			// (a.walling 2009-04-22 11:13) - PLID 28957 - Popup the prescription editor if set to popup
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
			// (j.jones 2012-11-14 14:08) - PLID 52819 - this returns a medication pointer, but it's not
			// really used unless the EMN is still loading
			EMNMedication *pMedication = AddMedication(ea.nDestID, ea.bPopup, FALSE, sai);
			if(pProgress) pProgress->SetProgress(0,2,1);

			// (j.jones 2012-11-14 14:08) - PLID 52819 - if we are still loading, then our
			// medication pointer would always have a -1 ID, but if we are fully loaded
			// then it would have been saved, a -1 ID would mean it was deleted
			if(pMedication) {
				if(IsLoading()) {
					//we're loading, so having a medication pointer means we did really make one
					bAddedAnUnsavedMedication = TRUE;

					//Add to interface.
					if(GetInterface()) {
						GetInterface()->SendMessage(NXM_EMN_MEDICATION_ADDED, (WPARAM)pMedication, (LPARAM)pSourceEmn);
					}
				}
				else {
					//we're not loading, so the medication pointer has to have a positive ID
					//to indicate that we did really make one
					if(pMedication->nID != -1) {
						// (j.jones 2013-01-08 16:05) - PLID 45446 - This prescription has been saved, so track the ID.
						// If provided with a pointer for an ID, the caller will handle reconciliation.
						// Otherwise, track locally, and we will handle reconciliation in this function.
						if(pnNewPrescriptionID) {
							*pnNewPrescriptionID = pMedication->nID;
						}
						else {
							aryNewPrescriptionIDs.Add(pMedication->nID);
						}
					}

					//delete the medication, because we don't use its pointer anymore
					delete pMedication;
				}
			}

			if(pProgress) pProgress->SetProgress(0,2,2);
			
			//DRT 1/12/2007 - PLID 24178, 24182 - Re-show the window.
			// (a.walling 2007-09-07 09:42) - PLID 24371 - Show but do not activate
			if(GetParentEMR()) {
				GetParentEMR()->ShowActionProgressBar(SW_SHOWNA);
			}


			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}
	}

	// (j.jones 2012-09-28 15:45) - PLID 52922 - This function will check their preference
	// to save the EMN and warn about drug interactions.
	// We should not do this if the EMN is loading. This function will be called again
	// when loading is finished, if meds. exist.
	CEmrTreeWnd *pTree = GetInterface();
	if(pTree != NULL && !IsLoading() && (bAddedAnUnsavedMedication || aryNewPrescriptionIDs.GetSize() > 0)) {

		// (j.jones 2013-01-08 14:03) - PLID 45446 - open medication reconciliation
		if(!m_bIsTemplate && aryNewPrescriptionIDs.GetSize() > 0) {
			pTree->ReconcileCurrentMedicationsWithNewPrescriptions(this, aryNewPrescriptionIDs);

			//if reconciliation changed the current meds table, it would have forced a save
		}

		// (j.jones 2012-10-22 17:40) - PLID 52819 - must reload medications, if we added one
		ReloadMedicationsFromData(TRUE);

		// (j.jones 2012-11-13 10:10) - PLID 52869 - changed to be a posted message
		if(!m_bIsTemplate) {
			// (j.jones 2013-02-06 16:28) - PLID 55045 - Medication changes save immediately now,
			// so pass in TRUE for the lParam to tell this function that we already saved the changes
			// and the interactions should open if it was otherwise waiting for a save to succeed.
			CheckSaveEMNForDrugInteractions(TRUE);
		}
	}
}

//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoProcedure(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */)
{
	//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
	long nActionCount = paryActionsToSpawn->GetSize();
	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();

		//if it isn't already in the list, auto-add it
		if(!m_bIsTemplate) {
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			BOOL bDuplicate = FALSE;
			for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
				if(m_aryProcedures[i]->nID == ea.nDestID) {
					//Don't spawn twice.
					//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
					bDuplicate = TRUE;
				}
			}
			//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
			if(bDuplicate) {
				//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
				pSourceEmn->GetParentEMR()->UnlockAction(ea);
				continue;
			}

			// (c.haag 2006-11-14 17:34) - PLID 22825 - Make sure the procedure ID exists in data. If it does
			// not exist in data, raise a debug assertion and then carry on without importing a procedure.
			// Developers may detect bad data by running this query:
			//
			// select * from emractionst where desttype = 5 and destid not in (select id from proceduret)
			//
			//DRT 7/13/2007 - PLID 26669 - This is an extra database query that just causes unnecessary slowness.  We have chosen
			//	to live with these types of potential problems -- someone deleting a linked field while references to it are in 
			//	memory.  c.haag already fixed the bug that caused some bad data here, and wrote a mod to cleanup existing bad data.
			/*
			if (!ReturnsRecords("SELECT ID FROM ProcedureT WHERE ID = %d", ea.nDestID)) {
				ASSERT(FALSE);
				return;
			}
			*/

			if(pProgress) pProgress->SetProgress(0,3,1);
			EMNProcedure *pProc = new EMNProcedure;
			pProc->nID = ea.nDestID;
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);
			pProc->sai = sai;
			pProc->bIsNew = TRUE;
			//DRT 3/3/2006 - PLID 19441 - For efficiency, the more info dialog already has a list of 
			//	procedures in the combo box for the user to select, look there first for our procedure name.  The 
			//	interface window knows where the more info is, the CEMN does not, so we have to ask for help.
			//This should be safe because we are passing a pointer via SendMessage... the handler will be activated immediately.  If we
			//	were instead to use PostMessage, it is possible that our EMNProcedure* could get changed or deleted.
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_UPDATE_NAME_EMNPROCEDURE, (WPARAM)pProc, (LPARAM)pSourceEmn);
			}
			else {
				// ZM 4/3/2006 - Actually, this happens when importing topics that have a list item 
				// already checked that spawns a procedure.
					//This really shouldn't happen
					//ASSERT(FALSE);
			}
			if(pProgress) pProgress->SetProgress(0,3,2);
			AddProcedure(pProc);
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_EMN_PROCEDURE_ADDED, (WPARAM)pProc, (LPARAM)pSourceEmn);
				GetInterface()->SendMessage(NXM_EMN_CHANGED, (WPARAM)this);
			}
			if(pProgress) pProgress->SetProgress(0,3,3);

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}
	}
}

// (z.manning 2008-10-02 09:17) - PLID 21094 - Spawn lab actions
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoLab(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */)
{
	// (z.manning 2008-10-30 15:47) - PLID 21094 - It is not possible to spawn a lab without opening
	// the lab entry dialog and per d.thompson spawning dialogs are not permitted during the initial load.
	// So if this is the initial load, just skip spawning labs.
	if(bIsInitialLoad) {
		return;
	}

	//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
	long nActionCount = paryActionsToSpawn->GetSize();
	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++)
	{
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		//TES 2/16/2010 - PLID 37375 - Pull the source HotSpot from our array.
		CEMRHotSpot *pSourceSpot = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceSpot;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();
		EmrDetailImageStamp *pDetailStamp = NULL;
		if(ptrSourceTableRow != NULL) {
			// (c.haag 2012-10-26) - PLID 53440 - Use GetDetailImageStampObject
			pDetailStamp = ptrSourceTableRow->m_ID.GetDetailImageStampObject();
		}
		SourceActionInfo sai(&ea, pSourceDetail, pSourceSpot, ptrSourceTableRow);

		// (z.manning 2010-03-03 09:13) - PLID 37493 - Also look for a source hot spot for smart stamp based spawning
		if(pSourceSpot == NULL && pSourceDetail != NULL && ptrSourceTableRow != NULL && pDetailStamp != NULL)
		{
			if(pDetailStamp->eRule == esstsrIncreaseQuantity && pSourceDetail->m_EMRInfoType == eitTable)
			{
				pSourceSpot = pSourceDetail->GetSmartStampImageDetails()->GetHotSpotFromQuantityBasedSmartStamp(pDetailStamp->nStampID);
			}
			else
			{
				switch(pSourceDetail->m_EMRInfoType)
				{
					case eitImage:
						pSourceSpot = pSourceDetail->GetHotSpotFromDetailStamp(pDetailStamp);
						break;

					case eitTable:
						// (z.manning 2011-01-20 18:00) - PLID 42338 - Support multiple images per smart stamp table
						CEMNDetail *pImage = pSourceDetail->GetSmartStampImageDetails()->GetDetailFromDetailImageStamp(pDetailStamp);
						if(pImage != NULL) {
							pSourceSpot = pImage->GetHotSpotFromDetailStamp(pDetailStamp);
						}
						break;
				}
			}
		}

		// (z.manning 2010-03-17 12:21) - PLID 37439 - Check and see if we should add a new specimen to
		// an existing lab.
		// (d.thompson 2013-07-18) - PLID 40000 - We now have a preference whether this should happen or not.  The preference
		//	applies to all source types, not just smart stamps / ss tables.  Note that the old functionality (which previously
		//	had no preference) is now folded into this preference.
		EMNLab *pExistingLabToUse = NULL;
		if(GetRemotePropertyInt("MatchLabReqSpawning", 1, 0, "<None>", true) != 0) {
			// (d.thompson 2013-07-18) - PLID 40000 - Simple... if we found a lab, we use it.  No more matching on source of anything.
			//m_aryLabs is all labs on this EMN.  We want to match per EMN, not per EMR.
			for(int nExistingLabIndex = 0; nExistingLabIndex < m_aryLabs.GetSize() && pExistingLabToUse == NULL; nExistingLabIndex++)
			{
				EMNLab *pLab = m_aryLabs.GetAt(nExistingLabIndex);

				// (d.thompson 2013-07-18) - PLID 40000 - Do make sure that the lab procedure being used matches.  We don't want
				//	to mix up blood work and biopsies.
				if(ea.nDestID == pLab->nLabProcedureID) {
					pExistingLabToUse = pLab;
				}
				else {
					//Not a match, this lab must use a different procedure.  Try again!
				}
			}
		}

		if(!m_bIsTemplate)
		{
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			if(pProgress) { pProgress->SetProgress(0,2,1); }

			// (z.manning 2008-10-07 09:09) - PLID 21094 - Set the relevant details and then open
			// the lab entry dialog and let them enter labs as they would any other way.
			CWnd *pwndParent = GetOpenMultiPopupDlg() != NULL ? (CWnd*)GetOpenMultiPopupDlg() : (CWnd*)GetInterface();
			// (c.haag 2010-07-16 11:32) - PLID 34338 - Normally we have the main frame handle lab dialogs, but
			// this case is just too specialized for that. Because it's a new, modally run lab entry dialog, it's not
			// necessary for the main frame to be aware of it anyway.
			CLabEntryDlg dlg(pwndParent);
			dlg.m_bHideResults = TRUE; // (z.manning 2008-10-28 13:00) - PLID 31838
			dlg.SetPatientID(GetParentEMR()->GetPatientID());
			dlg.SetSourceActionID(ea.nID);
			dlg.SetSourceDataGroupID(ptrSourceTableRow->nGroupID);
			// (c.haag 2012-10-26) - PLID 53440 - Use GetDetailImageStampID
			dlg.SetSourceDetailImageStampID(ptrSourceTableRow->m_ID.GetDetailImageStampID());
			if(pExistingLabToUse != NULL) {
				// (z.manning 2010-03-17 15:24) - PLID 37439 - We want to add a specimen to an existing lab
				// so load from that ID and tell the lab entry dialog to immediately add a new specimen.
				dlg.SetInitialLabID(pExistingLabToUse->nID);
				dlg.m_bAddNewLabImmediatelyOnLoad = TRUE;
			}
			else {
				dlg.SetLabProcedureID(ea.nDestID);
			}
			if(pSourceSpot) {
				//TES 2/15/2010 - PLID 37375 - If we have a source HotSpot, then prefill the dialog with that spot's anatomic location
				dlg.SetInitialAnatomicLocation(pSourceSpot->GetAnatomicLocationID(), pSourceSpot->GetAnatomicQualifierID(), pSourceSpot->GetSide());
			}
			// (j.jones 2010-01-28 10:36) - PLID 37059 - fill in the EMN location
			dlg.SetDefaultLocationID(pSourceEmn->GetLocationID());
			// (r.gonet 07/22/2013) - PLID 57683 - In the preferences, we may have the providers from the EMN set up to be the default
			// lab providers. Pass them here.
			CDWordArray dwProviderIDs;
			for(int i = 0; i < pSourceEmn->m_aryProviders.GetSize(); i++) {
				dwProviderIDs.Add(pSourceEmn->m_aryProviders[i]->nID);
			}
			dlg.SetEMNProviders(dwProviderIDs);
			CEmrTreeWnd *pTree = GetInterface();
			// (a.walling 2011-10-20 14:23) - PLID 46071 - Liberating window hierarchy dependencies among EMR interface components
			if(pTree && pTree->GetPicContainer()) {
				dlg.m_nPIC = pTree->GetPicContainer()->GetCurrentPicID();
			}

			if(pSourceDetail != NULL && pSourceDetail->GetID() != -1) {
				dlg.SetSourceDetailID(pSourceDetail->GetID());
			}
			if(pProgress) { pProgress->Hide(); }
			dlg.DoModal();
			if(dlg.HasOpenedReport()) {
				// (z.manning 2008-11-04 09:47) - PLID 31904 - If we opened a report we need to minimize
				// the PIC container so they can see it.
				if(pwndParent != NULL) {
					pwndParent->SendMessage(NXM_EMR_MINIMIZE_PIC);
				}
			}
			else {
				if(pProgress) { pProgress->Show(); }
			}

			if(dlg.HasDataChanged())
			{
				// (z.manning 2008-10-07 09:10) - PLID 21094 - If they created labs then store them
				for(int nNewLabIndex = 0; nNewLabIndex < dlg.m_aryNewLabs.GetSize(); nNewLabIndex++) {
					EMNLab lab = dlg.m_aryNewLabs.GetAt(nNewLabIndex);
					EMNLab *pNewLab = new EMNLab;
					*pNewLab = lab;
					if(pSourceDetail != NULL)
					{
						//TES 2/16/2010 - PLID 37375 - Include the source HotSpot
						pNewLab->sai = sai;

						CEMRTopic *pTopic = pSourceDetail->m_pParentTopic;
						if(pTopic != NULL) {
							// (c.haag 2010-07-01 11:52) - PLID 36061 - Refactored detail creation into its own function
							CreateNewLabDetail(pTopic, pNewLab, bIsInitialLoad);
						}
					}
					else {
						// (z.manning 2008-10-07 09:13) - There's really no reason we shouldn' have a valid
						// source detail pointer here. But let's assert instead of throwing an exception becuase
						// the main problem it will cause is the inability to unspawn a lab which is something
						// that users shouldn't really be doing much anyway.
						ASSERT(FALSE);
					}
					m_aryLabs.Add(pNewLab);
				}

				// (j.jones 2010-08-30 08:57) - PLID 40095 - we may have saved labs and made changes
				// such that there is data in m_arSavedExistingLabs that is not in m_aryNewLabs
				for(int nSavedLabIndex = 0; nSavedLabIndex < dlg.m_arSavedExistingLabs.GetSize(); nSavedLabIndex++) {
					EMNLab lab = dlg.m_arSavedExistingLabs[nSavedLabIndex];
					EMNLab *pLab = GetLabByID(lab.nID);
					if(pLab != NULL) {
						pLab->CopyLabDetailsOnly(lab);
					}
					//TES 12/17/2009 - PLID 36622 - Now, update the details, if the text changed.
					CString strNewText = lab.GetText();
					CArray<CEMNDetail*,CEMNDetail*> arDetails;
					GetDetailsByLabID(lab.nID, arDetails);
					for(int nDetailIndex = 0; nDetailIndex < arDetails.GetSize(); nDetailIndex++) {
						CString strPreviousText = VarString(arDetails[nDetailIndex]->GetState(),"");
						if(strPreviousText != strNewText) {
							arDetails[nDetailIndex]->RequestStateChange((LPCTSTR)strNewText);
						}
					}
				}
			}

			if(pProgress) { pProgress->SetProgress(0,2,2); }

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}
	}
}

//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
// (c.haag 2008-06-17 09:53) - PLID 17842 - Added optional parameter for letting the caller get the newly added detail
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoEmrItem(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */, CEMNDetail** ppNewDetailOut /*= NULL */)
{
	try {
		EMRLOGINDENT(1, "CEMN::ProcessEmrAction_eaoEmrItem called for EMN \"%s\" (ID=%d TemplateID=%d)", m_strDescription, m_nID, m_nTemplateID); // (c.haag 2010-05-19 9:04) - PLID 38759

		// (c.haag 2008-06-17 09:57) - PLID 17842 - Before we do anything, make sure that ppNewDetailOut, if not null, points to a NULL detail.
		// Otherwise, if this somehow failed, the caller may be stuck with their uninitialized value, and think that garbage data is a valid detail.
		if (NULL != ppNewDetailOut) { *ppNewDetailOut = NULL; }

		//DRT 8/29/2007 - PLID 27225 - This only needs done once, not for every action.
		// (c.haag 2007-08-20 17:14) - PLID 25239 - Ensure that non-spawning-related loading is done
		EnsureCompletelyLoaded();

		//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
		long nActionCount = paryActionsToSpawn->GetSize();
		for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
			EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
			CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
			TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);

			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);


			//TES 12/7/2006 - PLID 23724 - DestID now represents an EmrInfoMasterT record, not an EmrInfoT record.
			//See if we already have the item in this EMN.  If we do: 
			//	If it's hidden, show it and return.
			//  If it's one-per-emr, return.
			//See if we have a stored location for it.  If we do:
			//  Tell the appropriate topic to add it at the specified location.
			//Otherwise:
			//  Tell the topic of the source item to add it.

			// (j.jones 2007-07-16 15:40) - PLID 26694 - added bOnePerEmn to the EmrAction struct
			/*
			_variant_t varOnePerEmn = GetTableField("EmrInfoT INNER JOIN EmrInfoMasterT ON EmrInfoT.ID = EmrInfoMasterT.ActiveEmrInfoID", "OnePerEmn", "EmrInfoMasterT.ID", ea.nDestID);
			if(varOnePerEmn.vt == VT_NULL) {
				//This field doesn't allow NULLs, so this must be an invalid EmrInfoT.ID.
				return;
			}
			*/

			//TES 4/7/2006 - Here's how we'll track our progress.  Give ourselves a range of 0-100 while we're searching for
			//it, then count opening the recordset as 100, count 100 for the rest of it, for a total of 300.
			int nProgress = 0;
			//Do we already have the item in this EMN?
			//Remember the template details that we find already present for this item, so we don't re-add them.
			CArray<long,long> arTemplateDetailIDs;
			CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
			GetAllTopics(arAllTopics);
			//TES 6/19/2006 - We need to have two loops, first one that determines whether showing the detail would violate
			//one-per-emn, and second, one to show the detail if it's hidden.
			BOOL bDoneOnePer = FALSE;
			// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
			int i = 0;
			for(i = 0; i < arAllTopics.GetSize(); i++) {
				for(int j = 0; j < arAllTopics[i]->GetEMNDetailCount(); j++) {
					//Update our progress.
					if(nProgress < 100) nProgress++;
					if(pProgress) pProgress->SetProgress(0,300,nProgress);

					CEMNDetail *pDetail = arAllTopics[i]->GetDetailByIndex(j);
					if(pDetail->m_nEMRInfoMasterID == ea.nDestID) {
						// (j.jones 2007-07-16 15:40) - PLID 26694 - added bOnePerEmn to the EmrAction struct
						if(ea.bOnePerEmn && pDetail->GetVisible()) {
							//It's already on this EMN, and it's only supposed to be on once, so we're done.
							//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
							bDoneOnePer = TRUE;
						}
						// (j.jones 2008-04-28 10:34) - PLID 29792 - only add to our "duplicate" array
						// if the source detail is the same
						if(pSourceDetail != NULL) {
							if(pSourceDetail == pDetail->GetSourceDetail()
								|| (pSourceDetail->GetID() != -1 && pSourceDetail->GetID() == pDetail->GetSourceDetailID())) {

								arTemplateDetailIDs.Add(pDetail->m_nEMRTemplateDetailID);
							}
						}
					}
				}
			}

			//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
			if(bDoneOnePer) {
				//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
				pSourceEmn->GetParentEMR()->UnlockAction(ea);
				continue;
			}

			//DRT 8/29/2007 - PLID 27225 - After much deliberation on the behavior of this entire function, I believe that
			//	the following (large) block of code ONLY affects templates, never a patient EMN.  The end result of this code
			//	is that we try to search for a hidden detail already on this EMN to show.  But when you are working with 
			//	a patient EMN, it is impossible for a detail to exist in a hidden state.  Details either exist visible or
			//	they don't exist at all.  Therefore I'm blocking out this code to be template-only.
			//If my assumption is wrong, I believe the only side effect would be that there would be hidden details to be
			//	ignored when we closed.
			if(m_bIsTemplate) {

				//
				// (c.haag 2007-01-25 08:16) - PLID 24417 - Later on in this function, we used to call
				// IsDetailSourceActionIDEquivalent individually for every detail in every topic, and
				// that function queries the data. We need to optimize this by running just one query
				// that would have the results for all the details, and build a map of those results for
				// quick referencing
				//

				// (j.jones 2007-03-07 09:44) - PLID 25095 - This needs tweaked a bit to accomodate the
				// possibility of duplicates using different SourceActionIDs, such that we ensure we're
				// spawning the item with the most recent SourceActionID. We'll do so by tracking the
				// highest SourceActionID possible (nIdealSourceActionIDToUse), then using whichever
				// spawned item matches that ID or is otherwise the highest SourceActionID (nMaxSourceActionIDFound)
				// of the available items to use.

				CMap<long, long, BOOL, BOOL> mapDSAIDEquivalent;
				_RecordsetPtr prsDSAIDEquivalent;
				long nIdealSourceActionIDToUse = -1;
				long nMaxSourceActionIDFound = -1;
				CString strSql;

				// Generate the query filter by concatenating the topic ID's
				for(i = 0; i < arAllTopics.GetSize(); i++) {
					for(int j = 0; j < arAllTopics[i]->GetEMNDetailCount(); j++) {
						CEMNDetail *pDetail = arAllTopics[i]->GetDetailByIndex(j);
						long nSourceActionID = pDetail->GetSourceActionID();
						// (j.jones 2007-08-01 09:49) - PLID 26900 - we can only spawn a detail
						// where the master ID is our destination ID, so we can reduce our filter
						// query that way
						if (nSourceActionID > 0 && pDetail->m_nEMRInfoMasterID == ea.nDestID) {
							CString str;
							str.Format("%d,", nSourceActionID);
							strSql += str;
						}
					}
				}
				// Now run the query and pull in the records. Note that the query is different for templates
				if (!strSql.IsEmpty()) {
					strSql.TrimRight(",");
					if(ea.eaoSourceType == eaoEmrDataItem) {
						// (j.jones 2007-03-07 09:47) - PLID 25095 - load in order of newest to oldest,
						// such that we know the first record returned is the ideal action record
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						prsDSAIDEquivalent = CreateParamRecordset(
							"SELECT ID FROM EMRActionsT WHERE SourceType = {INT} AND SourceID IN (SELECT ID FROM EmrDataT "
							" WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem WHERE SourceItem.ID = {INT}) ) "
							"AND DestType = {INT} AND ID IN ({INTSTRING}) "
							"ORDER BY ID DESC",
							eaoEmrDataItem, ea.nSourceID, eaoEmrItem, strSql);
					}
					else if(ea.eaoSourceType == eaoEmrImageHotSpot) {
						// (z.manning, 01/24/2008) - PLID 28690
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						prsDSAIDEquivalent = CreateParamRecordset(
							"SELECT ID FROM EmrActionsT "
							"WHERE SourceType = {INT} AND SourceID IN (SELECT ID FROM EmrImageHotSpotsT "
							"	WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
							"	WHERE SourceItem.ID = {INT})) AND DestType = {INT} AND ID IN ({INTSTRING}) "
							"ORDER BY ID DESC "
							, eaoEmrImageHotSpot, ea.nSourceID, eaoEmrItem, strSql);
					}
					else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
						// (z.manning 2009-02-17 10:07) - PLID 33072
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						prsDSAIDEquivalent = CreateParamRecordset(
							"SELECT ID FROM EmrActionsT \r\n"
							"WHERE SourceType = {INT} AND SourceID IN \r\n"
							"	(SELECT ID FROM EmrTableDropdownInfoT \r\n"
							"	 WHERE DropdownGroupID = \r\n"
							"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem \r\n"
							"		 WHERE SourceItem.ID = {INT})) \r\n"
							"		AND DestType = {INT} AND ID IN ({INTSTRING}) \r\n"
							, eaoEmrTableDropDownItem, ea.nSourceID, eaoEmrItem, strSql);
					}
					//TES 3/15/2010 - PLID 37530 - Smart Stamps now spawn on templates; they don't branch so just check for the ID.
					else if(ea.eaoSourceType == eaoSmartStamp) {						
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						prsDSAIDEquivalent = CreateParamRecordset(
							"SELECT ID FROM EmrActionsT \r\n"
							"WHERE SourceType = {INT} AND SourceID = {INT} \r\n"
							" AND DestType = {INT} AND ID IN ({INTSTRING}) \r\n"
							, eaoSmartStamp, ea.nSourceID, eaoEmrItem, strSql);
					}

					while (!prsDSAIDEquivalent->eof) {
						long nSourceActionID = AdoFldLong(prsDSAIDEquivalent, "ID");
						mapDSAIDEquivalent[nSourceActionID] = TRUE;

						// (j.jones 2007-03-07 09:48) - PLID 25095 - track the maximum
						// SourceActionID, though this assignment should only be occurring
						// in the first iteration of this while loop
						if(nSourceActionID > nIdealSourceActionIDToUse)
							nIdealSourceActionIDToUse = nSourceActionID;

						prsDSAIDEquivalent->MoveNext();
					}
					prsDSAIDEquivalent->Close();
				}

				// (c.haag 2007-01-25 08:30) - PLID 24417 - The optimization is ready. Resume topic and detail traversal (back to legacy code)

				// (j.jones 2007-03-07 09:56) - PLID 25095 - track the ideal detail pointer,
				// that uses nMaxSourceActionIDFound (yes we could just use the detail's
				// GetSourceActionID(), but I think nMaxSourceActionIDFound is clearer)
				CEMNDetail *pPreferredDetailToUse = NULL;

				//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
				BOOL bDoneSpawning = FALSE;
				for(i = 0; i < arAllTopics.GetSize() && !bDoneSpawning; i++) {
					for(int j = 0; j < arAllTopics[i]->GetEMNDetailCount() && !bDoneSpawning; j++) {
						//Update our progress.
						if(nProgress < 100) nProgress++;
						if(pProgress) pProgress->SetProgress(0,300,nProgress);

						CEMNDetail *pDetail = arAllTopics[i]->GetDetailByIndex(j);

						// (j.jones 2006-09-21 16:31) - PLID 22634 - IsDetailSourceActionIDEquivalent checks to
						// see if the detail has this action as a source OR if a previous version of the spawning
						// item is responsible for the source action

						// (j.jones 2007-01-12 15:10) - PLID 24027 - added SourceDetailID support
						BOOL bSourceDetailOK = FALSE;
						if(pSourceDetail) {
							//if we were given a source detail (and we should have), see if
							//the detail we are comparing to has the same source detail
							if(pDetail->GetSourceDetail()) {
								if(pSourceDetail == pDetail->GetSourceDetail()) {
									bSourceDetailOK = TRUE;
								}
							}
							//if the detail doesn't have a source detail pointer, compare on source detail IDs
							if(pDetail->GetSourceDetailID() != -1) {
								if(pDetail->GetSourceDetailID() == (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
									bSourceDetailOK = TRUE;
								}
							}
						}
						else {
							//we were not given a source detail, so don't bother trying to
							//compare by it, just use SourceActionID
							bSourceDetailOK = TRUE;
							//however, this shouldn't happen
							ASSERT(FALSE);
						}

						// (c.haag 2007-01-25 08:25) - PLID 24417 - Look at our map to determine whether
						// the source action ID is equivalent rather than calling IsDetailSourceActionIDEquivalent,
						// which is slower
						long nDetailSourceActionID = pDetail->GetSourceActionID();
						BOOL bIsDetailSourceActionIDEquivalent = FALSE;
						mapDSAIDEquivalent.Lookup(nDetailSourceActionID, bIsDetailSourceActionIDEquivalent);

						if(bIsDetailSourceActionIDEquivalent && pDetail->m_nEMRInfoMasterID == ea.nDestID && bSourceDetailOK) {
							//We've found it.  Is it just hidden?
							if(!pDetail->GetVisible()) {

								// (j.jones 2007-03-07 09:59) - PLID 25095 - do not show it yet, instead
								// first check and see if it is the ideal source action ID. If so, show
								// immediately. If not, track it as a candidate item to be shown,
								// provided it is preferable to our existing candidate item. 
								if(nIdealSourceActionIDToUse == nDetailSourceActionID) {

									// (j.jones 2007-03-07 09:59) - PLID 25095 - it's the ideal SourceActionID,
									// so we know no other candidate can be better

									//OK, we just need to show it.
									//TES 2/16/2007 - PLID 24768 - We also need to tell it what its sourcedetail is.  We always should
									// have been doing this, but it usually wasn't a problem, because the first time it was loaded, 
									// it did have its sourcedetail set properly (by code farther down in this function), 
									// and from then on the sourcedetail was loaded out of data, but the one exception is when 
									// importing topics that have spawned details on them; in that case, the detail is found in 
									// memory but does not exist in data, so we need to make sure that it is completely up to date.
									//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
									pDetail->SetSourceActionInfo(sai);
									
									pDetail->SetVisible(TRUE, FALSE, bIsInitialLoad);
									//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
									if(pDetail->m_pParentTopic && pDetail->m_pParentTopic->GetParentEMN()) {
										pDetail->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pDetail->GetMergeFieldName(TRUE));
									}
									//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
									// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
									if(GetInterface()) {
										GetInterface()->SendMessage(NXM_EMR_ITEM_ADDED, (WPARAM)pDetail, (LPARAM)bIsInitialLoad);
									}

									//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
									bDoneSpawning = TRUE;
								}
								else {

									// (j.jones 2007-03-07 10:03) - PLID 25095 - it's not ideal, but is it the best we have?
									if(nDetailSourceActionID > nMaxSourceActionIDFound) {
										nMaxSourceActionIDFound = nDetailSourceActionID;
										pPreferredDetailToUse = pDetail;
									}

									//keep searching the list
								}

							} // if(!pDetail->GetVisible()) {

						} // if(bIsDetailSourceActionIDEquivalent && pDetail->m_nEMRInfoMasterID == ea.nDestID && bSourceDetailOK) {

					} // for(int j = 0; j < arAllTopics[i]->GetEMNDetailCount() && !bDoneSpawning; j++) {

				} // for(i = 0; i < arAllTopics.GetSize() && !bDoneSpawning; i++) {

				//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
				if(bDoneSpawning) {
					//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
					pSourceEmn->GetParentEMR()->UnlockAction(ea);
					continue;
				}

				// (j.jones 2007-03-07 10:04) - PLID 25095 - did we find any candidate details?
				// If pPreferredDetailToUse is not NULL, it means it is the newest SourceActionID
				// we could find, but couldn't definitively confirm it was "the best option" until
				// the search completed. Now that we've done this, show it.
				// (It shouldn't have been assigned if it was visible, but just check again to make sure.)
				if(pPreferredDetailToUse != NULL && (!pPreferredDetailToUse->GetVisible())) {

					//this is a copy of the block of code from above
					
					//OK, we just need to show it.
					//TES 2/16/2007 - PLID 24768 - We also need to tell it what its sourcedetail is.  We always should
					// have been doing this, but it usually wasn't a problem, because the first time it was loaded, 
					// it did have its sourcedetail set properly (by code farther down in this function), 
					// and from then on the sourcedetail was loaded out of data, but the one exception is when 
					// importing topics that have spawned details on them; in that case, the detail is found in 
					// memory but does not exist in data, so we need to make sure that it is completely up to date.
					//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
					pPreferredDetailToUse->SetSourceActionInfo(sai);
					
					pPreferredDetailToUse->SetVisible(TRUE, FALSE, bIsInitialLoad);
					//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
					if(pPreferredDetailToUse->m_pParentTopic && pPreferredDetailToUse->m_pParentTopic->GetParentEMN()) {
						pPreferredDetailToUse->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pPreferredDetailToUse->GetMergeFieldName(TRUE));
					}
					// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
					if(GetInterface()) {
						GetInterface()->SendMessage(NXM_EMR_ITEM_ADDED, (WPARAM)pPreferredDetailToUse, (LPARAM)bIsInitialLoad);
					}

					//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
					//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
					pSourceEmn->GetParentEMR()->UnlockAction(ea);
					continue;
				}

				// (c.haag 2008-02-14 11:11) - PLID 28568 - (6.) (No code change -- comment only) If we get here, it means that 
				// whatever we want to spawn does not already exist on the template. A new detail will have to be created.
				// Because the act of unspawning can only work for details that already exist, this is the place in code
				// where the similarity between processing and revoking an emr item on a template must end.

			}//end if m_bIsTemplate

			//Our progress is now at 100
			if(pProgress) pProgress->SetProgress(0,300,100);

			//Is there a stored location for it?  Check for a detail with right source action id, whose template is either
			//our current template or the original template of our source detail
			//TES 1/24/2006 - PLID 18956 - FIRST check our current template, THEN if that fails, check the original template 
			//of our source detail, because priority should be given to the "apparent" template.
			//TES 3/7/2006 - PLID 19065 - Also, don't include any spawned locations that we've already deleted.
			CString strExclude = "-1";
			if(m_bIsTemplate) {
				CArray<CEMNDetail*,CEMNDetail*> arDeletedDetails;
				GenerateTotalEMNDeletedDetailArray(&arDeletedDetails);
				if(arDeletedDetails.GetSize()) {
					strExclude = "";
					for(int nDeletedDetail = 0; nDeletedDetail < arDeletedDetails.GetSize(); nDeletedDetail++) {
						strExclude += FormatString("%li,",arDeletedDetails[nDeletedDetail]->m_nEMRTemplateDetailID);
					}
					strExclude.TrimRight(",");
				}
			}

			bool bFound = false;			

			// (j.jones 2006-09-21 16:31) - PLID 22634 - look for more than just the current action,
			// also look for whether or not a previous version of the spawning item may be the spawning
			// parent of the stored item

			//default to searching just for this action ID
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			CSqlFragment sqlSourceActionIDFind("SourceActionID = {INT}", ea.nID);

			if(ea.eaoSourceType == eaoEmrItem) {

				//TES 12/7/2006 - As I attempted to test my changes below, I realized that a SourceType of eaoEmrItem and a 
				// DestType of eaoEmrItem is bad data!
				ASSERT(FALSE);
				/*//see if any previous version of that info item spawns this detail
				//TES 12/5/2006 - PLID 23724 - We can just compare on EmrInfoMasterID now.
				strSourceActionIDFind.Format("SourceActionID IN "
					"(SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
					" (SELECT ID FROM EmrInfoT WHERE EmrInfoMasterID = (SELECT EmrInfoMasterID FROM EmrInfoT SourceItem "
					" WHERE SourceItem.ID = %li)) "
					"AND DestType = %li AND DestID = %li)", eaoEmrItem, ea.nSourceID, eaoEmrItem, ea.nDestID);
				
				*//*CString strPastItemIDs = GeneratePastEMRInfoIDs(ea.nSourceID);
				//don't change the strSourceActionIDFind unless there is more than one version
				if(strPastItemIDs.Find(",") != -1) {
					//filter on actions for a past versions of the spawning item, that match up
					//with the current action's info item
					strSourceActionIDFind.Format("SourceActionID IN "
						"(SELECT ID FROM EMRActionsT WHERE SourceType = %li AND SourceID IN (%s) "
						"AND DestType = %li AND DestID = %li)", eaoEmrItem, strPastItemIDs, eaoEmrItem, ea.nDestID);
				}*/
			}
			else if(ea.eaoSourceType == eaoEmrDataItem) {

				//see if any previous version of that data item spawns this detail
				//TES 12/6/2006 - PLID 23766 - We can just compare on EmrDataGroupID now.
				// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
				sqlSourceActionIDFind.Create("SourceActionID IN "
					"(SELECT ID FROM EmrActionsT WHERE SourceType = {CONST} AND SourceID IN "
					" (SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = {CONST} AND DestID = {INT})", eaoEmrDataItem, ea.nSourceID, eaoEmrItem, ea.nDestID);
				
				/*CString strPastItemIDs = GeneratePastEMRDataIDs(ea.nSourceID);
				//don't change the strSourceActionIDFind unless there is more than one version
				if(strPastItemIDs.Find(",") != -1) {
					//filter on actions for a past versions of the spawning item, that match up
					//with the current action's info item
					strSourceActionIDFind.Format("SourceActionID IN "
						"(SELECT ID FROM EMRActionsT WHERE SourceType = %li AND SourceID IN (%s) "
						"AND DestType = %li AND DestID = %li)", eaoEmrDataItem, strPastItemIDs, eaoEmrItem, ea.nDestID);
				}*/
			}
			// (z.manning, 02/20/2008) - PLID 28690 - Need to handle image hot spot groups
			else if(ea.eaoSourceType == eaoEmrImageHotSpot) {
				// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
				sqlSourceActionIDFind.Create("SourceActionID IN "
					"(SELECT ID FROM EmrActionsT WHERE SourceType = {CONST} AND SourceID IN "
					" (SELECT ID FROM EmrImageHotSpotsT WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = {CONST} AND DestID = {INT})"
					, eaoEmrImageHotSpot, ea.nSourceID, eaoEmrItem, ea.nDestID);
			}
			else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
				// (z.manning 2009-02-17 10:07) - PLID 33072
				// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
				sqlSourceActionIDFind.Create("SourceActionID IN \r\n"
					"(SELECT ID FROM EmrActionsT \r\n"
					" WHERE SourceType = {CONST} AND SourceID IN \r\n"
					"	(SELECT ID FROM EmrTableDropdownInfoT \r\n"
					"	 WHERE DropdownGroupID = \r\n"
					"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem \r\n"
					"		 WHERE SourceItem.ID = {INT})) \r\n"
					"		AND DestType = {CONST} AND DestID = {INT}) \r\n"
					, eaoEmrTableDropDownItem, ea.nSourceID, eaoEmrItem, ea.nDestID);
			}

			// (j.jones 2007-01-15 11:16) - PLID 24027 - if on a patient EMN, check the source detail ID of the template
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			CSqlFragment sqlSourceDetailIDFind;
			if(pSourceDetail && pSourceDetail->m_nEMRTemplateDetailID != -1) {
				sqlSourceDetailIDFind.Create(" AND SourceDetailID = {INT}", pSourceDetail->m_nEMRTemplateDetailID);
			}

			// (j.jones 2007-01-31 11:17) - PLID 24515 - try to filter by SourceDetailID,
			// and if that is empty, search just by SourceActionIDs
			_RecordsetPtr rsTemplateDetails;
			if(!sqlSourceDetailIDFind.IsEmpty()) {
				// (j.jones 2007-07-16 14:28) - PLID 26695 - don't open if we have a -1 template ID
				long nTemplateID = GetTemplateID();
				if(nTemplateID != -1 && ea.nDestID != -1) {
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrTemplateTopicID FROM EmrTemplateDetailsT "
						"WHERE TemplateID = {INT} AND {SQL} AND EmrInfoMasterID = {INT} AND ID NOT IN ({INTARRAY}) AND ID NOT IN ({INTSTRING}) {SQL} "
						"ORDER BY SourceActionID DESC", 
						nTemplateID, sqlSourceActionIDFind, ea.nDestID,
						arTemplateDetailIDs, strExclude, sqlSourceDetailIDFind);
				}
				if(rsTemplateDetails == NULL || rsTemplateDetails->GetState() == adStateClosed || rsTemplateDetails->eof) {
					//OK, try the original template.

					// (j.jones 2007-07-16 14:28) - PLID 26695 - before, we would try to get
					// the template ID for a topic ID of -1, now we avoid that
					long nTemplateID = -1;
					//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
					if(pSourceDetail == NULL || pSourceDetail->m_pParentTopic == NULL) {
						//I'm unclear what this means, so we'll just have to give up with a clear error
						AfxThrowNxException("Error in ProcessEMRAction - pSourceDetail could not be properly accessed.");
					}
					long nOrigTopicID = pSourceDetail->m_pParentTopic->GetOriginalTemplateTopicID();
					//TES 3/31/2011 - PLID 43080 - If this topic is a spawned topic, but was not positioned in the master template, then
					// it will not have an OriginalTemplateTopicID.  However, its TemplateTopicID will point to its source template, so use
					// that.
					if(nOrigTopicID == -1) {
						nOrigTopicID = pSourceDetail->m_pParentTopic->GetTemplateTopicID();
					}
					if(nOrigTopicID != -1) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						_RecordsetPtr rsTemplateID = CreateParamRecordset("SELECT TemplateID FROM EmrTemplateTopicsT WHERE ID = {INT}", nOrigTopicID);
						if(!rsTemplateID->eof) {
							nTemplateID = AdoFldLong(rsTemplateID, "TemplateID",-1);
						}
						rsTemplateID->Close();
					}

					if(nTemplateID != -1 && ea.nDestID != -1) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrTemplateTopicID FROM EmrTemplateDetailsT "
							"WHERE TemplateID = {INT} AND {SQL} AND EmrInfoMasterID = {INT} AND ID NOT IN ({INTARRAY}) AND ID NOT IN ({INTSTRING}) {SQL} "
							"ORDER BY SourceActionID DESC", 
							nTemplateID, sqlSourceActionIDFind, ea.nDestID,
							arTemplateDetailIDs, strExclude, sqlSourceDetailIDFind);
					}
				}
			}

			// (j.jones 2007-07-16 14:50) - PLID 26695 - it is possible we know ahead of time
			// that we won't find anything, thus we may not have even opened the recordset
			if(sqlSourceDetailIDFind.IsEmpty() || rsTemplateDetails == NULL || rsTemplateDetails->GetState() == adStateClosed || rsTemplateDetails->eof) {
				// (j.jones 2007-07-16 14:28) - PLID 26695 - don't open if we have a -1 template ID
				long nTemplateID = GetTemplateID();
				if(nTemplateID != -1 && ea.nDestID != -1) {
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrTemplateTopicID FROM EmrTemplateDetailsT "
						"WHERE TemplateID = {INT} AND {SQL} AND EmrInfoMasterID = {INT} AND ID NOT IN ({INTARRAY}) AND ID NOT IN ({INTSTRING}) "
						"ORDER BY SourceActionID DESC", 
						nTemplateID, sqlSourceActionIDFind, ea.nDestID,
						arTemplateDetailIDs, strExclude);
				}
				if(rsTemplateDetails == NULL || rsTemplateDetails->GetState() == adStateClosed || rsTemplateDetails->eof) {
					//OK, try the original template.

					// (j.jones 2007-07-16 14:28) - PLID 26695 - before, we would try to get
					// the template ID for a topic ID of -1, now we avoid that
					long nTemplateID = -1;
					//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
					if(pSourceDetail == NULL || pSourceDetail->m_pParentTopic == NULL) {
						//I'm unclear what this means, so we'll just have to give up with a clear error
						AfxThrowNxException("Error in ProcessEMRAction - pSourceDetail could not be properly accessed(2).");
					}
					long nOrigTopicID = pSourceDetail->m_pParentTopic->GetOriginalTemplateTopicID();
					//TES 3/31/2011 - PLID 43080 - If this topic is a spawned topic, but was not positioned in the master template, then
					// it will not have an OriginalTemplateTopicID.  However, its TemplateTopicID will point to its source template, so use
					// that.
					if(nOrigTopicID == -1) {
						nOrigTopicID = pSourceDetail->m_pParentTopic->GetTemplateTopicID();
					}
					if(nOrigTopicID != -1) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						_RecordsetPtr rsTemplateID = CreateParamRecordset("SELECT TemplateID FROM EmrTemplateTopicsT WHERE ID = {INT}", nOrigTopicID);
						if(!rsTemplateID->eof) {
							nTemplateID = AdoFldLong(rsTemplateID, "TemplateID",-1);
						}
						rsTemplateID->Close();
					}

					if(nTemplateID != -1 && ea.nDestID != -1) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrTemplateTopicID FROM EmrTemplateDetailsT "
							"WHERE TemplateID = {INT} AND {SQL} AND EmrInfoMasterID = {INT} AND ID NOT IN ({INTARRAY}) AND ID NOT IN ({INTSTRING}) "
							"ORDER BY SourceActionID DESC", 
							nTemplateID, sqlSourceActionIDFind, ea.nDestID,
							arTemplateDetailIDs, strExclude);
					}
				}
			}

			//We've opened the recordset, our progress is now at 200.
			if(pProgress) pProgress->SetProgress(0,300,200);

			// (a.walling 2008-07-07 16:18) - PLID 27995 - Define the template detail ID here so it can be used outside of this scope.
			long nID = -1;
			long nTopicID = -1;
			// (j.jones 2007-07-16 14:50) - PLID 26695 - it is possible we know ahead of time
			// that we won't find anything, thus we may not have even opened the recordset
			if(rsTemplateDetails != NULL && rsTemplateDetails->GetState() != adStateClosed && !rsTemplateDetails->eof) {
				//Add to memory object.
				nTopicID = AdoFldLong(rsTemplateDetails, "EmrTemplateTopicID");
				nID = AdoFldLong(rsTemplateDetails, "ID");
				rsTemplateDetails->Close();
				// (a.walling 2010-04-05 13:56) - PLID 38060 - Also use the source action info
				CEMRTopic *pTopic = GetTopicByTemplateTopicID(nTopicID, pSourceDetail->GetSpawnedGroupID(), NULL, &pSourceDetail->GetSpawnedGroupSourceActionInfo());
				if(pTopic) {				
					// (a.walling 2009-10-23 09:23) - PLID 36046 - Track construction in initial reference count
					CEMNDetail *pNewDetail = CEMNDetail::CreateDetail(pTopic, "eaoEmrItem spawn template detail");
					// (c.haag 2007-08-06 10:58) - PLID 26954 - Assign the EMN spawner object
					// for faster processing of LoadContent
					pNewDetail->SetEMNSpawner(pEMNSpawner);
					try {
						// (j.jones 2007-04-12 15:51) - PLID 25604 - lock spawning so that if we popup,
						// we will do so BEFORE spawning the contents
						long nEMRGroupID = -1;
						long nPatientID = -1;
						if(GetParentEMR()) {
							GetParentEMR()->LockSpawning();

							nEMRGroupID = GetParentEMR()->GetID();
							nPatientID = GetParentEMR()->GetPatientID();
						}

						// (j.jones 2007-04-12 14:22) - PLID 25604 - passed bIsInitialLoad into this function
						// (a.walling 2012-06-22 14:01) - PLID 51150 - No parent window param
						pNewDetail->LoadFromTemplateDetailID(nID, m_bIsTemplate, FALSE, bIsInitialLoad, nPatientID, nEMRGroupID, NULL);
						// (z.manning 2011-02-02 13:42) - PLID 42306 - Make sure we flag this detail as new.
						pNewDetail->SetNew();
						//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
						pNewDetail->SetSourceActionInfo(sai);

						// (c.haag 2007-05-22 12:02) - PLID 26095 - Do not increment the detail reference;
						// we'll be done with it when we leave the scope of this code branch. The topic will
						// own the only reference.
						pTopic->AddDetail(pNewDetail, bIsInitialLoad, FALSE);

						// (j.jones 2010-02-12 14:23) - PLID 37318 - check whether this is part of a SmartStamp
						// set of details, and ensure links (or create the table) accordingly
						// (z.manning 2010-05-10 17:23) - PLID 38527 - Let this function know we're spawning the image
						EnsureSmartStampLinks(pNewDetail, TRUE);

						//Add to interface.
						// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
						if(GetInterface()) {
							GetInterface()->SendMessage(NXM_EMR_ITEM_ADDED, (WPARAM)pNewDetail, (LPARAM)bIsInitialLoad);
						}

						if(!m_bIsTemplate && ea.bPopup && !bIsInitialLoad) {

							// (a.walling 2009-11-17 15:37) - PLID 36365 - Will also update popups
							if (eitNarrative == pNewDetail->m_EMRInfoType) {
								pNewDetail->UpdateNarrativeFields();
							}

							// (z.manning, 02/01/2007) - PLID 24524 - The progress parameter may get 'lost' over the many functions
							// that may can get called during the loading/spawning process, so let's go straight to the source to 
							// hide/show the progress bar.
							if(GetParentEMR()) {
								GetParentEMR()->ShowActionProgressBar(SW_HIDE);
							}

							//TES 1/11/2008 - PLID 24157 - Instead of popping up the detail, add it to our list of 
							// popped-up details, we will display them all in a clean interface at the appropriate time.
							//pNewDetail->Popup();
							AddDetailToPopup(pNewDetail, pSourceDetail);

							// (a.walling 2007-09-07 09:42) - PLID 24371 - Show but do not activate
							if(GetParentEMR()) {
								GetParentEMR()->ShowActionProgressBar(SW_SHOWNA);
							}
						}
						bFound = true;

						// (j.jones 2007-04-12 15:51) - PLID 25604 - now unlock spawning, such that if we did
						// pop up, it is now safe to spawn
						if(GetParentEMR()) {
							GetParentEMR()->UnlockSpawning();
						}

						// (c.haag 2007-08-06 10:58) - PLID 26954 - Reset the EMN spawner object of the detail
						pNewDetail->SetEMNSpawner(NULL);

						// (c.haag 2008-06-17 10:00) - PLID 17842 - Assign this to the output
						if (NULL != ppNewDetailOut) { *ppNewDetailOut = pNewDetail; }

					} NxCatchAllSilentCallThrow( if (pNewDetail) { pNewDetail->SetEMNSpawner(NULL); } );
				}
			}
			else {
				if(rsTemplateDetails != NULL && rsTemplateDetails->GetState() != adStateClosed)
					rsTemplateDetails->Close();
			}

			if(!bFound) {
				//Either there was no stored location, or there was a stored location for a topic that doesn't actually exist
				//(which is possible if it was a spawned topic that never got spawned).
				//So, add to the current topic.

				// (j.jones 2007-04-12 15:51) - PLID 25604 - lock spawning so that if we popup,
				// we will do so BEFORE spawning the contents
				long nEMRGroupID = -1;
				long nPatientID = -1;
				if(GetParentEMR()) {
					GetParentEMR()->LockSpawning();

					nEMRGroupID = GetParentEMR()->GetID();
					nPatientID = GetParentEMR()->GetPatientID();
				}
				
				//Add to memory object.
				//(e.lally 2006-03-20) PLID 19751 - We want to add the new detail to the topic first, then load it
				//DRT 8/2/2007 - PLID 26919 - Added the SourceID of the action
				// (c.haag 2007-08-06 17:47) - PLID 26992 - Added the EMN spawner object so AddNewDetailFromEmrInfoMasterID
				// will only query data on rare occasions, if at all
				//DRT 8/14/2007 - PLID 27067 - Added SourceActionSourceDataGroupID as -1 because this is a new detail, and thus the unspawning
				//	can detect based on the source IDs.
				//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
				if(pSourceDetail == NULL || pSourceDetail->m_pParentTopic == NULL) {
					//I'm unclear what this means, so we'll just have to give up with a clear error
					AfxThrowNxException("Error in ProcessEMRAction - pSourceDetail could not be properly accessed when creating new spawned detail.");
				}

				// (a.walling 2008-07-07 16:18) - PLID 27995 - Previously, if we could not find the topic for this detail, we would load it
				// from the info id, place it on the topic of the spawning item, and make a 'new' one. However this was incorrect; it is not
				// really a new detail, and after attempting to save you would hit a trigger which fires an exception. The best way to handle
				// this is to load it as an existing detail, and set the new parent and positioning info appropriately, marking as modified.
				CEMNDetail *pNewDetail = NULL;
				
				if (nID != -1 && pSourceDetail->m_pParentTopic != NULL) {
					// (a.walling 2009-10-23 09:23) - PLID 36046 - Track construction in initial reference count
					pNewDetail = CEMNDetail::CreateDetail(pSourceDetail->m_pParentTopic, "eaoEmrItem spawn template detail source detail topic");
					// (a.walling 2012-06-22 14:01) - PLID 51150 - No parent window param
					pNewDetail->LoadFromTemplateDetailID(nID, m_bIsTemplate, FALSE, bIsInitialLoad, nPatientID, nEMRGroupID, NULL);
					// (z.manning 2011-02-02 13:42) - PLID 42306 - Make sure we flag this detail as new.
					pNewDetail->SetNew();
					pNewDetail->m_rcDefaultClientArea = CRect(0,0,0,0);
					pNewDetail->SetUnsaved();

					// (j.jones 2010-02-12 14:23) - PLID 37318 - check whether this is part of a SmartStamp
					// set of details, and ensure links (or create the table) accordingly
					// (z.manning 2010-05-10 17:23) - PLID 38527 - Let this function know we're spawning the image
					EnsureSmartStampLinks(pNewDetail, TRUE);

					pSourceDetail->m_pParentTopic->AddDetail(pNewDetail, bIsInitialLoad, FALSE);
					pSourceDetail->m_pParentTopic->SetUnsaved();

					//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
					pNewDetail->SetSourceActionInfo(sai);
				}
				else {
					// (z.manning 2011-11-09 10:41) - PLID 46367 - Pass in the source groups IDs here
					pNewDetail = pSourceDetail->m_pParentTopic->AddNewDetailFromEmrInfoMasterID(ea.nDestID, m_bIsTemplate, sai, bIsInitialLoad, ea.nSourceID, pEMNSpawner, ea.nSourceDataGroupID, ea.nSourceHotSpotGroupID, ea.nSourceTableDropdownGroupID);
					// (z.manning, 2011-03-15) - PLID 42817 - We need to flag the detail as new in this branch of code too.
					pNewDetail->SetNew();
				}

				// (c.haag 2007-08-06 10:58) - PLID 26954 - Assign the EMN spawner object
				// for faster processing of LoadContent
				pNewDetail->SetEMNSpawner(pEMNSpawner);
				try {
					// (j.jones 2007-04-13 10:23) - PLID 25616 - This code previously differed from the way
					// loading a remembered position worked, in that it only tried to pop up if the source detail's
					// parent topic had a valid window. But it should send NXM_EMR_ITEM_ADDED first, then try to popup,
					// just like the remembered positioning code.

					//Add to interface.
					// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
					if(GetInterface()) {
						GetInterface()->SendMessage(NXM_EMR_ITEM_ADDED, (WPARAM)pNewDetail, (LPARAM)bIsInitialLoad);
					}

					if(!m_bIsTemplate && ea.bPopup && !bIsInitialLoad) {
						// (z.manning, 02/01/2007) - PLID 24524 - The progress parameter may get 'lost' over the many functions
						// that may can get called during the loading/spawning process, so let's go straight to the source to 
						// hide/show the progress bar.
						if(GetParentEMR()) {
							GetParentEMR()->ShowActionProgressBar(SW_HIDE);
						}

						// (a.walling 2009-11-17 15:37) - PLID 36365 - Will also update popups
						if (eitNarrative == pNewDetail->m_EMRInfoType) {
							pNewDetail->UpdateNarrativeFields();
						}

						//TES 1/11/2008 - PLID 24157 - Instead of popping up the detail, tell our EMR to add it to
						// our list of popped-up details, we will display them all in a clean interface at the 
						// appropriate time.
						//pNewDetail->Popup();
						AddDetailToPopup(pNewDetail, pSourceDetail);

						// (a.walling 2007-09-07 09:43) - PLID 24371 - Show but do not activate
						if(GetParentEMR()) {
							GetParentEMR()->ShowActionProgressBar(SW_SHOWNA);
						}
					}

					// (j.jones 2007-04-12 15:51) - PLID 25604 - now unlock spawning, such that if we did
					// pop up, it is now safe to spawn
					if(GetParentEMR()) {
						GetParentEMR()->UnlockSpawning();
					}

					// (c.haag 2007-08-06 10:58) - PLID 26954 - Reset the EMN spawner object of the detail
					pNewDetail->SetEMNSpawner(NULL);

					// (c.haag 2008-06-17 10:00) - PLID 17842 - Assign this to the output
					if (NULL != ppNewDetailOut) { *ppNewDetailOut = pNewDetail; }

				} NxCatchAllSilentCallThrow( if (pNewDetail) { pNewDetail->SetEMNSpawner(NULL); } );
			}
			
			/*// After adding any number of details (even 1) we always have to ensure the tab labels 
			// and make sure there'e a blank detail
			EnsureAllTopicLabels();

			// (c.haag 2004-07-06 17:09) - PLID 13003 - Make sure the appearance of all the
			// merge conflict icon buttons are correct
			InvalidateAllDetailMergeButtons();*/

			//DRT 8/30/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}//end for loop of all actions
	}
	// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
	// mode. This makes it easier to pin down problems.
	NxCatchAllSilentCallThrow(ASSERT(FALSE));
	EMRLOGINDENT(-1, "CEMN::ProcessEmrAction_eaoEmrItem END"); // (c.haag 2010-05-19 9:04) - PLID 38759
}

//DRT 8/28/2007 - PLID 27218 - Split out of CEMN::ProcessEmrAction
// (c.haag 2008-06-17 09:53) - PLID 17842 - Added optional parameter for letting the caller get the newly added topics
// (c.haag 2008-06-26 12:53) - PLID 27549 - Added pEMNSpawnedMintLoader
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoMintItems(MFCArray<CActionAndSource> *paryActionsToSpawn, OUT CArray<SkippedTopic,SkippedTopic&> &arSkippedTopics, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */, CArray<CEMRTopic*,CEMRTopic*>* papNewTopicsOut /*= NULL*/,
							CEMNLoader* pEMNSpawnedMintLoader /*= NULL */)
{
	try {
		// (c.haag 2008-06-17 10:03) - PLDI 17842 - First thing's first: Reset the output. Otherwise, the caller might think we added whatever content is
		// presently in the output array.
		if (NULL != papNewTopicsOut) { papNewTopicsOut->RemoveAll(); }

		CEMR *pParentEmr = m_bIsTemplate ? NULL : GetParentEMR();

		//DRT 8/29/2007 - PLID 27218 - We now take an array of actions, loop over that array and do all the spawning inside it
		long nActionCount = paryActionsToSpawn->GetSize();
		for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++)
		{
			EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
			CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
			TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);
			//TES 3/18/2010 - PLID 37530 - We need to also track the source stamp ID and index
			long nSourceStampID = sai.GetStampID();
			long nSourceStampIndex = sai.GetStampIndexInDetailByType();

			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			//See if we already have the topic in this EMN.  If we do: 
			//	If it's hidden, show it and return.
			//See if we have a stored location for it.  If we do:
			//  Tell the appropriate add it at the specified location.
			//Otherwise:
			//  add it.
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail == NULL || pSourceDetail->m_pParentTopic == NULL) {
				//I'm unclear what this means, so we'll just have to give up with a clear error
				AfxThrowNxException("Error in ProcessEMRAction - pSourceDetail could not be properly accessed when spawning mint items.");
			}

			//Get EMN info
			CEMN *pEMN = pSourceDetail->m_pParentTopic->GetParentEMN();
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pEMN == NULL || pEMN->GetParentEMR() == NULL) {
				//I'm unclear what this means, so we'll just have to give up with a clear error
				AfxThrowNxException("Error in ProcessEMRAction - EMN or EMR could not be found.");
			}

			//TES 2/2/2006 - First, figure out where we're going to spawn things if there's no default location
			//(we need to decide now, otherwise we'll add one, recalculate, add another, recalculate...)
			CEMRTopic *pNextSibling = NULL;
			CEMRTopic *pParent = pSourceDetail->m_pParentTopic->GetParentTopic();
			if(pParent) {
				for(int i = 0; i < pParent->GetSubTopicCount()-1 && !pNextSibling; i++) {
					if(pParent->GetSubTopic(i) == pSourceDetail->m_pParentTopic)
						pNextSibling = pParent->GetSubTopic(i+1);
				}
			}
			else {
				for(int i = 0; i < pEMN->GetTopicCount()-1 && !pNextSibling; i++) {
					if(pEMN->GetTopic(i) == pSourceDetail->m_pParentTopic)
						pNextSibling = pEMN->GetTopic(i+1);
				}
			}

			//Now, let's tell the EMR to wait to process actions until the whole mint is spawned.
			pEMN->GetParentEMR()->LockSpawning();
			//Load the topic ids we need to add.
			CArray<long,long> arTemplateTopicIDs;
			//TES 2/16/2006 - Keep track of the ones that we don't actually spawn, so that we can know not to spawn their
			//children.
			CArray<long,long> arHiddenTemplateTopicIDs;
			// (c.haag 2007-08-09 09:01) - PLID 26157 - Keep track of which topic objects we actually loaded
			CArray<CEMRTopic*,CEMRTopic*> apNewTopics;
			CArray<CEMNLoader*,CEMNLoader*> apNewTopicLoaders;


			//
			// (c.haag 2007-09-10 11:28) - There are several CEMNLoader objects involved in this code:
			//
			// pEMNSourceLoader - If we are in the initial load of pEMN, then this is the CEMNLoader used in its
			// initial load. It provides access to a set of topics and details, regardless of whether they are
			// spawned, for the purpose of examining source action ID's and other things read from data. If we are
			// not in the initial load, then this is NULL.
			//
			// pEMNMintLoader - This is the CEMNLoader object which corresponds to the template we are spawning. It
			// provides access to a set of topics and details, regardless of whether they are spawned, for the purpose
			// of manufacturing new details and topics into pEMN. This is created on a need-to-create basis.
			//
			// pCalcLoader - This is a special CEMNLoader object. Its purpose is to help determine topic placement,
			// and to make PLID 26187 work in freeing us from querying data once per topic. If this is the initial load,
			// it should be equal to pEMN->GetEMNLoader(). If not in the initial load, it will be equal to
			// pEMN->GetEMNRetiredLoader(). If it is NULL, we must create it on the spot to avoid running once-per-topic
			// queries.
			//
			// 

			//
			// (c.haag 2007-05-29 17:20) - PLID 26157 - We now use a CEMNLoader object rather than calling
			// CEMRTopic::LoadFromTemplateTopicID. We will have to query topic and detail data to properly
			// use it.
			// (c.haag 2007-05-30 14:35) - PLID 26157 - Set the loading behavior to eEMNLoader_DoSingleLargeServerLoad.
			// We have to load the topics synchronously, and that behavior is most efficient for all-out synchronous
			// template loads.
			// (c.haag 2007-06-15 08:47) - PLID 26344 - We now have two loaders; one for the spawning template, and
			// one for this template.
			//
			CEMNLoader* pEMNSourceLoader = pEMN->GetEMNLoader();
			// (c.haag 2007-08-08 17:00) - PLID 27021 - Don't create the mint loader until we actually need it
			CEMNLoader* pEMNMintLoader = NULL;
			// (c.haag 2010-07-07 12:49) - PLID 38886 - Preserve a pointer to this mint loader. We'll use it later when
			// figuring out where to spawn topics (including those of templates that will be spawned later on which we
			// don't know about yet).
			CEmrMintItemsLoaderPreserver emilp(this, &pEMNMintLoader);
			// (c.haag 2007-09-10 11:41) - PLID 27024 - This loader object is used to help determine topic placement,
			// and to make PLID 26187 work
			CEMNLoader* pCalcLoader = NULL;
			BOOL bDeleteCalcLoader = FALSE;

			// (c.haag 2007-08-20 17:14) - PLID 25239 - Ensure that non-spawning-related loading is done
			pEMN->EnsureCompletelyLoaded();
			// (c.haag 2007-08-16 15:59) - PLID 25239 - Check if the loader is NULL. If it is, that
			// means the user manually induced a spawning action during the initial load, and the
			// initial load finished.
			if (NULL == pEMN->GetEMNLoader()) {
				pEMNSourceLoader = NULL;
			}

			// (c.haag 2007-09-10 11:43) - PLID 27024 - Assign the calculation loader
			if (NULL != pEMNSourceLoader) {
				// If a source loader is available, we can use that because it has the topics and details of the
				// template we are either loading or creating a patient chart from.
				pCalcLoader = pEMNSourceLoader;
			} else if (NULL != pEMN->GetRetiredEMNTemplateLoader()) {
				// If the initial load is over, but we still have the CEMNLoader used in the initial load, then
				// we can use that because it has the topics and details of the template we are either loading 
				// or creating a patient chart from.
				pCalcLoader = pEMN->GetRetiredEMNTemplateLoader();
			} else {
				// If we get here, it means we opened a patient chart, and we want to spawn from it. We have no
				// recourse but to create a new loader from scratch.
				CString strLoadSql = GetrsPreloadDetailsBasicQDeclarations();
				AppendTemplateLoadSubQuery_rsPreloadDetails(strLoadSql);
				AppendTemplateLoadSubQuery_rsPreloadTemplateTopics(strLoadSql);

				_CommandPtr pCmd = OpenParamQuery(strLoadSql);
				const long nPatientID = pEMN->GetParentEMR()->GetPatientID();
				const long nTemplateID = pEMN->GetTemplateID();
				AddParameterLong(pCmd, "TemplateID", nTemplateID); // template details
				AddParameterLong(pCmd, "TemplateID", nTemplateID);
				AddParameterLong(pCmd, "TemplateID", nTemplateID);
				// (a.walling 2013-07-18 10:14) - PLID 57628 - Removed old EmrTableDropdownInfoT data maps and cache logic
				AddParameterLong(pCmd, "TemplateID", nTemplateID); // template topics
				AddParameterLong(pCmd, "TemplateID", nTemplateID);
				_RecordsetPtr prsLoader = CreateRecordset(pCmd);

				// (j.jones 2011-04-28 14:39) - PLID 43122 - the loader now requires a provider ID for floating EMR data
				long nProviderIDForFloatingData = GetProviderIDForFloatingData();

				// Create the calculation loader
				pCalcLoader = new CEMNLoader(pEMN, GetRemoteData(), TRUE, pEMN->IsTemplate(), nTemplateID, nProviderIDForFloatingData);

				// Load in the template details				
				pCalcLoader->PreloadEmrTemplateDetails(nPatientID, prsLoader, pEMN->GetParentEMR());
				prsLoader = prsLoader->NextRecordset(NULL);
				pCalcLoader->PreloadEmrTemplateDetails(nPatientID, prsLoader, pEMN->GetParentEMR());

				// Load in the template topics
				prsLoader = prsLoader->NextRecordset(NULL);
				//DRT 9/25/2007 - PLID 27515 - Added SourceAction SourceID and SourceDataGroupID as -1 b/c we don't load override the SourceActionID
				SourceActionInfo saiBlank;
				pCalcLoader->PreloadEmrTemplateTopics(prsLoader, nTemplateID, TRUE, NULL, saiBlank, FALSE, nPatientID, pEMN->GetParentEMR(), FALSE, -1, -1);
				bDeleteCalcLoader = TRUE;
			}


			// (c.haag 2007-05-31 17:28) - PLID 26205 - We no longer need to query data to get this information.
			/*
			//TES 1/23/2006 - Only load top-level topics, they will load their own subtopics.
			//TES 2/8/2006 - Also, remember to use the order!
			_RecordsetPtr rsTopics = CreateRecordset("SELECT ID FROM EmrTemplateTopicsT WHERE TemplateID = %li AND SourceActionID Is Null AND EmrParentTemplateTopicID Is Null ORDER BY OrderIndex", ea.nDestID);
			while(!rsTopics->eof) {
				arTemplateTopicIDs.Add(AdoFldLong(rsTopics, "ID"));
				rsTopics->MoveNext();
			}
			rsTopics->Close();
			//TES 3/27/2006 - PLID 19871 - The fact that we're only loading parent topics could cause problems, if there is
			//a topic that is a subtopic on the source template, but a parent topic in our current template.  Therefore,
			//we add all child topics in the source template to the end of our list.  This will work out all right because
			//the code below, that loops through the list, first checks whether the topic has already been spawned.  So any
			//child topics that are handled correctly by their parents will be ignored the next time around.
			_RecordsetPtr rsSubTopics = CreateRecordset("SELECT ID FROM EmrTemplateTopicsT WHERE TemplateID = %li AND SourceActionID Is Null AND EmrParentTemplateTopicID Is Not Null", ea.nDestID);
			while(!rsSubTopics->eof) {
				arTemplateTopicIDs.Add(AdoFldLong(rsSubTopics, "ID"));
				rsSubTopics->MoveNext();
			}
			rsSubTopics->Close();
			*/

			// (j.jones 2007-07-30 11:31) - PLID 26874 - we now cache the AddOnce field in the topic loader
			BOOL bAddOnce = FALSE;

			// (c.haag 2007-05-30 17:03) - PLID 26187 - Variables used for action searching
			CArray<long,long> anSourceActionIDFindFilter; // (New equivalent of strSourceActionIDFind)

			try
			{
				// (c.haag 2007-08-08 17:00) - PLID 27021 - Populate arTemplateTopicID's, anSourceActionIDFindFilter and
				// the bAddOnce flag using a simple multi-part query. I also included Josh's optimization query for 26875;
				// only I integrated it to conform to CreateParamRecordset.
				_RecordsetPtr prs = CreateParamRecordset(
					FormatString(
					// (z.manning 2008-11-14 12:35) - PLID 32035 - I changed the order by clause of this query
					// to only by order index. We used to order by whether or not the EMRParentTemplateTopicID
					// was null, which is important, but that only handled one level of subtopics and we need
					// to handle multiple levels. We'll do that in code after we load all the topic IDs.
					"SELECT ID AS EMRTemplateTopicID, SourceActionID, TemplateID, EMRParentTemplateTopicID \r\n"
					"FROM EMRTemplateTopicsT \r\n"
					"WHERE EMRTemplateTopicsT.TemplateID = {INT} OR \r\n"
					"	EMRTemplateTopicsT.ID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = {INT}) \r\n"
					"ORDER BY OrderIndex; \r\n"
					//rsAddOnce
					"SELECT AddOnce FROM EMRTemplateT WHERE ID = {INT};\r\n"
					//rsSourceActionIDFind
					// (j.jones 2007-07-30 13:05) - PLID 26875 - included the SourceActionIDFind query in this batch,
					// even though it is not a part of the EMNLoader
					"SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
					" (SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = %li AND DestID = {INT}\r\n"
					// (z.manning, 02/21/2008) - PLID 28690 - Include actions with the same spot group ID
					"UNION ALL \r\n"
					"SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
					" (SELECT ID FROM EmrImageHotSpotsT WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = %li AND DestID = {INT}\r\n"
					// (z.manning 2009-02-17 10:18) - PLID 33072 - Also actions with same dropdown group ID
					"UNION ALL \r\n"
					"SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN \r\n"
					"	(SELECT ID FROM EmrTableDropdownInfoT \r\n"
					"	 WHERE DropdownGroupID = \r\n"
					"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem \r\n"
					"		 WHERE SourceItem.ID = {INT})) \r\n"
					"	 AND DestType = %li AND DestID = {INT} \r\n"
					, eaoEmrDataItem, eaoMintItems, eaoEmrImageHotSpot, eaoMintItems, eaoEmrTableDropDownItem, eaoMintItems)
					,ea.nDestID, ea.nDestID, ea.nDestID, ea.nSourceID, ea.nDestID, ea.nSourceID, ea.nDestID, ea.nSourceID, ea.nDestID);
				FieldsPtr f;

				// Topics recordset
				CArray<EmrTopicSortInfo,EmrTopicSortInfo&> aryTopicSortInfo;
				f = prs->Fields;
				while (!prs->eof) {
					const _variant_t vSourceActionID = f->Item["SourceActionID"]->Value;
					const long nTemplateID = AdoFldLong(f, "TemplateID");
					if (nTemplateID == ea.nDestID && VT_NULL == vSourceActionID.vt) {
						// (z.manning 2008-11-14 13:26) - PLID 32035 - Don't load the IDs directly into the array.
						// Instead keep an array of the info we'll need to properly sort them in hierarchy order.
						EmrTopicSortInfo sortinfo;
						sortinfo.nTopicID = AdoFldLong(f, "EMRTemplateTopicID");
						sortinfo.varParentTopicID = f->GetItem("EMRParentTemplateTopicID")->GetValue();
						aryTopicSortInfo.Add(sortinfo);
					}
					prs->MoveNext();
				}
				// (z.manning 2008-11-14 13:27) - PLID 32035 - Ok, now sort the topics in hierarchical order.
				SortTopicsByParent(aryTopicSortInfo, arTemplateTopicIDs);

				prs = prs->NextRecordset(NULL);
				f = prs->Fields;
				// AddOnce recordset
				if (!prs->eof) {
					bAddOnce = AdoFldBool(f, "AddOnce");
				}
				// (c.haag 2007-08-08 18:01) - PLID 27021 - Moved Josh's optimization for 26875 here
				// (j.jones 2007-07-30 13:09) - PLID 26875 - moved the SourceActionIDFindFilter recordset
				// into the batched recordsets
				//rsSourceActionIDFind
				prs = prs->NextRecordset(NULL);

				if(ea.eaoSourceType == eaoEmrItem) {
					ASSERT(FALSE);
				} else if(ea.eaoSourceType == eaoEmrDataItem) {
					/*
					_RecordsetPtr prs = CreateRecordset("SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
							" (SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
							" WHERE SourceItem.ID = %li)) "
							"AND DestType = %li AND DestID = %li", eaoEmrDataItem, ea.nSourceID, eaoMintItems, ea.nDestID);
					*/
					while (!prs->eof) {
						anSourceActionIDFindFilter.Add(AdoFldLong(prs, "ID"));
						prs->MoveNext();
					}
				} else {
					anSourceActionIDFindFilter.Add(ea.nID);
				}


				/* LEGACY CODE BEGINS HERE
				// (c.haag 2007-07-03 10:15) - PLID 26523 - Take exclusive ownership of topics until this is done
				CHoldEMNLoaderMutex mh(pEMNMintLoader->GetTopicsMutex());
				// (c.haag 2007-05-31 17:33) - PLID 26205 - nTopics includes root level topics as well as children. We can
				// ignore the EmrParentTemplateTopicID filter completely
				int nTopics = pEMNMintLoader->GetTotalTemplateTopicCount();
				for (int i=0; i < nTopics; i++) {
					// Since we loaded the template topics ordered by OrderIndex, we don't need to do any special traversals.
					CEMNLoader::CPreloadedTemplateTopic* p = pEMNMintLoader->GetPreloadedTemplateTopicByIndex(i);

					// (j.jones 2007-07-30 11:31) - PLID 26874 - we now cache the AddOnce field in the topic loader,
					// will be the same value for every topic in the template
					bAddOnce = VarBool(p->m_vTemplateAddOnce, FALSE);

					if (p->m_nTemplateID == ea.nDestID && VT_NULL == p->m_vSourceActionID.vt) {
						arTemplateTopicIDs.Add(p->m_nID);
					}
				}
				*/
			}
			// (c.haag 2007-07-03 12:48) - If something is thrown from here, let the developer know in debug
			// mode. This makes it easier to pin down problems.
			NxCatchAllSilentCallThrow(ASSERT(FALSE));

			//TES 1/31/2006 - Before anything else, if this is only supposed to be spawned once, and has already been spawned,
			//don't spawn it.

			// (j.jones 2007-07-30 11:31) - PLID 26874 - we now cache the AddOnce field in the topic loader
			//BOOL bAddOnce = VarBool(GetTableField("EmrTemplateT", "AddOnce", "ID", ea.nDestID));
			if(bAddOnce) {
				try {
					CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
					pEMN->GetAllTopics(arAllTopics);
					BOOL bDoneSpawning = FALSE;
					for(int i = 0; i < arAllTopics.GetSize() && !bDoneSpawning; i++) {
						for(int j = 0; j < arTemplateTopicIDs.GetSize() && !bDoneSpawning; j++) {
							if(arAllTopics[i]->GetVisible() && 
								arAllTopics[i]->GetOriginalTemplateTopicID() == arTemplateTopicIDs[j]) {
								//Matched!
								pEMN->GetParentEMR()->UnlockSpawning();
								//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
								bDoneSpawning = TRUE;
							}
						}
					}
					//DRT 8/29/2007 - PLID 27218 - continue the loop instead of returning.
					if(bDoneSpawning) {
						//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
						pSourceEmn->GetParentEMR()->UnlockAction(ea);
						continue;
					}
				}
				// (c.haag 2007-07-03 12:48) - If something is thrown from here, let the developer know in debug
				// mode. This makes it easier to pin down problems.
				NxCatchAllSilentCallThrow(ASSERT(FALSE));
			}

			//Here's how we'll calculate our progress.  We'll consider ourselves at 6 now, and count each topic as 3,
			//1 for finding if its already there, 1 for opening the recordset, and one for loading it.
			int nTotalProgress = 6 + (3*arTemplateTopicIDs.GetSize());
			int nProgress = 6;
			if(pProgress) pProgress->SetProgress(0, nTotalProgress, nProgress);

			//TES 1/24/2006 - Sometimes a topic will be spawned, before the topic which is its stored parent is spawned.
			//Therefore, we may need to iterate through the list multiple times.
			// (c.haag 2007-05-30 15:57) - PLID 26186 - These two variables used to be in the scope of the topic loop.
			// No longer. The reason is that 95% of the time, these will wind up being the same values. What's important
			// is whether the query we used to build these values has changed or not. If it changes, then all of these
			// values should be reset to their defaults and then populated with new values again.
			CMap<long, long, BOOL, BOOL> mapTSAIDEquivalent;
			long nIdealSourceActionIDToUse = -1;
			// (c.haag 2007-05-30 16:06) - PLID 26186 - This was the query we used to build the two variables above.
			// We generate one like it at every iteration in the loop below. If the generated one differs, then we must
			// update this query, run it, and repopulate those variables. If the generated one is the same, we won't 
			// run the query because we already ran it before.
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			CSqlFragment sqlIdealSourceActionIDQuery;

			long nSourceDetailIDFindFilter = -1; // (New equivalent of strSourceDetailIDFind)
			if(pSourceDetail && pSourceDetail->m_nEMRTemplateDetailID != -1) {
				nSourceDetailIDFindFilter = pSourceDetail->m_nEMRTemplateDetailID;
			}


			for(int i = 0; i < arTemplateTopicIDs.GetSize(); i++) {
				try {
					//Make sure our progress is at the right place.
					nProgress = 6 + (3*i);

					bool bSpawned = false;
					long nDestTopicID = arTemplateTopicIDs[i];
					//Do we already have the topic in this EMN?
					//Remember the topics that are already on the template, so we don't spawn them again.
					CArray<long,long> arExistingTopics;
					CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
					pEMN->GetAllTopics(arAllTopics);

					// (j.jones 2007-03-07 16:35) - PLID 25095 - I copied the efficiency mapping and
					// search for the most recent SourceActionID from the logic when spawning details.
					// For the mapping: IsTopicSourceActionIDEquivalent individually for every topic in the
					// template. That function queries the data. We need to optimize this by running just one query
					// that would have the results for all the topics, and build a map of those results for
					// quick referencing.
					// For the search: "This needs to accomodate the possibility of duplicates using different
					// SourceActionIDs, such that we ensure we're spawning the topics with the most recent 
					// SourceActionID. We'll do so by tracking the highest SourceActionID possible 
					// (nIdealSourceActionIDToUse), then using whichever spawned topic matches that ID or is
					// otherwise the highest SourceActionID (nMaxSourceActionIDFound) of the available topics to use."

					// Note: This map needs to be generated at each pass through arTemplateTopicIDs
					// AFTER pEMN->GetAllTopics() is called, because the topic list - and thus our map -
					// can change on each passthrough.

					// (c.haag 2007-05-30 16:06) - PLID 26186 - Not anymore! This map only needs to be
					// regenerated if the query used to build it changes.

					long nMaxSourceActionIDFound = -1;

					// Generate the query filter by concatenating the topic ID's
					// (c.haag 2007-05-30 15:53) - PLID 26186 - Use an array rather than building
					// an SQL string. Also, do not duplicate ID's like we did before.
					// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
					int j = 0;
					CArray<long,long> aSAIDsOfInterest;
					for (j=0; j < arAllTopics.GetSize(); j++) {
						CEMRTopic *pTopic = (CEMRTopic*)arAllTopics.GetAt(j);
						long nSourceActionID = pTopic->GetSourceActionID();
						
						// (j.jones 2007-08-01 11:27) - PLID 26900 - we can only spawn a topic
						// where the topic's template ID matches our template ID,
						// so we can reduce our filter query that way
						if (nSourceActionID > 0 && !IsIDInArray(nSourceActionID, aSAIDsOfInterest)
							&& pTopic->GetOriginalTemplateTopicID() == nDestTopicID) {							
							aSAIDsOfInterest.Add(nSourceActionID);
						}
					}
					
					// Now run the query and pull in the records.
					if (aSAIDsOfInterest.GetSize() > 0) {
						
						// (j.jones 2007-03-07 16:49) - PLID 25095 - load in order of newest to oldest,
						// such that we know the first record returned is the ideal action record
						// (c.haag 2007-05-30 15:55) - PLID 26186 - We now use ArrayAsString instead of
						// a pre-built SQL string
						//TES 3/16/2010 - PLID 37775 - We need to check the source type!  Before we just assumed the source type
						// was eaoEmrDataItem.
						CSqlFragment sqlSql;
						if(ea.eaoSourceType == eaoEmrDataItem) {
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							sqlSql.Create(
								"SELECT ID FROM EMRActionsT WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrDataT "
								" WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem WHERE SourceItem.ID = {INT}) ) "
								"AND DestType = {CONST} AND ID IN ({INTARRAY}) "
								"ORDER BY ID DESC",
								eaoEmrDataItem, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
						}
						else if(ea.eaoSourceType == eaoEmrImageHotSpot) {
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							sqlSql.Create(
								"SELECT ID FROM EmrActionsT "
								"WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrImageHotSpotsT "
								"	WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
								"	WHERE SourceItem.ID = {INT})) AND DestType = {CONST} AND ID IN ({INTARRAY}) "
								"ORDER BY ID DESC "
								, eaoEmrImageHotSpot, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
						}
						else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							sqlSql.Create(
								"SELECT ID FROM EmrActionsT \r\n"
								"WHERE SourceType = {CONST} AND SourceID IN \r\n"
								"	(SELECT ID FROM EmrTableDropdownInfoT \r\n"
								"	 WHERE DropdownGroupID = \r\n"
								"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem \r\n"
								"		 WHERE SourceItem.ID = {INT})) \r\n"
								"		AND DestType = {CONST} AND ID IN ({INTARRAY}) \r\n"
								, eaoEmrTableDropDownItem, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
						}
						//TES 3/16/2010 - PLID 37530 - Smart Stamps now spawn on templates; they don't branch so just check for the ID.
						else if(ea.eaoSourceType == eaoSmartStamp) {
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							sqlSql.Create(
								"SELECT ID FROM EmrActionsT \r\n"
								"WHERE SourceType = {CONST} AND SourceID = {INT} \r\n"
								" AND DestType = {CONST} AND ID IN ({INTARRAY}) \r\n"
								, eaoSmartStamp, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
						}

						// (c.haag 2007-05-30 16:02) - PLID 26186 - Check if the SQL statement we built is the
						// same one that we had for the previous template topic. If it is, then we will get
						// the same results as before. Ergo, there's no need to run the query.
						if (sqlIdealSourceActionIDQuery != sqlSql) {

							sqlIdealSourceActionIDQuery = sqlSql;
							mapTSAIDEquivalent.RemoveAll();
							nIdealSourceActionIDToUse = -1;

							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							_RecordsetPtr prsTSAIDEquivalent = CreateParamRecordset("{SQL}", sqlIdealSourceActionIDQuery);
							while (!prsTSAIDEquivalent->eof) {
								long nSourceActionID = AdoFldLong(prsTSAIDEquivalent, "ID");
								mapTSAIDEquivalent[nSourceActionID] = TRUE;

								// (j.jones 2007-03-07 16:49) - PLID 25095 - track the maximum
								// SourceActionID, though this assignment should only be occurring
								// in the first iteration of this while loop
								if(nSourceActionID > nIdealSourceActionIDToUse) {
									nIdealSourceActionIDToUse = nSourceActionID;
								}

								prsTSAIDEquivalent->MoveNext();
							}
							prsTSAIDEquivalent->Close();
						} 
					}

					// (j.jones 2007-03-07 16:51) - PLID 25095 - The optimization is ready.
					// Resume topic traversal (back to legacy code). But also
					// track the ideal topic pointer, that uses nMaxSourceActionIDFound
					// (yes we could just use the topic's GetSourceActionID(), but I think nMaxSourceActionIDFound is clearer)
					CEMRTopic *pPreferredTopicToUse = NULL;

					for(j = 0; j < arAllTopics.GetSize() && !bSpawned; j++) {
						try {
							CEMRTopic *pTopic = arAllTopics[j];
							if(pTopic->GetOriginalTemplateTopicID() == nDestTopicID) {

								// (j.jones 2006-09-21 16:31) - PLID 22634 - IsTopicSourceActionIDEquivalent checks to
								// see if the topic has this action as a source OR if a previous version of the spawning
								// item is responsible for the source action

								//TES 3/18/2010 - PLID 37530 - Added SourceStampID and SourceStampIndex support
								BOOL bSourceStampOK = FALSE;
								// (j.jones 2007-01-12 15:10) - PLID 24027 - added SourceDetailID support
								BOOL bSourceDetailOK = FALSE;
								// (a.walling 2010-04-02 14:53) - PLID 38042 - also added SourceDataGroupID support.
								// This is necessary because normally we were distinguishing these based on the action and the source detail.
								// However, the same dropdown on different rows of a table would have the same action and source detail, but
								// not the same data group.
								BOOL bSourceDataGroupIDOK = FALSE;

								if(pSourceDetail) {
									//if we were given a source detail (and we should have), see if
									//the topic we are comparing to has the same source detail
									if(pTopic->GetSourceDetail()) {
										if(pSourceDetail == pTopic->GetSourceDetail()) {
											bSourceDetailOK = TRUE;
										}
									}
									//if the topic doesn't have a source detail pointer, compare on source detail IDs
									if(pTopic->GetSourceDetailID() != -1) {
										if(pTopic->GetSourceDetailID() == (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
											bSourceDetailOK = TRUE;
										}
									}
									if(ea.eaoSourceType == eaoSmartStamp) {
										SourceActionInfo saiTopic = pTopic->GetSourceActionInfo();
										if(saiTopic.GetStampID() == nSourceStampID && saiTopic.GetStampIndexInDetailByType() == nSourceStampIndex) {
											bSourceStampOK = TRUE;
										}
									}
									else {
										bSourceStampOK = TRUE;
									}
									// (a.walling 2010-04-02 14:54) - PLID 38042 - Need to also compare the source data group to distinguish among
									// spawns from different rows on a table!
									if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
										if (sai.TableSourceMatches(pTopic->GetSourceActionInfo())) {
											bSourceDataGroupIDOK = TRUE;
										}
									}
									else {
										bSourceDataGroupIDOK = TRUE;
									}
								}
								else {
									//we were not given a source detail, so don't bother trying to
									//compare by it, just use SourceActionID
									bSourceDetailOK = TRUE;
									bSourceStampOK = TRUE;
									// (a.walling 2010-04-02 14:54) - PLID 38042
									bSourceDataGroupIDOK = TRUE;
									//however, this shouldn't happen
									ASSERT(FALSE);
								}

								// (j.jones 2007-03-07 16:52) - PLID 25095 - Look at our map to determine whether
								// the source action ID is equivalent rather than calling IsTopicSourceActionIDEquivalent,
								// which is slower
								long nTopicSourceActionID = pTopic->GetSourceActionID();
								BOOL bIsTopicSourceActionIDEquivalent = FALSE;
								mapTSAIDEquivalent.Lookup(nTopicSourceActionID, bIsTopicSourceActionIDEquivalent);

								//TES 3/18/2010 - PLID 37530 - Make sure the Source Stamp matches
								// (a.walling 2010-04-02 14:58) - PLID 38042 - Also the data group
								if(bIsTopicSourceActionIDEquivalent && bSourceDetailOK && bSourceStampOK && bSourceDataGroupIDOK) {

									// (j.jones 2007-03-07 17:05) - PLID 25095 - do not show it yet, instead
									// first check and see if it is the ideal source action ID. If so, show
									// immediately. If not, track it as a candidate item to be shown,
									// provided it is preferable to our existing candidate item. 
									if(nIdealSourceActionIDToUse == nTopicSourceActionID) {

										// (j.jones 2007-03-07 17:18) - PLID 25095 - it's the ideal SourceActionID,
										// so we know no other candidate can be better

										//We've found it.  Tell the interface.
										pTopic->SetVisible(TRUE);
										//TES 3/16/2010 - PLID 37530 - Make sure the topic's SourceActionInfo is fully up to date
										pTopic->SetSourceActionInfo(sai);
										if(GetInterface()) {
											// (c.haag 2007-05-31 12:57) - PLID 26175 - Set LPARAM to TRUE so that HTML
											// preview information is not created
											GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pTopic, (LPARAM)TRUE);
										}
										//now for all visible details, update their merge conflicts
										for(int k=0; k<pTopic->GetEMNDetailCount();k++) {
											CEMNDetail *pDetail = pTopic->GetDetailByIndex(k);
											if(pDetail->GetVisible() && pDetail->m_pParentTopic->GetParentEMN()) {
												pDetail->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pDetail->GetMergeFieldName(TRUE));
											}
										}
										pTopic->ProcessAllActions(bIsInitialLoad);
										bSpawned = true;
									}
									else {

										// (j.jones 2007-03-07 17:28) - PLID 25095 - it's not ideal, but is it the best we have?
										if(nTopicSourceActionID > nMaxSourceActionIDFound) {
											nMaxSourceActionIDFound = nTopicSourceActionID;
											pPreferredTopicToUse = pTopic;
										}

										//keep searching the list
									}
								}
								//TES 3/18/2010 - PLID 37530 - Make sure we add the Template ID, even if we're loading on an EMN.
								arExistingTopics.Add(pTopic->IsTemplate() ? pTopic->GetID() : pTopic->GetTemplateTopicID());
							}
						}
						// (c.haag 2007-07-03 12:39) - If something is thrown from here, let the developer know in debug
						// mode. This makes it easier to pin down problems.
						NxCatchAllSilentCallThrow(ASSERT(FALSE));
					} // for(j = 0; j < arAllTopics.GetSize() && !bSpawned; j++) {

					// (j.jones 2007-03-07 17:28) - PLID 25095 - did we find any candidate topics?
					// If pPreferredTopicToUse is not NULL, it means it is the newest SourceActionID
					// we could find, but couldn't definitively confirm it was "the best option" until
					// the search completed. Now that we've done this, show it.
					if(pPreferredTopicToUse != NULL) {
						
						//we have our preferred topic, but maybe it's already visible
						if(!pPreferredTopicToUse->GetVisible()) {

							//this is a copy of the block of code from above
							
							//We've found it.  Tell the interface.
							pPreferredTopicToUse->SetVisible(TRUE);
							//TES 3/16/2010 - PLID 37530 - Make sure the topic's SourceActionInfo is fully up to date
							// (a.walling 2010-04-01 18:01) - PLID 38038 - This was missing here, was only done if we got an exact
							// match above.
							pPreferredTopicToUse->SetSourceActionInfo(sai);
							if(GetInterface()) {
								// (c.haag 2007-05-31 12:57) - PLID 26175 - Set LPARAM to TRUE so that HTML
								// preview information is not created
								GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pPreferredTopicToUse, (LPARAM)TRUE);
							}
							//now for all visible details, update their merge conflicts
							for(int k=0; k<pPreferredTopicToUse->GetEMNDetailCount();k++) {
								CEMNDetail *pDetail = pPreferredTopicToUse->GetDetailByIndex(k);
								//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
								if(pDetail->GetVisible() && pDetail->m_pParentTopic && pDetail->m_pParentTopic->GetParentEMN()) {
									pDetail->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pDetail->GetMergeFieldName(TRUE));
								}
							}
							pPreferredTopicToUse->ProcessAllActions(bIsInitialLoad);
						}

						bSpawned = true;
					}
				
					if(bSpawned) {
						//We're done with this topic.
						continue;
					}

					//Increment the progress.
					if(pProgress) pProgress->SetProgress(0, nTotalProgress, nProgress++);

					//Is there a stored location for it?

					// (j.jones 2006-09-21 16:31) - PLID 22634 - look for more than just the current action,
					// also look for whether or not a previous version of the spawning item may be the spawning
					// parent of the stored item
					//

	// ------------------------------------------------------------------------------------------
	// (c.haag 2007-05-30 17:01) - PLID 26187 - We now do this completely in memory. No querying.
	// (c.haag 2007-06-18 16:14) - Ok...we only do it in memory if we actually have a valid
	// CEMNLoader object.
	// ------------------------------------------------------------------------------------------
					_RecordsetPtr rsTemplateDetails;
					CEMNLoader::CPreloadedTemplateTopic* pPreloadedTemplateTopic = NULL;
					try {
						// (c.haag 2007-08-16 17:34) - PLID 27024 - If the source loader is not available,
						// attempt our preloaded topic calculations using the local mint loader
						if (NULL == pCalcLoader) {
							//default to searching just for this action ID
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							CSqlFragment sqlSourceActionIDFind("SourceActionID = {INT}", ea.nID);

							if(ea.eaoSourceType == eaoEmrItem) {

								//TES 12/7/2006 - As I attempted to test my changes below, I realized that a SourceType of eaoEmrItem and a 
								// DestType of eaoEmrItem is bad data!
								ASSERT(FALSE);
								////see if any previous version of that info item spawns this topic
								//TES 12/5/2006 - PLID 23724 - We can just compare on EmrInfoMasterID now.
								//strSourceActionIDFind.Format("SourceActionID IN "
								//	"(SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
								//	" (SELECT ID FROM EmrInfoT WHERE EmrInfoMasterID = (SELECT EmrInfoMasterID FROM EmrInfoT SourceItem "
								//	" WHERE SourceItem.ID = %li)) "
								//	"AND DestType = %li AND DestID = %li)", eaoEmrItem, ea.nSourceID, eaoMintItems, ea.nDestID);
								
								//CString strPastItemIDs = GeneratePastEMRInfoIDs(ea.nSourceID);
								//don't change the strSourceActionIDFind unless there is more than one version
								//if(strPastItemIDs.Find(",") != -1) {
								//	//filter on actions for a past versions of the spawning item, that match up
								//	//with the current action's info item
								//	strSourceActionIDFind.Format("SourceActionID IN "
								//		"(SELECT ID FROM EMRActionsT WHERE SourceType = %li AND SourceID IN (%s) "
								//		"AND DestType = %li AND DestID = %li)", eaoEmrItem, strPastItemIDs, eaoMintItems, ea.nDestID);
								//}
							}
							else if(ea.eaoSourceType == eaoEmrDataItem) {

								//see if any previous version of that data item spawns this topic
								
								//TES 12/6/2006 - PLID 23766 - We can just compare on EmrDataGroupID now.
								// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
								sqlSourceActionIDFind.Create("SourceActionID IN "
									"(SELECT ID FROM EmrActionsT WHERE SourceType = {CONST} AND SourceID IN "
									" (SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
									" WHERE SourceItem.ID = {INT})) "
									"AND DestType = {CONST} AND DestID = {INT})", eaoEmrDataItem, ea.nSourceID, eaoMintItems, ea.nDestID);
								
								//CString strPastItemIDs = GeneratePastEMRDataIDs(ea.nSourceID);
								//don't change the strSourceActionIDFind unless there is more than one version
								//if(strPastItemIDs.Find(",") != -1) {
								//	//filter on actions for a past versions of the spawning item, that match up
								//	//with the current action's info item
								//	strSourceActionIDFind.Format("SourceActionID IN "
								//		"(SELECT ID FROM EMRActionsT WHERE SourceType = %li AND SourceID IN (%s) "
								//		"AND DestType = %li AND DestID = %li)", eaoEmrDataItem, strPastItemIDs, eaoMintItems, ea.nDestID);
								//}
							}
							// (z.manning, 01/24/2008) - PLID 28690 - Need to handle hot spots.
							else if (ea.eaoSourceType == eaoEmrImageHotSpot) {
								// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized - also fixed access violation
								sqlSourceActionIDFind.Create("SourceActionID IN "
									"SELECT ID FROM EmrActionsT "
									"WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrImageHotSpotsT "
									"	WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
									"	WHERE SourceItem.ID = {INT})) AND DestType = {CONST} AND ID IN ({INT}) "
									"ORDER BY ID DESC "
									, eaoEmrImageHotSpot, ea.nSourceID, eaoMintItems, ea.nDestID);
							}
							else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
								// (z.manning 2009-02-17 10:07) - PLID 33072
								// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
								sqlSourceActionIDFind.Create("SourceActionID IN \r\n"
									"(SELECT ID FROM EmrActionsT \r\n"
									" WHERE SourceType = {CONST} AND SourceID IN \r\n"
									"	(SELECT ID FROM EmrTableDropdownInfoT \r\n"
									"	 WHERE DropdownGroupID = \r\n"
									"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem \r\n"
									"		 WHERE SourceItem.ID = {INT})) \r\n"
									"		AND DestType = {CONST} AND DestID = {INT}) \r\n"
									, eaoEmrTableDropDownItem, ea.nSourceID, eaoMintItems, ea.nDestID);
							}

							// (j.jones 2007-01-15 11:16) - PLID 24027 - check the source detail ID of the template
							// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
							CSqlFragment sqlSourceDetailIDFind;
							if(pSourceDetail && pSourceDetail->m_nEMRTemplateDetailID != -1) {
								sqlSourceDetailIDFind.Create(" AND SourceDetailID = {INT} ", pSourceDetail->m_nEMRTemplateDetailID);
							}

							// (j.jones 2007-01-31 11:17) - PLID 24515 - try to filter by SourceDetailID,
							// and if that is empty, search just by SourceActionIDs
							if(sqlSourceDetailIDFind) {
								// (j.jones 2007-07-16 14:28) - PLID 26695 - don't open if we have a -1 template or topic ID
								// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
								if(pEMN->GetTemplateID() != -1 && nDestTopicID != -1) {
									rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrParentTemplateTopicID, OrderIndex, HideOnEMN "
										"FROM EmrTemplateTopicsT "
										"WHERE TemplateID = {INT} AND {SQL} AND SourceTemplateTopicID = {INT} "
										"AND ID NOT IN ({INTARRAY}) {SQL} ORDER BY SourceActionID DESC, OrderIndex ASC", pEMN->GetTemplateID(), sqlSourceActionIDFind, nDestTopicID, arExistingTopics, sqlSourceDetailIDFind);
								}
							}

							if(sqlSourceDetailIDFind.IsEmpty() || rsTemplateDetails->eof) {
								// (j.jones 2007-07-16 14:28) - PLID 26695 - don't open if we have a -1 template or topic ID
								if(pEMN->GetTemplateID() != -1 && nDestTopicID != -1) {
									// (a.walling 2007-11-27 13:20) - PLID 28194 - Prevent conflicting SourceDetailIDs
									// Alright, if we are here, it means we did not find one above with a matching sourcedetailID.
									// This code block is for backwards compatibility, but it errs by choosing a topic with a conflicting
									// sourcedetailID. If we are passed a source detail ID, we need to ensure that this is returning only
									// those topics that have a NULL source detail, rather than a source detail that conflicts with the 
									// one we are looking for.
									// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
									CSqlFragment sqlConflictSourceDetailIDFind;
									if (nSourceDetailIDFindFilter != -1) { // we are looking for a specific source detail
										sqlConflictSourceDetailIDFind.Create(" AND SourceDetailID IS NULL"); // we could not find it above, so
										// ensure the chosen topic has a NULL SourceDetailID.
									}

									rsTemplateDetails = CreateParamRecordset("SELECT ID, EmrParentTemplateTopicID, OrderIndex, HideOnEMN "
										"FROM EmrTemplateTopicsT "
										"WHERE TemplateID = {INT} AND {SQL} AND SourceTemplateTopicID = {INT} "
										"AND ID NOT IN ({INTARRAY}) {SQL} ORDER BY SourceActionID DESC, OrderIndex ASC", pEMN->GetTemplateID(), sqlSourceActionIDFind, nDestTopicID, arExistingTopics, sqlConflictSourceDetailIDFind);
								}
							}
	// ------------------------------------------------------------------------------------------
	// PLID 26187 - END LEGACY CODE EQUIVALENT #1
	// ------------------------------------------------------------------------------------------
	// ------------------------------------------------------------------------------------------
	// PLID 26187 - BEGIN CURRENT CODE #1
	// ------------------------------------------------------------------------------------------
						} // if (NULL == pCalcLoader) {
						else {
							// try to filter by SourceDetailID, and if that is empty, search just by SourceActionIDs
							// (c.haag 2007-08-22 09:14) - PLID 26187 - This body of code mimics everything in the
							// "LEGACY CODE EQUIVALENT" block of code above; only everything is done in memory. There are two
							// possible queries that can be run; and thus we also have two branches of code here which imitate
							// those two queries.


							// The legacy code did:
							//
							// "if(!strSourceDetailIDFind.IsEmpty()) {". 
							//
							// to see if the SourceDetailID is empty. We now represent the source detail ID
							// in nSourceDetailIDFindFilter as an actual integer. So, we do the equivalent
							// check by seeing if nSourceDetailIDFindFilter is not -1.
							if (-1 != nSourceDetailIDFindFilter) {

								// (c.haag 2007-07-03 10:15) - PLID 26523 - Take exclusive ownership of topics until this is done
								// (c.haag 2007-08-16 17:35) - PLID 27024 - Use "pCalcLoader" because we may not be pulling from
								// the pEMNSourceLoader object to get this information
								// (c.haag 2007-08-22 09:40) - PLID 26187 - I've annotated every component of the conditional to
								// explain its resembalance to the legacy version of this code which queried data
								// (c.haag 2010-07-07 13:06) - PLID 38886 - Don't just look at the EMN corresponding to pCalcLoader;
								// look at all of the templates that were added in this spawning chain to see if the user defined certain
								// places for these topics to be spawned to. Search from bottom (oldest) to top (newest).
								CArray<CEMNLoader*,CEMNLoader*> apLoaders;
								int stkIdx;
								for (stkIdx = 0; stkIdx < m_apeaoMintLoaderStack.GetSize(); stkIdx++) {
									if (*m_apeaoMintLoaderStack[stkIdx]) {
										apLoaders.Add(*m_apeaoMintLoaderStack[stkIdx]);
									}
								}
								// (c.haag 2010-07-14 10:24) - PLID 38886 - Now add the pCalcLoader to the first index because it's the very
								// oldest loader; this is usually the CEMNLoader used when opening the EMR. Wherever it decides topics should
								// go (based on user configuring) is the final authority because "it was here first".
								apLoaders.InsertAt(0, pCalcLoader);
								for (stkIdx=0; stkIdx < apLoaders.GetSize() && NULL == pPreloadedTemplateTopic; stkIdx++) 
								{
									CEMNLoader* pLoader = apLoaders[stkIdx];
									CHoldEMNLoaderMutex mh(pLoader->GetTopicsMutex());
									int nTemplateTopics = pLoader->GetTotalTemplateTopicCount();
									for (int i=0; i < nTemplateTopics; i++) {
										CEMNLoader::CPreloadedTemplateTopic* p = pLoader->GetPreloadedTemplateTopicByIndex(i);

										if (
											// Old code: "WHERE TemplateID = %li AND"
											//
											// This is pretty straight forward. pLoader refers to the template we're filtering on.
											TRUE &&

											// Old Code: "%s AND "
											//
											// %s points to strSourceActionIDFind, which is:
											//
											// "SourceActionID IN (SELECT ID FROM EmrActionsT WHERE SourceType = %li AND SourceID IN "
											// "(SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
											// " WHERE SourceItem.ID = %li)) AND DestType = %li AND DestID = %li)", eaoEmrDataItem, ea.nSourceID, eaoMintItems, ea.nDestID)
											//
											// We handle this in two parts. First, we test that the source action ID is not -1; otherwise, the query would
											// always return nothing. Second, we effectively ran the query above already. Look just below where anSourceActionIDFindFilter
											// was defined. You will see that a query is run, and anSourceActionIDFindFilter is populated with all the possible results.
											// These are the same results as the legacy query, only with the "SourceActionID IN"
											VarLong(p->m_vSourceActionID, -1) != -1 && IsIDInArray(VarLong(p->m_vSourceActionID, -1), anSourceActionIDFindFilter) &&

											// Old Code: "SourceTemplateTopicID = %li AND "
											//
											// This is a straight forward copy of that part of the query component
											VarLong(p->m_vSourceTemplateTopicID, -1) == nDestTopicID &&

											// Old Code: "ID NOT IN (%s) "
											//
											// %s points to ArrayAsString(arExistingTopics). This is another straight-forward copy of the query component
											!IsIDInArray(p->m_nID, arExistingTopics) &&

											// Old Code: "%s"
											//
											// %s points to strSourceDetailIDFind, which is:
											//
											// CString strSourceDetailIDFind = "";
											// if(pSourceDetail && pSourceDetail->m_nEMRTemplateDetailID != -1) {
											//		strSourceDetailIDFind.Format(" AND SourceDetailID = %li ", pSourceDetail->m_nEMRTemplateDetailID);
											// }
											//
											// If strSourceDetailIDFind is an empty string, then nSourceDetailIDFindFilter will be -1. In that case,
											// there is nothing to filter on, so the test will succeeed. If not, then nSourceDetailIDFindFilter is
											// equal to "pSourceDetail->m_nEMRTemplateDetailID", and we test it against the template topic's source
											// detail ID.
											((-1 == nSourceDetailIDFindFilter) || VarLong(p->m_vSourceDetailID, -1) == nSourceDetailIDFindFilter)
											//TES 3/18/2010 - PLID 37530 - We also need to confirm that we have the right Source Stamp Index
											&& ((-1 == nSourceStampIndex) || VarLong(p->m_vSourceStampIndex,-1) == nSourceStampIndex)
											)
										{
											// So far, so good. We qualified the old WHERE clause. Now we need to do ordering.
											if (NULL != pPreloadedTemplateTopic) {
												// ORDER BY SourceActionID DESC,
												if (VarLong(p->m_vSourceActionID) > VarLong(pPreloadedTemplateTopic->m_vSourceActionID)) {
													pPreloadedTemplateTopic = p;
												} else if (VarLong(p->m_vSourceActionID) == VarLong(pPreloadedTemplateTopic->m_vSourceActionID)) {
													// OrderIndex ASC
													if (VarLong(p->m_vOrderIndex) < VarLong(pPreloadedTemplateTopic->m_vOrderIndex)) {
														pPreloadedTemplateTopic = p;
													}
												}
											} else {
												pPreloadedTemplateTopic = p;
											}
										}

									} // for (int i=0; i < nTemplateTopics; i++) {
								} // for (int stkIdx=0; stkIdx < apLoaders.GetSize() && NULL == pPreloadedTemplateTopic; stkIdx++) {
							} // if (-1 != nSourceDetailIDFindFilter) {

							if (NULL == pPreloadedTemplateTopic) {
								// (c.haag 2007-07-03 10:15) - PLID 26523 - Take exclusive ownership of topics until this is done
								// (c.haag 2007-08-16 17:35) - PLID 27024 - Use "pCalcLoader" because we may not be pulling from
								// the pEMNSourceLoader object to get this information
								// (c.haag 2007-08-22 09:40) - PLID 26187 - I've lightly annotated every component of the conditional to
								// explain its resembalance to the legacy version of this code which queried data. For more thorough
								// annotations, look at the code branch above this one.
								// (c.haag 2010-07-07 13:06) - PLID 38886 - Don't just look at the EMN corresponding to pCalcLoader;
								// look at all of the templates that were added in this spawning chain to see if the user defined certain
								// places for these topics to be spawned to. Search from bottom (oldest) to top (newest).
								CArray<CEMNLoader*,CEMNLoader*> apLoaders;
								int stkIdx;
								for (stkIdx = 0; stkIdx < m_apeaoMintLoaderStack.GetSize(); stkIdx++) {
									if (*m_apeaoMintLoaderStack[stkIdx]) {
										apLoaders.Add(*m_apeaoMintLoaderStack[stkIdx]);
									}
								}
								// (c.haag 2010-07-14 10:24) - PLID 38886 - Now add the pCalcLoader to the first index because it's the very
								// oldest loader; this is usually the CEMNLoader used when opening the EMR. Wherever it decides topics should
								// go (based on user configuring) is the final authority because "it was here first".
								apLoaders.InsertAt(0, pCalcLoader);
								for (int stkIdx=0; stkIdx < apLoaders.GetSize() && NULL == pPreloadedTemplateTopic; stkIdx++) 
								{
									CEMNLoader* pLoader = apLoaders[stkIdx];
									CHoldEMNLoaderMutex mh(pLoader->GetTopicsMutex());
									int nTemplateTopics = pLoader->GetTotalTemplateTopicCount();
									for (int i=0; i < nTemplateTopics; i++) {
										CEMNLoader::CPreloadedTemplateTopic* p = pLoader->GetPreloadedTemplateTopicByIndex(i);

										if (// WHERE TemplateID = %li AND
											TRUE &&
											// %s AND 
											VarLong(p->m_vSourceActionID, -1) != -1 && IsIDInArray(VarLong(p->m_vSourceActionID, -1), anSourceActionIDFindFilter) &&
											// SourceTemplateTopicID = %li AND
											VarLong(p->m_vSourceTemplateTopicID, -1) == nDestTopicID &&
											// ID NOT IN (%s)
											!IsIDInArray(p->m_nID, arExistingTopics)
											)
										{
											// (a.walling 2007-11-27 13:22) - PLID 28194 - If we are given a sourcedetailID, ensure we do not load
											// something that has a conflicting sourcedetailID.
											if (nSourceDetailIDFindFilter != -1) {
												if ( (p->m_vSourceDetailID.vt == VT_I4) && (VarLong(p->m_vSourceDetailID, -1) != nSourceDetailIDFindFilter) ) {
													// if we get here, then we are looking for a non-null sourcedetail
													// and the sourcedetail of this topic is non-null
													// and the sourcedetail does not match the one we are looking for. so discard this as an option.
													continue;
												}
											}

											// So far, so good. We qualified the old WHERE clause. Now we need to do ordering.
											if (NULL != pPreloadedTemplateTopic) {
												// ORDER BY SourceActionID DESC,
												if (VarLong(p->m_vSourceActionID) > VarLong(pPreloadedTemplateTopic->m_vSourceActionID)) {
													pPreloadedTemplateTopic = p;
												} else if (VarLong(p->m_vSourceActionID) == VarLong(pPreloadedTemplateTopic->m_vSourceActionID)) {
													// OrderIndex ASC
													if (VarLong(p->m_vOrderIndex) < VarLong(pPreloadedTemplateTopic->m_vOrderIndex)) {
														pPreloadedTemplateTopic = p;
													}
												}
											} else {
												pPreloadedTemplateTopic = p;
											}
										}

									} // for (int i=0; i < nTemplateTopics; i++) {
								} // for (int stkIdx=0; stkIdx < apLoaders.GetSize() && NULL == pPreloadedTemplateTopic; stkIdx++) 
							} // if (NULL == pPreloadedTemplateTopic) {
						}
					}
					// (c.haag 2007-07-03 12:27) - If something is thrown from here, let the developer know in debug
					// mode. This makes it easier to pin down problems.
					NxCatchAllSilentCallThrow(ASSERT(FALSE));

	// ------------------------------------------------------------------------------------------
	// PLID 26187 - END CURRENT CODE #1
	// ------------------------------------------------------------------------------------------

					//Increment the progress.
					if(pProgress) pProgress->SetProgress(0, nTotalProgress, nProgress++);

					// (c.haag 2007-05-30 17:21) - PLID 26187 - We no longer have a recordset
					// (c.haag 2007-06-18 16:19) - Actually, one of the following is true at this point:
					// rsTemplateDetails is NULL, and pPreloadedTemplateTopic is NULL
					// rsTemplateDetails is NULL, and pPreloadedTemplateTopic is not NULL
					// rsTemplateDetails is not NULL, and pPreloadedTemplateTopic is NULL
					//
					// The last possibility will be true if pEMNSourceLoader is NULL.

					if(NULL != pPreloadedTemplateTopic || (NULL != rsTemplateDetails && !rsTemplateDetails->eof)) {
						long nParentTopicID = (NULL != pPreloadedTemplateTopic) ? VarLong(pPreloadedTemplateTopic->m_vEMRParentTemplateTopicID, -1) : AdoFldLong(rsTemplateDetails, "EmrParentTemplateTopicID", -1);
						long nID = (NULL != pPreloadedTemplateTopic) ? pPreloadedTemplateTopic->m_nID : AdoFldLong(rsTemplateDetails, "ID");
						long nOrderIndex = (NULL != pPreloadedTemplateTopic) ? VarLong(pPreloadedTemplateTopic->m_vOrderIndex) : AdoFldLong(rsTemplateDetails, "OrderIndex");
						if(!m_bIsTemplate && (
							(NULL != pPreloadedTemplateTopic && VarBool(pPreloadedTemplateTopic->m_vHideOnEMN)) ||
							(NULL == pPreloadedTemplateTopic && AdoFldBool(rsTemplateDetails, "HideOnEMN"))
							))
						{
							//This topic isn't supposed to spawn.  Don't spawn it.
							bSpawned = true;
							arHiddenTemplateTopicIDs.Add(nID);
						}
						//rsTemplateDetails->Close();
						//Find the correct parent.
						if(!bSpawned) {
							if(nParentTopicID != -1) {
								//Add to memory object.
								// (a.walling 2010-04-05 13:19) - PLID 38060 - Need to use the source action info as well
								CEMRTopic *pParentTopic = pEMN->GetTopicByTemplateTopicID(nParentTopicID, pSourceDetail->GetSpawnedGroupID(), NULL, &pSourceDetail->GetSpawnedGroupSourceActionInfo());

								// (c.haag 2006-09-29 12:07) - PLID 22770 - If we did not find a parent topic, then it could 
								// be because the parent is one of our newly spawned topics from this call to ProcessEmrAction().
								// Do a second check where the source action ID is ea.nID
								if (NULL == pParentTopic) {
									pParentTopic = pEMN->GetTopicByTemplateTopicID(nParentTopicID, ea.nID, pSourceDetail);
								}

								if(pParentTopic) {
									//TES 2/9/2006 - Go through the subtopics until you find one from the same template, with 
									//a later OrderIndex, and insert before that one.
									// (c.haag 2007-07-26 12:05) - Replaced 'i' with 'k' because 'i' is already in use in the
									// top-most loop.
									CEMRTopic *pInsertBefore = NULL;
									for(int k = 0; k < pParentTopic->GetSubTopicCount() && !pInsertBefore; k++) {
										if(pParentTopic->GetSubTopic(k)->GetTemplateID() == pEMN->GetTemplateID() &&
											pParentTopic->GetSubTopic(k)->GetTemplateTopicOrderIndex() > nOrderIndex) {
											pInsertBefore = pParentTopic->GetSubTopic(k);
										}
									}
									//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
									// then it's possible that an entry already exists, otherwise, create a new one.
									TopicPositionEntry *tpe = NULL;
									if(m_bIsTemplate) {
										tpe = m_pTopicPositionHead->GetEntryByID(nID);
										if(tpe == NULL) {
											tpe = new TopicPositionEntry;
											//TES 5/3/2010 - PLID 24692 - Assign the ID.
											tpe->nTopicID = nID;
										}
									}
									else {
										tpe = new TopicPositionEntry;
									}
									CEMRTopic *pNewTopic = new CEMRTopic(pParentTopic, tpe);
									//TES 10/5/2009 - PLID 35755 - If this is a template, we don't want spawning to cause the topics to get re-ordered
									pParentTopic->InsertSubTopic(pNewTopic, pInsertBefore, bIsInitialLoad, !m_bIsTemplate);

									// (c.haag 2007-05-30 08:56) - PLID 26157 - Use the preloader instead of CEMRTopic::LoadFromTemplateTopicID for speed purposes.
									// (c.haag 2007-07-03 10:00) - PLID 26523 - Modified to support thread safety
									BOOL bForceSlowLoad = FALSE;
									if (NULL != pEMNSourceLoader) {
										CHoldEMNLoaderMutex mh(pEMNSourceLoader->GetTopicsMutex());
										CEMNLoader::CPreloadedTemplateTopic* pPreloadedTopic = pEMNSourceLoader->GetPreloadedTemplateTopicByID(nID);
										if (NULL != pPreloadedTopic) {
											pPreloadedTopic->m_pTopic = pNewTopic; // Manually assign the topic because the CEMNLoader didn't create it
											// (c.haag 2007-07-03 12:10) - PLID 26523 - Release our lock on the loader so that it can finish its load
											mh.Release();
											try {
												// (c.haag 2007-08-08 11:42) - PLID 27014 - Specify that we must not load subtopics
												//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
												//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
												//	action source ID and have no need to go deeper.
												// (j.jones 2010-03-09 14:27) - PLID 37691 - if this is a patient EMN, pass in the patient ID
												long nPatientID = -1;
												if(!m_bIsTemplate && GetParentEMR() != NULL) {
													nPatientID = GetParentEMR()->GetPatientID();
												}
												// (z.manning 2010-08-20 09:56) - PLID 40190 - Pass in connection pointer
												// (z.manning 2011-09-30 17:28) - PLID 45778 - Pass in the parent EMR object
												pNewTopic->LoadFromPreloadedTemplateTopic(GetRemoteData(), pEMNSourceLoader, nID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai,
													FALSE, nPatientID, pParentEmr, FALSE, ea.nSourceID, -1);
												// (c.haag 2007-05-30 10:36) - PLID 26175 - Force the load to complete
												pNewTopic->ForceLoadToFinish();
												// (c.haag 2007-08-09 09:03) - PLID 26157 - Track the new topic and its loader for later
												apNewTopics.Add(pNewTopic);
												apNewTopicLoaders.Add(pEMNSourceLoader);
											}
											// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
											// mode. This makes it easier to pin down problems.
											NxCatchAllSilentCallThrow(ASSERT(FALSE));
										} else {
											// If we get there, the topic belongs on another template!
											bForceSlowLoad = TRUE;
										}
									} else {
										bForceSlowLoad = TRUE;
									}
									if (bForceSlowLoad) {
										//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
										//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
										//	action source ID and have no need to go deeper.
										pNewTopic->LoadFromTemplateTopicID(nID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, pParentEmr, NULL, ea.nSourceID, -1);
										// (c.haag 2007-08-09 09:04) - PLID 26157 - Track the new topic and its loader for later
										apNewTopics.Add(pNewTopic);
										apNewTopicLoaders.Add(NULL);
									}
									
									if(!bIsInitialLoad) {

										// (j.jones 2007-01-31 14:32) - PLID 24515 - did the SourceDetailID change?
										// if so, force the topic to be unsaved upon load
										BOOL bForceSave = FALSE;
										if(pSourceDetail && pNewTopic->GetSourceDetailID() != (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
											bForceSave = TRUE;
										}
										pNewTopic->SetUnsaved(bForceSave);
										if(pInsertBefore)
											pInsertBefore->SetUnsaved();
									}
									//Make sure to set the source action id so that the topic will rename itself correctly when it checks for duplicate topic names
									// (j.jones 2007-07-31 09:19) - PLID 26882 - changed to use the overload that takes in an action object
									//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
									pNewTopic->SetSourceActionInfo(sai);
									//Add to interface.
									if(GetInterface()) {
										// (c.haag 2007-05-31 12:57) - PLID 26175 - Set LPARAM to TRUE so that HTML
										// preview information is not created
										GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pNewTopic, (LPARAM)TRUE);
									}
									bSpawned = true;
								}
								else {
									//Our parent doesn't exist.  Was it intentionally hidden?
									for(int nHiddenTopic = 0; nHiddenTopic < arHiddenTemplateTopicIDs.GetSize() && !bSpawned; nHiddenTopic++) {
										// (c.haag 2007-09-19 16:40) - PLID 27449 - Use nHiddenTopic; it is obviously the intended loop counter
										if(arHiddenTemplateTopicIDs[nHiddenTopic] == nParentTopicID) {
											//OK, it was intentionally skipped, so let's intentionally skip this one.
											bSpawned = true;
											arHiddenTemplateTopicIDs.Add(nID);
										}
									}
									if(!bSpawned) {
										//Our parent hasn't been spawned yet.
										SkippedTopic st;
										st.nTemplateTopicID = nID;
										st.nParentTemplateTopicID = nParentTopicID;
										st.nOrderIndex = nOrderIndex;
										st.sai = sai; // (z.manning 2009-03-05 09:07) - PLID 33338
										//DRT 9/25/2007 - PLID 27515 - Added source action data.  DataGroupID not needed because 
										//	this is being spawned "live".
										st.nSourceActionSourceID = ea.nSourceID;
										st.nSourceActionSourceDataGroupID = -1;
										st.bIsInitialLoad = bIsInitialLoad;
										arSkippedTopics.Add(st);
										//I know this hasn't technically been spawned, but we don't want to process it any more.
										bSpawned = true;
									}
								}
							}
							else {
								//Add to memory object.
								//TES 2/9/2006 - Go through the subtopics until you find one from the same template, with 
								//a later OrderIndex, and insert before that one.
								CEMRTopic *pInsertBefore = NULL;
								for(int i = 0; i < pEMN->GetTopicCount() && !pInsertBefore; i++) {
									if(pEMN->GetTopic(i)->GetTemplateID() == pEMN->GetTemplateID() &&
										pEMN->GetTopic(i)->GetTemplateTopicOrderIndex() > nOrderIndex) {
										pInsertBefore = pEMN->GetTopic(i);
									}
								}
								//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
								// then it's possible that an entry already exists, otherwise, create a new one.
								TopicPositionEntry *tpe = NULL;
								if(m_bIsTemplate) {
									tpe = m_pTopicPositionHead->GetEntryByID(nID);
									if(tpe == NULL) {
										tpe = new TopicPositionEntry;
										//TES 5/3/2010 - PLID 24692 - Assign the ID.
										tpe->nTopicID = nID;
									}
								}
								else {
									tpe = new TopicPositionEntry;
								}
								CEMRTopic *pNewTopic = new CEMRTopic(pEMN, tpe);
								//TES 10/5/2009 - PLID 35755 - If this is a template, we don't want spawning to force a re-ordering of the topics.
								pEMN->InsertTopic(pNewTopic, pInsertBefore, bIsInitialLoad, !m_bIsTemplate);

								// (c.haag 2007-05-30 08:56) - PLID 26157 - Use the preloader instead of CEMRTopic::LoadFromTemplateTopicID for speed purposes.
								// (c.haag 2007-07-03 10:03) - PLID 26523 - Modified to support thread safety
								BOOL bForceSlowLoad = FALSE;
								if (NULL != pEMNSourceLoader) {
									CHoldEMNLoaderMutex mh(pEMNSourceLoader->GetTopicsMutex());
									CEMNLoader::CPreloadedTemplateTopic* pPreloadedTopic = pEMNSourceLoader->GetPreloadedTemplateTopicByID(nID);
									if (NULL != pPreloadedTopic) {
										pPreloadedTopic->m_pTopic = pNewTopic; // Manually assign the topic because the CEMNLoader didn't create it
										// (c.haag 2007-07-03 12:10) - PLID 26523 - Release our lock on the loader so that it can finish its load
										mh.Release();
										try {
											// (c.haag 2007-08-08 11:42) - PLID 27014 - Specify that we must not load subtopics
											//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
											//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
											//	action source ID and have no need to go deeper.
											// (j.jones 2010-03-09 14:27) - PLID 37691 - if this is a patient EMN, pass in the patient ID
											long nPatientID = -1;
											if(!m_bIsTemplate && GetParentEMR() != NULL) {
												nPatientID = GetParentEMR()->GetPatientID();
											}
											// (z.manning 2010-08-20 09:56) - PLID 40190 - Pass in connection pointer
											// (z.manning 2011-09-30 17:28) - PLID 45778 - Pass in the parent EMR object
											pNewTopic->LoadFromPreloadedTemplateTopic(GetRemoteData(), pEMNSourceLoader, nID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai,
												FALSE, nPatientID, pParentEmr, FALSE, ea.nSourceID, -1);
											// (c.haag 2007-05-30 10:36) - PLID 26175 - Force the load to complete
											pNewTopic->ForceLoadToFinish();
											// (c.haag 2007-08-09 09:03) - PLID 26157 - Track the new topic and its loader for later
											apNewTopics.Add(pNewTopic);
											apNewTopicLoaders.Add(pEMNSourceLoader);
										}
										// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
										// mode. This makes it easier to pin down problems.
										NxCatchAllSilentCallThrow(ASSERT(FALSE));
									} else {
										// The topic exists on another template!
										bForceSlowLoad = TRUE;
									}
								} else {
									bForceSlowLoad = TRUE;
								}
								if (bForceSlowLoad) {
									//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
									//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
									//	action source ID and have no need to go deeper.
									pNewTopic->LoadFromTemplateTopicID(nID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, pParentEmr, NULL, ea.nSourceID, -1);
									// (c.haag 2007-08-09 09:04) - PLID 26157 - Track the new topic and its loader for later
									apNewTopics.Add(pNewTopic);
									apNewTopicLoaders.Add(NULL);
								}

								if(!bIsInitialLoad) {
									// (j.jones 2007-01-31 14:32) - PLID 24515 - did the SourceDetailID change?
									// if so, force the topic to be unsaved upon load
									BOOL bForceSave = FALSE;
									if(pSourceDetail && pNewTopic->GetSourceDetailID() != (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
										bForceSave = TRUE;
									}
									pNewTopic->SetUnsaved(bForceSave);
									if(pInsertBefore)
										pInsertBefore->SetUnsaved();
								}
								//Make sure to set the source action id so that the topic will rename itself correctly when it checks for duplicate topic names
								//TES 3/16/2010 - PLID 37530 - Replaced all SetSource___() calls with SetSourceActionInfo()
								pNewTopic->SetSourceActionInfo(sai);
								//Add to interface.
								if(GetInterface()) {
									// (c.haag 2007-05-31 12:57) - PLID 26175 - Set LPARAM to TRUE so that HTML
									// preview information is not created
									GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pNewTopic, (LPARAM)TRUE);
								}
								bSpawned = true;
							}
						}
					}

					if(!bSpawned) {
						//We haven't found any other way to do it.  So, by default, we'll add this topic as the last sibling
						//of the source detail's topic.
						//TES 2/2/2006 - CORRECTION: we will spawn immediately after the source detail's topic.
						//TES 4/24/2006 - Also, they now have the option to be children of the current topic.
						//Add to memory object.

						if (NULL == pEMNMintLoader) {
							// (c.haag 2007-08-16 17:37) - PLID 27024 - The code to create pEMNMintLoader has
							// been moved to CreateMintItemsLoader
							pEMNMintLoader = CreateMintItemsLoader(ea, pEMN, sai);

							// (c.haag 2008-06-26 12:59) - PLID 27549 - If pEMNSpawnedMintLoader is not null, that means
							// this mint item collection is being spawned because of a detail from another just-spawned mint
							// item collection. That means we need to ensure that the topic hierarchy of this mint item collection
							// is correct by examining the topic hierarchy of pEMNSpawnedMintLoader.
							//
							if (pEMNSpawnedMintLoader != NULL) {
								CHoldEMNLoaderMutex mhNewTopics(pEMNMintLoader->GetTopicsMutex());
								CHoldEMNLoaderMutex mhSpawnedMintTopics(pEMNSpawnedMintLoader->GetTopicsMutex());
								const int nNewTopicCount = pEMNMintLoader->GetTotalTemplateTopicCount();
								const int nSpawnedMintTopicCount = pEMNSpawnedMintLoader->GetTotalTemplateTopicCount();
								//
								// We must first map a topic in pEMNMintLoader to a topic in pEMNSpawnedMintLoader. The mapping 
								// goes from pEMNMintLoader::topic::ID to pEMNSpawnedMintLoader::topic::m_vSourceTemplateTopicID.
								// To do the mapping, we have to have a loop for all parent mint topics inside a loop for all new topics
								//
								for (int nNewTopic=0; nNewTopic < nNewTopicCount; nNewTopic++) {
									CEMNLoader::CPreloadedTemplateTopic* pSpawningTopic = pEMNMintLoader->GetPreloadedTemplateTopicByIndex(nNewTopic);
									const long nSpawningTopicID = pSpawningTopic->m_nID;
									for (int nSpawnedMintTopic=0; nSpawnedMintTopic < nSpawnedMintTopicCount; nSpawnedMintTopic++) {

										const CEMNLoader::CPreloadedTemplateTopic* pSpawnedMintTopic = pEMNSpawnedMintLoader->GetPreloadedTemplateTopicByIndex(nSpawnedMintTopic);
										const long nSpawnedSourceTopicID = VarLong(pSpawnedMintTopic->m_vSourceTemplateTopicID, -1);

										if (nSpawningTopicID > -1 && nSpawnedSourceTopicID > -1 && nSpawningTopicID == nSpawnedSourceTopicID) {
											// Jackpot. If we get here, we found two topics related by source ID. The next step is the
											// most important: Deciding whether to actually change the parent of the currently spawning topic.
											// Here's the logic: If the new topic's parent ID does not match the parent mint topic's original
											// ID then they mismatch; and in that case, the spawned template hierarchy takes precedence.
											const long nSpawnedParentTopicID = VarLong(pSpawnedMintTopic->m_vEMRParentTemplateTopicID, -1);
											const CEMNLoader::CPreloadedTemplateTopic* pSpawnedParentTopic = pEMNSpawnedMintLoader->GetPreloadedTemplateTopicByID(nSpawnedParentTopicID);
											if (NULL != pSpawnedParentTopic) {
												const CEMNLoader::CPreloadedTemplateTopic* pSpawningParentTopic = pEMNMintLoader->GetPreloadedTemplateTopicByID(VarLong(pSpawnedParentTopic->m_vSourceTemplateTopicID, -1));
												if (NULL == pSpawningParentTopic) {
													// If we get here, it means the spawned template believes this topic has a parent, but the
													// spawning template says otherwise. The spawned template takes precedence.
													pSpawningTopic->m_vEMRParentTemplateTopicID = pSpawnedMintTopic->m_vEMRParentTemplateTopicID;
												} 
												else if (VarLong(pSpawnedParentTopic->m_vSourceTemplateTopicID, -1) != pSpawningParentTopic->m_nID) {
													// If we get here, it means the spawned template is in disagreement with the parent of the
													// corresponding spawned topic. The spawned template takes precedence.
													pSpawningTopic->m_vEMRParentTemplateTopicID = pSpawnedMintTopic->m_vEMRParentTemplateTopicID;
												}
												else {
													// If we get here, the two templates are in agreement about the hierarchy. Don't change anything.
												}
											}
											else {
												// No defined parent; don't change the hierarchy
											}

											// Break out of the loop; we should never have more than one result
											break;
										} // if (nSpawningTopicID > -1 && nSpawnedSourceTopicID > -1 && nSpawningTopicID == nSpawnedSourceTopicID) {

									} // for (int nParentMintTopic=0; nParentMintTopic < nParentMintTopicCount; nParentMintTopic++) {
								} // for (int nNewTopic=0; nNewTopic < nNewTopicCount; nNewTopic++) {
							}
						}

						CEMRTopic *pParent = ea.bSpawnAsChild ? pSourceDetail->m_pParentTopic : pSourceDetail->m_pParentTopic->GetParentTopic();
						CEMRTopic *pNewTopic = NULL;
						CEMNLoader::CPreloadedTemplateTopic* pPreloadedTopic;
						// (z.manning, 08/13/2007) - PLID 27041 - We need to see if this topic has a parent topic
						// on the template it's coming from or else we lose the hierarchical structure of the template
						// items we're importing.
						if(pEMNMintLoader != NULL) {
							// (z.manning, 08/13/2007) - PLID 27041 - This code for the getting the preloaded and the mutex
							// stuff was moved up here, though is identical to what it was before..
							CHoldEMNLoaderMutex mh(pEMNMintLoader->GetTopicsMutex());
							pPreloadedTopic = pEMNMintLoader->GetPreloadedTemplateTopicByID(nDestTopicID);
							if(pPreloadedTopic != NULL) {
								// (c.haag 2007-07-03 12:10) - PLID 26523 - Release our lock on the loader so that it can finish its load
								mh.Release();
								if(pPreloadedTopic->m_vEMRParentTemplateTopicID.vt == VT_I4) {
									long nTemplateTopicID = VarLong(pPreloadedTopic->m_vEMRParentTemplateTopicID, -1);
									if(nTemplateTopicID != -1) {
										// (z.manning, 08/13/2007) - PLID 27041 - Ok, the pre-loaded topic has a valid
										// parent template topic ID, so let's see if we can find a topic from this ID,
										// and if so, then use it as the parent.
										// (a.walling 2010-04-05 13:19) - PLID 38060 - Need to use the source action info as well
										CEMRTopic *pActualParent = GetTopicByTemplateTopicID(nTemplateTopicID, pSourceDetail->GetSpawnedGroupID(), pSourceDetail, &pSourceDetail->GetSpawnedGroupSourceActionInfo());
										if(pActualParent != NULL) {
											pParent = pActualParent;
										}
									}
								}
							}
						}

						if(pParent) {
							//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
							// then it's possible that an entry already exists, otherwise, create a new one.
							//TES 5/18/2010 - PLID 24692 - Correction: if we get to this point, we KNOW we don't have an entry, otherwise
							// we would have found a spot for this topic.  Plus, nDestTopicID represents a topic on the source template,
							// not on our template.  So, create a new entry every time.
							TopicPositionEntry *tpe = new TopicPositionEntry;

							pNewTopic = new CEMRTopic(pParent, tpe);
							//TES 10/5/2009 - PLID 35755 - Since we're not putting this in a stored position, it will
							// need to save its new position.
							pParent->InsertSubTopic(pNewTopic, pNextSibling, bIsInitialLoad, TRUE);

							// (c.haag 2007-05-30 08:49) - PLID 26157 - Use the preloader instead of CEMRTopic::LoadFromTemplateTopicID for speed purposes.
							// (c.haag 2007-07-03 10:03) - PLID 26523 - Modified to support thread safety
							BOOL bForceSlowLoad = FALSE;
							if (NULL != pEMNMintLoader) {
								// (c.haag 2007-05-30 10:36) - PLID 26175 - Force the load to complete
								if (NULL != pPreloadedTopic) {
									pPreloadedTopic->m_pTopic = pNewTopic; // Manually assign the topic because the CEMNLoader didn't create it
									try {
										// (c.haag 2007-08-08 11:42) - PLID 27014 - Specify that we must not load subtopics
										//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
										//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
										//	action source ID and have no need to go deeper.
										// (j.jones 2010-03-09 14:27) - PLID 37691 - if this is a patient EMN, pass in the patient ID
										long nPatientID = -1;
										if(!m_bIsTemplate && GetParentEMR() != NULL) {
											nPatientID = GetParentEMR()->GetPatientID();
										}
										// (z.manning 2010-08-20 09:57) - PLID 40190 - Pass in connection object
										// (z.manning 2011-09-30 17:28) - PLID 45778 - Pass in the parent EMR object
										pNewTopic->LoadFromPreloadedTemplateTopic(GetRemoteData(), pEMNMintLoader, nDestTopicID, TRUE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai,
											FALSE, nPatientID, pParentEmr, FALSE, ea.nSourceID, -1);
										// Force the load to finish
										pNewTopic->ForceLoadToFinish();
										// (c.haag 2007-08-09 09:03) - PLID 26157 - Track the new topic and its loader for later
										apNewTopics.Add(pNewTopic);
										apNewTopicLoaders.Add(pEMNMintLoader);
									}
									// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
									// mode. This makes it easier to pin down problems.
									NxCatchAllSilentCallThrow(ASSERT(FALSE));
								} else {
									// The topic exists on another template!
									bForceSlowLoad = TRUE;
								}
							} else {
								bForceSlowLoad = TRUE;
							}
							if (bForceSlowLoad) {
								//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
								//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
								//	action source ID and have no need to go deeper.
								pNewTopic->LoadFromTemplateTopicID(nDestTopicID, TRUE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, pParentEmr, NULL, ea.nSourceID, -1);
								// (c.haag 2007-08-09 09:04) - PLID 26157 - Track the new topic and its loader for later
								apNewTopics.Add(pNewTopic);
								apNewTopicLoaders.Add(NULL);
							}

							if(!bIsInitialLoad) {
								pNewTopic->SetUnsaved();
							}
						}
						else {
							//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
							// then it's possible that an entry already exists, otherwise, create a new one.
							//TES 5/18/2010 - PLID 24692 - Correction: if we get to this point, we KNOW we don't have an entry, otherwise
							// we would have found a spot for this topic.  Plus, nDestTopicID represents a topic on the source template,
							// not on our template.  So, create a new entry every time.
							TopicPositionEntry *tpe = new TopicPositionEntry;
							pNewTopic = new CEMRTopic(pEMN, tpe);
							//TES 10/5/2009 - PLID 35755 - Since we're not putting this in a stored position, it will
							// need to save its new position.
							pEMN->InsertTopic(pNewTopic, pNextSibling, bIsInitialLoad, TRUE);

							// (c.haag 2007-05-30 08:49) - PLID 26157 - Use the preloader instead of CEMRTopic::LoadFromTemplateTopicID for speed purposes.							
							// (c.haag 2007-07-03 10:07) - PLID 26523 - Modified to support thread safety
							BOOL bForceSlowLoad = FALSE;
							if (NULL != pEMNMintLoader) {
								// (c.haag 2007-05-30 10:36) - PLID 26175 - Force the load to complete
								if (NULL != pPreloadedTopic) {
									pPreloadedTopic->m_pTopic = pNewTopic; // Manually assign the topic because the CEMNLoader didn't create it
									try {
										// (c.haag 2007-08-08 11:42) - PLID 27014 - Specify that we must not load subtopics
										//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
										//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
										//	action source ID and have no need to go deeper.
										// (j.jones 2010-03-09 14:27) - PLID 37691 - if this is a patient EMN, pass in the patient ID
										long nPatientID = -1;
										if(!m_bIsTemplate && GetParentEMR() != NULL) {
											nPatientID = GetParentEMR()->GetPatientID();
										}
										// (z.manning 2010-08-20 09:57) - PLID 40190 - Pass in connection object
										// (z.manning 2011-09-30 17:28) - PLID 45778 - Pass in the parent EMR object
										pNewTopic->LoadFromPreloadedTemplateTopic(GetRemoteData(), pEMNMintLoader, nDestTopicID, TRUE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai,
											FALSE, nPatientID, pParentEmr, FALSE, ea.nSourceID, -1);
										// Force the load to finish
										pNewTopic->ForceLoadToFinish();
										// (c.haag 2007-08-09 09:03) - PLID 26157 - Track the new topic and its loader for later
										apNewTopics.Add(pNewTopic);
										apNewTopicLoaders.Add(pEMNMintLoader);
									}
									// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
									// mode. This makes it easier to pin down problems.
									NxCatchAllSilentCallThrow(ASSERT(FALSE));
								} else {
									// The topic exists on another template!
									bForceSlowLoad = TRUE;
								}
							} else {
								bForceSlowLoad = TRUE;
							}
							if (bForceSlowLoad) {
								//DRT 9/25/2007 - PLID 27515 - Added the SourceActionSourceID.  Since this is being spawned now, we can 
								//	leave the SourceActionSourceDataGroupID as -1 -- when the unspawner works, it will match the source
								//	action source ID and have no need to go deeper.
								pNewTopic->LoadFromTemplateTopicID(nDestTopicID, TRUE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, pParentEmr, NULL, ea.nSourceID, -1);
								// (c.haag 2007-08-09 09:04) - PLID 26157 - Track the new topic and its loader for later
								apNewTopics.Add(pNewTopic);
								apNewTopicLoaders.Add(NULL);
							}

							if(!bIsInitialLoad) {
								pNewTopic->SetUnsaved();
							}
						}
						//Add to interface.
						if(GetInterface()) {
							// (c.haag 2007-05-31 12:57) - PLID 26175 - Set LPARAM to TRUE so that HTML
							// preview information is not created
							GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pNewTopic, (LPARAM)TRUE);
						}
					}

					//Increment the progress
					if(pProgress) pProgress->SetProgress(0, nTotalProgress, nProgress++);
				}
				// (c.haag 2007-07-03 12:45) - If something is thrown from here, let the developer know in debug
				// mode. This makes it easier to pin down problems.
				NxCatchAllSilentCallThrow(ASSERT(FALSE));

			} // for(int i = 0; i < arTemplateTopicIDs.GetSize(); i++) {

			// (c.haag 2008-06-26 12:09) - PLID 27549 - It's possible that this template contains
			// multi-select details that are checked by default and spawn additional mint items. Prior
			// to the existence of this function, the topics for those additional mint items were not
			// spawned in the correct hierarchy. This is because their parent topic ID's were all NULL,
			// and the spawn was oblivious to the proper hierarchy defined in pEMNMintLoader.
			pSourceEmn->GetParentEMR()->DetectAndSpawnChildMintItems(pEMNMintLoader, apNewTopics);

			// (z.manning 2009-06-23 15:25) - PLID 34692 - It is possible we just spawned a topic
			// that is not new. One example (maybe the only one) is that we just re-spawned a topic
			// on a template that had been deleted earlier in the same session. We need to make sure
			// we don't try to delete this topic when saving or else FK errors may ensue.
			EnsureTopicsNotDeletedIfNotNew(apNewTopics);

			pEMN->GetParentEMR()->UnlockSpawning();

			// (c.haag 2007-05-31 10:49) - PLID 26157 - Now generate the HTML information. We
			// must build an array of all the topics we loaded, and send it to the interface
			// window for processing.
			try {
				if (NULL != GetInterface()) {

					// Temporarily assign each topic its parent EMN loader object so that the HTML can look
					// in memory rather than data for content information
					const int nNewTopics = apNewTopics.GetSize();
					int nTopic;
					for (nTopic=0; nTopic < nNewTopics; nTopic++) {
						CEMRTopic* pTopic = apNewTopics[nTopic];
						//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
						if(pTopic->GetLoadInfo() == NULL) {
							//We cannot continue
							AfxThrowNxException("Error in ProcessEmrAction - Could not get the topic loading information.");
						}
						pTopic->GetLoadInfo()->m_pLoader = apNewTopicLoaders[nTopic];
					}

					// Now send the message
					if(GetInterface() && apNewTopics.GetSize() > 0) {
						// (a.walling 2007-10-18 14:12) - PLID 25548 - Include the EMN pointer as the LPARAM
						GetInterface()->SendMessage(NXM_EMR_TOPIC_ADD_PREVIEW, (WPARAM)&apNewTopics, (LPARAM)this);
					}

					// Now revert the loader object for each topic back to NULL as it should be after a
					// topic load is done
					for (nTopic=0; nTopic < nNewTopics; nTopic++) {
						CEMRTopic* pTopic = apNewTopics[nTopic];
						pTopic->GetLoadInfo()->m_pLoader = NULL;
					}
				}

				// (c.haag 2008-06-17 10:04) - PLID 17842 - Return the array of newly created topics to the caller
				if (NULL != papNewTopicsOut) { papNewTopicsOut->Copy(apNewTopics); }

			}
			// (c.haag 2007-07-03 12:23) - If something is thrown from here, let the developer know in debug
			// mode. This makes it easier to pin down problems.
			NxCatchAllSilentCallThrow(ASSERT(FALSE));

			if (NULL != pEMNMintLoader) {
				// (c.haag 2007-05-30 09:00) - PLID 26157 - We're done with the CEMNLoader object.
				// In the current implementation, the reference count should always be a value of
				// one here.
				ASSERT(1 == pEMNMintLoader->GetRefCnt());
				pEMNMintLoader->Release();
			}
			// (c.haag 2007-09-10 12:10) - PLID 27024 - Delete the calculation loader if necessary
			if (NULL != pCalcLoader && bDeleteCalcLoader) {
				delete pCalcLoader;
			}

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}//end for loop of all actions
	}
	// (c.haag 2007-07-03 12:16) - If something is thrown from here, let the developer know in debug
	// mode. This makes it easier to pin down problems.
	NxCatchAllSilentCallThrow(ASSERT(FALSE));
}

// (c.haag 2008-06-24 08:48) - PLID 17244 - Spawn todo alarms
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::ProcessEmrAction_eaoTodo(MFCArray<CActionAndSource> *paryActionsToSpawn, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */)
{
	long nActionCount = paryActionsToSpawn->GetSize();
	for(int nActionIdx = 0; nActionIdx < nActionCount; nActionIdx++) {
		EmrAction ea = paryActionsToSpawn->GetAt(nActionIdx).ea;
		CEMNDetail *pSourceDetail = paryActionsToSpawn->GetAt(nActionIdx).sai.pSourceDetail;
		TableRow *ptrSourceTableRow = paryActionsToSpawn->GetAt(nActionIdx).sai.GetTableRow();

		if(!m_bIsTemplate) {
			// (z.manning, 01/30/2007) - PLID 24468 - If we don't have a source detail, let's use the current EMN
			// in places that pull the EMN from the source detail.
			CEMN* pSourceEmn = NULL;
			//DRT 8/22/2007 - PLID 26291 - Safety check for NULL
			if(pSourceDetail && pSourceDetail->m_pParentTopic) {
				pSourceEmn = pSourceDetail->m_pParentTopic->GetParentEMN();
			}
			else {
				pSourceEmn = this;
			}

			//DRT 8/29/2007 - PLID 27225 - We need to lock the action here.  This used to be done in CEMR::ProcessEmrActions, but we
			//	are trying to move away from that paradigm.  This may mean that for now some actions will be locked twice, but the
			//	locking code is setup to handle that, and shouldn't cause any issues at all.
			pSourceEmn->GetParentEMR()->LockAction(ea);

			if(pProgress) pProgress->SetProgress(0,2,1);

			// Call this function to create the todo alarm in data, and to add an EMNTodo object in memory for tracking what todos
			// were created before the EMN was saved.
			SourceActionInfo sai(&ea, pSourceDetail, ptrSourceTableRow);
			AddTodo(ea, sai);
			
			if(pProgress) pProgress->SetProgress(0,2,2);

			//DRT 8/29/2007 - PLID 27225 - Unlock this action before we quit.
			pSourceEmn->GetParentEMR()->UnlockAction(ea);
		}
	}
}

// (c.haag 2007-08-06 10:31) - PLID 26954 - Added an optional parameter for preloaded spawning-related data
//DRT 8/29/2007 - It is recommended that you not use this function any longer.  Instead, calling code should
//	be cognizant of speed of spawning, and match the actions being spawned to the specific functions, passing in
//	an entire array of actions to be spawned.  This function remains for legacy code that has not yet been
//	converted to the new design.
// (c.haag 2008-06-17 10:12) - PLID 17842 - Added an optional parameter to allow the caller to track what was spawned
// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
void CEMN::ProcessEmrAction(const EmrAction& ea, SourceActionInfo &sai, OUT CArray<SkippedTopic,SkippedTopic&> &arSkippedTopics, BOOL bIsInitialLoad, CProgressParameter *pProgress,
							CEMNSpawner* pEMNSpawner /*= NULL */, CProcessEmrActionsResult* pEmrActionsResult /*= NULL*/)
{
	//DRT 8/29/2007 - PLID 27218 - This function now is just a passthrough.  The functions for each individual action
	//	want an array of actions to spawn (for best efficiency).  If anyone calls this old function, then we'll just
	//	generate a 1 element array and pass that in.  This is not recommended to be used.
	CActionAndSource aas;
	aas.ea = ea;
	aas.sai = sai;
	// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
	MFCArray<CActionAndSource> aryActionsToSpawn;
	aryActionsToSpawn.Add(aas);
	CEMNDetail* pNewDetail = NULL;

	switch(ea.eaoDestType) {
		case eaoCpt:
			ProcessEmrAction_eaoCpt(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner);
			break;
		
		// (b.savon 2014-07-14 11:21) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
		//case eaoDiag:
		case eaoDiagnosis:
			ProcessEmrAction_eaoDiagnosis(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner);
			break;

		case eaoMedication: {
				long nNewMedicationID = -1;
				// (j.jones 2013-01-09 09:58) - PLID 45446 - if an actions result is requested, track the new prescription ID				
				ProcessEmrAction_eaoMedication(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner, pEmrActionsResult ? &nNewMedicationID : NULL);
				
				if (pEmrActionsResult != NULL && nNewMedicationID > -1) {
					pEmrActionsResult->m_aryNewPrescriptionIDs.Add(nNewMedicationID);
				}
			}
			break;

		case eaoProcedure:
			ProcessEmrAction_eaoProcedure(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner);
			break;

		case eaoEmrItem: {
			// (c.haag 2008-06-17 10:16) - PLID 17842 - We now track what details were added
			ProcessEmrAction_eaoEmrItem(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner, &pNewDetail);
			if (NULL != pNewDetail && NULL != pEmrActionsResult) { pEmrActionsResult->m_apNewDetails.Add(pNewDetail); }
			}
			break;

		case eaoMintItems: {
			// (c.haag 2008-06-17 10:16) - PLID 17842 - We now track what topics were added
			CArray<CEMRTopic*,CEMRTopic*> apNewTopics;
			ProcessEmrAction_eaoMintItems(&aryActionsToSpawn, arSkippedTopics, bIsInitialLoad, pProgress, pEMNSpawner, &apNewTopics);
			if (NULL != pEmrActionsResult) { pEmrActionsResult->m_apNewTopics.Append(apNewTopics); }
			}
			break;

		case eaoEmrDataItem:
			//not supported
			ASSERT(FALSE);
			break;

		case eaoMint:
			//Should be handled by the EMR.
			ASSERT(FALSE);
			break;

		case eaoAllergy:
			// (j.jones 2004-12-02 13:23) - this should have never been added,
			// (c.haag 2004-11-10 13:49) - PLID 14552 - Spawn allergies for patients
			//if (!m_bIsTemplate) {
			//	m_arydwAllergiesToSpawn.Add(DestID);
			//	m_arydwAllergiesToSpawn_DataItems.Add(nSourceID);
			//}
			break;

		case eaoEmrImageHotSpot:
			//DRT 2/19/2008 - PLID 19062 - HotSpots can only be sources, not destinations.  This should never happen.  If we do 
			//	happen to get some bad data, we'll just ignore it (thus, no ThrowException here).
			ASSERT(FALSE);
			break;

		case eaoTodo: // (c.haag 2008-06-24 10:09) - PLID 17244
			ProcessEmrAction_eaoTodo(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner);
			break;

		case eaoLab: 
			// (z.manning 2008-10-02 08:58) - PLID 21094 - Process lab actions on a patient EMN
			// Make sure labs is licensed and that user has permission to create labs.
			if(!m_bIsTemplate && CheckCurrentUserPermissions(bioPatientLabs, sptCreate, FALSE, 0, TRUE)
				&& g_pLicense != NULL && g_pLicense->CheckForLicense(CLicense::lcLabs, CLicense::cflrSilent))
			{
				ProcessEmrAction_eaoLab(&aryActionsToSpawn, bIsInitialLoad, pProgress, pEMNSpawner);
			}
			break;

		case eaoEmrTableDropDownItem:
			// (z.manning 2009-03-20 12:38) - PLID 15971 - Dropdowns can only be sources, not destinations.
			ASSERT(FALSE);
			break;

		case eaoSmartStamp:
			// (z.manning 2010-03-02 14:53) - PLID 37571 - Smart stamps can only be sources
			ASSERT(FALSE);
			break;

		case eaoWoundCareCodingCondition:
			// (r.gonet 08/03/2012) - PLID 51949 - This type can only be a source as its not an entity but a process
			ASSERT(FALSE);
			break;

		default:
			// Some new unhandled type or an invalid number was cast as an eao enum type
			ASSERT(FALSE);
			break;
	}

	// (c.haag 2008-07-21 14:03) - PLID 30725 - Now that the action has been processed, we know that both
	// the source and destination objects exist. Now we need to proceed with adding EMR problems to said
	// items if they exist. We also pass in pNewDetail so we don't have to hunt for it within the function.
	if (!m_bIsTemplate) {
		ProcessEmrProblemActions(ea, sai, pNewDetail);
	}
}

// (a.walling 2007-10-26 12:26) - PLID 25548 - This now returns a pointer to the topic that was added
CEMRTopic* CEMN::ProcessSkippedTopic(CEMNDetail *pSourceDetail, SkippedTopic st)
{
	//Do we have a parent for this yet?
	CEMN *pEMN = pSourceDetail->m_pParentTopic->GetParentEMN();
	// (a.walling 2010-04-05 13:56) - PLID 38060 - Also use the source action info
	CEMRTopic *pParentTopic = pEMN->GetTopicByTemplateTopicID(st.nParentTemplateTopicID, pSourceDetail->GetSpawnedGroupID(), NULL, &pSourceDetail->GetSpawnedGroupSourceActionInfo());
	// (a.walling 2007-10-26 09:30) - PLID 25548 - This the topic pointer we'll eventually return
	CEMRTopic* pNewTopicToReturn = NULL;

	if(!pParentTopic) {
		//if NULL, try with the source detail
		// (a.walling 2010-04-05 13:56) - PLID 38060 - Also use the source action info
		pParentTopic = pEMN->GetTopicByTemplateTopicID(st.nParentTemplateTopicID, pSourceDetail->GetSpawnedGroupID(), st.sai.pSourceDetail, &pSourceDetail->GetSpawnedGroupSourceActionInfo());
	}
	if(pParentTopic) {
		//We got it!  Put it where it belongs.
		
		//TES 2/9/2006 - Go through the subtopics until you find one from the same template, with 
		//a later OrderIndex, and insert before that one.
		CEMRTopic *pInsertBefore = NULL;
		for(int i = 0; i < pParentTopic->GetSubTopicCount() && !pInsertBefore; i++) {
			if(pParentTopic->GetSubTopic(i)->GetTemplateID() == pEMN->GetTemplateID() &&
				pParentTopic->GetSubTopic(i)->GetTemplateTopicOrderIndex() > st.nOrderIndex) {
					pInsertBefore = pParentTopic->GetSubTopic(i);
				}
			}
			//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
			// then it's possible that an entry already exists, otherwise, create a new one.
			TopicPositionEntry *tpe = NULL;
			if(m_bIsTemplate) {
				tpe = m_pTopicPositionHead->GetEntryByID(st.nTemplateTopicID);
				if(tpe == NULL) {
					tpe = new TopicPositionEntry;
					//TES 5/3/2010 - PLID 24692 - Assign the ID.
					tpe->nTopicID = st.nTemplateTopicID;
				}
			}
			else {
				tpe = new TopicPositionEntry;
			}
			CEMRTopic *pNewTopic = new CEMRTopic(pParentTopic, tpe);
			//TES 10/5/2009 - PLID 35755 - If this is being loaded into a preset position, and we're on a template,
			// we don't want to force its order index to be re-calculated when saving.
			BOOL bArrayChanged = (!m_bIsTemplate || st.nOrderIndex == -1);
			pParentTopic->InsertSubTopic(pNewTopic, pInsertBefore, st.bIsInitialLoad, bArrayChanged);
			//We set bIsNewTopic to FALSE, because we can only get here if it was loaded from EmrTemplateDetailsT while processing an action.
			//DRT 9/25/2007 - PLID 27515 - Added extra SourceAction data
			pNewTopic->LoadFromTemplateTopicID(st.nTemplateTopicID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, st.sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, m_bIsTemplate ? NULL : GetParentEMR(), NULL, st.nSourceActionSourceID, st.nSourceActionSourceDataGroupID, st.nSourceActionSourceHotSpotGroupID, st.nSourceActionSourceTableDropdownGroupID);
			//Add to interface.

			if(GetInterface()) {
				// (a.walling 2007-10-26 09:12) - PLID 25548 - Ignore the preview for now
				GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pNewTopic, (LPARAM)TRUE);
			}

			// (a.walling 2007-10-26 09:31) - PLID 25548 - Return this new topic
			pNewTopicToReturn = pNewTopic;
	}
	else {
		//We haven't found any other way to do it.  So, we will spawn immediately after the source detail's topic.
		//Add to memory object.
		CEMRTopic *pParent = pSourceDetail->m_pParentTopic->GetParentTopic();
		CEMRTopic *pNewTopic = NULL;
		if(pParent) {
			//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
			// then it's possible that an entry already exists, otherwise, create a new one.
			//TES 5/18/2010 - PLID 24692 - Correction: if we get to this point, we KNOW we don't have an entry, otherwise
			// we would have found a spot for this topic.  Plus, nDestTopicID represents a topic on the source template,
			// not on our template.  So, create a new entry every time.
			TopicPositionEntry *tpe = new TopicPositionEntry;
			pNewTopic = new CEMRTopic(pParent, tpe);
			CEMRTopic *pNext = NULL;
			for(int i = 0; i < pParent->GetSubTopicCount()-1 && !pNext; i++) {
				if(pParent->GetSubTopic(i) == pSourceDetail->m_pParentTopic) {
					pNext = pParent->GetSubTopic(i+1);
				}
			}
			//TES 10/5/2009 - PLID 35755 - We're not loading into a pre-set position, so make sure the new position
			// gets saved.
			pParent->InsertSubTopic(pNewTopic, pNext, st.bIsInitialLoad, TRUE);
			//We set bIsNewTopic to FALSE, because we can only get here if it was loaded from EmrTemplateDetailsT while processing an action.
			//DRT 9/25/2007 - PLID 27515 - Added extra SourceAction data
			pNewTopic->LoadFromTemplateTopicID(st.nTemplateTopicID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, st.sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, m_bIsTemplate ? NULL : GetParentEMR(), NULL, st.nSourceActionSourceID, st.nSourceActionSourceDataGroupID, st.nSourceActionSourceHotSpotGroupID, st.nSourceActionSourceTableDropdownGroupID);
			
			// (a.walling 2007-10-26 09:31) - PLID 25548 - Return this new topic
			pNewTopicToReturn = pNewTopic;
		}
		else {
			//TES 4/15/2010 - PLID 24692 - We need a position to assign to the topic.  If we're on a template, 
			// then it's possible that an entry already exists, otherwise, create a new one.
			//TES 5/18/2010 - PLID 24692 - Correction: if we get to this point, we KNOW we don't have an entry, otherwise
			// we would have found a spot for this topic.  Plus, nDestTopicID represents a topic on the source template,
			// not on our template.  So, create a new entry every time.
			TopicPositionEntry *tpe = new TopicPositionEntry;
			pNewTopic = new CEMRTopic(pEMN, tpe);
			CEMRTopic *pNext = NULL;
			for(int i = 0; i < pEMN->GetTopicCount()-1 && !pNext; i++) {
				if(pEMN->GetTopic(i) == pSourceDetail->m_pParentTopic) {
					pNext = pEMN->GetTopic(i+1);
				}
			}
			//TES 10/5/2009 - PLID 35755 - We're not loading into a pre-set position, so make sure the new position
			// gets saved.
			pEMN->InsertTopic(pNewTopic, pNext, st.bIsInitialLoad, TRUE);
			//We set bIsNewTopic to FALSE, because we can only get here if it was loaded from EmrTemplateDetailsT while processing an action.
			//DRT 9/25/2007 - PLID 27515 - Added extra SourceAction data
			pNewTopic->LoadFromTemplateTopicID(st.nTemplateTopicID, FALSE, GetInterface()?GetInterface()->GetSafeHwnd():NULL, st.sai, FALSE, m_bIsTemplate ? -1 : GetParentEMR()->GetPatientID(), NULL, m_bIsTemplate ? NULL : GetParentEMR(), NULL, st.nSourceActionSourceID, st.nSourceActionSourceDataGroupID, st.nSourceActionSourceHotSpotGroupID, st.nSourceActionSourceTableDropdownGroupID);

			// (a.walling 2007-10-26 09:31) - PLID 25548 - Return this new topic
			pNewTopicToReturn = pNewTopic;
		}

		if (!st.bIsInitialLoad) {
			// (j.jones 2007-10-04 09:26) - PLID 27610 - If we get here, it will be because we no longer have the parent topic
			// that we were looking for, and are now spawning elsewhere. So mark the topic as unsaved to reflect this change.
			pNewTopic->SetUnsaved(TRUE);
		}
		//Add to interface.
		if(GetInterface()) {
			// (a.walling 2007-10-26 09:12) - PLID 25548 - Ignore the preview for now
			GetInterface()->SendMessage(NXM_EMR_TOPIC_ADDED, (WPARAM)pNewTopic, (LPARAM)TRUE);
		}
	}

	// (a.walling 2007-10-26 09:31) - PLID 25548 - Finally, return the new topic we have added
	return pNewTopicToReturn;
}

// (c.haag 2008-07-21 12:06) - PLID 30725 - This function will spawn all problems for the given action onto
// one or more EMR objects
// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
void CEMN::ProcessEmrProblemActions(const EmrAction& ea, SourceActionInfo &sai, CEMNDetail* pNewDetail)
{
	// (a.walling 2014-07-01 15:28) - PLID 62697
	for (const auto& epa : ea.aProblemActions) {
		ProcessEmrProblemAction(ea, epa, sai, pNewDetail);
	}
}

// (c.haag 2008-07-21 12:06) - PLID 30725 - This function will spawn a single problem onto an EMR object
// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
void CEMN::ProcessEmrProblemAction(const EmrAction& ea, const EmrProblemAction& epa, SourceActionInfo &sai, CEMNDetail* pNewDetail)
{
	// (z.manning 2016-04-11 14:02) - NX-100140 - Make sure we want to spawn this problem
	if (!ShouldSpawnEmrProblemForPatient(GetParentEMR()->GetPatientID(), epa.nID, GetParentEMR()->GetDeletedEmrProblemIDs())) {
		return;
	}

	EMRProblemRegardingTypes eprtType = eprtInvalid;
	EmrActionObject eaoType = (epa.bSpawnToSourceItem) ? ea.eaoSourceType : ea.eaoDestType;

	// The problem action tells us what we're spawning to. Now given the type of object, fetch the object
	// and add to it.
	switch (eaoType) {
	case eaoCpt: // The problem will be bound to the EMN; specifically, to a charge.
		ProcessEmrProblemAction_eaoCpt(ea, epa, sai);
		break;
	// (b.savon 2014-07-14 12:44) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
	//case eaoDiag: // The problem will be bound to the EMN; specifically, to a diagnosis code
	case eaoDiagnosis:
		ProcessEmrProblemAction_eaoDiagnosis(ea, epa, sai);
		break;
	case eaoMedication: // The problem will be bound to the EMN; specifically, to a medication
		ProcessEmrProblemAction_eaoMedication(ea, epa, sai);
		break;
	case eaoEmrItem: // The problem will be bound to a detail
		ProcessEmrProblemAction_eaoEmrItem(epa, (epa.bSpawnToSourceItem) ? sai.pSourceDetail : pNewDetail);
		break;
	case eaoEmrDataItem: // The problem will be bound to a detail; specifically, to a list selection
		ProcessEmrProblemAction_eaoEmrDataItem(ea, epa, sai.pSourceDetail);
		break;
	case eaoMintItems: // (z.manning 2011-11-14 14:50) - PLID 46231
		ProcessEmrProblemAction_eaoMintItems(ea, epa, sai);
		break;
	case eaoMint: // The problem will be bound to a spawned EMN. Should be handled by the EMR.
		ASSERT(FALSE);
		break;
	default: // We don't support any other kind of object
		ASSERT(FALSE);
		break;
	}
}

// (c.haag 2008-07-21 12:18) - PLID 30725 - This function will associate a spawned service item with a problem.
// This function expects that the service code is brand new and just spawned prior to this function call.
// (z.manning 2009-02-23 12:54) - PLID 33141 - Replaced source detail pointer with source action info class
void CEMN::ProcessEmrProblemAction_eaoCpt(const EmrAction& ea, const EmrProblemAction& epa, SourceActionInfo &sai)
{
	// (c.haag 2009-05-29 09:27) - PLID 34293 - Updated code with new problem structure
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn a CPT problem without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-02-23 15:44) - PLID 64723 
	// (r.gonet 2015-03-09 18:21) - PLID 65008 - Pass DoNotShowOnProblemPrompt.
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID, epa.bDoNotShowOnCCDA, 
		epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrCharge, -1, -1);
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references

	// Find the charge. The service ID, source action ID and source detail object should altogether
	// be useable as a primary key.
	const int nCharges = GetChargeCount();
	for (int i=0; i < nCharges && NULL == pNewLink->GetCharge(); i++) {
		EMNCharge* pCharge = GetCharge(i);
		if (pCharge->nServiceID == ea.nDestID &&
			pCharge->sai.nSourceActionID == ea.nID &&
			pCharge->sai.HasSameSource(sai))
		{
			// Add the problem to the charge
			pCharge->m_apEmrProblemLinks.Add(pNewLink);
			pNewLink->UpdatePointersWithCharge(this, pCharge);

			// (j.jones 2008-07-24 08:35) - PLID 30729 - change the EMR problem icon based on whether we have problems
			if (GetInterface()) {
				GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
				GetInterface()->PostMessage(NXM_EMN_REFRESH_CHARGES, (WPARAM)this);
				if (!IsLockedAndSaved()) {
					// (a.walling 2012-03-22 16:50) - PLID 49141 - Notify the interface
					NotifyMoreInfoChanged();
				}
			}

			// (c.haag 2009-06-04 16:00) - PLID 34293 - Flag the EMR as modified
			if (NULL != GetParentEMR()) {
				GetParentEMR()->SetUnsaved();
			}
		}
	}

	if (NULL == pNewLink->GetCharge()) {
		// If, somehow, we never found the charge, this was all for nothing!
		ASSERT(FALSE);
		delete pNewLink; // (c.haag 2009-05-29 09:37) - PLID 34293 - This leaves the EMR with the only reference to the problem,
						// and it will be deleted in the CEMR destructor
		ThrowNxException("Could not find the charge to create a problem for! (ServiceID = %d, SAID = %d, SourceDetail = %08x)",
			ea.nDestID, ea.nID, sai.pSourceDetail);
	}
}

// (c.haag 2008-07-21 12:33) - PLID 30725 - This function will associate a spawned diagnosis code with a problem.
// This function expects that the diagnosis code is brand new and just spawned prior to this function call.
// (b.savon 2014-07-23 14:44) - PLID 63013 - Rename
void CEMN::ProcessEmrProblemAction_eaoDiagnosis(const EmrAction& ea, const EmrProblemAction& epa, SourceActionInfo &sai)
{
	// (c.haag 2009-05-29 09:27) - PLID 34293 - Updated code with new problem structure
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn a Diagnosis Code without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-02-23 15:44) - PLID 64723 
	// (r.gonet 2015-03-09 18:21) - PLID 65008 - Pass DoNotShowOnProblemPrompt.
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID, epa.bDoNotShowOnCCDA,
		epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrDiag, -1, -1);
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references

	// Find the diagnosis code. Check only on the diagnosis code ID. Note how we did not check the source action ID
	// or source detail. This is on purpose because an EMN cannot have duplicate diagnosis codes (whereas we can have
	// duplicate charges and medications). In this implementation, if a code already exists, it's best to err on
	// the side of caution, and add the problem to that code.
	// (c.haag 2008-08-14 14:06) - PLID 30725 - Ignore the comment above. We have to check on the action source data
	// too; otherwise we won't be able to unspawn the problem. PLID 31074 was created to make it possible to unspawn
	// problems even if they're bound to EMR objects from unrelated actions.
	const int nCodes = GetDiagCodeCount();
	for (int i=0; i < nCodes && NULL == pNewLink->GetDiagCode(); i++) {
		EMNDiagCode* pDiagCode = GetDiagCode(i);

		// (b.savon 2014-07-23 14:44) - PLID 63013 - Handle diagnosis tuples; Based on search mode, set the comparables.
		long nDiagCodeID_ICD9 = -1;
		long nDiagCodeID_ICD10 = -1;
		switch (DiagSearchUtils::GetPreferenceSearchStyle()){
			case eManagedICD9_Search:
			{
				nDiagCodeID_ICD9 = ea.diaDiagnosis.nDiagCodeID_ICD9;
				if (ea.diaDiagnosis.nDiagCodeID_ICD9 == -1){
					nDiagCodeID_ICD10 = ea.diaDiagnosis.nDiagCodeID_ICD10;
				}
				else{
					nDiagCodeID_ICD10 = -1;
				}
			}
				break;
			case eICD9_10_Crosswalk:
			{
				nDiagCodeID_ICD9 = ea.diaDiagnosis.nDiagCodeID_ICD9;
				nDiagCodeID_ICD10 = ea.diaDiagnosis.nDiagCodeID_ICD10;
			}
				break;
			case eManagedICD10_Search:
			{
				if (ea.diaDiagnosis.nDiagCodeID_ICD10 == -1){
					nDiagCodeID_ICD9 = ea.diaDiagnosis.nDiagCodeID_ICD9;
				}
				else{
					nDiagCodeID_ICD9 = -1;
				}
				nDiagCodeID_ICD10 = ea.diaDiagnosis.nDiagCodeID_ICD10;
			}
				break;
		}

		// (b.savon 2014-08-07 15:41) - PLID 63013 - Don't be so restrictive; modes matter!
		if (pDiagCode->sai.nSourceActionID == ea.nID &&
			pDiagCode->sai.HasSameSource(sai))
		{
			// (r.farnworth 2014-08-27 16:00) - PLID 63425 - Set the matched codes to link to the problem without prompt
			DiagCodeSearchStyle dcss = DiagSearchUtils::GetPreferenceSearchStyle();
			BOOL bShowICD9 = (dcss == eICD9_10_Crosswalk || dcss == eManagedICD9_Search);
			BOOL bShowICD10 = (dcss == eICD9_10_Crosswalk || dcss == eManagedICD10_Search);

			CEmrProblem *cProblem = pNewLink->GetProblem();
			cProblem->m_nDiagICD9CodeID = (bShowICD9) ? pDiagCode->nDiagCodeID : -1;
			cProblem->m_nDiagICD10CodeID = (bShowICD10) ? pDiagCode->nDiagCodeID_ICD10 : -1;
			cProblem->m_bIsModified = TRUE;

			// Add the problem to the diagnosis code.
			pDiagCode->m_apEmrProblemLinks.Add(pNewLink);
			pNewLink->UpdatePointersWithDiagCode(this, pDiagCode);

			// (j.jones 2008-07-24 08:35) - PLID 30729 - change the EMR problem icon based on whether we have problems
			if (GetInterface()) {
				GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
				GetInterface()->PostMessage(NXM_EMN_REFRESH_DIAG_CODES, (WPARAM)this);
				if (!IsLockedAndSaved()) {
					// (a.walling 2012-03-22 16:50) - PLID 49141 - Notify the interface
					NotifyMoreInfoChanged();
				}
			}

			// (c.haag 2009-06-04 16:00) - PLID 34293 - Flag the EMR as modified
			if (NULL != GetParentEMR()) {
				GetParentEMR()->SetUnsaved();
			}
		}
	}
}

// (c.haag 2008-07-22 09:47) - PLID 30725 - This function will associate a spawned medication with a problem.
// This function expects that the medication is brand new and just spawned prior to this function call.
// (z.manning 2009-02-26 17:13) - PLID 33141 - Use the new source action info class
void CEMN::ProcessEmrProblemAction_eaoMedication(const EmrAction& ea, const EmrProblemAction& epa, SourceActionInfo &sai)
{
	// (c.haag 2009-05-29 09:27) - PLID 34293 - Updated code with new problem structure
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn a Medication without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-02-23 15:44) - PLID 64723 
	// (r.gonet 2015-03-09 18:21) - PLID 65008 - Pass DoNotShowOnProblemPrompt.
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID,epa.bDoNotShowOnCCDA,
		epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrMedication, -1, -1);
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references

	// Find the medication, the ID, source action ID, and source detail object should altogether
	// be useable as a primary key
	const int nCodes = GetMedicationCount();
	for (int i=0; i < nCodes && NULL == pNewLink->GetMedication(); i++) {
		EMNMedication* pMed = GetMedicationPtr(i);
		if (pMed->nMedicationID == ea.nDestID &&
			pMed->sai.nSourceActionID == ea.nID &&
			pMed->sai.HasSameSource(sai))
		{
			// Add the problem to the medication
			pMed->m_apEmrProblemLinks.Add(pNewLink);
			pNewLink->UpdatePointersWithMedication(this, pMed);

			// (j.jones 2008-07-24 08:35) - PLID 30729 - change the EMR problem icon based on whether we have problems
			if (GetInterface()) {
				GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
				GetInterface()->PostMessage(NXM_EMN_REFRESH_PRESCRIPTIONS, (WPARAM)this);
				if (!IsLockedAndSaved()) {
					// (a.walling 2012-03-22 16:50) - PLID 49141 - Notify the interface
					NotifyMoreInfoChanged();
				}
			}

			// (c.haag 2009-06-04 16:00) - PLID 34293 - Flag the EMR as modified
			if (NULL != GetParentEMR()) {
				GetParentEMR()->SetUnsaved();
			}
		}
	}

	if (NULL == pNewLink->GetMedication()) {
		// If, somehow, we never found the medication, this was all for nothing!
		ASSERT(FALSE);
		delete pNewLink; // (c.haag 2009-05-29 09:37) - PLID 34293 - This leaves the EMR with the only reference to the problem,
						// and it will be deleted in the CEMR destructor
		ThrowNxException("Could not find the medication to create a problem for! (MedicationID = %d, SAID = %d, SourceDetail = %08x)",
			ea.nDestID, ea.nID, sai.pSourceDetail);
	}
}

// (c.haag 2008-07-21 12:33) - PLID 30725 - This function will associate an EMR item with a problem. Items
// themselves cannot spawn items; so we have to expect that pDestDetail was just spawned
void CEMN::ProcessEmrProblemAction_eaoEmrItem(const EmrProblemAction& epa, CEMNDetail* pDestDetail)
{
	// (c.haag 2009-05-29 09:27) - PLID 34293 - Updated code with new problem structure
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn an EMR item without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-02-23 15:44) - PLID 64723 
	// (r.gonet 2015-03-09 18:21) - PLID 65008 - Pass DoNotShowOnProblemPrompt.
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID, epa.bDoNotShowOnCCDA,
		epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrItem, -1, -1);
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references
	pNewLink->UpdatePointersWithDetail(pDestDetail);

	// Add this problem to the detail
	pDestDetail->m_apEmrProblemLinks.Add(pNewLink);

	// Now update the icon button on the detail
	if (NULL != pDestDetail->m_pEmrItemAdvDlg) {
		pDestDetail->m_pEmrItemAdvDlg->UpdateProblemStatusButtonAppearance(TRUE);
	}

	// (c.haag 2009-06-04 16:00) - PLID 34293 - Flag the EMR as modified
	if (NULL != GetParentEMR()) {
		GetParentEMR()->SetUnsaved();
	}

	// (j.jones 2008-07-24 08:35) - PLID 30729 - change the EMR problem icon based on whether we have problems
	if (GetInterface()) {
		GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
	}
}

// (c.haag 2008-07-21 13:51) - PLID 30725 - This function will associate an EMR data selection with a problem.
// Selections themselves cannot be spawned, so the selection must be in the source detail
void CEMN::ProcessEmrProblemAction_eaoEmrDataItem(const EmrAction& ea, const EmrProblemAction& epa, CEMNDetail* pSourceDetail)
{
	// (c.haag 2009-05-29 09:27) - PLID 34293 - Updated code with new problem structure
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn a CPT problem without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-02-23 15:44) - PLID 64723 
	// (r.gonet 2015-03-09 18:21) - PLID 65008 - Pass DoNotShowOnProblemPrompt.
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID, epa.bDoNotShowOnCCDA,
		epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrDataItem, ea.nSourceID, ea.nSourceID);
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references
	pNewLink->UpdatePointersWithDetail(pSourceDetail);

	// Add this problem to the detail
	pSourceDetail->m_apEmrProblemLinks.Add(pNewLink);

	// Now update the icon button on the detail
	if (NULL != pSourceDetail->m_pEmrItemAdvDlg) {
		pSourceDetail->m_pEmrItemAdvDlg->UpdateProblemStatusButtonAppearance(TRUE);
	}

	// (c.haag 2009-06-04 16:00) - PLID 34293 - Flag the EMR as modified
	if (NULL != GetParentEMR()) {
		GetParentEMR()->SetUnsaved();
	}

	// (j.jones 2008-07-24 08:35) - PLID 30729 - change the EMR problem icon based on whether we have problems
	if (GetInterface()) {
		GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
	}
}

// (z.manning 2011-11-14 14:56) - PLID 46231 - Added function for topic problem actions
void CEMN::ProcessEmrProblemAction_eaoMintItems(const EmrAction& ea, const EmrProblemAction& epa, SourceActionInfo &sai)
{
	if (NULL == GetParentEMR()) {
		ThrowNxException("Tried to spawn a Topic problem without a parent EMR");
	}
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs, but they are -1 here
	// (c.haag 2014-07-23) - PLID 62788 - Assign the SNOMED code to the problem. It will be -1 if there is none.
	// (r.farnworth 2014-08-19 14:49) - PLID 62787 - Assign the Diagnosis code to the problem.
	// (s.tullis 2015-03-11 10:15) - PLID 64723 - pass DoNotshowonCCDA
	// (r.gonet 2015-03-09 20:13) - PLID 65008 - Pass DoNotShowOnProblemPrompt
	CEmrProblem* pNewProblem = GetParentEMR()->AllocateEmrProblem(-1, GetParentEMR()->GetPatientID(),
		epa.strDescription, COleDateTime::GetCurrentTime(), COleDateTime::GetCurrentTime(), dtInvalid,
		epa.nStatus, epa.nDiagICD9CodeID, epa.nDiagICD10CodeID, -1, FALSE, epa.nSNOMEDCodeID, epa.bDoNotShowOnCCDA, epa.bDoNotShowOnProblemPrompt);
	pNewProblem->m_nEmrProblemActionID = epa.nID;
	pNewProblem->Release(); // Release this function's reference to the problem. The EMR and link will retain references

	CArray<CEMRTopic*,CEMRTopic*> arypTopics;
	GetAllTopics(arypTopics);
	for(int nTopicIndex = 0; nTopicIndex < arypTopics.GetCount(); nTopicIndex++)
	{
		CEMRTopic *pTopic = arypTopics.GetAt(nTopicIndex);
		if (pTopic->GetSourceActionInfo().nSourceActionID == ea.nID &&
			pTopic->GetSourceActionInfo().HasSameSource(sai)
			)
		{
			// Add the problem to the topic
			CEmrProblemLink* pNewLink = new CEmrProblemLink(pNewProblem, -1, eprtEmrTopic, -1, -1);
			pTopic->m_apEmrProblemLinks.Add(pNewLink);
			pNewLink->UpdatePointersWithTopic(pTopic);
		}
	}

	if (NULL != GetParentEMR()) {
		GetParentEMR()->SetUnsaved();
	}

	if (GetInterface()) {
		GetInterface()->PostMessage(NXM_EMR_PROBLEM_CHANGED);
	}
}

// (c.haag 2008-08-01 14:52) - PLID 30897 - This function gathers a list of all charge objects that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the charge object pointer and action-pertinent 
// information in adeoDoomedObjects. That array will later be used in the actual removing of those charges.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoCpt(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects,
		CEmrCodingGroupArray &aryCodingGroupsToChange, CMap<CEmrCodingGroup*, CEmrCodingGroup*, long, long> &mapCodingGroupQuantitiesToSubtract)
{
	//
	// This function is based off the legacy Revoke Emr Action code for charges, and has signficiant differences:
	// 1. Rather than removing charges, the charge objects are added to an array.
	// 2. This is a read-only operation...meaning this should not affect the actual EMN object or any charges.
	// If it wasn't for GetParentEMR(), we would use const after the function name.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//

	CEmrCodingGroupArray *pMasterCodingGroupArray = GetMainFrame()->GetEmrCodingGroupManager();

	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) { // Do for all actions
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;

		//Confirm that every action is indeed a CPT action
		if(ea.eaoDestType != eaoCpt) {
			AfxThrowNxException("Invalid operation when attempting to gather service codes for action revoking");
		}

		// (j.jones 2011-07-11 10:58) - PLID 38366 - if this CPT is in a coding group,
		// add up the amount we need to subtract from the coding group (ie. if we are revoking
		// 3 CPTs that all exist in one coding group, the quantity to subtract will be 3, non-negative)		
		for(int j=0; j<pMasterCodingGroupArray->GetCount(); j++) {
			CEmrCodingGroup *pCodingGroup = pMasterCodingGroupArray->GetAt(j);

			if(!pCodingGroup->HasCptCodeID(ea.nDestID)) {
				//this group does not apply to this code
				continue;
			}

			BOOL bFound = FALSE;
			CEmnCodingGroupInfo *pEMNGroupToUse = NULL;
			for(int k=0; k<aryCodingGroupsToChange.GetSize() && !bFound; k++) {
				CEmrCodingGroup *pCodingGroupToCheck = (CEmrCodingGroup*)aryCodingGroupsToChange.GetAt(k);
				if(pCodingGroupToCheck == pCodingGroup) {
					//found our group
					bFound = TRUE;
				}
			}

			if(!bFound) {
				aryCodingGroupsToChange.Add(pCodingGroup);
			}

			//update our map
			long nQuantityToSubtract = 0;
			mapCodingGroupQuantitiesToSubtract.Lookup(pCodingGroup, nQuantityToSubtract);
			nQuantityToSubtract++;
			mapCodingGroupQuantitiesToSubtract.SetAt(pCodingGroup, nQuantityToSubtract);		
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, aas.sai.pSourceDetail);

		if (!m_bIsTemplate) {
			for(int j = m_aryCharges.GetSize()-1; j >= 0; j--) { // Do for all EMN charges
				EMNCharge *pCharge = m_aryCharges[j];
				// (z.manning 2009-02-24 10:17) - PLID 33138 - Moved the logic for matching source action
				// to dest object to a utuility function
				if(IsSourceActionInfoOk(aas.sai, pCharge->sai, ea, pCharge->nServiceID)) {
					// Jackpot. Add the action-and-source and the charge to our doomed array.
					CDoomedEmrObject deo;
					deo.m_aas = aas;
					deo.SetCharge(pCharge);
					adeoDoomedObjects.Add(deo);
				}
			} // for(int j = m_aryCharges.GetSize()-1; j >= 0; j--) {

		} // if (!m_bIsTemplate) {
	} // for(int i = 0; i < nActionCnt; i++) {
}

// (c.haag 2008-08-01 15:09) - PLID 30897 - This function gathers a list of all diagnosis codes that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the diagnosis object pointer and action-pertinent 
// information in adeoDoomedObjects. That array will later be used in the actual removing of those diagnosis codes.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoDiag(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for diagnosis codes, and has signficiant differences:
	// 1. Rather than removing diagnosis code objects, those objects are added to an array.
	// 2. This is a read-only operation...meaning this should not affect the actual EMN object or any diagnosis codes.
	// If it wasn't for GetParentEMR(), we would use const after the function name.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//
	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) { // Do for all actions
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed a Diag action
		// (b.savon 2014-07-14 13:11) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
		if(ea.eaoDestType != eaoDiagnosis/*eaoDiag*/) {
			AfxThrowNxException("Invalid operation when attempting to gather diagnosis codes for action revoking");
		}
		
		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);

		if (!m_bIsTemplate) {
			for(int j = m_aryDiagCodes.GetSize()-1; j >= 0; j--) { // Do for all codes
				EMNDiagCode *pDiag = m_aryDiagCodes[j];

				// (z.manning 2009-02-26 14:07) - PLID 
				// (b.savon 2014-07-23 11:53) - PLID 62996 - Call the essentials; don't check destType
				if (IsSourceActionInfoOK_Essentials(aas.sai, pDiag->sai, ea)) {
					// Jackpot. Add the action-and-source and the code to our doomed array.
					CDoomedEmrObject deo;
					deo.m_aas = aas;
					deo.SetDiagCode(pDiag);
					adeoDoomedObjects.Add(deo);
				}
			} // for(int j = m_aryDiagCodes.GetSize()-1; j >= 0; j--) {
		} // if (!m_bIsTemplate) {
	} // for(int i = 0; i < nActionCnt; i++) {
}

// (c.haag 2008-08-01 15:15) - PLID 30897 - This function gathers a list of all medication objects that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the medication object pointer and action-pertinent 
// information in adeoDoomedObjects. That array will later be used in the actual removing of those medications.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoMedication(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for medications, and has signficiant differences:
	// 1. Rather than removing medications, the medication objects are added to an array.
	// 2. This is a read-only operation...meaning this should not affect the actual EMN object or any medications.
	// If it wasn't for GetParentEMR(), we would use const after the function name.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//
	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) {
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed a medication action
		if(ea.eaoDestType != eaoMedication) {
			AfxThrowNxException("Invalid operation when attempting to gather medications for action revoking");
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);

		if (!m_bIsTemplate) {
			for(int j = m_aryMedications.GetSize()-1; j >= 0; j--) { // Do for all medications
				EMNMedication* pMed = m_aryMedications[j];

				// (j.jones 2012-11-15 10:23) - PLID 53259 - if the medication was sent via Erx,
				// it cannot be unspawned, so do not add it to the doomed list
				if(IsERxStatus(pMed->eQueueStatus)) {
					continue;
				}

				// Do a source detail equivalency test
				// (z.manning 2009-02-26 17:18) - PLID 33141 - Moved this logic to a utility function
				if(IsSourceActionInfoOk(aas.sai, pMed->sai, ea, pMed->nMedicationID)) {
					// Jackpot. Add the action-and-source and the code to our doomed array.
					CDoomedEmrObject deo;
					deo.m_aas = aas;
					deo.SetMedication(pMed);
					adeoDoomedObjects.Add(deo);
				}
			} // for(int j = m_aryMedications.GetSize()-1; j >= 0; j--) {
		} // if (!m_bIsTemplate) {
	} // for(int i = 0; i < nActionCnt; i++) {
}

// (c.haag 2008-08-01 15:20) - PLID 30897 - This function gathers a list of all procedure objects that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the procedure object pointer and action-pertinent 
// information in adeoDoomedObjects. That array will later be used in the actual removing of those medications.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoProcedure(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for procedures, and has signficiant differences:
	// 1. Rather than removing procedures, the procedure objects are added to an array.
	// 2. This is a read-only operation...meaning this should not affect the actual EMN object or any procedures.
	// If it wasn't for GetParentEMR(), we would use const after the function name.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//
	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) { // Do for all actions
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed a procedure action
		if(ea.eaoDestType != eaoProcedure) {
			AfxThrowNxException("Invalid operation when attempting to gather procedures for action revoking");
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);

		if (!m_bIsTemplate) {
			for(int j = m_aryProcedures.GetSize()-1; j >= 0; j--) { // Do for all procedures
				EMNProcedure* pProc = m_aryProcedures[j];

				// Do a source detail equivalency test
				// (z.manning 2009-02-27 10:52) - PLID 33141 - We now have a utility function for this logic
				if(IsSourceActionInfoOk(aas.sai, pProc->sai, ea, pProc->nID)) {
					// Jackpot. Add the action-and-source and the code to our doomed array.
					CDoomedEmrObject deo;
					deo.m_aas = aas;
					deo.SetProcedure(pProc);
					adeoDoomedObjects.Add(deo);					
				}
			} // for(int j = m_aryProcedures.GetSize()-1; j >= 0; j--) { // Do for all procedures
		} // if (!m_bIsTemplate) {
	} // for(int i = 0; i < nActionCnt; i++) { // Do for all actions
}

// (z.manning 2008-10-09 09:41) - PLID 31628 - Unspawning labs
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoLab(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for labs, and has signficiant differences:
	// 1. Rather than removing labs, the lab objects are added to an array.
	// 2. This is a read-only operation...meaning this should not affect the actual EMN object or any labs.
	// If it wasn't for GetParentEMR(), we would use const after the function name.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//
	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int nActionIndex = 0; nActionIndex < nActionCnt; nActionIndex++) // Do for all actions
	{
		CActionAndSource aas = paryActionsToRevoke->GetAt(nActionIndex);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed a lab action
		if(ea.eaoDestType != eaoLab) {
			AfxThrowNxException("Invalid operation when attempting to gather labs for action revoking");
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR()) {
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);
		}

		if(!m_bIsTemplate)
		{
			for(int nLabIndex = m_aryLabs.GetSize() - 1; nLabIndex >= 0; nLabIndex--) // Do for all labs
			{
				EMNLab* pLab = m_aryLabs.GetAt(nLabIndex);

				if(IsSourceActionInfoOk(aas.sai, pLab->sai, ea, pLab->nLabProcedureID)) {
					// Jackpot. Add the action-and-source and the code to our doomed array.
					CDoomedEmrObject deo;
					deo.m_aas = aas;
					deo.SetLab(pLab);
					adeoDoomedObjects.Add(deo);					
				}
			} // for(int j = m_aryLabs.GetSize()-1; j >= 0; j--) { // Do for all labs
		} // if (!m_bIsTemplate) {
		else {
			// (z.manning 2008-10-09 09:49) - PLID 31628 - It shouldn't be possible to ever have a spawned lab
			// on a template.
			ASSERT(m_aryLabs.GetSize() == 0);
		}
	} // for(int i = 0; i < nActionCnt; i++) { // Do for all actions
}

// (c.haag 2008-08-01 15:25) - PLID 30897 - This function gathers a list of all EMR items that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the EMN detail pointer and action-pertintent
// information in adeoDoomedObjects. That array will later be used in the actual removing of those EMR items.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoEmrItem(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for EMR items, and has signficiant differences:
	// 1. Rather than removing details, the details are added to an array.
	// 2. This is a read-only operation. Nothing in the EMN itself should be changed unless maybe it's in the middle
	// of an asynchronous load, and that load needs to finish when GetTotalDetailCount is called. Otherwise, there would
	// be a const in the declaration protecting it at the compiler level.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//

	//DRT 8/8/2007 - PLID 27010 - For Phase B of the 27003 changes, I split this function out to its own item.  The previous behavior
	//	is odd and we think has several excessive pieces that can be eliminated.  Here is what really needs to happen, for each
	//	action that is being revoked:
	//1)  Due to the fact that we can have "historic" actions (from the auto copy code), we need to search back (recordset) and find all EMRActionsT.ID values which
	//	are "equivalent" to our current action.
	//2)  We then search through every detail in the current EMN, looking for one that has an equivalent source action, has a matching source detail, and 
	//	comes from the right info master ID.
	//3)  Once that detail is found, we remove it (or hide it, on templates if the parent is still there).  Because an EmrAction can only possibly spawn
	//	1 detail, we are now done.
	//
	//The "equivalent" check requires a database access.  Long ago this was done once per detail, per action (slow!).  Then it was changed to 
	//	make a map, so 1 recordset per action revoked.  Good, but in the case of large revokes (deleting a topic with a lot of things spawned, for example), 
	//	this is still very slow.  At this point we have all the eaoEmrItem revokes to do at once, so we want to generate a new map which is done
	//	before the actual revoking takes place.


	//We will fill in a map of maps, because we need to keep a list of equivalent source actions for each possible action.  However, 
	//	because of the "we're already on the latest action" case below (see the 'strTest' variable and surrounding comment), any
	//	
	//Local typedef, only used in this function
	typedef CMap<long, long, BOOL, BOOL> CMapLongToBool;
	//This map is from EmrAction.nID -> a map of equivalent actions
	CMap<long, long, CMapLongToBool*, CMapLongToBool*> mapEquiv;
	long nIdealSourceActionIDToUse = -1; // (c.haag 2008-02-14 10:24) - PLID 28568 - Used exactly like it is in ProcessEmrAction_eaoEmrItem

	{
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		CSqlFragment sqlAllSql;
		long nActionCnt = paryActionsToRevoke->GetSize();
		for(int i = 0; i < nActionCnt; i++) {
			CActionAndSource aas = paryActionsToRevoke->GetAt(i);
			EmrAction ea = aas.ea;

			//Confirm that every action is indeed an item action
			if(ea.eaoDestType != eaoEmrItem) {
				AfxThrowNxException("Invalid operation when attempting to gather EMR items for action revoking");
			}

			// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
			// from locked actions, confusing as that is)
			if(GetParentEMR())
				GetParentEMR()->DeletePendingEMRActions(ea, aas.sai.pSourceDetail);

			//Loop over all the details in the entire EMN, searching for any detail which has an info master ID which
			//	matches our action's destination ID.  This will find all details which *could* have been spawned by
			//	our current action.  Populate a comma separated list of IDs.
			CString strIDList;
			bool bFoundCurrentAction = false;;
			long nTotalDetailCount = GetTotalDetailCount();
			long nQualifyingDetails = 0; // (c.haag 2008-02-14 13:00) - PLID 28568 - Counts the number of qualifying details
			for (long nDetailIdx = 0; nDetailIdx < nTotalDetailCount; nDetailIdx++) {
				CEMNDetail *pDetail = GetDetail(nDetailIdx);
				long nSourceActionID = pDetail->GetSourceActionID();
				// (j.jones 2007-08-01 09:49) - PLID 26900 - we can only unspawn a detail
				// where the master ID is our destination ID, and unspawning is allowed,
				// so we can reduce our filter query that way
				if (nSourceActionID > 0 && pDetail->m_nEMRInfoMasterID == ea.nDestID
					&& pDetail->GetAllowUnspawn()) {
					//If we reached this point, then the current detail we're looking at was created from
					//	the same info master ID as whatever our current action is supposed to revoke.  It's
					//	likely this is the thing we should revoke, but it's possible that multiple actions could
					//	spawn the same detail.
					CString str;
					str.Format("%d,", nSourceActionID);
					strIDList += str;

					//See comments below on 8/9/2007 for details
					//DRT 10/16/2007 - PLID 27010 - Changed the rules very slightly to include detail comparison.  Added notes below
					//	for consistency.
					bool bSourceDetailMatches = false;
					if(pDetail->GetSourceDetail() == aas.sai.pSourceDetail || pDetail->GetSourceDetailID() == (IsTemplate() ? aas.sai.pSourceDetail->m_nEMRTemplateDetailID : aas.sai.pSourceDetail->m_nEMRDetailID))
						bSourceDetailMatches = true;
					if(nSourceActionID == ea.nID && bSourceDetailMatches)
						bFoundCurrentAction = true;
					// (c.haag 2008-02-14 12:59) - PLID 28568 - Increment the number of qualifying details for this loop
					nQualifyingDetails++;
				}
			}//end for loop, for all details

			//
			//Now we have a comma separated list of all source action IDs on details which are created from the info
			//	master ID that we are supposed to revoke.
			//
			//DRT 8/8/2007 - I contend that if the above loop comes back with 1 record, and that 1 record
			//	matches ea.nID (which is an EMRActionsT.ID) exactly, then we must be already using the correct action 
			//	for our spawn, and there is only 1 on this entire EMN.  Therefore, we can skip the recordset entirely, 
			//	because the recordset basically comes down to asking
			//	Give me the ID of all EMRActions where ID = <my current ID that we just loaded from data when this 
			//	EMN was opened> in this case
			//DRT 8/9/2007 - Expanding on this a bit.  After some more research (testing & examining query results), I 
			//	have come to the conclusion that it's not a 1-1 relationship that we can skip over.  If our current
			//	action ID (ea.nID) exists anywhere on this current EMN, then we know this action is being used.  There
			//	is no point finding historical records -- we're clearly already using the right one!  Therefore I 
			//	check above if we ever find the current action, and if so, bFoundCurrentAction is true.  In this way, 
			//	we now only need to run the recordset for those actions which are truly historical.
			//DRT 10/16/2007 - 1 last change.  The above isn't quite accurate.  If you have a detail which historically
			//	spawns another detail, then re-add that same original source detail, and have it spawn the current action 
			//	(so now you've got the same source detail twice, spawning the same dest detail twice, but 1 has a 
			//	historical SourceActionID and 1 has a new SourceActionID), then bFoundCurrentAction was getting set above, 
			//	which wasn't entirely accurate -- because the source detail it was flagged on was not the source detail
			//	for unspawning.  I changed it to also compare the source detail (in the same manner the revoke does below), 
			//	so now if bFoundCurrentAction is true, it is definitely for this spawn, and not another copy on the EMN.
			// (c.haag 2008-01-23 15:54) - PLID 28568 - (3.) The logic is missing a key component -- the contention is that
			// if the loop comes back with 1 record, then we don't need to run a query. However, that was never checked for
			// until the introduction of nQualifyingDetails.
			// (z.manning 2010-03-03 12:59) - PLID 37571 - Smart stamp actions are global per stamp and not per-item in
			// any way, so even if we have multiple qualifying details, use the current action as the ideal one and we
			// will later narrow down which one is correct based on the smart stamp ID or pointer.
			if(bFoundCurrentAction && (1 == nQualifyingDetails || ea.eaoSourceType == eaoSmartStamp)) {
				//If we get here, then we have detected that our current source action ID already exists on this EMN.
				//	Therefore, we know this is the detail we want to revoke.  Add a map with our own ID so it detects in
				//	the removal below.

				//DRT 10/1/2007 - PLID 27010 - Aha!  If we revoke the same action twice in an unspawn, this needs to handle that case.
				CMapLongToBool *map = NULL;

				//Lookup to see if it already exists
				if(mapEquiv.Lookup(ea.nID, map)) {
					//This action already has a map.
				}
				else {
					//No map yet exists, we'll need to create one, and set it in the main map
					map = new CMapLongToBool;
					mapEquiv.SetAt(ea.nID, map);
				}

				//Flag our action as found
				map->SetAt(ea.nID, TRUE);

				// (c.haag 2008-02-14 13:01) - (3.) PLID 28568 - Update nIdealSourceActionIDToUse
				nIdealSourceActionIDToUse = ea.nID;
			}
			else {
				//If we get here, then there are multiple details that have the same destination info master ID, or there
				//	is 1, and it doesn't have the exact same SourceActionID as our Action's ID.  In this case, we want to
				//	lookup historically and find all actions that are in the same EMRDataGroup (per SourceID).  Due to the nature of
				//	copied EMRInfo records, we may have an EMRActionsT.ID that is "equivalent", meaning that it is spawning
				//	a historical record of the same Info Item, but has a different action ID.
				//
				//This query will need run to give us a list of all equivalent actions.
				if(!strIDList.IsEmpty()) {
					strIDList.TrimRight(",");
					if(ea.eaoSourceType == eaoEmrDataItem) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						sqlAllSql += CSqlFragment(
							"UNION SELECT {INT} AS CurrentActionID, ID AS EquivActionID FROM EMRActionsT WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrDataT "
							" WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem WHERE SourceItem.ID = {INT}) ) "
							"AND DestType = {CONST} AND ID IN ({INTSTRING})\r\n", 
							ea.nID, eaoEmrDataItem, ea.nSourceID, eaoEmrItem, strIDList);
					}
					// (z.manning, 02/07/2008) - PLID 28690 - Need to handle hotspot groups as well.
					else if(ea.eaoSourceType == eaoEmrImageHotSpot) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						sqlAllSql += CSqlFragment(
							"UNION SELECT {INT} AS CurrentActionID, ID AS EquivActionID FROM EMRActionsT WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrImageHotSpotsT "
							" WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem WHERE SourceItem.ID = {INT}) ) "
							"AND DestType = {CONST} AND ID IN ({INTSTRING})\r\n", 
							ea.nID, eaoEmrImageHotSpot, ea.nSourceID, eaoEmrItem, strIDList);
					}
					// (z.manning 2009-02-17 10:29) - PLID 33072 - EMR table dropdown item actions
					else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
						// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
						sqlAllSql += CSqlFragment(
							"UNION SELECT {INT} AS CurrentActionID, ID AS EquivActionID FROM EMRActionsT WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrTableDropdownInfoT "
							" WHERE DropdownGroupID = (SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem WHERE SourceItem.ID = {INT}) ) "
							"AND DestType = {CONST} AND ID IN ({INTSTRING})\r\n", 
							ea.nID, eaoEmrTableDropDownItem, ea.nSourceID, eaoEmrItem, strIDList);
					}
					else if(ea.eaoSourceType == eaoSmartStamp) {
						// (z.manning 2010-03-02 17:10) - PLID 37571 - Smart stamp actions are global and thus have
						// no group equivelents.
					}
					else {
						AfxThrowNxException("CEMN::RevokeEmrActions_eaoEmrItem - Invalid action source type - %i", ea.eaoSourceType);
					}
				}
				else {
					//If we hit here, we are trying to revoke an action that doesn't exist, and no sources match.  This must be an invalid
					//	historical option found by the EMNUnspawner.  We can safely ignore these possibilities.
				}
			}
		}//end for loop, all actions to be revoked

		//
		//At this point we have query text, which is basically a bunch of queries UNION'd together.  I could find no way to make this
		//	just 1 single query, and still get all the info that is needed, which would be faster.  This isn't bad though.
		if(!sqlAllSql.IsEmpty()) {
			sqlAllSql->m_strSql = sqlAllSql->m_strSql.Mid(6); //Trim off the first UNION

			//We can't really parameterize this because of the IN () and UNION stuff.
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized. I defy you!
			_RecordsetPtr prs = CreateParamRecordset("{SQL}", sqlAllSql);

			//Now loop over all records.  We will get 2 values, the current action ID (one of our values in the array passed to this function), and 
			//	an equivalent action ID.  We can populate the map from there.
			while(!prs->eof) {
				long nCurrentActionID = AdoFldLong(prs, "CurrentActionID");
				long nEquivActionID = AdoFldLong(prs, "EquivActionID");

				//Lookup the map for this current action.  If it's NULL, this is the first item in the map
				CMapLongToBool *map = NULL;
				if(!mapEquiv.Lookup(nCurrentActionID, map)) {
					//Failed to find the map, make a new one					
					map = new CMapLongToBool;

					//And put it in the main map
					mapEquiv.SetAt(nCurrentActionID, map);

					// (c.haag 2008-02-14 10:25) - PLID 28568 - (3.) Update nIdealSourceActionIDToUse; it should be the highest SAID in the map
					if (nCurrentActionID > nIdealSourceActionIDToUse) {
						nIdealSourceActionIDToUse = nCurrentActionID;
					}
				}

				//At this point we have a map of all equivalent action IDs for this current action ID.  Add our new one.
				map->SetAt(nEquivActionID, TRUE);

				prs->MoveNext();
			}
		}
	}


	// Now that the map is fully generated, we're ready to traverse the actions and search for doomed details to add to the doomed array
	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) {
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed an emr item action
		if(ea.eaoDestType != eaoEmrItem) {
			AfxThrowNxException("Invalid operation when attempting to gather EMR items for action revoking");
		}

		//BEGIN PLID 27003 PHASE A COPIED CODE

		//TES 12/7/2006 - PLID 23724 - DestID now references an EmrInfoMasterT record, not an EmrInfoT record.
		// (c.haag 2006-03-03 13:27) - PLID 19422 - If we remove a detail, we can not
		// rely on nTotalDetailCount being accurate any longer. We need to restart the
		// loop.

		//DRT 8/8/2007 - Removed the while loop -- for an eaoEmrItem action, there can only possibly be 1 detail spawned.  We have
		//	no need to loop multiple times over the set of EMN Details
		// (c.haag 2008-01-23 15:57) - PLID 28568 - (4.) But we have to go through ALL the details to find it!
		//BOOL bFoundDetail = FALSE;
		CEMNDetail* pFoundDetail = NULL;

		const long nTotalDetailCount = GetTotalDetailCount();

		// (c.haag 2008-01-23 15:55) - PLID 28568 - (4.) This logic used to be:
		//
		// "check all details until we find the first qualifying one"
		//
		// But that does not factor in the possiblity that multiple details qualify, and that one detail
		// can indeed be better than another. So, we're changing the loop to
		//
		// "check all details and run with the best qualifying one"
		//
		for(long nDetailIdx = nTotalDetailCount - 1; nDetailIdx >= 0 /*&& !bFoundDetail*/; nDetailIdx--) {
			CEMNDetail *pDetail = GetDetail(nDetailIdx);
			//TES 3/31/2006 - Check AllowUnspawn(), which would mean the detail is trying to unspawn itself.
			// (j.jones 2006-09-26 09:40) - PLID 22695 - ensure we compare differing versions of the same detail

			// (z.manning 2009-02-24 10:59) - PLID 33338 - For table dropdown item based spawning we use
			// the source table element instead of the source detail since the exact same dropdown elments
			// (and thus dropdown actions) exist within the same detail.
			BOOL bSourceDataGroupIDOK = FALSE;
			if(ea.eaoSourceType == eaoEmrTableDropDownItem)
			{
				if(aas.sai.TableSourceMatches(pDetail->GetSourceActionInfo())) {
					bSourceDataGroupIDOK = TRUE;
				}
			}
			else {
				// (z.manning 2009-02-26 11:52) - PLID 33338 - No other spawning type requires we compare
				// source data ID.
				bSourceDataGroupIDOK = TRUE;
			}

			// (z.manning 2010-03-02 14:58) - PLID 37571 - Special handling for smart stamp actions
			BOOL bSourceSmartStampOk = FALSE;
			if(ea.eaoSourceType == eaoSmartStamp)
			{
				if(aas.sai.GetTableRow()->m_ID == pDetail->GetSourceTableRow()->m_ID) {
					bSourceSmartStampOk = TRUE;
				}
			}
			else {
				// (z.manning 2010-03-02 15:06) - PLID 37571 - This doesn't matter on non smart stamp spawning
				bSourceSmartStampOk = TRUE;
			}

			BOOL bSourceDetailOK = FALSE;
			{
				// Do a source detail equivalency test
				if(aas.sai.pSourceDetail != NULL) {
					//if we were given a source detail (and we should have), see if
					//the object we are comparing to has the same source detail
					if(pDetail->GetSourceDetail() != NULL) {
						if(aas.sai.pSourceDetail == pDetail->GetSourceDetail()) {
							bSourceDetailOK = TRUE;
						}
					}
					//if the object doesn't have a source detail pointer, compare on source detail IDs
					if(pDetail->GetSourceDetailID() != -1) {
						if(pDetail->GetSourceDetailID() == aas.sai.nSourceDetailID) {
							bSourceDetailOK = TRUE;
						}
					}
				}
				else {
					bSourceDetailOK = TRUE;
				}
			}

			// (c.haag 2007-01-25 08:25) - PLID 24417 - Look at our map to determine whether
			// the source action ID is equivalent rather than calling IsDetailSourceActionIDEquivalent,
			// which is slower
			//DRT 8/8/2007 - PLID 27010 - Changed the map.  It is now a map from EmrAction.nID -> <other map>
			//	where <other map> is a map of equivalent SourceActionID's and a TRUE flag
			BOOL bIsDetailSourceActionIDEquivalent = FALSE;
			CMapLongToBool *map = NULL;
			mapEquiv.Lookup(ea.nID, map);
			if(map != NULL) {
				//Now lookup this specific action ID to see if it's equiv
				map->Lookup(pDetail->GetSourceActionID(), bIsDetailSourceActionIDEquivalent);
			}
			else {
				//DRT 8/8/2007 - If we get here, there is no map for the action.  This can happen only if there
				//	are multiple info items on this EMN that match our action DestID, and there are no equivalent
				//	actions.  This would be a rare case.
			}

			if(pDetail->m_nEMRInfoMasterID == ea.nDestID &&
				bIsDetailSourceActionIDEquivalent && bSourceDetailOK && bSourceDataGroupIDOK && bSourceSmartStampOk
				&& pDetail->GetAllowUnspawn()) {
				//Tell the interface we're about to remove it.

				// (j.jones 2006-03-15 09:17) - massive unspawning may have already removed this item
				if(!pDetail)
					continue;

				// (c.haag 2008-01-23 15:58) - PLID 28568 (4c.) - We found a detail; but it may not be the best one
				// for the job. Just update pFoundDetail.
				if (NULL == pFoundDetail) {
					// If we haven't found one yet, just assign it
					pFoundDetail = pDetail;
				} else {
					// If we did find one earlier, then keep the one with the higher SAID because it's newer
					if (pFoundDetail->GetSourceActionID() < pDetail->GetSourceActionID()) {
						pFoundDetail = pDetail;
					}
				}

				// (c.haag 2008-02-14 10:29) - PLID 28568 (4c.) - If this is a template, and we found the detail 
				// whose SAID matches the ideal one to use, end this loop and run with it. This is consistent
				// with the equivalent loop in ProcessEmrAction_eaoEmrItem.
				if (m_bIsTemplate) {
					if (nIdealSourceActionIDToUse == pDetail->GetSourceActionID()) {
						break; // Consistent with ProcessEmrActions_eaoEmrItem
					}
				} else {
					break; // For non-templates, we always end the loop here (legacy code).
				}

			} // 			if(pDetail->m_nEMRInfoMasterID == ea.nDestID &&
			//	bIsDetailSourceActionIDEquivalent && bSourceDetailOK
			//	&& pDetail->GetAllowUnspawn()) {

		} // for(long nDetailIdx = nTotalDetailCount - 1; nDetailIdx >= 0 /*&& !bFoundDetail*/; nDetailIdx--) {



		// (c.haag 2008-01-23 16:14) - PLID 28568 - (5.) Now check whether we found a detail, and if so,
		// run with it
		if (NULL != pFoundDetail) {
			CDoomedEmrObject deo;
			deo.m_aas = aas;
			deo.SetDetail(pFoundDetail);
			adeoDoomedObjects.Add(deo);					
		} // if (NULL != pFoundDetail) {

	} // for(int i = 0; i < nActionCnt; i++) {

	//Cleanup the memory allocated for the map
	POSITION pos = mapEquiv.GetStartPosition();
	while(pos != NULL) {
		CMapLongToBool *map = NULL;
		long nID = -1;

		mapEquiv.GetNextAssoc(pos, nID, map);

		//Deallocate the map
		if(map)
			delete map;
	}
}

// (c.haag 2008-08-01 15:34) - PLID 30897 - This function gathers a list of all EMR topics that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the EMN topic pointer and action-pertinent
// information in adeoDoomedObjects. That array will later be used in the actual removing of those EMR items. If
// a topic is removed and has children, its children will NOT be added to the array.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoMintItems(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	//
	// This function is based off the legacy Revoke Emr Action code for EMR topics, and has signficiant differences:
	// 1. Rather than removing topics, the topics are added to an array.
	// 2. This is a read-only operation. Nothing in the EMN itself should be changed unless maybe it's in the middle
	// of an asynchronous load, and that load needs to finish when GetAllTopics is called. Otherwise, there would
	// be a const in the declaration protecting it at the compiler level.
	// 3. No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	// 4. To repeat myself: If a topic is removed and has children, its children will NOT be added to the array.
	//

	// (c.haag 2008-08-01 15:41) - PLID 30897 - We only need to gather all the topics once since we're not actually deleting 
	// or changing any.
	CArray<CEMRTopic*,CEMRTopic*> arTopics;
	GetAllTopics(arTopics);

	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) { // Do for all actions
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		//Confirm that every action is indeed a mint items action
		if(ea.eaoDestType != eaoMintItems) {
			AfxThrowNxException("Invalid operation when attempting to gather EMR topics for action revoking");
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);

		// (j.jones 2007-07-30 09:54) - PLID 26868 - duplicated a good deal of code from
		// ProcessEmrAction such that we can more efficiently find "equivalent" source action IDs

		//TES 1/24/2006 - Sometimes a topic will be spawned, before the topic which is its stored parent is spawned.
		//Therefore, we may need to iterate through the list multiple times.
		// (c.haag 2007-05-30 15:57) - PLID 26186 - These two variables used to be in the scope of the topic loop.
		// No longer. The reason is that 95% of the time, these will wind up being the same values. What's important
		// is whether the query we used to build these values has changed or not. If it changes, then all of these
		// values should be reset to their defaults and then populated with new values again.
		CMap<long, long, BOOL, BOOL> mapTSAIDEquivalent;
		long nIdealSourceActionIDToUse = -1;
		// (c.haag 2007-05-30 16:06) - PLID 26186 - This was the query we used to build the two variables above.
		// We generate one like it at every iteration in the loop below. If the generated one differs, then we must
		// update this query, run it, and repopulate those variables. If the generated one is the same, we won't 
		// run the query because we already ran it before.
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		CSqlFragment sqlIdealSourceActionIDQuery;

		// (c.haag 2007-05-30 17:03) - PLID 26187 - Variables used for action searching
		CArray<long,long> anSourceActionIDFindFilter; // (New equivalent of strSourceActionIDFind)
		if(ea.eaoSourceType == eaoEmrItem) {
			ASSERT(FALSE);
		} 
		else if(ea.eaoSourceType == eaoEmrDataItem) {			
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			_RecordsetPtr prs = CreateParamRecordset("SELECT ID FROM EmrActionsT WHERE SourceType = {INT} AND SourceID IN "
					" (SELECT ID FROM EmrDataT WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = {INT} AND DestID = {INT}", eaoEmrDataItem, ea.nSourceID, eaoMintItems, ea.nDestID);
			while (!prs->eof) {
				anSourceActionIDFindFilter.Add( AdoFldLong(prs, "ID") );
				prs->MoveNext();
			}
		}
		else if(ea.eaoSourceType == eaoEmrImageHotSpot) {
			// (z.manning, 01/24/2008) - PLID 28690 - Need to handle EMR image hot spots.
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			_RecordsetPtr prs = CreateParamRecordset("SELECT ID FROM EmrActionsT WHERE SourceType = {INT} AND SourceID IN "
					" (SELECT ID FROM EmrImageHotSpotsT WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
					" WHERE SourceItem.ID = {INT})) "
					"AND DestType = {INT} AND DestID = {INT}", eaoEmrImageHotSpot, ea.nSourceID, eaoMintItems, ea.nDestID);
			while (!prs->eof) {
				anSourceActionIDFindFilter.Add( AdoFldLong(prs, "ID") );
				prs->MoveNext();
			}
		}
		else if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
			// (z.manning 2009-02-17 10:33) - PLID 33072 - Table dropdown item actions
			_RecordsetPtr prs = CreateParamRecordset(
				"SELECT ID FROM EmrActionsT \r\n"
				"WHERE SourceType = {INT} AND SourceID IN "
				"	(SELECT ID FROM EmrTableDropdownInfoT WHERE DropdownGroupID = \r\n"
				"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem "
				"		 WHERE SourceItem.ID = {INT})) "
				"	AND DestType = {INT} AND DestID = {INT} \r\n", eaoEmrTableDropDownItem, ea.nSourceID, eaoMintItems, ea.nDestID);
			while (!prs->eof) {
				anSourceActionIDFindFilter.Add( AdoFldLong(prs, "ID") );
				prs->MoveNext();
			}
		}
		else {
			anSourceActionIDFindFilter.Add(ea.nID);
		}
		long nSourceDetailIDFindFilter = -1; // (New equivalent of strSourceDetailIDFind)
		if(pSourceDetail && pSourceDetail->m_nEMRTemplateDetailID != -1) {
			nSourceDetailIDFindFilter = pSourceDetail->m_nEMRTemplateDetailID;
		}

		// (j.jones 2007-07-30 09:23) - PLID 26868 - I copied the efficiency mapping and
		// search for the most recent SourceActionID from the logic when spawning details.
		// For the mapping: IsTopicSourceActionIDEquivalent individually for every topic in the
		// template. That function queries the data. We need to optimize this by running just one query
		// that would have the results for all the topics, and build a map of those results for
		// quick referencing.
		// For the search: "This needs to accomodate the possibility of duplicates using different
		// SourceActionIDs, such that we ensure we're spawning the topics with the most recent 
		// SourceActionID. We'll do so by tracking the highest SourceActionID possible 
		// (nIdealSourceActionIDToUse), then using whichever spawned topic matches that ID or is
		// otherwise the highest SourceActionID (nMaxSourceActionIDFound) of the available topics to use."

		// Note: This map needs to be generated at each pass through arTemplateTopicIDs
		// AFTER pEMN->GetAllTopics() is called, because the topic list - and thus our map -
		// can change on each passthrough.

		// (c.haag 2007-05-30 16:06) - PLID 26186 - Not anymore! This map only needs to be
		// regenerated if the query used to build it changes.

		long nMaxSourceActionIDFound = -1;

		// Generate the query filter by concatenating the topic ID's
		// (c.haag 2007-05-30 15:53) - PLID 26186 - Use an array rather than building
		// an SQL string. Also, do not duplicate ID's like we did before.
		CArray<long,long> aSAIDsOfInterest;
		for (int j=0; j < arTopics.GetSize(); j++) { // Do for all topics
			CEMRTopic *pTopic = (CEMRTopic*)arTopics.GetAt(j);
			long nSourceActionID = pTopic->GetSourceActionID();
			
			// (j.jones 2007-08-01 11:27) - PLID 26900 - we can only unspawn a topic
			// where the topic's template ID matches our template ID, and unspawning is allowed,
			// so we can reduce our filter query that way
			long nMatchingTopicID = pTopic->GetOriginalTemplateID();
			if (nMatchingTopicID == -1)
				nMatchingTopicID = pTopic->GetTemplateID();

			if (nSourceActionID > 0 && !IsIDInArray(nSourceActionID, aSAIDsOfInterest)
				&& pTopic->AllowUnspawn() && (ea.nDestID == nMatchingTopicID)) {
				aSAIDsOfInterest.Add(nSourceActionID);
			}
		}
		
		// Now run the query and pull in the records.
		if (aSAIDsOfInterest.GetSize() > 0) {
			
			// (j.jones 2007-03-07 16:49) - PLID 25095 - load in order of newest to oldest,
			// such that we know the first record returned is the ideal action record
			// (c.haag 2007-05-30 15:55) - PLID 26186 - We now use ArrayAsString instead of
			// a pre-built SQL string
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			CSqlFragment sqlSql;
			if(ea.eaoSourceType == eaoEmrDataItem)
			{
				sqlSql = CSqlFragment(
					"SELECT ID FROM EMRActionsT WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrDataT "
					" WHERE EmrDataGroupID = (SELECT EmrDataGroupID FROM EmrDataT SourceItem WHERE SourceItem.ID = {INT}) ) "
					"AND DestType = {CONST} AND ID IN ({INTARRAY}) "
					"ORDER BY ID DESC",
					eaoEmrDataItem, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
			}
			// (z.manning, 01/24/2008) - PLID 28690 - Need a separate query for hot spot based unspawning.
			else if(ea.eaoSourceType == eaoEmrImageHotSpot)
			{
				sqlSql = CSqlFragment(
					"SELECT ID FROM EmrActionsT "
					"WHERE SourceType = {CONST} AND SourceID IN (SELECT ID FROM EmrImageHotSpotsT "
					"	WHERE EmrSpotGroupID = (SELECT EmrSpotGroupID FROM EmrImageHotSpotsT SourceItem "
					"	WHERE SourceItem.ID = {INT})) AND DestType = {CONST} AND ID IN ({INTARRAY}) "
					"ORDER BY ID DESC "
					, eaoEmrImageHotSpot, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
			}
			// (z.manning 2009-02-17 10:36) - PLID 33072 - Table dropdown item actions
			else if(ea.eaoSourceType == eaoEmrTableDropDownItem)
			{
				sqlSql = CSqlFragment(
					"SELECT ID FROM EmrActionsT \r\n"
					"WHERE SourceType = {CONST} AND SourceID IN \r\n"
					"	(SELECT ID FROM EmrTableDropdownInfoT "
					"	 WHERE DropdownGroupID = \r\n"
					"		(SELECT DropdownGroupID FROM EmrTableDropdownInfoT SourceItem "
					"		 WHERE SourceItem.ID = {INT})) \r\n"
					"	AND DestType = {CONST} AND ID IN ({INTARRAY}) "
					"ORDER BY ID DESC "
					, eaoEmrTableDropDownItem, ea.nSourceID, eaoMintItems, aSAIDsOfInterest);
			}
			else if(ea.eaoSourceType == eaoSmartStamp) {
				// (z.manning 2010-03-02 17:10) - PLID 37571 - Smart stamp actions are global and thus have
				// no group equivelents.
				for(int i = 0; i < aSAIDsOfInterest.GetSize(); i++) {
					mapTSAIDEquivalent[aSAIDsOfInterest.GetAt(i)] = TRUE;
				}
			}
			else {
				// (z.manning, 01/24/2008) - PLID 28690 - So the next person realizes they need to change something here
				ThrowNxException("CEMN::RevokeEmrActions_eaoMintItems - Invalid action source type (%i)", ea.eaoSourceType);
			}

			// (c.haag 2007-05-30 16:02) - PLID 26186 - Check if the SQL statement we built is the
			// same one that we had for the previous template topic. If it is, then we will get
			// the same results as before. Ergo, there's no need to run the query.
			if (sqlIdealSourceActionIDQuery != sqlSql) {

				sqlIdealSourceActionIDQuery = sqlSql;
				mapTSAIDEquivalent.RemoveAll();
				nIdealSourceActionIDToUse = -1;

				// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
				_RecordsetPtr prsTSAIDEquivalent = CreateParamRecordset("{SQL}", sqlSql);
				while (!prsTSAIDEquivalent->eof) {
					long nSourceActionID = AdoFldLong(prsTSAIDEquivalent, "ID");
					mapTSAIDEquivalent[nSourceActionID] = TRUE;

					// (j.jones 2007-03-07 16:49) - PLID 25095 - track the maximum
					// SourceActionID, though this assignment should only be occurring
					// in the first iteration of this while loop
					// (j.jones 2007-07-30 10:17) - PLID 26868 - this variable is NOT
					// needed, currently, in the Revoking process, but it doesn't cost
					// us anything to track it, so may as well keep the logic incase
					// it is needed in the future.
					if(nSourceActionID > nIdealSourceActionIDToUse) {
						nIdealSourceActionIDToUse = nSourceActionID;
					}

					prsTSAIDEquivalent->MoveNext();
				}
				prsTSAIDEquivalent->Close();
			} 
		}

		for(int i=arTopics.GetSize()-1; i>=0; i--) { // Do for all topics
			CEMRTopic *pTopic = arTopics[i];
			//TES 3/31/2006 - Check AllowUnspawn(), which determines whether a detail is attempting to unspawn itself.
			// (j.jones 2006-09-26 09:40) - PLID 22695 - ensure we compare differing versions of the same topic

			// (z.manning 2009-02-24 10:59) - PLID 26579 - For table dropdown item based spawning we use
			// the source table element instead of the source detail since the exact same dropdown elments
			// (and thus dropdown actions) exist within the same detail.
			BOOL bSourceDataGroupIDOK = FALSE;
			if(ea.eaoSourceType == eaoEmrTableDropDownItem)
			{
				if(aas.sai.TableSourceMatches(pTopic->GetSourceActionInfo())) {
					bSourceDataGroupIDOK = TRUE;
				}
			}
			else {
				// (z.manning 2009-02-26 11:52) - PLID 33141 - No other spawning type requires we compare
				// source data ID.
				bSourceDataGroupIDOK = TRUE;
			}

			// (z.manning 2010-03-02 14:58) - PLID 37571 - Special handling for smart stamp actions
			BOOL bSourceSmartStampOk = FALSE;
			if(ea.eaoSourceType == eaoSmartStamp)
			{
				if(aas.sai.GetTableRow()->m_ID == pTopic->GetSourceActionInfo().GetTableRow()->m_ID) {
					bSourceSmartStampOk = TRUE;
				}
			}
			else {
				// (z.manning 2010-03-02 15:06) - PLID 37571 - This doesn't matter on non smart stamp spawning
				bSourceSmartStampOk = TRUE;
			}

			// (j.jones 2007-01-12 15:10) - PLID 24027 - added SourceDetailID support
			BOOL bSourceDetailOK = FALSE;
			if(pSourceDetail) {
				//if we were given a source detail (and we should have), see if
				//the topic we are comparing to has the same source detail
				if(pTopic->GetSourceDetail()) {
					if(pSourceDetail == pTopic->GetSourceDetail()) {
						bSourceDetailOK = TRUE;
					}
				}
				//if the topic doesn't have a source detail pointer, compare on source detail IDs
				if(pTopic->GetSourceDetailID() != -1) {
					if(pTopic->GetSourceDetailID() == (m_bIsTemplate ? pSourceDetail->m_nEMRTemplateDetailID : pSourceDetail->m_nEMRDetailID)) {
						bSourceDetailOK = TRUE;
					}
				}
			}
			else {
				//we were not given a source detail, so don't bother trying to
				//compare by it, just use SourceActionID
				bSourceDetailOK = TRUE;
				//however, this shouldn't happen
				ASSERT(FALSE);
			}

			// (a.walling 2007-03-21 11:29) - PLID 25301 - Notice when revoking actions for an EMR item, one of the conditionals is
			// that the destid matches the emrinfomaster id. We should have the same check here; the DestID must match up to the original
			// template id of that topic.
			long nMatchingTopicID = pTopic->GetOriginalTemplateID();
			if (nMatchingTopicID == -1)
				nMatchingTopicID = pTopic->GetTemplateID();

			// (j.jones 2007-07-30 10:20) - PLID 26868 - Look at our map to determine whether
			// the source action ID is equivalent rather than calling IsTopicSourceActionIDEquivalent,
			// which is slower
			long nTopicSourceActionID = pTopic->GetSourceActionID();
			BOOL bIsTopicSourceActionIDEquivalent = FALSE;
			mapTSAIDEquivalent.Lookup(nTopicSourceActionID, bIsTopicSourceActionIDEquivalent);

			if(bIsTopicSourceActionIDEquivalent && bSourceDetailOK && bSourceDataGroupIDOK && bSourceSmartStampOk && pTopic->AllowUnspawn() && (ea.nDestID == nMatchingTopicID)) {

				//Remove it.
				CDoomedEmrObject deo;
				deo.m_aas = aas;
				deo.SetTopic(pTopic);
				adeoDoomedObjects.Add(deo);	
			}
		} // for(int i=arTopics.GetSize()-1; i>=0; i--) { // Do for all topics
	} // for(int i = 0; i < nActionCnt; i++) { // Do for all actions
}

// (c.haag 2008-08-01 14:52) - PLID 30897 - This function gathers a list of all todo objects that will be removed
// from an EMN as a result of one or more unspawning actions, and stores the todo ID and action-pertinent 
// information in adeoDoomedObjects. That array will later be used in the actual removing of those todo alarms.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::GetEmrObjectsToRevoke_eaoTodo(MFCArray<CActionAndSource> *paryActionsToRevoke, CDoomedEmrObjectAry& adeoDoomedObjects)
{
	// This is a read-only operation...meaning this should not affect the actual EMN object or any charges. Note the
	// use of the const operator at the end of the function name.
	//
	// No locking is involved; nor should it be because there is no recursion, and because this is a read-only
	// operation.
	//

	const long nActionCnt = paryActionsToRevoke->GetSize();
	for(int i = 0; i < nActionCnt; i++) { // Do for all actions
		CActionAndSource aas = paryActionsToRevoke->GetAt(i);
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;

		// (b.savon 2014-08-27 09:56) - PLID 63456 - Don't unspawn until the detail is closed.
		if (NULL == pSourceDetail || pSourceDetail->m_bIsPoppedUp) {
			// Spawned todo alarms always require source details
			continue;
		}

		//Confirm that every action is indeed a todo action
		if(ea.eaoDestType != eaoTodo) {
			AfxThrowNxException("Invalid operation when attempting to gather todo alarms for action revoking");
		}

		// (j.jones 2007-04-12 16:31) - PLID 25618 - revoke any locked spawns (note: different
		// from locked actions, confusing as that is)
		if(GetParentEMR())
			GetParentEMR()->DeletePendingEMRActions(ea, pSourceDetail);

		if (!m_bIsTemplate) {
			_RecordsetPtr prs = NULL;
			// (c.haag 2008-07-14 14:59) - PLID 30607 - Check the created todo list first. If that fails,
			// then search data.
			// (c.haag 2008-07-09 11:36) - PLID 30648 - Query additional fields
			// (c.haag 2008-07-10 15:17) - PLID 30674 - Also filter on SourceActionID
			const int nCreatedTodos = m_apCreatedTodosWhileUnsaved.GetSize();
			for (int j=0; j < nCreatedTodos; j++) {

				// (z.manning 2009-02-26 14:53) - PLID 33141 - We also need to compare data group IDs for
				// table dropdown item actions.
				BOOL bSourceDataGroupOk = TRUE;
				if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
					bSourceDataGroupOk = (m_apCreatedTodosWhileUnsaved[j]->sai.TableSourceMatches(aas.sai));
				}
				// (z.manning 2010-03-02 15:20) - PLID 37571 - Check source detail stamp on smart stamp spawning
				BOOL bSourceSmartStampOk = TRUE;
				if(ea.eaoSourceType == eaoSmartStamp) {
					bSourceSmartStampOk = (m_apCreatedTodosWhileUnsaved[j]->sai.GetTableRow()->m_ID == aas.sai.GetTableRow()->m_ID);
				}
				if (m_apCreatedTodosWhileUnsaved[j]->sai.pSourceDetail == pSourceDetail &&
					m_apCreatedTodosWhileUnsaved[j]->sai.nSourceActionID == ea.nID &&
					(TodoType)VarLong(m_apCreatedTodosWhileUnsaved[j]->vRegardingType) == ttEMNDetail &&
					bSourceDataGroupOk && bSourceSmartStampOk)
				{
					long nTodoID = m_apCreatedTodosWhileUnsaved[j]->nTodoID;
					prs = CreateParamRecordset(
						"SELECT TodoList.TaskID, RegardingID, Remind, Done, EnteredBy, PersonID, Priority, Task, LocationID, CategoryID, dbo.GetTodoAssignToIDString(TodoList.TaskID) AS AssignToIDs, dbo.GetTodoAssignToNamesString(TodoList.TaskID) AS AssignToNames, Deadline, (SELECT Description FROM NoteCatsF WHERE ID = TodoList.CategoryID) AS Category, Notes FROM TodoList INNER JOIN EMRTodosT ON EMRTodosT.TaskID = TodoList.TaskID "
						"WHERE TodoList.TaskID = {INT}", nTodoID);
					break;
				}

			} // for (int j=0; j < nCreatedTodos; j++) {

			// (c.haag 2008-07-14 14:59) - PLID 30607 - The todo doesn't exist in our created list. Just search the data using Detail ID as the key.
			if (NULL == prs) {
				// This detail is saved. Query by detail ID.
				// (c.haag 2008-07-09 11:36) - PLID 30648 - Query additional fields
				// (c.haag 2008-07-10 15:16) - PLID 30674 - Also filter on SourceActionID
				// (c.haag 2012-10-17) - PLID 52863 - Also filter on source detail image stamp ID
				prs = CreateParamRecordset(
					FormatString("SELECT TodoList.TaskID, RegardingID, Remind, Done, EnteredBy, PersonID, Priority, Task, LocationID, CategoryID, dbo.GetTodoAssignToIDString(TodoList.TaskID) AS AssignToIDs, dbo.GetTodoAssignToNamesString(TodoList.TaskID) AS AssignToNames, Deadline, (SELECT Description FROM NoteCatsF WHERE ID = TodoList.CategoryID) AS Category, Notes "
						"FROM TodoList "
						"INNER JOIN EMRTodosT ON EMRTodosT.TaskID = TodoList.TaskID "
						"WHERE RegardingType = %d "
						"	AND RegardingID = {INT} "
						"	AND SourceActionID = {INT} "
						"	AND COALESCE(SourceDetailImageStampID,-1) = {INT} "
						,(long)ttEMNDetail), pSourceDetail->m_nEMRDetailID, ea.nID, aas.sai.GetDetailStampID());
			}

			FieldsPtr f = prs->Fields;
			while (!prs->eof) {
				long nTaskID = AdoFldLong(f, "TaskID");

				CDoomedEmrObject deo;
				deo.m_aas = aas;
				deo.SetTodoID(nTaskID);
				adeoDoomedObjects.Add(deo);	

				prs->MoveNext();

			} // while (!prs->eof) {
		} // if (!m_bIsTemplate) {
	} // for(int i = 0; i < nActionCnt; i++) { // Do for all actions
}


//DRT 8/7/2007 - PLID 27003 - Original source pulled out of RevokeEmrAction
// (c.haag 2008-08-01 16:02) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
// (j.jones 2011-07-11 10:53) - PLID 38366 - this will also process a given array of coding groups and the quantities to reduce
// from each coding group, which were previously calculated
void CEMN::RevokeEmrActions_eaoCpt(const CDoomedEmrObjectAry& adeoDoomedObjects, CEmrCodingGroupArray &aryCodingGroupsToChange,
	CMap<CEmrCodingGroup*, CEmrCodingGroup*, long, long> &mapCodingGroupQuantitiesToSubtract)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) { // Do for all doomed objects
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		EMNCharge* pCharge = deo.GetCharge();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a CPT action
		if(ea.eaoDestType != eaoCpt) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoCpt");
		}

		// (c.haag 2008-07-21 17:40) - PLID 30799 - Unspawn any problems bound to the source object
		if (!m_bIsTemplate) {
			RevokeEmrProblemAction(ea, pSourceDetail);
		}

		//Tell the interface that we're about to remove it.
		if(GetInterface()) {
			GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_CHARGE, (WPARAM)pCharge, (LPARAM)this);
		}

		//Remove the charge
		for (int nCharge=0; nCharge < m_aryCharges.GetSize(); nCharge++) {
			if (m_aryCharges[nCharge] == pCharge) {
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
				RemoveChargeByIndex(nCharge);
				break;
			}
		}

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);

		// (c.haag 2008-08-05 15:42) - PLID 30799 - Do not update the EMN problem flag icon.
		// That is done in the unspawner or the code responsible for the unspawning.

	} // for(int i = 0; i < nDoomedObjects; i++) {

	// (j.jones 2011-07-11 10:53) - PLID 38366 - now process each group that was affected,
	// by updating our local copies of the group (if they exist) with the new quantity,
	// and processing the rules for the group at the new quantity level
	for(int i=0; i<aryCodingGroupsToChange.GetSize(); i++) {
		CEmrCodingGroup *pCodingGroup = (CEmrCodingGroup*)aryCodingGroupsToChange.GetAt(i);
		long nQuantityToSubtract = 0;
		mapCodingGroupQuantitiesToSubtract.Lookup(pCodingGroup, nQuantityToSubtract);
		if(nQuantityToSubtract > 0) {
			//update this group with a negative quantity to subtract these values
			UpdateCodingGroup(pCodingGroup, FALSE, -nQuantityToSubtract);
		}
	}
}

// (c.haag 2008-08-01 16:06) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoDiag(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	BOOL bRemovedADiag = FALSE;

	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		EMNDiagCode* pDiag = deo.GetDiagCode();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a Diag action
		// (b.savon 2014-07-14 13:11) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
		if(ea.eaoDestType != eaoDiagnosis/*eaoDiag*/) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoDiag");
		}

		// (c.haag 2008-07-21 17:40) - PLID 30799 - Unspawn any problems bound to the source item
		if (!m_bIsTemplate) {
			RevokeEmrProblemAction(ea, pSourceDetail);
		}

		//Tell the interface that we're about to remove it.
		if(GetInterface()) {
			GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_DIAG, (WPARAM)pDiag, (LPARAM)this);
		}

		//Remove the diagnosis code
		for (int nDiag=0; nDiag < m_aryDiagCodes.GetSize(); nDiag++) {
			if (m_aryDiagCodes[nDiag] == pDiag) {
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
				RemoveDiagCodeByIndex(nDiag);

				// (j.jones 2012-10-01 15:44) - PLID 52869 - track that we removed a diagnosis code
				bRemovedADiag = TRUE;
				break;
			}
		}


		//END PHASE A COPIED CODE

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);

		// (c.haag 2008-08-05 15:42) - PLID 30799 - Do not update the EMN problem flag icon.
		// That is done in the unspawner or the code responsible for the unspawning.

		// (j.jones 2012-10-01 15:44) - PLID 52869 - this function will check their preference
		// to save the EMN and warn about drug interactions
		if(!m_bIsTemplate && !IsLoading() && bRemovedADiag) {
			CheckSaveEMNForDrugInteractions(FALSE);
		}

	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (c.haag 2008-08-01 16:10) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoMedication(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		EMNMedication* pMed = deo.GetMedication();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a medication action
		if(ea.eaoDestType != eaoMedication) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoMedication");
		}

		BOOL bRemovedAMedication = FALSE;

		// (j.jones 2012-10-29 16:06) - PLID 53259 - medications cannot be deleted if they have been e-Prescribed
		if(!IsERxStatus(pMed->eQueueStatus)) {
			// (c.haag 2008-07-22 09:46) - PLID 30799 - Unspawn any problems bound to the source item
			if (!m_bIsTemplate) {
				RevokeEmrProblemAction(ea, pSourceDetail);
			}

			//Tell the interface that we're about to remove it.
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_MEDICATION, (WPARAM)pMed, (LPARAM)this);
			}

			//Remove it.
			for (int nMed=0; nMed < m_aryMedications.GetSize(); nMed++) {
				if (m_aryMedications[nMed] == pMed) {
					// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
					RemoveMedicationByIndex(nMed);

					// (j.jones 2012-10-01 08:47) - PLID 52922 - track that we removed a medication
					bRemovedAMedication = TRUE;
					break;
				}
			}
		}

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);

		// (c.haag 2008-08-05 15:42) - PLID 30799 - Do not update the EMN problem flag icon.
		// That is done in the unspawner or the code responsible for the unspawning.

		// (j.jones 2012-10-01 08:45) - PLID 52922 - this function will check their preference
		// to save the EMN and warn about drug interactions
		if(!m_bIsTemplate && !IsLoading() && bRemovedAMedication) {
			// (j.jones 2012-11-13 10:10) - PLID 52869 - changed to be a posted message
			// (j.jones 2013-02-06 16:28) - PLID 55045 - Medication changes save immediately now,
			// so pass in TRUE for the lParam to tell this function that we already saved the changes
			// and the interactions should open if it was otherwise waiting for a save to succeed.
			CheckSaveEMNForDrugInteractions(TRUE);
		}

	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (c.haag 2008-08-01 16:11) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoProcedure(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		EMNProcedure* pProc = deo.GetProcedure();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a procedure action
		if(ea.eaoDestType != eaoProcedure) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoProcedure");
		}

		//Tell the interface that we're about to remove it.
		if(GetInterface()) {
			GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_PROCEDURE, (WPARAM)pProc->nID, (LPARAM)this);
		}

		//Remove it.
		for (int nProc=0; nProc < m_aryProcedures.GetSize(); nProc++) {
			if (m_aryProcedures[nProc] == pProc) {
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
				RemoveProcedureByIndex(nProc);
				break;
			}
		}		

		//Make sure the tree gets updated.
		if(GetInterface()) {
			// (z.manning, 10/05/2007) - PLID 27630 - Tell the interface the procedure has been removed.
			GetInterface()->SendMessage(NXM_POST_DELETE_EMN_PROCEDURE, (WPARAM)pProc->nID, (LPARAM)this);
		}						

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);
	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (z.manning 2008-10-08 16:46) - PLID 31628 - Revoke labs
void CEMN::RevokeEmrActions_eaoLab(const CDoomedEmrObjectAry &adeoDoomedObjects)
{
	for(int nDoomedObjectIndex = 0; nDoomedObjectIndex < adeoDoomedObjects.GetSize(); nDoomedObjectIndex++)
	{
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(nDoomedObjectIndex);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		EMNLab *pLab = deo.GetLab();

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}

		//Confirm that every action is indeed a lab action
		if(ea.eaoDestType != eaoLab) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoLab");
		}

		// (z.manning 2008-10-09 15:14) - PLID 31628 - Labs are a bit different from other types
		// of unspawned items as they are not directly a part of EMR and if they choose to commit
		// the unspawn the lab will be immediately deleted.
		// Note: It's 100% intentional that this warning is inside the loop.  In the even we are
		// unspawning multiple labs we want to warn them twice per lab.
		CWnd *pwndParent = GetOpenMultiPopupDlg() != NULL ? (CWnd*)GetOpenMultiPopupDlg() : (CWnd*)GetInterface();
		CLabConfirmDeleteDlg dlgConfirm(pwndParent);
		dlgConfirm.SetLabInfo(pLab->GetText());
		dlgConfirm.SetPatientName(GetPatientNameFirst() + " " + GetPatientNameLast());
		if(dlgConfirm.DoModal() != IDOK) {
			return;
		}

		// (j.jones 2009-06-04 17:38) - PLID 34487 - Find out if any problems will be modified (links removed)
		// or deleted outright. Warn the user accordingly.
				
		CArray<long, long> arynEMRProblemLinkIDsToDelete;
		CArray<long, long> arynEMRProblemIDsToDelete;
		CString strEMRProblemLinkIDsToDelete, strEMRProblemIDsToDelete;
		
		if(pLab->nID != -1) {
			// (a.walling 2014-07-23 09:12) - PLID 63003 - Use CONST_INT for EMRProblemLinkT.EMRRegardingType enums
			_RecordsetPtr rsLinkedProblems = CreateParamRecordset("SELECT ID, "
				"CASE WHEN EMRProblemID IN ("
					"SELECT EMRProblemID FROM EMRProblemLinkT WHERE	NOT (EMRRegardingType = {CONST_INT} AND EMRRegardingID = {INT}) "
				") "
				"THEN -1 ELSE EMRProblemID END AS EMRProblemIDToDelete "
				"FROM EMRProblemLinkT WHERE	EMRRegardingType = {CONST_INT} AND EMRRegardingID = {INT}",
				eprtLab, pLab->nID,
				eprtLab, pLab->nID);

			while(!rsLinkedProblems->eof) {

				//every record references a link to delete
				long nProblemLinkID = AdoFldLong(rsLinkedProblems, "ID");

				//add to our array
				BOOL bFound = FALSE;
				int i=0;
				for(i=0; i<arynEMRProblemLinkIDsToDelete.GetSize() && !bFound; i++) {
					if(arynEMRProblemLinkIDsToDelete.GetAt(i) == nProblemLinkID) {
						bFound = TRUE;
					}
				}
				if(!bFound) {
					arynEMRProblemLinkIDsToDelete.Add(nProblemLinkID);
					if(!strEMRProblemLinkIDsToDelete.IsEmpty()) {
						strEMRProblemLinkIDsToDelete += ",";
					}
					strEMRProblemLinkIDsToDelete += AsString(nProblemLinkID);
				}				

				//the problem ID will be -1 if we're not deleting the problem the above link references,
				//will be a real ID if we do need to delete the problem
				long nProblemID = AdoFldLong(rsLinkedProblems, "EMRProblemIDToDelete", -1);
				if(nProblemID != -1) {

					//add to our array
					bFound = FALSE;
					for(i=0; i<arynEMRProblemIDsToDelete.GetSize() && !bFound; i++) {
						if(arynEMRProblemIDsToDelete.GetAt(i) == nProblemID) {
							bFound = TRUE;
						}
					}
					if(!bFound) {
						arynEMRProblemIDsToDelete.Add(nProblemID);
						if(!strEMRProblemIDsToDelete.IsEmpty()) {
							strEMRProblemIDsToDelete += ",";
						}
						strEMRProblemIDsToDelete += AsString(nProblemID);
					}
				}

				rsLinkedProblems->MoveNext();
			}
			rsLinkedProblems->Close();
		}

		// (z.manning 2008-10-09 15:19) - PLID 31628 - Warn them once more to be sure.

		CString strWarning = "Are you absolutely sure you want to delete this lab?";

		// (j.jones 2009-06-04 17:40) - PLID 34487 - as long as we're doing something to problems,
		// just give this generic message, we don't really have to get into specifics here
		if(!strEMRProblemIDsToDelete.IsEmpty() || !strEMRProblemLinkIDsToDelete.IsEmpty()) {
			strWarning += "\n\nAll EMR problems linked to this lab will be deleted unless they are also linked to other EMR objects.";
		}

		int nResult = ::MessageBox(pwndParent == NULL ? NULL : pwndParent->GetSafeHwnd(),
			strWarning, "Delete Lab", MB_YESNO|MB_ICONWARNING);
		if(nResult != IDYES) {
			return;
		}

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail != NULL) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		GetParentEMR()->LockAction(ea);

		// (z.manning 2008-10-09 15:23) - PLID 31628 - Ok, we've warned them twice so we'll take their
		// word for it that they do in fact want to delete this lab.
		DeletePatientLab(pLab->nID, strEMRProblemLinkIDsToDelete, strEMRProblemIDsToDelete);

		// (z.manning 2008-10-09 15:51) - PLID 31628 - We also need to remove any details associated with 
		// the deleted lab.
		CArray<CEMNDetail*,CEMNDetail*> arypLabDetails;
		GetDetailsByLabID(pLab->nID, arypLabDetails);
		for(int nLabDetailIndex = 0; nLabDetailIndex < arypLabDetails.GetSize(); nLabDetailIndex++) {
			CEMNDetail *pLabDetail = arypLabDetails.GetAt(nLabDetailIndex);
			pLabDetail->m_pParentTopic->RemoveDetail(pLabDetail);
		}

		RemoveLab(pLab->nID);

		// (j.jones 2009-06-05 08:49) - PLID 34487 - if the EMR is tracking any of these problems, flag them as deleted,
		// so the EMR knows they have been removed from data (it will possibly try to re-delete them, but that's ok)

		CArray<CEmrProblemLink*, CEmrProblemLink*> aryProblemLinks;
		GetParentEMR()->GetAllProblemLinks(aryProblemLinks);
		int i=0;
		for(i=0; i<arynEMRProblemLinkIDsToDelete.GetSize(); i++) {
			long nProblemLinkID = arynEMRProblemLinkIDsToDelete.GetAt(i);

			//see if it is tracked by the EMR
			BOOL bFound = FALSE;
			for(int j=0; j<aryProblemLinks.GetSize() && !bFound; j++) {
				CEmrProblemLink *pLink = aryProblemLinks.GetAt(j);
				if(pLink != NULL && !pLink->GetIsDeleted()
					&& pLink->GetID() == nProblemLinkID) {

					bFound = TRUE;
					pLink->SetDeleted();

					//update the interface accordingly
					if(GetInterface()) {
						UpdateEMRInterface(GetInterface(), pLink);
					}
				}
			}
		}

		CArray<CEmrProblem*, CEmrProblem*> aryProblems;
		GetParentEMR()->GetAllProblems(aryProblems);
		for(i=0; i<arynEMRProblemIDsToDelete.GetSize(); i++) {
			long nProblemID = arynEMRProblemIDsToDelete.GetAt(i);

			//see if it has problem links tracked by the EMR (could be unsaved new links)
			int j=0;
			//loop through all links, don't stop if you found one
			for(j=0; j<aryProblemLinks.GetSize(); j++) {
				CEmrProblemLink *pLink = aryProblemLinks.GetAt(j);
				if(pLink != NULL && !pLink->GetIsDeleted()
					&& pLink->GetProblem() != NULL
					&& pLink->GetProblem()->m_nID == nProblemID) {

					pLink->SetDeleted();

					//update the interface accordingly
					if(GetInterface()) {
						UpdateEMRInterface(GetInterface(), pLink);
					}
				}
			}

			//see if the problem is tracked by the EMR
			BOOL bFound = FALSE;
			for(j=0; j<aryProblems.GetSize() && !bFound; j++) {
				CEmrProblem *pProblem = aryProblems.GetAt(j);
				if(pProblem != NULL && pProblem->m_nID == nProblemID) {
					bFound = TRUE;
					pProblem->m_bIsDeleted = TRUE;
					//don't flag as modified, we don't have to save it
				}
			}
		}

		//We're done, the detail can be unspawned now.
		if(pSourceDetail != NULL) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);
	}
}

// (c.haag 2008-08-01 16:11) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoEmrItem(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		CEMNDetail *pFoundDetail = deo.GetDetail();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed an emr item action
		if(ea.eaoDestType != eaoEmrItem) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoEmrItem");
		}

		if(m_bIsTemplate) {
			// (z.manning, 3/2/2006, PLID 19099) - Remove it from the template altogether
			// in situations where it can never be spawned again to avoid "dead" data.
			// (j.jones 2007-07-30 08:46) - PLID 26867 - why query the data if the deleted status is
			// inside the ea action? If the ea were out of date (it's not), we'd have other problems
			// more significant than this, so ea.bDeleted is safe to use.
			//if( VarBool(GetTableField("EmrActionsT","Deleted","ID",ea.nID),FALSE) // The action has since been deleted.
			if(ea.bDeleted
				|| pSourceDetail->m_pParentTopic->IsDetailDeleted(pSourceDetail) ) // The spawning detail was deleted.
			{
				pFoundDetail->m_pParentTopic->RemoveDetail(pFoundDetail);
				//Done
			}
			else {
				pFoundDetail->SetVisible(FALSE, TRUE, FALSE);

				if(pFoundDetail->m_pParentTopic) {
					//DRT 8/7/2007 - PLID 26914 - The unspawner may have flagged this detail as pending deletion.  But in some
					//	cases, it will be hidden instead of actually removed.  In that case, get rid of the pending deletion flag.
					pFoundDetail->m_pParentTopic->RemoveDetailFromPendingDeletion(pFoundDetail);
				}

				if(pFoundDetail->m_pParentTopic->GetParentEMN()) {
					pFoundDetail->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pFoundDetail->GetMergeFieldName(TRUE), pFoundDetail);
				}

				//Done
			}
		}
		else {
			// (c.haag 2008-08-05 13:50) - We may have spawned problems for the source detail / list item, so we need to
			// handle those here and now.
			if (!m_bIsTemplate) {
				RevokeEmrProblemAction(ea, pSourceDetail);
			}

			pFoundDetail->m_pParentTopic->RemoveDetail(pFoundDetail);
			//TES 1/11/2008 - PLID 24157 - Make sure that if the detail is on our popped-up items dialog, that
			// it gets taken off.
			RemoveDetailFromPopup(pFoundDetail);
			//Done

			// (c.haag 2008-08-05 15:42) - PLID 30799 - Do not update the EMN problem flag icon.
			// That is done in the unspawner or the code responsible for the unspawning.
		}

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);

	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (c.haag 2008-08-01 16:15) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoMintItems(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		CEMRTopic *pTopic = deo.GetTopic();

		//First of all, this detail can't unspawn itself.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(FALSE);
		}

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a mint items action
		if(ea.eaoDestType != eaoMintItems) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoMintItems");
		}

		if (!m_bIsTemplate) {
			// (c.haag 2008-08-05 13:50) - PLID 30799 - We may have spawned a problem for the source detail / list item...so we need to unspawn those now.
			RevokeEmrProblemAction(ea, pSourceDetail);
		}

		//Tell the interface that we're about to remove it.
		if(GetInterface()) {
			if(pTopic->GetParentTopic()) {
				CArray<CEMRTopic*,CEMRTopic*> arTopics;
				GetAllTopics(arTopics);
				//TES 7/6/06 - If our parent topic is also being removed, we don't want to set it as unsaved,
				//because if it is restored later, we want it to remember that it's still in its original spot.
				CEMRTopic *pParent = pTopic->GetParentTopic();
				bool bFoundParent = false;
				for(int j = 0; j < arTopics.GetSize() && !bFoundParent; j++) {
					if(pParent == arTopics[j]) bFoundParent = true;
				}
				if(!bFoundParent) {
					pParent->SetUnsaved();
				}
			}
		}

		if( !m_bIsTemplate 
//								|| VarBool(GetTableField("EmrActionsT","Deleted","ID",ea.nID),FALSE) // The action has since been deleted.
			|| ea.bDeleted // (a.walling 2007-03-21 11:13) - PLID 25301 save a DB call
			|| pSourceDetail->m_pParentTopic->IsDetailDeleted(pSourceDetail) ) // The spawning detail was deleted.) 
		{
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_PRE_DELETE_EMR_TOPIC, (WPARAM)pTopic);
			}
			if(pTopic->GetParentTopic()) {
				//DRT 8/9/2007 - PLID 26876 - Use the external subtopic removal function
				pTopic->GetParentTopic()->RemoveSubTopic_External(pTopic);
			}
			else {
				RemoveTopic(pTopic);
			}
		}
		else {
			if(GetInterface()) {
				GetInterface()->SendMessage(NXM_HIDE_EMR_TOPIC, (WPARAM)pTopic);
			}
			//DRT 8/3/2007 - PLID 26937 - No longer needed, the CEMNUnspawner will handle
			//	determining all details that need be revoked.
			//pTopic->RevokeAllActions();
			pTopic->SetVisible(FALSE);
			//now for all visible details, update their merge conflicts
			for(int k=0; k<pTopic->GetEMNDetailCount();k++) {
				CEMNDetail *pDetail = pTopic->GetDetailByIndex(k);
				if(pDetail->m_pParentTopic->GetParentEMN()) {
					pDetail->m_pParentTopic->GetParentEMN()->UpdateMergeConflicts(pDetail->GetMergeFieldName(TRUE), pDetail);
				}
			}
		}

		//We're done, the detail can be unspawned now.
		if(pSourceDetail) {
			pSourceDetail->SetAllowUnspawn(TRUE);
		}

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);

	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (c.haag 2008-06-24 10:48) - PLID 17244 - Revoke todo actions
// (c.haag 2008-08-01 16:15) - PLID 30897 - This function no longer searches for objects to delete. Those
// objects are now passed into this function in adeoDoomedObjects
void CEMN::RevokeEmrActions_eaoTodo(const CDoomedEmrObjectAry& adeoDoomedObjects)
{
	const int nDoomedObjects = adeoDoomedObjects.GetSize();
	for(int i = 0; i < nDoomedObjects; i++) {
		CDoomedEmrObject deo = adeoDoomedObjects.GetAt(i);
		CActionAndSource aas = deo.m_aas;
		EmrAction ea = aas.ea;
		CEMNDetail *pSourceDetail = aas.sai.pSourceDetail;
		long nTaskID = deo.GetTodoID();

		// Todo alarms should always have source details
		if (NULL == pSourceDetail) {
			continue;
		}

		//First of all, this detail can't unspawn itself.
		pSourceDetail->SetAllowUnspawn(FALSE);

		//DRT 8/7/2007 - Moved action locking here from CEMR::RevokeEmrAction
		if(GetParentEMR()->IsActionLocked(ea)) {
			//This would be an infinite loop.
			//DRT 8/30/2007 - PLID 27010 - Need to continue the loop of actions, not quit entirely.
			continue;
		}
		GetParentEMR()->LockAction(ea);

		//Confirm that every action is indeed a todo action
		if(ea.eaoDestType != eaoTodo) {
			AfxThrowNxException("Invalid operation when attempting to revoke:  eaoTodo");
		}

		if (!m_bIsTemplate) {
			// (c.haag 2008-06-24 10:51) - Delete todo's tied with this detail ID
			_RecordsetPtr prs = CreateParamRecordset("SELECT TodoList.TaskID, RegardingID, Remind, Done, EnteredBy, PersonID, Priority, Task, LocationID, CategoryID, dbo.GetTodoAssignToIDString(TodoList.TaskID) AS AssignToIDs, dbo.GetTodoAssignToNamesString(TodoList.TaskID) AS AssignToNames, Deadline, (SELECT Description FROM NoteCatsF WHERE ID = TodoList.CategoryID) AS Category, Notes FROM TodoList INNER JOIN EMRTodosT ON EMRTodosT.TaskID = TodoList.TaskID WHERE TodoList.TaskID = {INT}", nTaskID);
			FieldsPtr f = prs->Fields;
			if (!prs->eof) {
				CArray<long, long> anAssignToIDs;
				long nTaskID = AdoFldLong(f, "TaskID");
				// (c.haag 2008-07-08 15:56) - PLID 17244 - Get the audit text
				CString strAssignTo = AdoFldString(f, "AssignToNames");
				CString strCategory = AdoFldString(f, "Category", "");
				CString strNotes = AdoFldString(f, "Notes");
				// CR and LF's don't show up in the audit trail elegantly; replace them with spaces or else the note will look ugly
				strNotes.Replace(10, ' ');
				strNotes.Replace(13, ' ');
				COleDateTime dtDeadline = AdoFldDateTime(f, "Deadline");
				CString strOld = FormatString("Assigned To: %s, Deadline: %s, Category: %s, Note: %s", 
					strAssignTo, FormatDateTimeForInterface(dtDeadline, 0, dtoDate), strCategory, strNotes);

				// Audit the change
				long nAuditID = -1;
				try {
					nAuditID = BeginAuditTransaction();
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditID, aeiPatientTodoTaskDelete, nTaskID, strOld, "<Deleted>", aepMedium, aetDeleted);

					// (c.haag 2008-07-09 11:34) - PLID 30648 - The parent topic is responsible for keeping
					// track of what todo alarms were unspawned during the course of the topic being unsaved.
					// Notify the topic of the unspawn.
					// (c.haag 2008-07-14 12:34) - PLID 30696 - The parent topic no longer tracks it; now it's
					// all in the EMN
					
					CString strAssignToIDs = AdoFldString(f, "AssignToIDs");
					ParseDelimitedStringToLongArray(strAssignToIDs, " ", anAssignToIDs);
					
					AddDeletedTodoWhileUnsaved(nTaskID, 
						pSourceDetail,
						ea.nID,
						aas.sai.GetTableRow(),
						f->Item["Remind"]->Value,
						f->Item["Done"]->Value,
						f->Item["Deadline"]->Value,
						f->Item["EnteredBy"]->Value,
						f->Item["PersonID"]->Value,
						f->Item["Notes"]->Value,
						f->Item["Priority"]->Value,
						f->Item["Task"]->Value,
						f->Item["LocationID"]->Value,
						f->Item["CategoryID"]->Value,
						f->Item["RegardingID"]->Value,
						(long)ttEMNDetail,
						anAssignToIDs,
						_bstr_t(strAssignTo)
						);									

					// Delete the todo. The second parameter is TRUE, meaning the delete is taking place 
					// from EMR, and we do not need to be an administrator to delete todos for unsaved details.
					TodoDelete(nTaskID, TRUE);

					// Commit the audit transaction
					CommitAuditTransaction(nAuditID);
					nAuditID = -1;
				}
				NxCatchAllSilentCallThrow(if(nAuditID==-1){RollbackAuditTransaction(nAuditID);})


				// (c.haag 2008-07-07 13:36) - PLID 30607 - Update the todo list in the more info
				// window if it exists
				if (GetInterface()) {
					GetInterface()->PostMessage(NXM_EMN_TODO_DELETED, (WPARAM)this, (LPARAM)nTaskID);
				}
				// (c.haag 2008-07-07 13:33) - PLID 30607 - Send a table checker
				// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Ex Todo
				if (anAssignToIDs.GetSize() == 1){
					CClient::RefreshTodoTable(nTaskID, GetParentEMR()->GetPatientID(), (long)anAssignToIDs[0], TableCheckerDetailIndex::tddisDeleted);
				}
				else{
					CClient::RefreshTodoTable(nTaskID, GetParentEMR()->GetPatientID(), -1, TableCheckerDetailIndex::tddisDeleted);

				}
				prs->MoveNext();

			} // while (!prs->eof) {
		} // if (!m_bIsTemplate) {

		//We're done, the detail can be unspawned now.
		pSourceDetail->SetAllowUnspawn(TRUE);

		//We're done processing this action, so this action is now free to be processed again.
		GetParentEMR()->UnlockAction(ea);
	} // for(int i = 0; i < nDoomedObjects; i++) {
}

// (c.haag 2008-08-07 09:55) - PLID 30979 - Given an array of actions and sources, unspawn all the actions.
// This should only be called when someone has deleted data actions when editing an EMN template on the fly.
// (a.walling 2014-07-14 16:32) - PLID 62812 - use MFCArray
void CEMN::RevokeEmrActions(const MFCArray<CActionAndSource>& aryaas)
{
	// (c.haag 2008-08-07 11:28) - PLID 30799 - Added this here so the developer knows that
	// this should only be called from a template. So, there should not be any EMR problem
	// logic here.
	ASSERT(m_bIsTemplate);

	// Gather lists of individual actions and source details 
	MFCArray<CActionAndSource> aryCptActions;
	MFCArray<CActionAndSource> aryDiagActions;
	MFCArray<CActionAndSource> aryMedicationActions;
	MFCArray<CActionAndSource> aryProcedureActions;
	MFCArray<CActionAndSource> aryEmrItemActions;
	MFCArray<CActionAndSource> aryMintItemsActions;
	MFCArray<CActionAndSource> aryMintActions;
	MFCArray<CActionAndSource> aryTodoActions;
	MFCArray<CActionAndSource> aryLabActions; // (z.manning 2008-10-08 17:09) - PLID 31628
	int i;
	for (i=0; i < aryaas.GetSize(); i++) {
		CActionAndSource aas = aryaas[i];
		switch(aas.ea.eaoDestType) {
		case eaoCpt: aryCptActions.Add(aas); break;
		// (b.savon 2014-07-14 12:44) - PLID 62706 - Deprecate the old Diag DestType and handle the changes Practice wide
		//case eaoDiag: aryDiagActions.Add(aas); break;
		case eaoDiagnosis: aryDiagActions.Add(aas); break;
		case eaoMedication: aryMedicationActions.Add(aas); break;
		case eaoProcedure: aryProcedureActions.Add(aas); break;
		case eaoEmrItem: aryEmrItemActions.Add(aas); break;
		case eaoMintItems: aryMintItemsActions.Add(aas); break;
		case eaoMint: aryMintActions.Add(aas); break;
		case eaoTodo: aryTodoActions.Add(aas); break;
		case eaoLab: aryLabActions.Add(aas); break; // (z.manning 2008-10-08 17:10) - PLID 31628
		default:
			ASSERT(FALSE); // Not supported
			break;
		}
	}

	// Gather a list of all the objects that will be deleted as a result of the revoking before
	// we actually do any revoking.
	CDoomedEmrObjectAry aryDoomedCpts;
	CDoomedEmrObjectAry aryDoomedDiags;
	CDoomedEmrObjectAry aryDoomedMedications;
	CDoomedEmrObjectAry aryDoomedProcedures;
	CDoomedEmrObjectAry aryDoomedItems;
	CDoomedEmrObjectAry aryDoomedTopics;
	CDoomedEmrObjectAry aryDoomedEMNs;
	CDoomedEmrObjectAry aryDoomedTodos;
	CDoomedEmrObjectAry aryDoomedLabs; // (z.manning 2008-10-08 16:59) - PLID 31628

	// (j.jones 2011-07-11 10:56) - PLID 38366 - track coding groups that will be affected
	CEmrCodingGroupArray aryCodingGroupsToChange;
	CMap<CEmrCodingGroup*, CEmrCodingGroup*, long, long> mapCodingGroupQuantitiesToSubtract;

	if(aryCptActions.GetSize() > 0) {
		// (j.jones 2011-07-11 10:56) - PLID 38366 - track coding groups that will be affected
		GetEmrObjectsToRevoke_eaoCpt(&aryCptActions, aryDoomedCpts, aryCodingGroupsToChange, mapCodingGroupQuantitiesToSubtract);
	}
	if(aryDiagActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoDiag(&aryDiagActions, aryDoomedDiags);
	}
	if(aryMedicationActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoMedication(&aryMedicationActions, aryDoomedMedications);
	}
	if(aryProcedureActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoProcedure(&aryProcedureActions, aryDoomedProcedures);
	}
	if(aryEmrItemActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoEmrItem(&aryEmrItemActions, aryDoomedItems);
	}
	if(aryMintItemsActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoMintItems(&aryMintItemsActions, aryDoomedTopics);
	}
	if(GetParentEMR() && aryMintActions.GetSize() > 0) {
		//Special:  Mint's are handled at the EMR level, not the EMN level.
		GetParentEMR()->GetEmrObjectsToRevoke_eaoMint(&aryMintActions, aryDoomedEMNs);
	}
	if(aryTodoActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoTodo(&aryTodoActions, aryDoomedTodos);
	}
	// (z.manning 2008-10-08 16:59) - PLID 31628 - Unspawning labs
	if(aryLabActions.GetSize() > 0) {
		GetEmrObjectsToRevoke_eaoLab(&aryLabActions, aryDoomedLabs);
	}

	// (c.haag 2008-08-07 10:04) - PLID 30979 - LockHandlingDetailChanges() was never
	// called in RevokeDeletedActions or RevokeDeletedActionsForInfoID before. Since
	// the point of the item is to merely make it so that we know what was going to be
	// unspawned before we unspawn it, and not to change the behavior in any other way,
	// I'm not going to add LockHandlingDetailChanges here.

	// (c.haag 2008-08-07 09:39) - PLID 30979 - Now revoke the actions
	if(aryDoomedCpts.GetSize() > 0 || aryCodingGroupsToChange.GetSize() > 0) {
		try {
			// (j.jones 2011-07-11 10:56) - PLID 38366 - pass in the coding groups that will be affected
			RevokeEmrActions_eaoCpt(aryDoomedCpts, aryCodingGroupsToChange, mapCodingGroupQuantitiesToSubtract);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoCpt");
	}
	if(aryDoomedDiags.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoDiag(aryDoomedDiags);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoDiag");
	}
	if(aryDoomedMedications.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoMedication(aryDoomedMedications);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoMedication");
	}
	if(aryDoomedProcedures.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoProcedure(aryDoomedProcedures);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoProcedure");
	}
	if(aryDoomedItems.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoEmrItem(aryDoomedItems);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoEmrItem");
	}
	if(aryDoomedTopics.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoMintItems(aryDoomedTopics);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoMintItems");
	}
	if(aryDoomedEMNs.GetSize() > 0) {
		//Special:  Mint's are handled at the EMR level, not the EMN level.
		try {
			GetParentEMR()->RevokeEmrActions_eaoMint(aryDoomedEMNs);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoMint");
	}
	if(aryDoomedTodos.GetSize() > 0) { // (c.haag 2008-06-24 10:55) - PLID 17244
		try {
			RevokeEmrActions_eaoTodo(aryDoomedTodos);
		} NxCatchAll("Error in CEMN::RevokeEmrActions() : eaoTodo");
	}
	// (z.manning 2008-10-08 16:48) - PLID 31628 - Revoke labs
	if(aryDoomedLabs.GetSize() > 0) {
		try {
			RevokeEmrActions_eaoLab(aryDoomedLabs);
		}NxCatchAll("CEMN::RevokeEmrActions : eaoLab");
	}
}

void CEMN::RevokeDeletedActions()
{
	// (z.manning, 3/30/2006, PLID 19916) - This should only be called when someone has deleted
	// data actions when editing an EMN template on the fly.

	long nActionTotal = m_arActionsToRevoke.GetSize();
	if(nActionTotal <= 0) {
		// Nothing to revoke
		return;
	}
	ASSERT(m_bIsTemplate);

	// Go through each every element of every detail of every topic in the EMN and check
	// to see if any deleted action was for that element, if so, revoke the action
	// (c.haag 2008-08-07 10:17) - PLID 30979 - We no longer revoke within the loop. Instead,
	// we just gather detail objects, and call RevokeEmrActions.
	MFCArray<CActionAndSource> aryaas;
	for(int nTopicCount = 0; nTopicCount < m_arypEMRTopics.GetSize(); nTopicCount++) {
		CEMRTopic* pTopic = m_arypEMRTopics.GetAt(nTopicCount);
		for(int nDetailCount = 0; nDetailCount < pTopic->GetEMNDetailCount(); nDetailCount++) {
			CEMNDetail* pDetail = pTopic->GetDetailByIndex(nDetailCount);
			for(int nElementCount = 0; nElementCount < pDetail->GetListElementCount(); nElementCount++) {
				ListElement le = pDetail->GetListElement(nElementCount);								
				for(int nDeletedActionCount = 0; nDeletedActionCount < nActionTotal; nDeletedActionCount++) {
					//ONLY process if the data matches the revoked action
					if(m_arActionsToRevoke.GetAt(nDeletedActionCount).eaoSourceType == eaoEmrDataItem
						&& le.nID == m_arActionsToRevoke.GetAt(nDeletedActionCount).nSourceID) {
						// (c.haag 2008-08-07 10:18) - PLID 30979 - Add to the Action-And-Source array
						//RevokeEmrAction(m_arActionsToRevoke.GetAt(nDeletedActionCount), pDetail);
						EmrAction ea = m_arActionsToRevoke.GetAt(nDeletedActionCount);
						if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
							// (z.manning 2009-03-20 11:35) - PLID 15971 - For dropdowns, every row is a potentail source.
							for(int nRow = 0; nRow < pDetail->GetRowCount(); nRow++) {
								TableRow *ptr = pDetail->GetRowPtr(nRow);
								SourceActionInfo sai(&ea, pDetail, ptr);
								CActionAndSource aas(ea, sai);
								aryaas.Add(aas);
							}
						}
						else {
							SourceActionInfo sai(&ea, pDetail);
							CActionAndSource aas(ea, sai);
							aryaas.Add(aas);
						}
					}
				}
			}
		}
	}

	// (c.haag 2008-08-07 10:19) - PLID 30979 - Now revoke the actions
	if (aryaas.GetSize() > 0) {
		RevokeEmrActions(aryaas);
	}

	m_arActionsToRevoke.RemoveAll();
}

void CEMN::RevokeDeletedActionsForInfoID(long nEMRInfoID)
{
	// (j.jones 2006-05-25 11:48) - PLID 20807 - This should only be called when someone has deleted
	// data actions when editing an EMN template on the fly.

	long nActionTotal = m_arActionsToRevoke.GetSize();
	if(nActionTotal <= 0) {
		// Nothing to revoke
		return;
	}
	ASSERT(m_bIsTemplate);

	// Find all occurences of this Info item across the entire EMN, and revoke its deleted actions
	// (c.haag 2008-08-07 10:17) - PLID 30979 - We no longer revoke within the loop. Instead,
	// we just gather detail objects, and call RevokeEmrActions.
	MFCArray<CActionAndSource> aryaas;
	for(int nTopicCount = 0; nTopicCount < m_arypEMRTopics.GetSize(); nTopicCount++) {
		CEMRTopic* pTopic = m_arypEMRTopics.GetAt(nTopicCount);
		for(int nDetailCount = 0; nDetailCount < pTopic->GetEMNDetailCount(); nDetailCount++) {
			CEMNDetail* pDetail = pTopic->GetDetailByIndex(nDetailCount);
			if(pDetail->m_nEMRInfoID == nEMRInfoID) {
				for(int nDeletedActionCount = 0; nDeletedActionCount < nActionTotal; nDeletedActionCount++) {
					// (c.haag 2008-08-07 10:18) - PLID 30979 - Add to the Action-And-Source array
					/*// (z.manning, 04/23/2007) - PLID 24586 - Unspawning of EMNs is handled by the EMR class, so
					// if the action type is spawning an EMN, let the parent EMR take care of it.
					if(m_arActionsToRevoke.GetAt(nDeletedActionCount).eaoDestType == eaoMint) {
						if(GetParentEMR()) {
							GetParentEMR()->RevokeEmrAction(m_arActionsToRevoke.GetAt(nDeletedActionCount), pDetail);
						}
					}
					else {
						RevokeEmrAction(m_arActionsToRevoke.GetAt(nDeletedActionCount), pDetail);
					}*/
					EmrAction ea = m_arActionsToRevoke.GetAt(nDeletedActionCount);
					if(ea.eaoSourceType == eaoEmrTableDropDownItem) {
						// (z.manning 2009-03-20 11:35) - PLID 15971 - For dropdowns, every row is a potentail source.
						for(int nRow = 0; nRow < pDetail->GetRowCount(); nRow++) {
							TableRow *ptr = pDetail->GetRowPtr(nRow);
							SourceActionInfo sai(&ea, pDetail, ptr);
							CActionAndSource aas(ea, sai);
							aryaas.Add(aas);
						}
					}
					else {
						SourceActionInfo sai(&ea, pDetail);
						CActionAndSource aas(ea, sai);
						aryaas.Add(aas);
					}
				}
			}
		}
	}

	// (c.haag 2008-08-07 10:19) - PLID 30979 - Now revoke the actions
	if (aryaas.GetSize() > 0) {
		RevokeEmrActions(aryaas);
	}

	m_arActionsToRevoke.RemoveAll();
}

// (c.haag 2008-07-21 17:50) - PLID 30799 - This will revoke all problems spawned through the given action that are
// bound to the given source detail or a list selection within it. Problems that are bound to the destination object
// (emns, mint items, details, diagnosis codes, charges, etc.) are handled elsewhere in code.
void CEMN::RevokeEmrProblemAction(const EmrAction& ea, CEMNDetail* pSourceDetail)
{
	// First, we only support actions spawned from items, data items or hotspots
	switch (ea.eaoSourceType) {
		case eaoEmrDataItem:
		case eaoEmrItem:
		case eaoEmrImageHotSpot:
		case eaoProcedure:
		case eaoEmrTableDropDownItem: // (z.manning 2009-02-23 16:24) - PLID 33138
		case eaoSmartStamp: // (z.manning 2010-03-02 15:28) - PLID 37571
		case eaoWoundCareCodingCondition: // (r.gonet 08/03/2012) - PLID 51949 - Revoke problems for wound care calculator, 
			{
				// Do for all problem actions corresponding to the EMR action
				// (a.walling 2014-07-01 15:28) - PLID 62697
				for (const EmrProblemAction& epa : ea.aProblemActions) {
					// Only handle cases where we spawn a problem to the source object. Destination 
					// object problem spawning is handled on a case-by-case basis in the RevokeEmrActions_ 
					// function family.
					if (epa.bSpawnToSourceItem) {
						if (ea.eaoSourceType == eaoEmrDataItem || ea.eaoSourceType == eaoEmrItem) {
							EMRProblemRegardingTypes eprt = (ea.eaoSourceType == eaoEmrDataItem) ? eprtEmrDataItem : eprtEmrItem;
							// Do for all problems in the source detail
							// (c.haag 2009-05-29 09:52) - PLID 34293 - Unspawn the problem link; not the problem
							const int nProblemLinks = pSourceDetail->m_apEmrProblemLinks.GetSize();
							for (int j=0; j < nProblemLinks; j++) {
								CEmrProblemLink* pLink = pSourceDetail->m_apEmrProblemLinks[j];
								if (pLink->GetDetail() == pSourceDetail &&
									pLink->GetProblem()->m_nEmrProblemActionID == epa.nID &&
									pLink->GetType() == eprt &&
									!pLink->GetProblem()->m_bIsDeleted)
								{
									// If we get here, the problem must correspond to this action. So, we aim to remove it from the source detail.
									// (c.haag 2008-08-04 17:09) - PLID 30799 - Per the EMR team, we no longer check permissions here. We simply
									// delete the problem; the user should have been warned prior to this code execution.
									// (c.haag 2009-05-29 09:53) - PLID 34293 - Delete the link, not the problem
									//pProblem->m_bIsDeleted = TRUE;
									pLink->SetDeleted();
									// (c.haag 2008-08-21 12:48) - PLID 30799 - The save code requires that this problem be flagged as modified.
									// (c.haag 2009-05-29 09:53) - PLID 34293 - This should not be necessary
									//pProblem->m_bIsModified = TRUE;

									// Now update the icon button on the source detail
									if (NULL != pSourceDetail->m_pEmrItemAdvDlg) {
										pSourceDetail->m_pEmrItemAdvDlg->UpdateProblemStatusButtonAppearance(TRUE);
									}

									// (c.haag 2009-06-04 16:23) - PLID 34293 - Flag the EMR as modified
									if (NULL != GetParentEMR()) {
										GetParentEMR()->SetUnsaved();
									}

									// (c.haag 2008-08-05 15:42) - PLID 30799 - Do not update the EMN problem flag icon.
									// That is done in the unspawner or the code responsible for the unspawning.
								}
							}
						} else {
							// We don't support binding problems to source actions where the source is
							// not an Emr Item or an Emr List Selection.
							ASSERT(FALSE);
						}
					} else {
						// This will be handled elsewhere
					}
				}
			}
			break;
		default:
			ASSERT(FALSE); // Not supported
			break;
	}
}

// (a.walling 2011-10-20 14:23) - PLID 46075 - Clean up interaction with external interfaces
void CEMN::SetInterface(CEmrTreeWnd* pEmrTreeWnd)
{
	m_pInterface = pEmrTreeWnd;
}

// (j.jones 2008-05-20 11:18) - PLID 30079 - added parameter to decide whether to show the prescription editor
// (z.manning 2009-02-26 17:19) - PLID 33141 - Use the source action info class
EMNMedication* CEMN::AddMedication(long nMedicationID, BOOL bShowPrescriptionEditor, BOOL bAlreadyCheckedAllergies, SourceActionInfo &sai)
{
	try {
		// (c.haag 2007-02-02 18:09) - PLID 24561 - We now store medication names in EmrDataT.Data rather than DrugList.Name
		// (d.thompson 2008-12-01) - PLID 32174 - DefaultPills is now DefaultQuantity, Description is now PatientInstructions (and parameterized)
		// (d.thompson 2009-01-15) - PLID 32176 - DrugList.Unit is now DrugStrengthUnitsT.Name, joined from DrugList.StrengthUnitID
		//TES 2/12/2009 - PLID 33034 - Added Strength and Dosage Form
		//TES 3/31/2009 - PLID 33750 - Removed DosageFormID
		// (d.thompson 2009-03-18) - PLID 33481 - StrengthUnitID should have been QuantityUnitID from the start
		// (d.thompson 2009-04-02) - PLID 33571 - Added strength unit
		//TES 8/3/2009 - PLID 35008 - Added DEASchedule
		// (s.dhole 2013-03-15 16:40) - PLID 55509 added DrugList.StrengthUnitID , DrugList.DosageFormID ,DrugList.QuantityUnitID
		// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
		_RecordsetPtr rs = CreateParamRecordset("SELECT EMRDataT.Data AS Name, PatientInstructions, DefaultRefills, DefaultQuantity, "
			"COALESCE(DrugStrengthUnitsT.Name, '') AS Unit, Strength, DrugDosageFormsT.Name AS DosageForm, "
			" StrengthUnitT.Name AS StrengthUnit, DrugList.DEASchedule , "
			" DrugList.StrengthUnitID , DrugList.DosageFormID ,DrugList.QuantityUnitID, "
			" DrugList.DosageUnitID, DrugList.DosageRouteID, DrugList.DosageQuantity, DrugList.DosageFrequency "
			"FROM DrugList "
			"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
			"LEFT JOIN DrugStrengthUnitsT ON DrugList.QuantityUnitID = DrugStrengthUnitsT.ID "
			"LEFT JOIN DrugDosageFormsT ON DrugList.DosageFormID = DrugDosageFormsT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS StrengthUnitT ON DrugList.StrengthUnitID = StrengthUnitT.ID "
			"WHERE DrugList.ID = {INT}", nMedicationID);
		FieldsPtr fields = rs->Fields;

		// (j.jones 2012-11-14 14:08) - PLID 52819 - This pointer is mostly obsolete, as we try to
		// save medications immediately then reload the med. list. It will still be used, however,
		// if the EMN is still loading and the dialog is not shown.
		EMNMedication *pMedication = new EMNMedication;
		pMedication->nID = -1;
		pMedication->nMedicationID = nMedicationID;
		// (d.thompson 2008-12-01) - PLID 32174 - Description is now PatientInstructions
		pMedication->strPatientExplanation = AdoFldString(fields, "PatientInstructions");
		// (j.jones 2010-05-07 11:05) - PLID 36062 - calculate the EnglishDescription
		pMedication->strEnglishDescription = GetLatinToEnglishConversion(pMedication->strPatientExplanation);
		pMedication->strRefillsAllowed = AdoFldString(fields, "DefaultRefills");
		// (d.thompson 2008-12-01) - PLID 32174 - DefaultPills is now DefaultQuantity
		pMedication->strQuantity = AdoFldString(fields, "DefaultQuantity");
		pMedication->strUnit = AdoFldString(fields, "Unit");
		//TES 8/3/2009 - PLID 35008 - Added DEASchedule
		pMedication->strDEASchedule = AdoFldString(fields, "DEASchedule", "");
		// (s.dhole 2013-03-07 16:39) - PLID 55509
		pMedication->nStrengthUnitID = AdoFldLong (fields, "StrengthUnitID", -1);
		pMedication->nDosageFormID = AdoFldLong(fields, "DosageFormID", -1);
		pMedication->nQuantityUnitID = AdoFldLong(fields, "QuantityUnitID", -1);

		// (d.thompson 2009-03-12) - PLID 33482 - If the quantity or qty units are blank, that means they've got
		//	some screwy data, and we really want them to fix it.  Most likely it happened due to the 9100 changes
		//	that moved Unit from free text to a defined field.  Pop up the "correction" dialog, which will update
		//	data and give us back the results.
		if(AdoFldString(fields, "DefaultQuantity", "").IsEmpty() || AdoFldString(fields, "Unit", "").IsEmpty()) {
			CCorrectMedicationQuantitiesDlg dlg(GetInterface());
			dlg.m_nDrugListID = nMedicationID;
			if(dlg.DoModal() == IDOK) {
				pMedication->strQuantity = dlg.m_strOutputDefQty;
				pMedication->strUnit = dlg.m_strOutputQtyUnit;
			}
			else {
				// (j.jones 2012-11-21 11:48) - PLID 53818 - This is now required at all times, when opening from
				// either an EMN or a template.
				delete pMedication;
				return NULL;
			}
		}
		else {
			//quantity and unit are both filled, there's no need to fix anything
		}

		pMedication->SetChanged_Deprecated();
		pMedication->sai = sai;
		pMedication->m_strDrugName = AdoFldString(fields, "Name", "");

		//TES 2/12/2009 - PLID 33034 - Added Strength and Dosage Form
		//TES 3/31/2009 - PLID 33750 - Removed DosageFormID
		pMedication->strStrength = AdoFldString(fields, "Strength", "");
		pMedication->strDosageForm = AdoFldString(fields, "DosageForm", "");
		// (d.thompson 2009-04-02) - PLID 33571 - added strength unit
		pMedication->strStrengthUnit = AdoFldString(fields, "StrengthUnit", "");
		// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
		pMedication->nDosageUnitID = AdoFldLong(fields, "DosageUnitID", -1);
		pMedication->nDosageRouteID = AdoFldLong(fields, "DosageRouteID", -1);
		pMedication->strDosageQuantity = AdoFldString(fields, "DosageQuantity", "");
		pMedication->strDosageFrequency = AdoFldString(fields, "DosageFrequency", "");

		// (j.jones 2008-05-20 10:03) - PLID 30079 - added other fields that the prescription editor uses

		//use the first provider

		pMedication->nProviderID = -1;
		if(m_aryProviders.GetSize() > 0) {
			EMNProvider *pProv = GetProvider(0);
			if(pProv) {
				pMedication->nProviderID = pProv->nID;
			}
		}

		//use the EMN location
		pMedication->nLocationID = GetLocationID();
		if(pMedication->nLocationID == -1) {
			pMedication->nLocationID = GetCurrentLocationID();
		}

		pMedication->nPharmacyID = -1;

		// (c.haag 2009-01-27 16:33) - PLID 32868 - Only get a patient name if this is not an EMR template
		if(GetParentEMR() && !m_bIsTemplate) {
			pMedication->nPatientID = GetParentEMR()->GetPatientID();
			pMedication->strPatientName = GetExistingPatientName(pMedication->nPatientID);
		}
		else {
			pMedication->nPatientID = -1;
			pMedication->strPatientName = "";
		}

		//use the EMN date
		pMedication->dtPrescriptionDate = GetEMNDate();

		rs->Close();

		// (j.jones 2012-10-31 11:28) - PLID 52818 - If we are still loading the EMN,
		// add the medication and return. Otherwise, force a save before calling the prescription dialog.
		if(IsLoading()) {
			AddMedication(pMedication);
			return pMedication;
		}
		else {
			CEmrTreeWnd* pTreeWnd = GetInterface();
			//TES 2/12/2014 - PLID 60740 - No need to check IsMoreInfoUnsaved() if we've already checked IsUnsaved()
			if(pTreeWnd && (IsUnsaved() || GetID() == -1) && IsWritable()) {
				if(FAILED(pTreeWnd->SaveEMR(esotEMN, (long)this, FALSE))) {
					//Warn if this happened. Presumably the user has already been told why the save failed.
					if(pMedication) {
						if (GetInterface() && ::IsWindow(GetInterface()->GetSafeHwnd())) {
							CString strWarn;
							strWarn.Format("The EMN must be saved before a medication can be added. "
								"Because the save was cancelled, the prescription for %s was not created.\n\n"
								"You will need to re-create this prescription after the EMN has been successfully saved.", pMedication->m_strDrugName);
							GetInterface()->MessageBox(strWarn, "Practice", MB_ICONEXCLAMATION|MB_OK);
						}
						delete pMedication;
					}
					return NULL;
				}
			}

			// (a.walling 2009-04-22 10:49) - PLID 28957 - Use the proper parent
			// (a.walling 2009-04-23 09:41) - PLID 28957 - Also pass in the IsSpawned parameter
			// (j.jones 2012-10-31 15:15) - PLID 52819 - provide the EMN ID and template status
			CPrescriptionEditDlg dlg(GetInterface(), GetID(), m_bIsTemplate);

			// (b.savon 2014-08-26 10:38) - PLID 63401 - Spawning a prescription from EMR does not request eligibility or check for formulary.
			long nInsuranceID = -1;
			if (g_pLicense->HasEPrescribing(CLicense::cflrSilent) == CLicense::eptSureScripts && GetParentEMR()->GetPatientID() != -1) {
				nInsuranceID = CheckExistingFormularyData(GetInterface(), GetParentEMR()->GetPatientID());
			}

			// (j.jones 2012-11-16 11:34) - PLID 53765 - this now returns an enum of whether we created or deleted a prescription
			// (j.jones 2012-11-19 09:37) - PLID 52819 - we will always save the medication immediately,
			// bShowPrescriptionEditor will determine whether we see the dialog after it saves
			// (j.fouts 2013-03-12 10:19) - PLID 52973 - Seperated Creating a prescription out from the prescription Edit Dlg
			// (b.savon 2014-08-26 10:38) - PLID 63401 - Spawning a prescription from EMR does not request eligibility or check for formulary.
			NexTech_Accessor::_UpdatePresQueueResultsPtr pResults = SaveNewPrescription(nMedicationID, FALSE, NULL, GetParentEMR()->GetPatientID(),
				pMedication->nProviderID, pMedication->nLocationID, GetEMNDate(), GetID(), m_bIsTemplate, sai, -1, -1, nInsuranceID);

			Nx::SafeArray<IUnknown*> saryPrescriptions(pResults->PrescriptionsAdded);
			
			// (b.savon 2013-03-19 17:03) - PLID 55477 - Use struct
			PrescriptionInfo rxInformation;
			NexTech_Accessor::_QueuePrescriptionPtr pPrescription = saryPrescriptions[0];
			rxInformation.pPrescription = pPrescription;
			rxInformation.saryPrescribers = pResults->Prescriber;
			rxInformation.sarySupervisors = pResults->Supervisor;
			rxInformation.saryNurseStaff = pResults->NurseStaff;
			rxInformation.erxUserRole = pResults->UserRole;

			if(saryPrescriptions.GetCount() == 0)
			{
				ThrowNxException("Attempted to create a new prescription, but no prescription was returned."); 
			}

			PrescriptionDialogReturnValue epdrvReturn = epdrvEditRx;
			if(bShowPrescriptionEditor)
			{
				// (j.jones 2013-11-25 09:55) - PLID 59772 - for new prescriptions we pass in the drug interactions info
				// only if they didn't disable real-time drug interactions
				DrugInteractionInfo *pDrugInteractionInfo = NULL;
				DrugInteractionInfo drugInteractionInfo;
				EMRDrugInteractionCheckType eDrugInteractionPref = pTreeWnd->GetEMRDrugInteractionChecksPref();
				if(eDrugInteractionPref != edictNoPrompt && eDrugInteractionPref != edictWarnWhenClosingOrLocking) {				
					if(pResults->DrugDrugInteracts) {
						drugInteractionInfo.saryDrugDrugInteracts = pResults->DrugDrugInteracts;
					}
					if(pResults->DrugAllergyInteracts) {
						drugInteractionInfo.saryDrugAllergyInteracts = pResults->DrugAllergyInteracts;
					}
					if(pResults->DrugDiagnosisInteracts) {
						drugInteractionInfo.saryDrugDiagnosisInteracts = pResults->DrugDiagnosisInteracts;
					}
					pDrugInteractionInfo = &drugInteractionInfo;
				}

				// (j.jones 2016-01-06 15:40) - PLID 67823 - filled bIsNewRx
				epdrvReturn = (PrescriptionDialogReturnValue)dlg.EditPrescription(true, rxInformation, pDrugInteractionInfo);

				// (j.fouts 2013-03-12 15:03) - PLID 52973 - The edit dlg is no longer respnsible for creating new prescriptions
				//It will only return epdrvEditRx or epdrvDeleteRx, so if we didn't delete the prescription we just made set the
				//update EMNMedication object with the values from the new prescription
				// (s.dhole 2013-05-30 16:44) - PLID  - PLID 56734 this may return epdrvErrorRx if there is sure script error
				if(epdrvReturn == epdrvEditRx ||  epdrvReturn == epdrvErrorRx ) {
					//set the prescription ID
					pMedication->nID = dlg.GetPrescriptionID();
					// (j.jones 2013-01-08 12:42) - PLID 47303 - also need the sig, it's later sent to med. reconciliation
					pMedication->strPatientExplanation = dlg.GetPatientExplanation();
				}
				else if(epdrvReturn == epdrvDeleteRx) {
					pMedication->nID = -1;
				}
				else {
					//there shouldn't have been any other return type other than
					//Edit or Delete, if you hit this it's ok, find out what the return value was
					ASSERT(FALSE);
					pMedication->nID = -1;
				}
			}
			else {
				// (j.jones 2012-11-19 09:37) - PLID 52819 - if we didn't show the editor, we know we made the prescription
				// and our current pointer has the correct information
				pMedication->nID = AsLong(pPrescription->PrescriptionID);
				// (j.jones 2013-01-08 12:42) - PLID 47303 - also need the sig, it's later sent to med. reconciliation
				pMedication->strPatientExplanation = (LPCTSTR)pPrescription->PatientExplanation;
			}
		}

		//the caller needs to ensure the EMN reloads its medications
		return pMedication;

	}NxCatchAll("Error in CEMN::AddMedication()");
	
	return NULL;
}

// (c.haag 2008-06-24 09:26) - PLID 17244 - Adds a todo alarm to data and creates an EMNTodo
// object in memory for tracking purposes
void CEMN::AddTodo(const EmrAction& ea, SourceActionInfo &sai)
{
	if (m_bIsTemplate) {
		ThrowNxException("Attempted to create a todo for an EMR template");
	} else if (NULL == sai.pSourceDetail) {
		ThrowNxException("Attempted to create a todo without a source detail");
	} else if (GetParentEMR()->GetPatientID() == -1) {
		ThrowNxException("Attempted to create a todo without a valid patient");
	}

	// First, calculate the deadline and remind dates
	COleDateTime dtDeadline = COleDateTime::GetCurrentTime();
	COleDateTime dtRemind = COleDateTime::GetCurrentTime();
	MoveTodoDate(dtDeadline, ea.nTodoDeadlineType, ea.nTodoDeadlineInterval);
	MoveTodoDate(dtRemind, ea.nTodoRemindType, ea.nTodoRemindInterval);

	// Now get the assign tos
	// (a.walling 2014-07-01 15:28) - PLID 62697
	std::vector<long> anAssignTo = ea.anTodoAssignTo;
	
	// (c.haag 2008-06-25 09:33) - PLID 30505 - Check the assign-to list for special
	// sentinel values, and deal with them accordingly
	for (int i=0; i < (int)anAssignTo.size(); i++) {
		switch ((EMRTodoSpecialAssignees)anAssignTo[i]) {
		case etsaLoggedInUser:
			{
				long nUserID = GetCurrentUserID();
				if (boost::exists(anAssignTo, nUserID)) {
					// Already in the array -- just discard the sentinel value
					anAssignTo.erase(anAssignTo.begin() + i--);
				} else {
					// Not in the array; add it
					anAssignTo[i] = nUserID;
				}
			}
			break;
		case etsaPatientCoordinator:
			{
				_RecordsetPtr prs = CreateParamRecordset("SELECT EmployeeID FROM PatientsT WHERE PersonID = {INT}",
					GetParentEMR()->GetPatientID());
				if (!prs->eof) {
					long nPatCoordID = AdoFldLong(prs, "EmployeeID", -1);
					if (nPatCoordID > -1) {
						// Found a valid patient coordinator
						if (boost::exists(anAssignTo, nPatCoordID)) {
							// Already in the array
							anAssignTo.erase(anAssignTo.begin() + i--);
						} else {
							// Needs to be added to the array
							anAssignTo[i] = nPatCoordID;
						}
					} else {
						// No valid patient coordinator. Remove this assignee.
						anAssignTo.erase(anAssignTo.begin() + i--);
					}
				} else {
					// No valid patient coordinator. Remove this assignee.
					anAssignTo.erase(anAssignTo.begin() + i--);
				}
			}
			break;

		}
	}

	// If the following is true, it means we have nobody to assign the todo alarm to; so
	// don't create it at all
	if (anAssignTo.empty()) {
		return;
	}

	CArray<long, long> mfcAssignTo;
	for (long assignTo : anAssignTo) {
		mfcAssignTo.Add(assignTo);
	}
	
	// Now calculate the notes
	// (c.haag 2010-02-02 11:28) - PLID 33925 - We now let the user decide to include the
	// EMN name and detail name
	//CString strNotes = FormatString("EMN: %s\r\nDetail: %s\r\n%s",
	//	m_strDescription, sai.pSourceDetail->GetLabelText(), ea.strTodoNotes);
	CString strNotes;
	int nTodoNoteFlags = GetRemotePropertyInt("EmrSpawnedTodoFormat", 3, 0, "<None>", true);
	if (nTodoNoteFlags & 0x00000001) {
		strNotes += FormatString("EMN: %s\r\n", m_strDescription);
	}
	if (nTodoNoteFlags & 0x00000002) {
		strNotes += FormatString("Detail: %s\r\n", sai.pSourceDetail->GetLabelText());
	}
	strNotes += ea.strTodoNotes;

	// (c.haag 2008-06-25 15:06) - PLID 17244 - I'm leaving this commented out on purpose.
	// It's possible that we want multiple todos for the same regarding type and detail; the
	// following code would make that not work. I want to make sure that developers see that
	// this was something I had considered, and later dismissed as an idea during general item
	// testing and desiging.
	// (c.haag 2008-07-10 16:13) - PLID 30674 - This is now altogether moot because now we track
	// the source action ID of spawned todo alarms. I'm still keeping everything in for
	// posterity.
	//
	// Make sure we don't already have a todo for this item
	//if (pSourceDetail->m_nEMRDetailID > 0) {
	//	TodoDelete(FormatString("RegardingType = %d and RegardingID = %d",
	//		(long)ttEMNDetail, pSourceDetail->m_nEMRDetailID));
	//}

	// Create the todo alarm in data
	// (c.haag 2008-07-10 14:57) - PLID 30674 - Include the source action ID
	// (c.haag 2008-07-14 12:33) - PLID 17244 - The regarding ID should be -1, whether or not
	// the EMN is saved
	// (c.haag 2008-07-16 11:05) - PLID 17244 - Before we create the todo, check to see if it was deleted. This can happen if
	// you open an existing EMN, unspawn and respawn a todo alarm. If that happens, we want to restore the original todo.
	long nTodoID = -1;
	const int nUnspawned = m_apDeletedTodosWhileUnsaved.GetSize();
	for (i=0; i < nUnspawned; i++) {
		EMNTodo* pTodo = m_apDeletedTodosWhileUnsaved[i];
		if (pTodo->sai.nSourceActionID == ea.nID &&
			pTodo->sai.HasSameSource(sai)) {
			// Yep, it was deleted before the topic was saved. So, pull that todo's information. Unlike with creating new
			// todo alarms, here we want the old regarding ID to be used when recreating the old todo.
			nTodoID = TodoCreate(VarDateTime(pTodo->vRemind),
					VarDateTime(pTodo->vDeadline),
					pTodo->anAssignTo,
					VarString(pTodo->vNotes),
					VarString(pTodo->vTask),					
					VarLong(pTodo->vRegardingID),
					(TodoType)VarLong(pTodo->vRegardingType),
					VarLong(pTodo->vPersonID), // This should *never* be null
					VarLong(pTodo->vLocationID, -1),
					(TodoPriority)VarByte(pTodo->vPriority),
					VarLong(pTodo->vCategoryID, -1),
					VarDateTime(pTodo->vDone, (DATE)0),
					VarLong(pTodo->vEnteredBy),
					pTodo->sai.nSourceActionID,
					pTodo->sai.GetDataGroupID()
					);
			break;
		}
	} // for (i=0; i < nUnspawned; i++) {

	if (-1 == nTodoID) {
		nTodoID = TodoCreate(dtRemind, dtDeadline, mfcAssignTo, strNotes,
			ea.strTodoMethod, -1, ttEMNDetail, 
			GetParentEMR()->GetPatientID(), GetLocationID(), (TodoPriority)ea.nTodoPriority, ea.nTodoCategoryID, (DATE)0,
			GetCurrentUserID(), ea.nID, sai.GetDataGroupID());
	}

	// (c.haag 2008-07-08 15:42) - PLID 17244 - Audit the todo creation. Unfortunately we have to query data to get the names.
	_RecordsetPtr prsNewTodo = CreateParamRecordset("SELECT dbo.GetTodoAssignToNamesString({INT}) AS AssignToNames, (SELECT Description FROM NoteCatsF WHERE ID = {INT}) AS Category", nTodoID, ea.nTodoCategoryID);
	if (!prsNewTodo->eof) {
		CString strAssignTo = AdoFldString(prsNewTodo, "AssignToNames");
		CString strCategory = AdoFldString(prsNewTodo, "Category", "");
		CString strAuditNotes = strNotes;
		long nAuditID = BeginNewAuditEvent();
		// CR and LF's don't show up in the audit trail elegantly; replace them with spaces or else the note will look ugly
		strAuditNotes.Replace(10, ' ');
		strAuditNotes.Replace(13, ' ');
		CString strNew = FormatString("Assigned To: %s, Deadline: %s, Category: %s, Note: %s", 
			strAssignTo, FormatDateTimeForInterface(dtDeadline, 0, dtoDate), strCategory, strAuditNotes);
		AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditID, aeiPatientToDoCreated, nTodoID, "", strNew, aepMedium, aetCreated);

		// (c.haag 2008-07-09 11:30) - PLID 30648 - The parent topic is responsible for keeping
		// track of what todo alarms were spawned during the course of the topic being unsaved.
		// Notify the topic of the addition.
		// (c.haag 2008-07-14 12:34) - PLID 30696 - The parent topic no longer tracks it; now it's
		// all in the EMN
		// (c.haag 2012-10-17) - PLID 52863 - Use the overload for spawned todo alarms
		_variant_t vNull;
		vNull.vt = VT_NULL;
		AddCreatedTodoWhileUnsaved(nTodoID, ea, sai,
			_variant_t(dtRemind, VT_DATE),
			vNull, // Done
			_variant_t(dtDeadline, VT_DATE),
			(long)GetCurrentUserID(),
			(long)GetParentEMR()->GetPatientID(),
			_bstr_t(strNotes),
			(long)GetLocationID(),
			(long)ttEMNDetail,
			mfcAssignTo,
			_bstr_t(strAssignTo)
			);

		// (c.haag 2008-07-07 13:36) - PLID 30607 - Update the todo list in the more info
		// window if it exists
		if (GetInterface()) {
			GetInterface()->PostMessage(NXM_EMN_TODO_ADDED, (WPARAM)this, (LPARAM)nTodoID);
		}
		
		// Whether or not the detail has a regarding ID, we need to fire a table checker
		// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Ex Todo
		if (mfcAssignTo.GetSize() == 1){
			CClient::RefreshTodoTable(nTodoID, GetParentEMR()->GetPatientID(), mfcAssignTo[0], TableCheckerDetailIndex::tddisAdded);
		}
		else{
			CClient::RefreshTodoTable(nTodoID, GetParentEMR()->GetPatientID(), -1, TableCheckerDetailIndex::tddisAdded);
		}
		
	}
	else {
		// It should not be possible to get here
	}
}

// (c.haag 2008-06-24 09:39) - PLID 17244 - Takes a todo date (remind or deadline) and
// increments it based on the type and interval of the todo spawner
void CEMN::MoveTodoDate(COleDateTime& dt, long nType, long nInterval)
{
	switch (nType) {
	case 0: // Days
		dt += COleDateTimeSpan(1 * nInterval,0,0,0);
		break;
	case 1: // Weeks
		dt += COleDateTimeSpan(7 * nInterval,0,0,0);
		break;
	case 2: // Months
		{
			// (s.dhole 2012-08-01 09:11) PLID 51912 code change  to support date  as 31 or leap year date 29
			// COleDateTime month range is 1-12
			long nDay = dt.GetDay();
			long nYears =dt.GetYear() + (nInterval / 12);
			long nMonths = nInterval % 12;
			long nCurrentMonths = dt.GetMonth();
			dt.SetDate( nYears , nCurrentMonths , dt.GetDay() );
			// for leap year  day > 28 then check valid day of month 
			long nNewDay = nDay;
			if (nDay>28){
				// set correct month day
				while ( dt.GetStatus() == COleDateTime::invalid && nNewDay >28){
					nNewDay --;
					dt.SetDate(nYears, nCurrentMonths , nNewDay );
				}
			}
			while (nMonths > 0) {
				long nTempMonths =1;
				if (dt.GetMonth() == 12) {
					nYears = dt.GetYear() + 1;
					nTempMonths = 1;
				} else {
					nYears = dt.GetYear() ;	
					nTempMonths =dt.GetMonth() +1;
				}
				dt.SetDate( nYears , nTempMonths, nDay );
				if (nDay>28){
					nNewDay = nDay;
					while (dt.GetStatus() == COleDateTime::invalid && nNewDay>28){
						nNewDay--;
						dt.SetDate(nYears, nTempMonths, nNewDay);
					}
				}
				nMonths--;
			}
		}
		break;
	case 3: // Years
		{
			// (s.dhole 2012-08-01 09:11) PLID 51912 code change  to support date  as 31 or leap year date 29
			// use breackpoit 
			long nDay = dt.GetDay();
			long nMonth= dt.GetMonth();
			long nYears =dt.GetYear() + nInterval;
			dt.SetDate( nYears , nMonth, dt.GetDay() );
			// for leap year  day > 28 then check valid day of month 
			while (dt.GetStatus() == COleDateTime::invalid && nDay >28){
				nDay --;
				dt.SetDate(nYears, nMonth, nDay );
			}
		}
		break;
	default:
		break;
	}
}


// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code

// (j.jones 2008-10-30 17:24) - PLID 31869 - passed in a connection pointer
// (a.walling 2009-11-17 16:51) - PLID 36365
void CEMN::LoadGenericNarrativeFields(CNarrativeMergeFieldMap &mapGenericMergeFields, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	// (j.jones 2008-10-30 17:32) - PLID 31869 - converted to support a passed-in connection
	_ConnectionPtr pCon;
	if(lpCon) {
		pCon = lpCon;
	}
	else {
		pCon = GetRemoteData();
	}

	// (c.haag 2007-08-06 09:28) - PLID 26858 - This function populates arFields with general narrative
	// fields. This code was ripped from LoadAllNarratives.
	if(GetParentEMR()->GetPatientID() != -1) {
		CString strFirst = m_strPatNameFirst;
		CString strMiddle = m_strPatNameMiddle;
		CString strLast = m_strPatNameLast;

		CString strNameLfm = strLast + ", " + strFirst + " " + strMiddle;
		mapGenericMergeFields.SetAt("Name", NarrativeMergeField("Name", strNameLfm, strNameLfm, false, false, false, false, -1, true, false));
		mapGenericMergeFields.SetAt("Name (First)", NarrativeMergeField("Name (First)", strFirst, strFirst, false, false, false, false, -1, true, false));
		mapGenericMergeFields.SetAt("Name (Middle)", NarrativeMergeField("Name (Middle)", strMiddle, strMiddle, false, false, false, false, -1, true, false));
		mapGenericMergeFields.SetAt("Name (Last)", NarrativeMergeField("Name (Last)", strLast, strLast, false, false, false, false, -1, true, false));

		//for pronouns
		long nGender = m_cbPatientGender;

		CString strMaleFemaleUpper, strMaleFemaleLower, strHeSheUpper, strHeSheLower,
			strHimHerUpper, strHimHerLower, strHisHerUpper, strHisHerLower;

		switch(nGender) {
			case 1:
				strMaleFemaleUpper = "Male";
				strMaleFemaleLower = "male";
				strHeSheUpper = "He";
				strHeSheLower = "he";
				strHimHerUpper = "Him";
				strHimHerLower = "him";
				strHisHerUpper = "His";
				strHisHerLower = "his";
				break;
			case 2:
				strMaleFemaleUpper = "Female";
				strMaleFemaleLower = "female";
				strHeSheUpper = "She";
				strHeSheLower = "she";
				strHimHerUpper = "Her";
				strHimHerLower = "her";
				strHisHerUpper = "Her";
				strHisHerLower = "her";
				break;
			case 0:
			default:
				strMaleFemaleUpper = "";
				strMaleFemaleLower = "";
				strHeSheUpper = "";
				strHeSheLower = "";
				strHimHerUpper = "";
				strHimHerLower = "";
				strHisHerUpper = "";
				strHisHerLower = "";
				break;
		}

		mapGenericMergeFields.SetAt("Male/Female", NarrativeMergeField("Male/Female", strMaleFemaleUpper, strMaleFemaleUpper, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("male/female", NarrativeMergeField("male/female", strMaleFemaleLower, strMaleFemaleLower, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("He/She", NarrativeMergeField("He/She", strHeSheUpper, strHeSheUpper, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("he/she", NarrativeMergeField("he/she", strHeSheLower, strHeSheLower, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("Him/Her", NarrativeMergeField("Him/Her", strHimHerUpper, strHimHerUpper, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("him/her", NarrativeMergeField("him/her", strHimHerLower, strHimHerLower, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("His/Her", NarrativeMergeField("His/Her", strHisHerUpper, strHisHerUpper, false, false, false, true, -1, true, false));
		mapGenericMergeFields.SetAt("his/her", NarrativeMergeField("his/her", strHisHerLower, strHisHerLower, false, false, false, true, -1, true, false));

		mapGenericMergeFields.SetAt("Age", NarrativeMergeField("Age", m_strPatientAge, m_strPatientAge, false, false, false, false, -1, true, false));
	}
	else {
		mapGenericMergeFields.SetAt("Name", NarrativeMergeField("Name", "", "", false, false, false, false, -1, false, false));
		mapGenericMergeFields.SetAt("Name (First)", NarrativeMergeField("Name (First)", "", "", false, false, false, false, -1, false, false));
		mapGenericMergeFields.SetAt("Name (Middle)", NarrativeMergeField("Name (Middle)", "", "", false, false, false, false, -1, false, false));
		mapGenericMergeFields.SetAt("Name (Last)", NarrativeMergeField("Name (Last)", "", "", false, false, false, false, -1, false, false));
		mapGenericMergeFields.SetAt("Male/Female", NarrativeMergeField("Male/Female", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("male/female", NarrativeMergeField("male/female", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("He/She", NarrativeMergeField("He/She", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("he/she", NarrativeMergeField("he/she", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("Him/Her", NarrativeMergeField("Him/Her", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("him/her", NarrativeMergeField("him/her", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("His/Her", NarrativeMergeField("His/Her", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("his/her", NarrativeMergeField("his/her", "", "", false, false, false, true, -1, false, false));
		mapGenericMergeFields.SetAt("Age", NarrativeMergeField("Age", "", "", false, false, false, false, -1, false, false));
	}
}

// (a.walling 2009-11-18 12:10) - PLID 36365
void CEMN::LoadLWNarrativeFields(CNarrativeMergeFieldMap &mapGenericMergeFields, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	_ConnectionPtr pCon;
	if(lpCon) {
		pCon = lpCon;
	}
	else {
		pCon = GetRemoteData();
	}

	// (j.jones 2008-01-11 13:21) - PLID 18709 - load all the LW merge fields
	CStringSortedArrayNoCase aryFieldList;
	// (j.jones 2008-10-30 17:24) - PLID 31869 - passed in a connection pointer
	LoadLWMergeFieldList(aryFieldList, pCon);
	int i=0;
	for(i=0;i<aryFieldList.GetSize();i++) {
		CString strMergeField = aryFieldList.GetAt(i);
		mapGenericMergeFields.SetAt(strMergeField, NarrativeMergeField(strMergeField, "", "", false, false, false, false, -1, false, true));
	}
}

// (j.jones 2008-10-30 17:24) - PLID 31869 - passed in a connection pointer
// (a.walling 2009-11-17 16:56) - PLID 36365
void CEMN::LoadEmnNarrativeFields(CNarrativeMergeFieldMap &mapGenericMergeFields, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	// (j.jones 2008-10-30 17:32) - PLID 31869 - converted to support a passed-in connection
	_ConnectionPtr pCon;
	if(lpCon) {
		pCon = lpCon;
	}
	else {
		pCon = GetRemoteData();
	}

	if(!m_bIsTemplate) {
		//We're on an actual EMN, load from the screen.
		//TES 12/26/2006 - PLID 23400 - There could be multiple providers now.
		CString strProviders;
		for(int i = 0; i < m_aryProviders.GetSize(); i++) {
			strProviders += m_aryProviders[i]->strName + "; ";
		}
		if(strProviders.IsEmpty()) {
			strProviders = "<No Provider>";
		}
		else {
			//Trim the last semicolon.
			strProviders = strProviders.Left(strProviders.GetLength()-2);
		}
		mapGenericMergeFields.SetAt("Provider", NarrativeMergeField("Provider", strProviders, strProviders, false, false, false, false, -1, true, false));

		CString strDate;
		strDate = FormatDateTimeForInterface(m_dtEMNDate, 0, dtoDate, false);
		mapGenericMergeFields.SetAt("Date", NarrativeMergeField("Date", strDate, strDate, false, false, false, false, -1, true, false));
	}
	else {
		mapGenericMergeFields.SetAt("Provider", NarrativeMergeField("Provider", "", "", false, false, false, false, -1, false, false));
		mapGenericMergeFields.SetAt("Date", NarrativeMergeField("Date", "", "", false, false, false, false, -1, false, false));
	}

	// (a.walling 2010-03-29 08:27) - PLID 37923 - Ensure the Spawning EMN Text field is populated
	EnsureSpawningEMNTextMergeField(&mapGenericMergeFields, lpCon);
}

// (a.walling 2010-03-29 08:26) - PLID 37923 - Ensure the Spawning EMN Text field is populated
bool CEMN::EnsureSpawningEMNTextMergeField(CNarrativeMergeFieldMap* pmapGenericMergeFields /*= NULL*/, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	if (!pmapGenericMergeFields) {
		pmapGenericMergeFields = &m_mapGenericMergeFields;
	}

	CString strEMNSpawningText;
	CString strEMNSpawningTextSentence;

	// (a.walling 2010-04-01 10:44) - PLID 38013 - Consolidating some constant text strings
	bool bFound = false;
	if (m_bIsTemplate) {
		pmapGenericMergeFields->SetAt(NFIELD_EMN_SPAWNING_TEXT, NarrativeMergeField(NFIELD_EMN_SPAWNING_TEXT, "", "", false, false, false, false, -1, true, false));
	} else {
		// (a.walling 2010-03-26 17:26) - PLID 37923 - Get the value from the other EMN if possible
		if (!m_sai.IsBlank()) {
			CEMN* pSourceEMN = NULL;
			CEMNDetail* pSourceDetail = NULL;

			if (m_sai.pSourceDetail && m_sai.pSourceDetail->m_pParentTopic) {
				// These will be available only during the initial spawn
				pSourceEMN = m_sai.pSourceDetail->m_pParentTopic->GetParentEMN();
				pSourceDetail = m_sai.pSourceDetail;
			} else if (m_sai.nSourceDetailID != -1) {
				// Otherwise, we don't have any pointers.
				CEMR* pParentEMR = GetParentEMR();
				if (pParentEMR) {
					for (int i = 0; i < pParentEMR->GetEMNCount() && pSourceDetail == NULL; i++) {
						CEMN* pEMN = pParentEMR->GetEMN(i);
						if (pEMN && pEMN != this && !pEMN->IsLoading()) {
							pSourceDetail = pEMN->GetDetailByID(m_sai.nSourceDetailID);
							if (pSourceDetail) {
								pSourceEMN = pEMN;
								break;
							}
						}
					}
				}
			}

			if (pSourceEMN && pSourceDetail && !pSourceEMN->IsLoading()) {
				// ensure our table rows and etc are available
				pSourceDetail->LoadContent(FALSE, NULL, lpCon);

				// (a.walling 2010-08-23 16:13) - PLID 37923 - Get the table if our source is the image
				if (pSourceDetail->IsSmartStampImage()) {
					pSourceDetail = pSourceDetail->GetSmartStampTableDetail();
					if (pSourceDetail) {
						pSourceDetail->LoadContent(FALSE, NULL, lpCon);
					}
				}

				if (pSourceDetail && pSourceDetail->IsSmartStampTable()) {

					TableRow* pCurrentTableRow = NULL;

					// may not always be available in memory, so first just try to get it from what is loaded
					if (m_sai.GetDetailStampID() != -1) {
						EmrDetailImageStamp* pEmrDetailImageStamp = pSourceDetail->GetDetailImageStampByID(m_sai.GetDetailStampID());

						if (pEmrDetailImageStamp) {
							pCurrentTableRow = pSourceDetail->GetRowByDetailStamp(pEmrDetailImageStamp);
						}
					}

					if (pCurrentTableRow == NULL) {
						// this will only be available in the initial spawn
						pCurrentTableRow = m_sai.GetTableRow();
					}

					if (NULL != pCurrentTableRow) {
						// special case -- if a smart stamp table, just get the row we are interested in.						
						strEMNSpawningText = pSourceEMN->GetDataOutput(pSourceDetail, NULL, false, false, NULL, ecfParagraph, NULL, lpCon, &pCurrentTableRow->m_ID);
						strEMNSpawningTextSentence = pSourceEMN->GetSentence(pSourceDetail, NULL, false, false, ecfParagraph, strEMNSpawningText, NULL, lpCon);
					
						bFound = true;
					} else {
						// who knows?
					}
				} else {

					strEMNSpawningText = pSourceEMN->GetDataOutput(pSourceDetail, NULL, false, false, NULL, ecfParagraph, NULL, lpCon);
					strEMNSpawningTextSentence = pSourceEMN->GetSentence(pSourceDetail, NULL, false, false, ecfParagraph, strEMNSpawningText, NULL, lpCon);
				
					bFound = true;
				}				
			}

			// this field is only 'filled' if we were able to actually determine the value.
			pmapGenericMergeFields->SetAt(NFIELD_EMN_SPAWNING_TEXT, NarrativeMergeField(NFIELD_EMN_SPAWNING_TEXT, strEMNSpawningText, strEMNSpawningTextSentence, false, false, false, false, -1, bFound, false));
		} else {
			pmapGenericMergeFields->SetAt(NFIELD_EMN_SPAWNING_TEXT, NarrativeMergeField(NFIELD_EMN_SPAWNING_TEXT, "", "", false, false, false, false, -1, true, false));
		}
	}

	return bFound;
}

// (j.jones 2008-01-11 13:15) - PLID 18709 - takes in an array and loads in the names of all
// available merge fields
void CEMN::LoadLWMergeFieldList(CStringSortedArrayNoCase &aryFieldList, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	// (j.jones 2008-10-30 17:25) - PLID 31869 - converted to support a passed-in connection
	_ConnectionPtr pCon;
	if(lpCon) {
		pCon = lpCon;
	}
	else {
		pCon = GetRemoteData();
	}

	// (c.haag 2013-03-19) - PLID 55697 - This is now in EMR Utils
	::LoadEMRLetterWritingMergeFieldList(aryFieldList, pCon);
}

// (c.haag 2004-06-30 12:31) - This is the callback for merging an EMR chart with a Word template
CString CALLBACK CEMN__ExtraMergeFields(BOOL bFieldNamesInsteadOfData, const CString &strKeyFieldValue, LPVOID pParam)
{
	try {
		CExtraMergeFields *pemf = (CExtraMergeFields *)pParam;
		if (bFieldNamesInsteadOfData) {
			return pemf->m_strHeaders;
		} else {
			return pemf->m_strData;
		}
	} NxCatchAllCallIgnore({
		return "";
	});
}

// (c.haag 2009-08-10 11:18) - PLID 29160 - Added bMergeToPrinter
void CEMN::Merge(CString strTemplateFileName, BOOL bSaveInHistory, BOOL bMergeToPrinter)
{
	CWaitCursor pWait;

	// (c.haag 2004-07-06 11:20) - PLID 13003 - Warn if there are any merge name conflicts
	if (!WarnOfDuplicateMergeNames()) {
		// Returns FALSE if the user decided not to merge the chart
		return;
	}	

	// Create the merge engine object
	CMergeEngine mi;

	// (z.manning, 03/06/2008) - PLID 29131 - Need to load the sender merge fields
	if(!mi.LoadSenderInfo(TRUE)) {
		return;
	}

	// (c.haag 2004-11-11 13:29) - PLID 14074 - Assign the EMR group ID so we can tie
	// this document in with the history tab for this EMR group
	long nEMRID = GetParentEMR()->GetID();
	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	_RecordsetPtr rs = CreateParamRecordset("SELECT ID FROM PicT WHERE EMRGroupID = {INT}", nEMRID);
	if(!rs->eof) {
		mi.m_nPicID = AdoFldLong(rs, "ID",-1);
	}
	else {
		mi.m_nPicID = -1;
	}
	rs->Close();

	mi.m_nEMNID = m_nID;
	
	// (b.cardillo 2005-06-29 08:57) - PLID 16577 - Check the preference to see if we should 
	// save the document in the patient's history or not.
	if (bSaveInHistory) {
		// (b.cardillo 2004-06-21 09:48) - PLID 12909 - Make sure it saves itself into this patient's history tab.
		mi.m_nFlags |= BMS_SAVE_FILE_AND_HISTORY;
	}
	// (c.haag 2009-08-10 11:18) - PLID 29160 - Added the option to merge directly to the printer
	if (bMergeToPrinter) {
		mi.m_nFlags = (mi.m_nFlags | BMS_MERGETO_PRINTER) & ~BMS_MERGETO_SCREEN;
	}

	CString strTemplateName = strTemplateFileName.Right(strTemplateFileName.GetLength() - strTemplateFileName.ReverseFind('\\') - 1);
	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	_RecordsetPtr prsCat = CreateParamRecordset("SELECT NoteCatID FROM EMRWordTemplateCategoryT WHERE TemplateName = {STR}",
		strTemplateName);
	if (!prsCat->eof) {
		mi.m_nCategoryID = AdoFldLong(prsCat->GetFields(), "NoteCatID");
	}
	prsCat->Close();
	
	// (b.cardillo 2004-06-21 10:08) - PLID 12909 - Figure out which category (if any) this collection connects to.
	if (mi.m_nCategoryID == -1 && m_nEMRCollectionID != -1) {
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset(
			"SELECT ID FROM NoteCatsF "
			"WHERE Description = (SELECT Name FROM EMRCollectionT WHERE ID = {INT}) AND "
			"IsPatientTab = 1", m_nEMRCollectionID);
		if (!prs->eof) {
			mi.m_nCategoryID = AdoFldLong(prs->GetFields(), "ID");
		}
	}

	// Generate the extra fields (passing in the mergeengine object so any temp files needed can be deleted AFTER the merge)
	CExtraMergeFields emf;
	GenerateMergeData(mi, emf.m_strHeaders, emf.m_strData);

	// Pass the emf into the merge engine so it knows where to get the extra merge fields
	mi.m_pfnCallbackExtraFields = CEMN__ExtraMergeFields;
	mi.m_pCallbackParam = &emf;

	// Prepare the table with the patient ids we're going to merge
	CString strMergeT;
	{
		CString strSql;
		strSql.Format("SELECT ID FROM PersonT WHERE ID = %li", GetParentEMR()->GetPatientID());
		strMergeT = CreateTempIDTable(strSql, "ID");
	}

	// (c.haag 2004-05-10 10:09) - Prepare the temporary merge files
	// for merging whole sets of categories. (Note: The destructor
	// will delete them)
	GenerateTempMergeFiles(mi);

	// (c.haag 2004-05-10 12:25) - Add procedures and EMR's to the merge
	if (m_aryProcedures.GetSize() > 0)
	{
		CString strProcIDs;
		for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
			CString strID;
			strID.Format("%li, ", VarLong(((EMNProcedure*)m_aryProcedures.GetAt(i))->nID));
			strProcIDs += strID;
		}
		strProcIDs = strProcIDs.Left(strProcIDs.GetLength()-2);
		//TES 6/13/2007 - PLID 26269 - This was including all ProcInfoT records for the patient for some reason.  I changed
		// it to just filter on the current PIC.
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prsProcInfoDetails = CreateParamRecordset("SELECT ID FROM ProcInfoDetailsT WHERE ProcedureID IN ({INTSTRING}) AND ProcInfoID IN (SELECT ProcInfoID FROM PicT WHERE EmrGroupID = {INT})", 
			strProcIDs, GetParentEMR()->GetID());
		while (!prsProcInfoDetails->eof)
		{	
			mi.m_arydwProcInfoIDs.Add(AdoFldLong(prsProcInfoDetails, "ID"));
			prsProcInfoDetails->MoveNext();
		}
	}
	mi.m_arydwEMRIDs.Add(m_nID);

	// Do the merge
	//TES 7/8/2011 - PLID 20536 - Pass in our date to use as the Service Date on the merged document.
	mi.MergeToWord(strTemplateFileName, AsVector(m_saTempFiles), strMergeT, "", -1, -1, false, "", &m_dtEMNDate);

	RemoveTempMergeFiles();
}

// (c.haag 2004-04-30 13:14) - Generate a single HTML file for every
// individual EMR category so they can be merged into a Word template.
void CEMN::GenerateTempMergeFiles(CMergeEngine &mi)
{
	try {
		//TES 6/7/2004: Generate our list of info items from what's on screen.
		CString strItemFilter;
		long nTotalDetailCount = GetTotalDetailCount();
		for(int i = 0; i < nTotalDetailCount; i++) {
			CString strPart;
			strPart.Format("%li, ", GetDetail(i)->m_nEMRInfoID);
			strItemFilter += strPart;
		}
		if(strItemFilter.IsEmpty()) return;
		//Trim last ", "
		strItemFilter = strItemFilter.Left(strItemFilter.GetLength()-2);

		//DRT 6/20/2006 - PLID 21122 - Speed improvement.  I found that the loop that orders the list
		//	of details was being called inside GetParagraph, which is called inside GenerateTempMergeFile, 
		//	which is called in a loop here for every detail.  It was not uncommon for there to be 50+ items
		//	in this list, which means we looped over 50 details, and inside each one, created a new list, 
		//	looping through 50+ details again.
		//Instead, let's put our code up here, sort the list once (it's the same list for every detail), and
		//	then pass it down the line.
		CList<CEMNDetail*,CEMNDetail*> listOrderedDetails;
		//Note that we do not need to clean up any memory in this list... we are not generating EMNDetails, only getting pointers
		//	to existing objects.
		SortAllDetails(&listOrderedDetails);

		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr rsCategories = CreateParamRecordset("SELECT EmrCategoriesT.ID, EmrCategoriesT.Name AS CatName, EmrCategoriesT.Format "
			"FROM EmrCategoriesT WHERE ID IN (SELECT EMRCategoryID FROM EMRInfoCategoryT WHERE EmrInfoID IN ({INTSTRING})) "
			"ORDER BY EmrCategoriesT.Name ASC", strItemFilter);

		while (!rsCategories->eof) {
			GenerateTempMergeFile(AdoFldLong(rsCategories, "ID"), (EmrCategoryFormat)AdoFldLong(rsCategories, "Format"),
				AdoFldString(rsCategories, "CatName"), mi, &listOrderedDetails);
			rsCategories->MoveNext();
		}

		// (a.walling 2010-06-09 18:09) - PLID 37580 - Built-in Signatures category
		GenerateTempMergeFile(-26, ecfList,	"Signatures", mi, &listOrderedDetails);
	}
	NxCatchAll("Error in CEMN::GenerateTempMergeFiles: error generating temporary merge chart notes");
}

void CEMN::GenerateTempMergeFile(long nCategoryID, EmrCategoryFormat fmt, const CString& strCatName, CMergeEngine &mi, CList<CEMNDetail*,CEMNDetail*> *plistOrderedDetails)
{
	CString strFilename;
	CString strHTML;
	//CString strNewName = strCatName;

	// (c.haag 2004-05-27 08:56) PLID 12614 - Treat field names consistently
	// with how we do it in EMR (See ConvertToHeaderName() in EMRDlg.cpp)
	// First replace every non-alphanumeric character with an underscore

	/*

	for (long i=0; i<strNewName.GetLength(); i++) {
		if (!isalnum(strNewName.GetAt(i))) {
			strNewName.SetAt(i, '_');
		}
	}
	// Then make every sequence of more than one underscore into a single underscore
	while (strNewName.Replace("__", "_"));
	*/

	// (j.jones 2007-01-02 10:53) - PLID 24051 - corrected truncation problems by determing exactly
	// what the merge field was truncated to (if at all)
	CString strNewName = ConvertToHeaderName("EMR_Category", strCatName);
	//remove the EMR_Category prefix
	strNewName = strNewName.Right(strNewName.GetLength() - 13);

	// Generate our temporary file
	strFilename.Format("MergeHTML_Cat_EMR_%s_%d.htm", strNewName, m_nID);
	CString strFullPath = GetNxTempPath() ^ strFilename;
	CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);

	// Write the content to the file
	//DRT 6/20/2006 - PLID 15556 - Pass the list of ordered details down the line.
	strHTML = "<html><head></head><body>" + GetParagraph(nCategoryID, fmt, mi, plistOrderedDetails) + "</body></html>";
	f.WriteString(strHTML);
	f.Close();

	// Add to our temp file list
	m_saTempFiles.Add(strFullPath);
}

// (a.walling 2007-04-25 13:56) - PLID 25549 - Moved GetDetailRectangle to EMRUtils

//DRT 6/20/2006 - PLID 21122 - This used to be in GetParagraph, but was calculated
//	once for every detail in the EMN being merged.  This function will sort all
//	the details in the current EMR, and return an ordered list of all of those
//	details.
//You do not need to cleanup anything in this list, these pointers are to existing data
//	objects, not new ones.
void CEMN::SortAllDetails(CList<CEMNDetail*,CEMNDetail*> *plistOrderedDetails)
{
	//TES 8/31/2004: Re-order our list of items based on topic, then y-pos, then x-pos.
	// (j.jones 2006-01-04 15:14) - GetTotalDetailCount() goes by topics already,
	//so we really only need to re-order based on position
	// (c.haag 2007-03-27 15:04) - PLID 25374 - This has been completely revamped. We
	// now only traverse the segment of the list that can be modified, and we calculate
	// detail rectangles only once.
	
	/*
	long nTotalDetailCount = GetTotalDetailCount();
	CEMRTopic *pLastTopic = NULL;
	for(int i = 0; i < nTotalDetailCount; i++) {
		
		CEMNDetail *pCurDetail = GetDetail(i);

		// (j.jones 2006-03-28 10:00) - track when we've started loading a new topic
		// (we are already looping in order by topic, so just check
		// that it is not the same parent as the last item)
		BOOL bNewTopic = FALSE;
		if(pLastTopic != pCurDetail->m_pParentTopic)
			bNewTopic = TRUE;
		pLastTopic = pCurDetail->m_pParentTopic;

		bool bInserted = false;

		for(POSITION pos = plistOrderedDetails->GetHeadPosition(); pos;) {
			CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);

			//if we have moved to a new topic...
			if(bNewTopic) {
				//add to the end
				pos = plistOrderedDetails->GetTailPosition();
				plistOrderedDetails->InsertAfter(pos, pCurDetail);
				pos = NULL;
				bInserted = true;
			}
			else {
				//Well, they're on the same topic

				//get the rect of the listOrderedDetails detail
				CRect rcCurListDetail;

				if(pCurListDetail->m_pEmrItemAdvDlg && pCurListDetail->m_pEmrItemAdvDlg->GetSafeHwnd()) {
					pCurListDetail->m_pEmrItemAdvDlg->GetClientRect(&rcCurListDetail);
					pCurListDetail->m_pEmrItemAdvDlg->ClientToScreen(&rcCurListDetail);
					pCurListDetail->m_pEmrItemAdvDlg->GetParent()->SendMessage(NXM_CONVERT_RECT_FOR_DATA, (WPARAM)&rcCurListDetail);
				}
				else {
					rcCurListDetail = pCurListDetail->m_rcDefaultClientArea;
				}

				//get the rect of the GetTotalDetailCount detail
				CRect rcCurDetail;

				if(pCurDetail->m_pEmrItemAdvDlg && pCurDetail->m_pEmrItemAdvDlg->GetSafeHwnd()) {
					pCurDetail->m_pEmrItemAdvDlg->GetWindowRect(rcCurDetail);
					pCurDetail->m_pEmrItemAdvDlg->GetClientRect(&rcCurDetail);
					pCurDetail->m_pEmrItemAdvDlg->ClientToScreen(&rcCurDetail);
					pCurDetail->m_pEmrItemAdvDlg->GetParent()->SendMessage(NXM_CONVERT_RECT_FOR_DATA, (WPARAM)&rcCurDetail);
				}
				else {
					rcCurDetail = pCurDetail->m_rcDefaultClientArea;
				}

				//now compare the two
				if(pCurDetail->m_pParentTopic == pCurListDetail->m_pParentTopic
					&& (rcCurListDetail.top > rcCurDetail.top ||
					(rcCurListDetail.top == rcCurDetail.top && rcCurListDetail.left > rcCurDetail.left))) {
					//Yes.
					if(pos)
						plistOrderedDetails->GetPrev(pos);
					else
						pos = plistOrderedDetails->GetTailPosition();
					plistOrderedDetails->InsertBefore(pos, pCurDetail);
					pos = NULL;
					bInserted = true;
				}
			}
		}
		if(!bInserted) {
			//Add to the end.
			if(plistOrderedDetails->IsEmpty()) 
				plistOrderedDetails->AddHead(pCurDetail);
			else
				plistOrderedDetails->AddTail(pCurDetail);
		}
	}*/

	CArray<CEMNDetail*,CEMNDetail*> arDetails;
	CMap<CEMNDetail*,CEMNDetail*,CRect,const CRect&> mapRectangles;
	GenerateTotalEMNDetailArray(&arDetails);
	const long nTotalDetailCount = arDetails.GetSize();
	CEMRTopic *pLastTopic = NULL; // Because the list must be sorted in order of topic,y-pos,xpos,
								// and because arDetails is already sorted by topic, we retain
								// the topic of the previous detail to tell us whether the topic
								// has changed
	POSITION posTopicHead = NULL; // When the topic changes, we know that everything from the list
								// head to the tail will never change. So, we will add the first
								// detail with a differing topic to the list at posTopicHead, and
								// continue building the list from there
	long i;

	for (i=0; i < nTotalDetailCount; i++) {
		CEMNDetail *pDetail = arDetails[i];

		// Check if the topic changed. If so, assign the new topic head. If this
		// is the first detail in the list, just add it and move along.
		if (pLastTopic != pDetail->m_pParentTopic) {
			pLastTopic = pDetail->m_pParentTopic;
			// This is the first detail, so create the first node in the list
			if (NULL == (posTopicHead = plistOrderedDetails->GetTailPosition())){
				posTopicHead = plistOrderedDetails->AddHead(pDetail);
				mapRectangles[pDetail] = GetDetailRectangle(pDetail);
				continue;
			} else {
				// This is not the first detail, so starting from the current tail, continue
				// building the list
				posTopicHead = plistOrderedDetails->AddTail(pDetail);
				mapRectangles[pDetail] = GetDetailRectangle(pDetail);
				continue;
			}
		}
		// If we get here, we're in the same topic, so find its placement in the topic-specific
		// part of the list
		else {
			POSITION pos;
			CRect rc = mapRectangles[pDetail] = GetDetailRectangle(pDetail);
			BOOL bAdded = FALSE;
			POSITION posCur;
			for (pos = posTopicHead; pos && !bAdded;) {
				posCur = pos;
				CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);
				CRect rcListDetail = mapRectangles[pCurListDetail];
				if (!(rcListDetail.top < rc.top || (rcListDetail.top == rc.top && rcListDetail.left < rc.left))) {
					// We now know where this is supposed to go, so add it to the list
					POSITION posNew = plistOrderedDetails->InsertBefore(posCur, pDetail);
					// If we're at the head of the list, the new position becomes the new head
					if (posTopicHead == posCur) {
						posTopicHead = posNew;
					}
					bAdded = TRUE;
				}
			}
			if (!bAdded) {
				// If the element was never added before now, it must go to the end of the list
				plistOrderedDetails->AddTail(pDetail);
			}
		}
	}

	//
	// (c.haag 2007-03-27 15:00) - Uncomment this code if you want to display the contents of the list
	// (this is not part of any one punch list item; it's just a debug helper and is intended only for
	// testing purposes)
	//
/*#ifdef _DEBUG
	for(POSITION pos = plistOrderedDetails->GetHeadPosition(); pos;) {
		CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);
		CRect rcCurDetail;
		if(pCurListDetail->m_pEmrItemAdvDlg && pCurListDetail->m_pEmrItemAdvDlg->GetSafeHwnd()) {
			pCurListDetail->m_pEmrItemAdvDlg->GetClientRect(&rcCurDetail);
			pCurListDetail->m_pEmrItemAdvDlg->ClientToScreen(&rcCurDetail);
			pCurListDetail->m_pEmrItemAdvDlg->GetParent()->SendMessage(NXM_CONVERT_RECT_FOR_DATA, (WPARAM)&rcCurDetail);
		}
		else {
			rcCurDetail = pCurListDetail->m_rcDefaultClientArea;
		}
		TRACE("Topic = %x  top = %d  left = %d\n", pCurListDetail->m_pParentTopic, rcCurDetail.top, rcCurDetail.left);
	}
#endif*/
}

void CEMN::RemoveTempMergeFiles()
{
	for (long i=0; i < m_saTempFiles.GetSize(); i++)
	{
		DeleteFileWhenPossible(m_saTempFiles[i]);
	}
	m_saTempFiles.RemoveAll();
}

BOOL CEMN::WarnOfDuplicateMergeNames()
{
	// a.wetta 2/18/2005 - PLID 15692 - When there are duplicate items, don't prompt the user about them.
	// There is probably a reason there are duplicate items, so just change the merge names of the items and 
	// merge everything.
	// (c.haag 2007-03-27 10:28) - PLID 25359 - The old method is extremely slow. The new method is faster
	// because what we do is build a map of merge field names to detail arrays, and for arrays that have
	// a quantity greater than one, we add them to a single array and feed them to the FixDuplicateMergeFieldNames
	// function.
	/*
	//CStringArray astrDuplicateMergeNames;
	CArray<CEMNDetail*,CEMNDetail*> aryduplpEMNDetail;
	long nTotalDetailCount = GetTotalDetailCount();
	for (long i=0; i < nTotalDetailCount; i++)
	{
		CEMNDetail *pEMNDetail = GetDetail(i);
		CArray<CEMNDetail*,CEMNDetail*> arypEMNDetail;
		FindDetailsByMergeFieldName(pEMNDetail->GetMergeFieldName(TRUE), arypEMNDetail);
		if (arypEMNDetail.GetSize() > 1)
		{
			//Keep track of all the duplicate items
			aryduplpEMNDetail.Add(pEMNDetail);
		}
	}
	if (aryduplpEMNDetail.GetSize() > 0)
	{
		FixDuplicateMergeFieldNames(aryduplpEMNDetail);
	}
	return TRUE;*/


	// (c.haag 2007-03-27 10:35) - Gather the master list of all details in this EMN
	CArray<CEMNDetail*,CEMNDetail*> arDetails;
	GenerateTotalEMNDetailArray(&arDetails);
	const long nTotalDetailCount = arDetails.GetSize();
	CMap<CString,LPCTSTR,CArray<CEMNDetail*,CEMNDetail*>*,CArray<CEMNDetail*,CEMNDetail*>*>
		mapMergeNames;
	long i;

	// (c.haag 2007-03-27 10:35) - Now map all the details to merge field names
	for (i=0; i < nTotalDetailCount; i++) {
		CArray<CEMNDetail*,CEMNDetail*>* pValue = NULL;
		CEMNDetail* pDetail = arDetails[i];
		const CString strDetailMergeFieldName = pDetail->GetMergeFieldName(TRUE);
		if (!mapMergeNames.Lookup(strDetailMergeFieldName, pValue)) {
			pValue = new CArray<CEMNDetail*,CEMNDetail*>;
			mapMergeNames[strDetailMergeFieldName] = pValue;
		} else {
			// The array (pValue) already exists, meaning we found a duplicate
		}
		pValue->Add(pDetail);
	}

	// (c.haag 2007-03-27 10:35) - Now that the map has been created, traverse the map
	// deleting memory we allocated and adding details to the master duplicate array
	POSITION pos = mapMergeNames.GetStartPosition();
	CArray<CEMNDetail*,CEMNDetail*> apDuplicates;
	while (pos) {
		CArray<CEMNDetail*,CEMNDetail*>* pValue = NULL;
		CString strMergeFieldName;
		mapMergeNames.GetNextAssoc(pos, strMergeFieldName, pValue);
		const long nArySize = pValue->GetSize();
		if (nArySize > 1) {
			for (i=0; i < nArySize; i++) {
				apDuplicates.Add(pValue->GetAt(i));
			}
		}
		delete pValue;
	}

	// (c.haag 2007-03-27 10:39) - Fix the duplicates
	if (apDuplicates.GetSize() > 0) {
		FixDuplicateMergeFieldNames(apDuplicates);
	}

	return TRUE;
}

void CEMN::FixDuplicateMergeFieldNames(CArray<CEMNDetail*,CEMNDetail*>& aryduplpEMNDetail)
{
	//TES 1/31/2007 - PLID 24522 - If we're locked, then we can't override field names.
	if(IsLockedAndSaved()) return;

	// (j.gruber 2012-04-25 15:05) - PLID 49984 - also check Writeable status
	if (!IsWritable()) {
		return;
	}

	// Check for duplicate topic names and create array of tab names to be used when making new merge field name
	CArray<CString, CString> aryTopicNames;
	CArray<CEMRTopic*,CEMRTopic*> arTopics;
	GetAllTopics(arTopics);
	for (int j=0; j < arTopics.GetSize(); j++)
	{
		int nDuplicateCount = 1;
		for (int k=0; k < j; k++)
		{
			if (arTopics[j]->GetName() == arTopics[k]->GetName())
			{
				++nDuplicateCount;
			}
		}
		if (nDuplicateCount != 1)
		{
			CString strTabName;
			strTabName.Format("%s %li", arTopics[j]->GetName(), nDuplicateCount);
			aryTopicNames.Add(strTabName);
		}
		else
			aryTopicNames.Add(arTopics[j]->GetName());
	}

	//Check for duplicate items on the same topic
	CArray<CString, CString> aryItemNames;
	for (int m=0; m < aryduplpEMNDetail.GetSize(); m++)
	{
		int nDuplicateCount = 1;
		for (int n=0; n < m; n++)
		{
			if (aryduplpEMNDetail[m]->GetLabelText() == aryduplpEMNDetail[n]->GetLabelText() &&
				aryduplpEMNDetail[m]->m_pParentTopic == aryduplpEMNDetail[n]->m_pParentTopic)
			{
				++nDuplicateCount;
			}
		}
		if (nDuplicateCount != 1)
		{
			CString strItemName;
			strItemName.Format("%s %li", aryduplpEMNDetail[m]->GetLabelText(), nDuplicateCount);
			aryItemNames.Add(strItemName);
		}
		else
			aryItemNames.Add(aryduplpEMNDetail[m]->GetLabelText());
	}

	
	// Go through all duplicate items and fix the merge field name
	for (int i=0; i < aryduplpEMNDetail.GetSize(); i++) 
	{
		int nTopicIndex = -1;
		for(int nTopic = 0; nTopic < arTopics.GetSize() && nTopicIndex == -1; nTopic++) {
			if(arTopics[nTopic] == aryduplpEMNDetail[i]->m_pParentTopic) nTopicIndex = nTopic;
		}
		CString strMergeField;
		strMergeField.Format("%s (%s)", aryItemNames[i], aryTopicNames[nTopicIndex]);

		CString strOld = aryduplpEMNDetail[i]->GetMergeFieldName(TRUE);
		aryduplpEMNDetail[i]->SetMergeFieldOverride(strMergeField);
		aryduplpEMNDetail[i]->m_bNeedRefreshMergeButton = TRUE;
		UpdateMergeConflicts(strOld);
		UpdateMergeConflicts(aryduplpEMNDetail[i]->GetMergeFieldName(TRUE));
		
		// (a.walling 2008-06-12 16:44) - PLID 27301 - Let the interface know
		if (GetInterface() != NULL) {
			MergeOverrideChanged moc;
			moc.strOldName = strOld;
			moc.strNewName = aryduplpEMNDetail[i]->GetMergeFieldName(TRUE);
			// (a.walling 2008-06-13 16:12) - PLID 27301 - Infinite loop protection - only send if we changed
			if (moc.strOldName != moc.strNewName) {
				GetInterface()->SendMessage(NXM_MERGE_OVERRIDE_CHANGED, (WPARAM)aryduplpEMNDetail[i], (LPARAM)&moc);
			}
		}
	}

}

BOOL CEMN::IsTemplate()
{
	return m_bIsTemplate;
}

// (z.manning, 05/07/2007) - PLID 25925 - Added a parameter for the location name.
// (a.walling 2008-07-01 17:29) - PLID 30586 - Added param for logo
// (a.walling 2010-10-29 10:33) - PLID 31435 - Added param for logo width
void CEMN::SetLocation(long nLocationID, CString strLocationName, CString strLogoPath, long nLogoWidth)
{
	m_Location.nID = nLocationID;
	m_Location.strName = strLocationName;
	m_Location.strLogo = strLogoPath;
	m_Location.nLogoWidth = nLogoWidth;
	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
void CEMN::SetDischargeStatus(long nStatusID, CString strCode, CString strDescription)
{
	m_DischargeStatus.nID = nStatusID;
	m_DischargeStatus.strCode = strCode;
	m_DischargeStatus.strDesc = strDescription;
	m_bUnsaved = TRUE;
	SetMoreInfoUnsaved();
}

// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
void CEMN::SetAdmissionTime(COleDateTime dtDate)
{
	m_dtAdmissionTime = dtDate;
	m_bUnsaved = TRUE;
	SetMoreInfoUnsaved();
}

// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
void CEMN::SetDischargeTime(COleDateTime dtDate)
{
	m_dtDischargeTime = dtDate;
	m_bUnsaved = TRUE;
	SetMoreInfoUnsaved();
}

long CEMN::GetLocationID()
{
	return m_Location.nID;
}

void CEMN::GenerateCategoryMergeData(CList<MergeField,MergeField&> &listMergeFields)
{
	// (a.walling 2010-06-09 18:09) - PLID 37580 - Built-in Signatures category
	CString strEMRSignaturesCatFieldName;
	{
		CString strEMRSignaturesCatFieldName = ConvertToHeaderName("EMR_Category", "Signatures");
		// We still need just the category name cleaned up but without the "EMR_Category_" at the front
		CString strCat = strEMRSignaturesCatFieldName.Mid(13);
		CString strFullPathData;
		strFullPathData.Format("{NXRTF %s_%s_%d.htm}", GetNxTempPath() ^ "MergeHTML_Cat_EMR", strCat, m_nID);

		MergeField mf;
		mf.strHeader = strEMRSignaturesCatFieldName;

		// Add to the output value text
		mf.strData = strFullPathData;

		// (a.walling 2010-06-09 18:09) - PLID 37580 - What is this, CList superstition?
		if(listMergeFields.IsEmpty()) {
			listMergeFields.AddHead(mf);
		}
		else {
			listMergeFields.AddTail(mf);
		}
	}

	_RecordsetPtr prsEMRCat = CreateRecordset("SELECT EMRCategoriesT.Name AS Name FROM EMRCategoriesT ORDER BY EMRCategoriesT.Name");
	while (!prsEMRCat->eof)
	{
		// Get the merge field name based on this category
		// (b.cardillo 2004-06-02 13:01) - For some reason this used to do the work of ConvertToHeaderName() in 
		// place here instead of just calling it.  (This replaces (c.haag 2004-05-27 08:56) PLID 12614.)
		CString strCategoryName = AdoFldString(prsEMRCat, "Name");
		CString strCatFieldName = ConvertToHeaderName("EMR_Category", strCategoryName);
		// We still need just the category name cleaned up but without the "EMR_Category_" at the front
		CString strCat = strCatFieldName.Mid(13);
		CString strFullPathData;
		strFullPathData.Format("{NXRTF %s_%s_%d.htm}", GetNxTempPath() ^ "MergeHTML_Cat_EMR", strCat, m_nID);
	
		// (a.walling 2010-06-09 18:09) - PLID 37580 - Check fo conflict with built-in Signatures category
		if (strCatFieldName.CompareNoCase(strEMRSignaturesCatFieldName) == 0) {
			AfxMessageBox("There is a category with the same name as the built-in Signatures category. This category will be ignored. Please contact NexTech Technical Support for assistance.", MB_ICONWARNING);
		}

		// Add to the output header text
		MergeField mf;
		mf.strHeader = strCatFieldName;

		// Add to the output value text
		mf.strData = strFullPathData;
		listMergeFields.AddTail(mf);

		prsEMRCat->MoveNext();
	}
}

void CEMN::GenerateRelatedMergeData(CList<MergeField,MergeField&> &listMergeFields, POSITION posLastNonAlphabetized)
{
	// (c.haag 2004-07-06 16:26) - PLID 13327 - Include EMR Info records that COULD be spawned from another
	// existing item
	CString strEMRItemIDs;
	CArray<long, long> aryAllEMRInfoIDs;
	CArray<long, long> aryQueryEMRInfoIDs;

	// Start by including all the EMR Info ID's we have on the chart right now
	long nTotalDetailCount = GetTotalDetailCount();
	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	long i = 0;

	for (i=0; i < nTotalDetailCount; i++)
	{
		CEMNDetail *pEMNDetail = GetDetail(i);
		CString str;
		aryAllEMRInfoIDs.Add(pEMNDetail->m_nEMRInfoID);
		//initialize aryQueryEMRInfoIDs to be the same content as aryAllEMRInfoIDs
		aryQueryEMRInfoIDs.Add(pEMNDetail->m_nEMRInfoID);
		}
	// (c.haag 2004-07-06 16:26) - PLID 13327 - Now repeatedly try to add new
	// EMR Info ID's to our list based on the content of EMRActionsT. Again, 
	// we're not looking for already-spawned items, we are looking for what MAY
	// be spawned, and what those items MAY spawn, etc.
	// (b.cardillo 2004-07-09 10:34) - Since the recordset loaded immediately inside this loop
	// uses the strEMRItemIDs in an "IN ()" clause we have to make sure strEMRItemIDs isn't 
	// empty.  If it's empty, then the recordset wouldn't return anything anyway (because the 
	// "IN ()" clause is ANDed with all the other clauses, so there's no need to enter the loop.

	// (j.jones 2013-03-15 13:03) - PLID 55530 - now we cache the EMRInfoT.Name field
	// here in order to prevent a second query later to get that information
	// (a.walling 2013-07-02 09:02) - PLID 57407 - CMap's ARG_VALUE should be const CString& instead of LPCTSTR so it can use CString reference counting
	CMap<long, long, CString, const CString&> mapInfoIDToName;

	while (aryQueryEMRInfoIDs.GetSize() > 0)
	{
		//TES 12/7/2006 - PLID 23724 - Modified to reflect the fact that DestID now references EmrInfoMasterT instead of EmrInfoT.
		// (j.jones 2013-03-15 13:03) - PLID 55530 - Parameterized this query.
		_RecordsetPtr prs = CreateParamRecordset("SELECT ID, Name FROM EMRInfoT WHERE ID IN ({INTARRAY}) "
			"\r\n"
			"SELECT EmrInfoMasterT.ActiveEmrInfoID "
			"FROM EmrInfoMasterT "
			"INNER JOIN EMRActionsT ON EmrInfoMasterT.ID = EmrActionsT.DestID "
			"INNER JOIN EMRDataT ON EMRActionsT.SourceID = EMRDataT.ID "
			"WHERE EMRActionsT.SourceType = 4 AND EMRActionsT.DestType = 3 "
			"AND EMRDataT.EMRInfoID IN ({INTARRAY}) "
			"GROUP BY EmrInfoMasterT.ActiveEmrInfoID", aryQueryEMRInfoIDs, aryQueryEMRInfoIDs);
		// (j.jones 2013-03-15 13:03) - PLID 55530 - clear our IDs so the next iteration
		// only queries new IDs, and not the same ones over and over
		aryQueryEMRInfoIDs.RemoveAll();

		// (j.jones 2013-03-15 13:03) - PLID 55530 - first get the names of the EMRInfoT records we looked for
		while (!prs->eof)
		{
			// Go through each DestID and see if we already have it in our array of 
			// EMR Item ID's.
			long nEMRInfoID = AdoFldLong(prs, "ID");
			// (j.jones 2013-03-15 13:03) - PLID 55530 - fill our map
			mapInfoIDToName.SetAt(nEMRInfoID, AdoFldString(prs, "Name"));
			prs->MoveNext();
		}

		prs = prs->NextRecordset(NULL);

		while (!prs->eof)
		{
			// Go through each DestID and see if we already have it in our array of 
			// EMR Item ID's.
			long nEMRInfoID = AdoFldLong(prs, "ActiveEmrInfoID");
			BOOL bFound = FALSE;
			for (i=0; i < aryAllEMRInfoIDs.GetSize() && !bFound; i++)
			{
				if (aryAllEMRInfoIDs.GetAt(i) == nEMRInfoID) {
					bFound = TRUE;
			}
				}
			//if we did not find this ID in our master list, we need to add it to that
			//list as well as the list of IDs to query next, which will be handled
			//by another iteration of the recordset
			if (!bFound) {
				//add this ID to aryAllEMRInfoIDs
				aryAllEMRInfoIDs.Add(nEMRInfoID);
				//also add to aryQueryEMRInfoIDs, we will loop again and query these new InfoIDs only
				aryQueryEMRInfoIDs.Add(nEMRInfoID);
			}
			prs->MoveNext();
		}
	}

	// (j.jones 2013-03-15 13:30) - PLID 55530 - we no longer need a second query to get the
	// EMRInfoT.Name value, we've stored it in a map
	for (i=0; i < aryAllEMRInfoIDs.GetSize(); i++)
	{
		long nInfoID = aryAllEMRInfoIDs.GetAt(i);
		CString strInfoName;
		if(!mapInfoIDToName.Lookup(nInfoID, strInfoName)) {
			//should be impossible
			ThrowNxException("CEMN::GenerateRelatedMergeData failed to find a name for EMRInfoT.ID of %li.", nInfoID);
	}
		CString strHeaderName = ConvertToHeaderName("EMR", strInfoName);

		// (c.haag 2004-07-06 09:18) - Check to see if the caller wants us to ignore this field name.
		//TES 9/1/2004: Put the field in alphabetic order.
		POSITION pos = posLastNonAlphabetized;
		CString strCurrentHeader = listMergeFields.GetNext(pos).strHeader;
		while (pos)
		{
			strCurrentHeader = listMergeFields.GetNext(pos).strHeader;
			if (strCurrentHeader.CompareNoCase(strHeaderName) >= 0)
				break;
		}
		if (strCurrentHeader != strHeaderName) {
			MergeField mf;
			mf.strHeader = strHeaderName;

			// Add to the output value text
			mf.strData = "\"\"";
			if(!pos) {
				if(strCurrentHeader.CompareNoCase(strHeaderName) > 0) {
					pos = listMergeFields.GetTailPosition();
					listMergeFields.InsertBefore(pos, mf);
				}
				else {
					listMergeFields.AddTail(mf);
				}
			}
			else {
				listMergeFields.GetPrev(pos);
				listMergeFields.InsertBefore(pos, mf);
			}
		}
	}
}


void CEMN::GenerateMergeData(CMergeEngine &mi, OUT CString &strHeaders, OUT CString &strData)
{
	CString strHeadersLoc, strDataLoc;
	CList<MergeField, MergeField&> listFields;

	//TES 9/1/2004: We want to enforce the order: Common Fields, then Category fields, then all other fields alphabetically.

	// Add fields that will be in any and every EMR merge
	GenerateCommonMergeData(listFields);
	// (c.haag 2004-06-30 12:46) - Merge categories
	GenerateCategoryMergeData(listFields);

	POSITION pLastNonAlphabetized = listFields.GetTailPosition();

	// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
	long i = 0;

	// (c.haag 2004-07-02 15:36) - From now on we only include fields that come from this specific
	// chart in memory, and we get the information from memory.
	long nTotalDetailCount = GetTotalDetailCount();
	for (i=0; i < nTotalDetailCount; i++)
	{
		CEMNDetail *pEMNDetail = GetDetail(i);
		CString strFormatted = GetSentence(pEMNDetail, &mi, true, false);
		MergeField mf;
		CString strHeader = pEMNDetail->GetMergeFieldName(TRUE);
		mf.strHeader = strHeader;
		// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed function. Prepares string for a Word merge data file.
		mf.strData = "\"" + ConvertToQuotableWordCSVString(strFormatted) + "\"";

		//Find the right place to put this field.
		bool bFound = false;
		POSITION pos = pLastNonAlphabetized;
		while (pos)
		{
			//TES 2/25/2005 - PLID 15778 - Note that this and GenerateRelatedMergeData need to BOTH be case-insensitive.
			if (listFields.GetNext(pos).strHeader.CompareNoCase(strHeader) >= 0) {
				bFound = true;
				break;
			}
		}
		if (pos && listFields.GetPrev(pos).strHeader == strHeader) {
			//Duplicate!
			continue;
		}
		if(!pos && bFound) {
			//It must have been the last one.
			pos = listFields.GetTailPosition();
		}
		if(!pos)
			listFields.AddTail(mf);
		else
			listFields.InsertBefore(pos, mf);

	}

	// (c.haag 2004-07-06 09:09) - Now we include all the fields that don't exist for this
	// chart, but do exist for the procedures of this chart, as empty fields. We actually
	// look to data to get these values! <gasp>
	GenerateRelatedMergeData(listFields, pLastNonAlphabetized);

	POSITION pos = listFields.GetHeadPosition();
	for(i=0; i < listFields.GetCount(); i++) {
		MergeField mf = listFields.GetNext(pos);
		strHeadersLoc += mf.strHeader + ",";
		strDataLoc += mf.strData + ",";
	}
	strHeaders = strHeadersLoc.Left(strHeadersLoc.GetLength()-1);
	strData = strDataLoc.Left(strDataLoc.GetLength()-1);
}

void CEMN::GenerateCommonMergeData(CList<MergeField,MergeField&> &listMergeFields)
{
	// (c.haag 2004-07-02 16:53) - If you are editing a word template, these are
	// already included
	// Add the provider name
	{
		//TES 12/26/2006 - PLID 23400 - There can now be multiple providers

		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Provider";
		mf.strData = "\"";
		if (m_aryProviders.GetSize()) {
			CString strName;
			for(int i = 0; i < m_aryProviders.GetSize(); i++) {
				strName += m_aryProviders[i]->strName + "; ";
			}
			strName = strName.Left(strName.GetLength() -2);
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed function. Prepares string for a Word merge data file.
			mf.strData += ConvertToQuotableWordCSVString(strName);
		}
		mf.strData += "\"";
		if(listMergeFields.IsEmpty()) {
			listMergeFields.AddHead(mf);
		}
		else {
			listMergeFields.AddTail(mf);
		}
	}

	//DRT 1/9/2007 - PLID 24160 - Add secondary provider information
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Provider_Secondary";
		mf.strData = "\"";
		if (m_arySecondaryProviders.GetSize()) {
			CString strName;
			for(int i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
				strName += m_arySecondaryProviders[i]->strName + "; ";
			}
			strName = strName.Left(strName.GetLength() -2);
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed function. Prepares string for a Word merge data file.
			mf.strData += ConvertToQuotableWordCSVString(strName);
		}
		mf.strData += "\"";
		if(listMergeFields.IsEmpty()) {
			listMergeFields.AddHead(mf);
		}
		else {
			listMergeFields.AddTail(mf);
		}
	}

	// Add the EMR date
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Date";
		// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
		mf.strData = "\"" + ConvertToQuotableWordCSVString(FormatDateTimeForInterface(m_dtEMNDate, DTF_STRIP_SECONDS, dtoDate)) + "\"";
		listMergeFields.AddTail(mf);
	}

	// Add the EMR input date
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Input_Date";
		if(m_nID == -1) {
			//if unsaved, used the current date
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
			mf.strData = "\"" + ConvertToQuotableWordCSVString(FormatDateTimeForInterface(COleDateTime::GetCurrentTime(), DTF_STRIP_SECONDS, dtoDate, true)) + "\"";
		}
		else {
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			_RecordsetPtr prsDate = CreateParamRecordset("SELECT InputDate FROM EMRMasterT WHERE ID = {INT}", m_nID);
			if (!prsDate->eof) {
				// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
				mf.strData = "\"" + ConvertToQuotableWordCSVString(FormatDateTimeForInterface(AdoFldDateTime(prsDate, "InputDate"), DTF_STRIP_SECONDS, dtoDate, true)) + "\"";
			} else {
				mf.strData = "\"\"";
			}
			prsDate->Close();
		}
		listMergeFields.AddTail(mf);
	}

	//TES 7/23/2004 - PLID 13614 - Add the procedure(s) of this EMR.
	//DRT 7/16/2007 - PLID 26681 - We already have the name, don't need to query it
	{
		//Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Procedure_List";
		mf.strData = "\"";
		for(int i = 0; i < m_aryProcedures.GetSize(); i++) {
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
			mf.strData += ConvertToQuotableWordCSVString(m_aryProcedures.GetAt(i)->strName) + ", ";
		}
		if(mf.strData.Right(2) == ", ") mf.strData = mf.strData.Left(mf.strData.GetLength()-2);
		mf.strData += "\"";
		listMergeFields.AddTail(mf);
	}

	// (j.jones 2005-03-25 12:02) - PLID 16058 - Add the Service Codes
	{
		// Add the header		
		CString strHeader, strFullPathData;
		strHeader = "EMR_ServiceCode_List";
		strFullPathData.Format("{NXRTF %s_ServiceCodes_%d.htm}", GetNxTempPath() ^ "MergeHTML_EMR", m_nID);

		MergeField mf;
		mf.strHeader = strHeader;
		mf.strData = strFullPathData;
		listMergeFields.AddTail(mf);

		//Create the file
		CString strFilename;
		CString strHTML;

		strFilename.Format("MergeHTML_EMR_ServiceCodes_%d.htm", m_nID);
		CString strFullPath = GetNxTempPath() ^ strFilename;
		CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);

		// (j.jones 2012-07-24 12:56) - PLID 44349 - this merge field includes all codes
		CString strHTMLServiceCodes = GetServiceCodesOutput(FALSE);

		// Write the content to the file
		strHTML = "<html><head></head><body>" + strHTMLServiceCodes + "</body></html>";
		f.WriteString(strHTML);
		f.Close();

		// Add to our temp file list
		m_saTempFiles.Add(strFullPath);
	}

	// (j.jones 2012-07-24 12:47) - PLID 44349 - added billable service codes
	{
		// Add the header		
		CString strHeader, strFullPathData;
		strHeader = "EMR_BillableServiceCode_List";
		strFullPathData.Format("{NXRTF %s_BillableServiceCodes_%d.htm}", GetNxTempPath() ^ "MergeHTML_EMR", m_nID);

		MergeField mf;
		mf.strHeader = strHeader;
		mf.strData = strFullPathData;
		listMergeFields.AddTail(mf);

		//Create the file
		CString strFilename;
		CString strHTML;

		strFilename.Format("MergeHTML_EMR_BillableServiceCodes_%d.htm", m_nID);
		CString strFullPath = GetNxTempPath() ^ strFilename;
		CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);

		// (j.jones 2012-07-24 12:56) - PLID 44349 - this merge field includes only billable codes
		CString strHTMLServiceCodes = GetServiceCodesOutput(TRUE);

		// Write the content to the file
		strHTML = "<html><head></head><body>" + strHTMLServiceCodes + "</body></html>";
		f.WriteString(strHTML);
		f.Close();

		// Add to our temp file list
		m_saTempFiles.Add(strFullPath);
	}

	// (a.walling 2006-12-10 22:09) - PLID 17298 - Add medication merge fields
	{
		// Add the header		
		CString strHeader, strFullPathData;
		strHeader = "EMR_Medication_List";
		strFullPathData.Format("{NXRTF %s_Medications_%d.htm}", GetNxTempPath() ^ "MergeHTML_EMR", m_nID);

		MergeField mf;
		mf.strHeader = strHeader;
		mf.strData = strFullPathData;
		listMergeFields.AddTail(mf);

		//Create the file
		CString strFilename;
		CString strHTML;

		strFilename.Format("MergeHTML_EMR_Medications_%d.htm", m_nID);
		CString strFullPath = GetNxTempPath() ^ strFilename;
		CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);

		CString strHTMLMedications = GetMedicationsOutput();

		// Write the content to the file
		strHTML = "<html><head></head><body>" + strHTMLMedications + "</body></html>";
		f.WriteString(strHTML);
		f.Close();

		// Add to our temp file list
		m_saTempFiles.Add(strFullPath);
	}

	// (j.jones 2005-03-25 12:02) - PLID 16058 - Add the ICD-9 Codes
	{
		// Add the header		
		CString strHeader, strFullPathData;
		strHeader = "EMR_DiagCode_List";
		strFullPathData.Format("{NXRTF %s_DiagCodes_%d.htm}", GetNxTempPath() ^ "MergeHTML_EMR", m_nID);

		MergeField mf;
		mf.strHeader = strHeader;
		mf.strData = strFullPathData;
		listMergeFields.AddTail(mf);

		//Create the file
		CString strFilename;
		CString strHTML;

		strFilename.Format("MergeHTML_EMR_DiagCodes_%d.htm", m_nID);
		CString strFullPath = GetNxTempPath() ^ strFilename;
		CStdioFile f(strFullPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText | CFile::shareCompat);

		CString strHTMLDiagCodes = GetDiagCodesOutput();

		// Write the content to the file
		strHTML = "<html><head></head><body>" + strHTMLDiagCodes + "</body></html>";
		f.WriteString(strHTML);
		f.Close();

		// Add to our temp file list
		m_saTempFiles.Add(strFullPath);
	}

	// Add the EMR notes
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Notes";
		CString strNotes;
		// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
		mf.strData.Format("\"%s\"", ConvertToQuotableWordCSVString(m_strNotes));
		listMergeFields.AddTail(mf);
	}

	//TES 9/8/2004 - PLID 13723 - Add this EMR's collection.
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Collection";
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset("SELECT Name FROM EMRCollectionT WHERE ID = {INT}", m_nEMRCollectionID);
		if(prs->eof) {
			mf.strData = "\"<Generic Collection>\"";
		}
		else {
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
			mf.strData = "\"" + ConvertToQuotableWordCSVString(AdoFldString(prs, "Name","")) + "\"";
		}
		listMergeFields.AddTail(mf);
	}

	// (a.wetta 2006-04-13 08:50) - PLID 13905 - Add the EMR's surgery appointment
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Surgery_Appt";
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset("select AptTypeT.Name, AppointmentsT.StartTime "
											"from AppointmentsT "
											"left join ProcInfoT on AppointmentsT.ID = ProcInfoT.SurgeryApptID "
											"left join PicT on ProcInfoT.ID = PicT.ProcInfoID "
											"left join EMRMasterT on PicT.EmrGroupID = EMRMasterT.EMRGroupID "
											"left join AptTypeT on AppointmentsT.AptTypeID = AptTypeT.ID "
											"where EMRMasterT.ID = {INT}", m_nID);
		if(prs->eof) {
			mf.strData = "\"\"";
		}
		else {
			CString str;
			str.Format("%s: %s", AdoFldString(prs, "Name",""), AdoFldDateTime(prs, "StartTime").Format("%x %#I:%M %p"));
			
			// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
			mf.strData = "\"" + ConvertToQuotableWordCSVString(str) + "\"";
		}
		listMergeFields.AddTail(mf);		
	}

	// (a.wetta 2006-04-13 08:50) - PLID 13905 - Add the EMR's other appointments list
	// (c.haag 2007-03-08 09:49) - PLID 25110 - Altered query to be independent of the active patient ID
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Other_Appts_List";
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset("select AptTypeT.Name, AppointmentsT.StartTime "
											"from AppointmentsT "
											"left join AptTypeT on AppointmentsT.AptTypeID = AptTypeT.ID "
											"WHERE PatientID IN (SELECT PatientID FROM EMRMasterT WHERE EMRMasterT.ID = {INT}) "
											"AND AppointmentsT.ID <> (SELECT  CASE WHEN SurgeryApptID Is Null THEN -1 ELSE SurgeryApptID END FROM ProcInfoT "
														  "left join PicT on PicT.ProcInfoID = ProcInfoT.ID "
														  "left join EMRMasterT on PicT.EmrGroupID = EMRMasterT.EMRGroupID "
														  "WHERE EMRMasterT.ID = {INT}) "
											"AND (AppointmentsT.ID IN (SELECT AppointmentID FROM AppointmentPurposeT WHERE PurposeID IN (SELECT ProcedureID FROM ProcInfoDetailsT "
														  "left join PicT on PicT.ProcInfoID = ProcInfoDetailsT.ProcInfoID "
														  "left join EMRMasterT on PicT.EmrGroupID = EMRMasterT.EMRGroupID "
														  "WHERE EMRMasterT.ID = {INT})) "
													// (a.walling 2013-02-21 13:58) - PLID 55287 - Disambiguate ProcInfoAppointmentsT.AppointmentID from EMRMasterT.AppointmentID
													"OR AppointmentsT.ID IN (SELECT ProcInfoAppointmentsT.AppointmentID FROM ProcInfoAppointmentsT "
														  "left join PicT on ProcInfoAppointmentsT.ProcInfoID = PicT.ProcInfoID "
														  "left join EMRMasterT on PicT.EmrGroupID = EMRMasterT.EMRGroupID "
														  "WHERE EMRMasterT.ID = {INT})) "
											"AND AppointmentsT.Status <> 4 "
											"order by AppointmentsT.StartTime", m_nID, m_nID, m_nID, m_nID);
		if(prs->eof) {
			mf.strData = "\"\"";
		}
		else {
			mf.strData = "\"";
			CString str;
			while (!prs->eof) {
				str.Format("%s: %s", AdoFldString(prs, "Name",""), AdoFldDateTime(prs, "StartTime").Format("%x %#I:%M %p"));
				// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed to ConvertToQuotableWordCSVString. Prepares string for a Word merge data file.
				mf.strData += ConvertToQuotableWordCSVString(str) + ", ";
				prs->MoveNext();
			}
			if(mf.strData.Right(2) == ", ") mf.strData = mf.strData.Left(mf.strData.GetLength()-2);
			mf.strData += "\"";
		}
		prs->Close();
		listMergeFields.AddTail(mf);		
	}

	// (j.jones 2007-08-16 09:36) - PLID 27054 - added Visit Type
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Visit_Type";
		// (j.kuziel 2011-12-08 11:04) - PLID 45613 - Changed function. Prepares string for a Word merge data file.
		mf.strData.Format("\"%s\"", ConvertToQuotableWordCSVString(m_strVisitTypeName));
		listMergeFields.AddTail(mf);
	}

	// (b.eyers 2016-02-23) - PLID 68323 - added discharge status description
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Discharge_Status_Description";

		mf.strData.Format("\"%s\"", ConvertToQuotableWordCSVString(m_DischargeStatus.strDesc));
		listMergeFields.AddTail(mf);
	}

	// (b.eyers 2016-02-23) - PLID 68323 - added discharge status code
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Discharge_Status_Code";

		mf.strData.Format("\"%s\"", ConvertToQuotableWordCSVString(m_DischargeStatus.strCode));
		listMergeFields.AddTail(mf);
	}

	// (b.eyers 2016-02-23) - PLID 68323 - added admission time
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Admission_Time";

		mf.strData = "\"" + ConvertToQuotableWordCSVString(FormatDateTimeForInterface(m_dtAdmissionTime, DTF_STRIP_SECONDS, dtoTime)) + "\"";
		listMergeFields.AddTail(mf);
	}

	// (b.eyers 2016-02-23) - PLID 68323 - added discharge time
	{
		// Add the header and value
		MergeField mf;
		mf.strHeader = "EMR_Discharge_Time";

		mf.strData = "\"" + ConvertToQuotableWordCSVString(FormatDateTimeForInterface(m_dtDischargeTime, DTF_STRIP_SECONDS, dtoTime)) + "\"";
		listMergeFields.AddTail(mf);
	}
}

// (j.jones 2012-07-24 12:49) - PLID 44349 - added filter for only billable codes
CString CEMN::GetServiceCodesOutput(BOOL bOnlyIncludeBillableCodes)
{
	CString strOut = "";

	for(int i=0;i<m_aryCharges.GetSize();i++) {

		EMNCharge *ecCharge = m_aryCharges.GetAt(i);

		// (j.jones 2012-07-24 12:49) - PLID 44349 - added filter for only billable codes
		if(!bOnlyIncludeBillableCodes || ecCharge->bBillable) {

			long nID = ecCharge->nServiceID;

			CString strCPT, strDesc;
			
			strCPT = ecCharge->strCode;
			
			strDesc	= ecCharge->strDescription;
			
			//remember we could be outputting products with no CPT Code
			strOut += strCPT;
			if(!strCPT.IsEmpty())
				strOut += " - ";
			strOut += strDesc;
			strOut += "<br>";
		}
	}

	if(strOut.Right(4) == "<br>")
		strOut = strOut.Left(strOut.GetLength()-4);

	return strOut;
}

CString CEMN::GetDiagCodesOutput()
{
	CString strOut = "";

	for(int i=0;i<m_aryDiagCodes.GetSize();i++) {
		EMNDiagCode* pDiag = m_aryDiagCodes.GetAt(i);

		CString strCodeICD9 = pDiag->strCode;
		CString strDescICD9 = pDiag->strCodeDesc;
		CString strCodeICD10 = pDiag->strCode_ICD10;
		CString strDescICD10 = pDiag->strCodeDesc_ICD10;
		CString strTmp = "";

		//(r.wilson 3/7/2014) PLID 61269 -
		// 1. If an ICD-9 & ICD-10 exists, display: "ICD-10 code - ICD-10 description (ICD-9 code)"
		if(strCodeICD9 != "" && strCodeICD10 != "")
		{
			strTmp.Format("%s - %s (%s)",strCodeICD10, strDescICD10, strCodeICD9);
			strOut += strTmp;
		}
		//(r.wilson 3/7/2014) PLID 61269 -
		// 2. If only an ICD-9 exists, display is unchanged from current style: "ICD-9 code - ICD-9 description"
		else if(strCodeICD10 == "" && strCodeICD9 != "")
		{
			strTmp.Format("%s - %s",strCodeICD9, strDescICD9);
			strOut += strTmp;
		}
		//(r.wilson 3/7/2014) PLID 61269 -
		// 3. If only an ICD-10 exists, display: "ICD-10 code - ICD-10 description"
		else if(strCodeICD10 != "" && strCodeICD9 == "")
		{
			strTmp.Format("%s - %s",strCodeICD10, strDescICD10);
			strOut += strTmp;
		}
		strOut += "<br>";	
	}

	if(strOut.Right(4) == "<br>")
		strOut = strOut.Left(strOut.GetLength()-4);

	return strOut;
}

// (a.walling 2006-12-11 14:27) - PLID 17298 - Add emn medication merge fields
CString CEMN::GetMedicationsOutput()
{
	CString strOut = "";

	for(int i=0;i<m_aryMedications.GetSize();i++) {
		EMNMedication* pMed = m_aryMedications.GetAt(i);
		long nMedID = pMed->nID;

		CString strPatientExplanation = pMed->strPatientExplanation;
		strPatientExplanation.Remove('\r');
		strPatientExplanation.Replace("\n", " / ");

		strOut += pMed->m_strDrugName;
		strOut += " - ";
		strOut += pMed->strQuantity + " " + pMed->strUnit + " (" + pMed->strRefillsAllowed + " refills)";
		if (!strPatientExplanation.IsEmpty()) {
			strOut += " - " + strPatientExplanation;
		}
		strOut += "<br>";
	}

	if(strOut.Right(4) == "<br>")
		strOut = strOut.Left(strOut.GetLength()-4);

	return strOut;
}

CString CEMN::GetParagraph(long nCategoryID, EmrCategoryFormat Format, CMergeEngine &mi, CList<CEMNDetail*,CEMNDetail*> *plistOrderedDetails)
{
	CString strOutput;
	//First, begin the list based on its format.
	switch(Format) {
	case ecfParagraph:
		//Do nothing.
		break;
	case ecfList:
		// (j.jones 2005-01-04 11:59) - not required here, or else we'd be adding an extraneous blank line
		//strOutput += "<br>";
		break;
	case ecfBulletedList:
		strOutput += "<UL>";
		break;
	case ecfNumberedList:
		strOutput += "<OL>";
		break;
	}

	//
	//DRT 6/20/2006 - PLID 21122 - I removed the loop that generated an ordered list of details here.  This function
	//	is called in a loop for every detail on the EMN... then we were looping again on every detail in the EMN to
	//	generate a list again and again.  I generated that list once (copied code to SortAllDetails) outside, and
	//	we then pass it in.  The details are in the same order for every loop.
	//


	//
	//DRT 6/20/2006 - PLID 21125 - The paragraph generation was creating a recordset for each detail in the ordered
	//	list.  I converted so that we execute 1 query to get a list of valid IDs, and then compare that list of IDs
	//	against the ordered list.  Keep in mind that this function is called for every category associated with a
	//	detail on this EMN, so any slowness here is multiplied.
	//

	//loop once to generate a list of all Info IDs
	CDWordArray aryInfoIDs;
	{
		POSITION pos = plistOrderedDetails->GetHeadPosition();
		while(pos) {
			CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);
			aryInfoIDs.Add(pCurListDetail->m_nEMRInfoID);
		}
	}

	//Now generate a single query that will find all the valid IDs (those that have the given nCategoryID)
	//if empty will get "-1", which cannot possibly yield any results from EMRInfoCategoryT
	
	CDWordArray aryValidIDs;
	// (a.walling 2010-06-09 18:09) - PLID 37580 - Built-in Signatures category
	if (nCategoryID != -26) {
		CString strIDs = ArrayAsString(aryInfoIDs, false);
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prsExists = CreateParamRecordset("SELECT EMRInfoID FROM EMRInfoCategoryT WHERE EMRCategoryID = {INT} AND EMRInfoID IN ({INTSTRING})", nCategoryID, strIDs);
		while(!prsExists->eof) {
			aryValidIDs.Add(AdoFldLong(prsExists, "EMRInfoID"));
			prsExists->MoveNext();
		}
		prsExists->Close();
	}

	//Now we have 2 lists to compare -- 
	//	plistOrderedDetails		This is an ordered list of all details on the EMN
	//	aryValidIDs				This is a list of all details (which are a subset of the plistOrderedDetails) which exist for the nCategoryID we've been given
	//We must compare again to preserve the order in plistOrderedDetails, which is of critical importance.

	{
		POSITION pos = plistOrderedDetails->GetHeadPosition();
		while(pos) {
			CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);
			long nEMRInfoID = pCurListDetail->m_nEMRInfoID;
			// (a.walling 2010-06-09 18:09) - PLID 37580 - Built-in Signatures category
			if(IsIDInArray(nEMRInfoID, &aryValidIDs) || (nCategoryID == -26 && pCurListDetail->IsSignatureDetail())) {
				//This detail is valid for our given category
				//DRT This code all existed before my speed changes

				//TES 9/2/2004: Skip the tags if there's no sentence.
				CString strSentence = GetSentence(pCurListDetail, &mi, true, true, Format);
				if(!strSentence.IsEmpty()) {

					//Put the pre-sentence tag, based on the format.
					switch(Format) {
					case ecfParagraph:
						//Nothing
						break;
					case ecfList:
						// (j.jones 2005-01-04 11:58) - required here, if it's not the first item
						if(strOutput != "")
							strOutput += "<br>";
						break;
					case ecfBulletedList:
					case ecfNumberedList:
						strOutput += "<LI>";
						break;
					}


					//Get the actual sentence.
					strOutput += strSentence;
					
					//Put the post-sentence info, based on the format.
					switch(Format) {
					case ecfParagraph:
						strOutput += " ";
						break;
					//case ecfList:
					case ecfNumberedList:
					case ecfBulletedList:
						strOutput += "<br>";
						break;
					}
				}

				//Done with this item.
			}
		}
	}

	// (z.manning 2008-12-10 12:26) - PLID 32392 - For paragraph formatted categories we put a space in between
	// each detail's text. That's fine, but make sure we trim the final space so we're not adding a spece where
	// it doesn't make sense e.g. when a period immediately follows the category merge field.
	if(strOutput.GetLength() > 0) {
		int nLastCharPos = strOutput.GetLength() - 1;
		if(Format == ecfParagraph && strOutput.GetAt(nLastCharPos) == ' ') {
			strOutput.Delete(nLastCharPos);
		}
	}


/*DRT 6/20/2006 - PLID 15556 - This block is the old (very slow) code that was removed.
	//Loop through all our items, using our new ordered list.
	for(POSITION pos = plistOrderedDetails->GetHeadPosition(); pos;) {
		CEMNDetail *pCurListDetail = plistOrderedDetails->GetNext(pos);
		//Is this item in this category (and what's its long form?)
		long nItemID = pCurListDetail->m_nEMRInfoID;
		if(ReturnsRecords("SELECT * FROM EmrInfoCategoryT WHERE EMRCategoryID = %li AND EMRInfoID = %li", nCategoryID, nItemID)) {
			//Yup.  Add it to our list.

			//TES 9/2/2004: Skip the tags if there's no sentence.
			CString strSentence = GetSentence(pCurListDetail, &mi, true, true, Format);
			if(!strSentence.IsEmpty()) {

				//Put the pre-sentence tag, based on the format.
				switch(Format) {
				case ecfParagraph:
					//Nothing
					break;
				case ecfList:
					// (j.jones 2005-01-04 11:58) - required here, if it's not the first item
					if(strOutput != "")
						strOutput += "<br>";
					break;
				case ecfBulletedList:
				case ecfNumberedList:
					strOutput += "<LI>";
					break;
				}


				//Get the actual sentence.
				strOutput += strSentence;
				
				//Put the post-sentence info, based on the format.
				switch(Format) {
				case ecfParagraph:
					strOutput += " ";
					break;
				//case ecfList:
				case ecfNumberedList:
				case ecfBulletedList:
					strOutput += "<br>";
					break;
				}
			}

			//Done with this item.
		}
	}
DRT 6/20/2006 - End of removed code*/

	//Now the post-paragraph info, based on the format.
	// (j.jones 2005-02-11 14:41) - PLID 15483 - bulleted/numbered lists require a <br>
	// after them to be more compliant with Word. Read this PL item to understand why.
	switch(Format) {
	case ecfParagraph:
	case ecfList:
		//Nothing.
		break;
	case ecfBulletedList:		
		strOutput += "</UL>";
		if(strOutput != "<UL></UL>")
			strOutput += "<br>";
		break;
	case ecfNumberedList:
		strOutput += "</OL>";
		if(strOutput != "<OL></OL>")
			strOutput += "<br>";
		break;
	}

	//Done, baby!
	return strOutput;
}

void CEMN::EditWordTemplates(HWND hwnd, CString strDefaultFile /*= ""*/, CString strDefaultPath /*= ""*/)
{

	//DRT 3/17/03 - Check for permission first!
	if (!CheckCurrentUserPermissions(bioLWEditTemplate, sptView))
		return;

	if (!GetWPManager()->CheckWordProcessorInstalled()) {
		return;
	}

	// (c.haag 2004-07-02 15:50) - PLID 13003 - Now we only get fields from the chart
	/*
	// (c.haag 2004-05-12 16:00) - PLID 12293 - Allow the user to select EMR merge fields
	// if they are associated with procedures or diagnosis codes.
	// (b.cardillo 2004-06-23 16:53) - PLID 13137 - Use a unified statement instead of 
	// combining two and hoping that starting with an "AND" is going to work.
	CString strEMRFilter;
	{
		CString strEMRProcedures;
		{
			if(m_ProcedureList->GetRowCount() != 0) {
				CString strProcIDs;
				for(int i = 0; i < m_ProcedureList->GetRowCount(); i++) {
					CString strID;
					strID.Format("%li, ", VarLong(m_ProcedureList->GetValue(i, 0)));
					strProcIDs += strID;
				}
				strProcIDs = strProcIDs.Left(strProcIDs.GetLength()-2);
				strEMRProcedures.Format("EMRInfoT.ID IN (SELECT EmrInfoID FROM ProcedureToEMRInfoT WHERE ProcedureID IN (%s)) ", 
					strProcIDs);
			}
		}
		CString strEMRDiagCodes;
		{
			long nDiagCodeCount = m_DiagCodeList->GetRowCount();
			if (nDiagCodeCount > 0) {
				CString strCodeIDs;
				for(int i = 0; i < m_DiagCodeList->GetRowCount(); i++) {
					CString strID;
					strID.Format("%li, ", VarLong(m_DiagCodeList->GetValue(i, 0)));
					strCodeIDs += strID;
				}
				strCodeIDs = strCodeIDs.Left(strCodeIDs.GetLength()-2);
				strEMRDiagCodes.Format("EMRInfoT.ID IN (SELECT EmrInfoID FROM DiagCodeToEMRInfoT WHERE DiagCodeID IN (%s))", strCodeIDs);
			}
		}
		// Ok, now we have 0, 1, or 2 filter strings.  We want to put it together.
		if (!strEMRProcedures.IsEmpty()) {
			// The procedure one is not empty, see about the diag code one
			if (!strEMRDiagCodes.IsEmpty()) {
				// 2: They're both not empty so combine them into one
				strEMRFilter.Format("(EMRInfoT.ID = -26 OR (%s) OR (%s))", strEMRProcedures, strEMRDiagCodes);
			} else {
				// 1: The procedure one is not empty but the diag code one is, so just use the procedure one
				strEMRFilter.Format("(EMRInfoT.ID = -26 OR (%s))", strEMRProcedures);
			}
		} else if (!strEMRDiagCodes.IsEmpty()) {
			// 1: The diag code one is not empty but the procedure one is, so just use the diag code one
			strEMRFilter.Format("(EMRInfoT.ID = -26 OR (%s))", strEMRDiagCodes);
		} else {
			// 0: They're both empty, leave so we have no emr filter
			strEMRFilter.Empty();
		}
	}
*/

	char path[MAX_PATH];
	CString strInitDir;
	if(strDefaultFile.IsEmpty()) {
		path[0] = 0;
	}
	else {
		strcpy(path, strDefaultFile);
	}
	if(strDefaultPath.IsEmpty()) {
		strInitDir = GetTemplatePath();
	}
	else {
		strInitDir = strDefaultPath;
	}
	OPENFILENAME ofn;
	ZeroMemory(&ofn, sizeof(OPENFILENAME));
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hwnd;

	// (a.walling 2007-06-14 13:22) - PLID 26342 - Should we support word 2007?
	// (a.walling 2007-10-12 14:04) - PLID 26342 - Also support macro-enabled 2007 documents
	// Always support Word 2007 templates
	static char Filter2007[] = "Microsoft Word Templates (*.dot, *.dotx, *.dotm)\0*.DOT;*.DOTX;*.DOTM\0";
	ofn.lpstrFilter = Filter2007;
	
	ofn.lpstrCustomFilter = NULL;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = path;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrInitialDir = strInitDir.GetBuffer(MAX_PATH);
	strInitDir.ReleaseBuffer();
	ofn.lpstrTitle = "Select a template to edit";
	ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;
	ofn.lpstrDefExt = "dot";

	if (!(::GetOpenFileName(&ofn))) {	
		DWORD dwErr = CommDlgExtendedError();
		return;
	}

	CString strMergeInfoFilePath;

	try {
		// (z.manning 2016-02-12 13:57) - PLID 68230 - Use the base word processor app class
		std::shared_ptr<CGenericWordProcessorApp> pApp = GetWPManager()->GetAppInstance();
		if (nullptr == pApp) return; // (c.haag 2016-06-01 11:48) - NX-100320 - If it's null then it's not supported and an exception was not thrown
		pApp->EnsureValid();

		// Create an empty MergeInfo.nxt
		long nFlags = BMS_HIDE_ALL_DATA	| BMS_DEFAULT | /*BMS_HIDE_PRACTICE_INFO |*/
					/*BMS_HIDE_PERSON_INFO | BMS_HIDE_DATE_INFO | BMS_HIDE_PRESCRIPTION_INFO |*/
					/*BMS_HIDE_CUSTOM_INFO | BMS_HIDE_INSURANCE_INFO |*/ BMS_HIDE_BILL_INFO /*|*/
					/*BMS_HIDE_PROCEDURE_INFO | BMS_HIDE_DOCTOR_INFO*/;

		// Generate the extra fields
		CExtraMergeFields emf;
		// (c.haag 2004-07-02 16:53) - This is already done by mergeengine.cpp
		//GenerateCommonMergeData(emf.m_strHeaders, emf.m_strData);
		//TES 9/1/2004: More or less cut-and-paste the code I just wrote in GenerateMergeData, there's got to be a way
		//to modularize this though.  Although come to think of it, there was no reason to put it in GenerateMergeData,
		//since it doesn't matter what order the fields are in there.  Oh, well.
		CString strHeadersLoc, strDataLoc;
		CList<MergeField,MergeField&> listFields;
		GenerateCategoryMergeData(listFields);

		POSITION pLastNonAlphabetized = listFields.GetTailPosition();

		// (c.haag 2004-07-02 15:36) - From now on we only include fields that come from this specific
		// chart in memory, and we get the information from memory.
		long nTotalDetailCount = GetTotalDetailCount();
		for (long i=0; i < nTotalDetailCount; i++)
		{
			CEMNDetail *pEMNDetail = GetDetail(i);
			MergeField mf;
			CString strHeader = pEMNDetail->GetMergeFieldName(TRUE);
			mf.strHeader = strHeader;
			mf.strData = "\"\"";

			//Find the right place to put this field.
			POSITION pos = pLastNonAlphabetized;
			listFields.GetNext(pos);
			CString strCurrentHeader;
			while (pos)
			{
				strCurrentHeader = listFields.GetNext(pos).strHeader;
				if (strCurrentHeader.CompareNoCase(strHeader) >= 0)
					break;
			}
			if (strCurrentHeader == strHeader) {
				//Duplicate!
				continue;
			}
			if(!pos)
				listFields.AddTail(mf);
			else
				listFields.InsertBefore(pos, mf);

		}

		// (c.haag 2004-07-06 09:09) - Now we include all the fields that don't exist for this
		// chart, but do exist for the procedures of this chart, as empty fields. We actually
		// look to data to get these values! <gasp>
		GenerateRelatedMergeData(listFields, pLastNonAlphabetized);

		POSITION pos = listFields.GetHeadPosition();
		while(pos) {
			MergeField mf = listFields.GetNext(pos);
			strHeadersLoc += mf.strHeader + ",";
			strDataLoc += mf.strData + ",";
		}

		emf.m_strHeaders = strHeadersLoc.Left(strHeadersLoc.GetLength()-1);
		emf.m_strData = strDataLoc.Left(strDataLoc.GetLength()-1);

		strMergeInfoFilePath = CMergeEngine::CreateBlankMergeInfo(nFlags, CEMN__ExtraMergeFields, &emf);


		if (!strMergeInfoFilePath.IsEmpty()) {

			// Open the template
			// (z.manning 2016-02-18 09:18) - PLID 68366 - This now returns a word processor document object
			// (c.haag 2016-04-22 10:40) - NX-100275 - OpenTemplate no longer returns a document. We never did anything with it except throw an exception if it were null
			// anyway, and now OpenTemplate does that for us
			pApp->OpenTemplate(path, strMergeInfoFilePath);

			// We can't delete the merge info text file right now because it is in use, but 
			// it's a temp file so mark it to be deleted after the next reboot
			DeleteFileWhenPossible(strMergeInfoFilePath);
			strMergeInfoFilePath.Empty();
		} else {
			AfxThrowNxException("Could not create blank merge info");
		}

		// (c.haag 2016-02-23) - PLID 68416 - We no longer catch Word-specific exceptions here. Those are now managed deep within the WordProcessor application object
	}NxCatchAll("CEMN::EditWordTemplates");

	if (!strMergeInfoFilePath.IsEmpty()) {
		// This means the file wasn't used and/or it wasn't 
		// marked for deletion at startup, so delete it now
		DeleteFile(strMergeInfoFilePath);
	}
}

// (a.walling 2012-03-26 08:55) - PLID 49141 - use const references, ignore set if values are equivalent
void CEMN::SetNotes(const CString& strNotes)
{
	if (!CompareAssign(m_strNotes, strNotes)) {
		return;
	}

	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

BOOL CEMN::PropagateNewID(long nID, EmrSaveObjectType esotSaveType, long nObjectPtr, long &nAuditTransactionID)
{
	//test to see if the nObjectPtr and esotSaveType match this object,
	//if so, assign the ID and return TRUE,
	//otherwise, propagate into the children of this item

	//is it this object?
	if(esotSaveType == esotEMN && (CEMN*)nObjectPtr == this) {
		//we have a winner!

		if(m_bIsTemplate) {

			// (c.haag 2007-06-19 17:32) - PLID 26388 - Fail if ID's already exist
			if (m_nID != -1) {
				ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on an EMN with an existing ID! (Current = %d nID = %d)", m_nID, nID);
			}
			if (m_nTemplateID != -1) {
				ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on an EMN with an existing template ID! (Current = %d nID = %d)", m_nTemplateID, nID);
			}

			m_nID = nID;
			m_nTemplateID = nID;

			// (a.walling 2008-06-02 12:24) - PLID 22049 - Notify the interface
			// (a.walling 2008-08-13 13:33) - PLID 22049 - This should occur after updating the revision in SaveEMRObject
			/*
			if (GetInterface()) {
				// (a.walling 2008-08-12 16:43) - PLID 22049 - Send rather than Post the message
				GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 1);
			}
			*/

			//we could not audit at the time the record was created
			//because we did not have the template ID.
			//Now we do, so audit the creation.

			CString strDesc;
			strDesc.Format("Template Created: %s", m_strDescription);
			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			AuditEvent(-1, "", nAuditTransactionID, aeiEMNTemplateCreated, m_nID, "", strDesc, aepMedium, aetCreated);
		}
		else {

			// (c.haag 2007-06-19 17:32) - PLID 26388 - Fail if an ID already exists
			if (m_nID != -1) {
				ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on an EMN with an existing ID! (Current = %d nID = %d)", m_nID, nID);
			}

			m_nID = nID;

			// (j.jones 2008-07-29 17:33) - PLID 30880 - if any problems are on this EMN, update their regarding IDs
			int i=0;
			// (z.manning 2009-05-22 14:51) - PLID 34332 - Handle problem links.
			for(i = 0; i < m_apEmrProblemLinks.GetSize(); i++) {
				CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(i);
				if(pProblemLink != NULL && pProblemLink->GetType() == eprtEmrEMN) {
					pProblemLink->SetRegardingID(nID);
				}
			}

			// (c.haag 2008-07-11 10:33) - PLID 30550 - If any todo's were added for this EMN, we need to update 
			// the regarding ID
			for (i=0; i < m_apCreatedTodosWhileUnsaved.GetSize(); i++) {
				EMNTodo* pTodo = m_apCreatedTodosWhileUnsaved[i];
				if (ttEMN == (TodoType)VarLong(pTodo->vRegardingType)) {
					// After the ID is assigned, we must make sure the EMN description is also up to date.
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					CSqlFragment sqlDescUpdateQ = TodoGetEmnAlarmUpdateQ(nID);
					long nTodoID = pTodo->nTodoID;
					ExecuteParamSql("UPDATE TodoList SET RegardingID = {INT} WHERE TaskID = {INT} AND RegardingType = {INT}\r\n{SQL}"
						,nID
						,nTodoID
						,ttEMN
						,sqlDescUpdateQ);
					// (c.haag 2012-12-06) - PLID 52863 - Don't delete the todo alarm. It will get deleted later in UpdateUnsavedTodos

					// Fire a table checker because we may have updated the todo notes
					// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Ex Todo
					if (pTodo->anAssignTo.GetSize() == 1){
						CClient::RefreshTodoTable(nTodoID, VarLong(pTodo->vPersonID,-1), VarLong(pTodo->anAssignTo[0],-1), TableCheckerDetailIndex::tddisChanged);
					}
					else{
						CClient::RefreshTodoTable(nTodoID, VarLong(pTodo->vPersonID,-1), -1, TableCheckerDetailIndex::tddisChanged);
					}
				}
			} // for (i=0; i < m_aryNonRegardingTodos.GetSize(); i++) {

			
			// (b.savon 2014-08-25 09:03) - PLID 62712 - Handle the ToDo creation preference when spawning diagnosis tuples in a different search mode
			for (int i = 0; i < m_aryDiagnosisActionsHeldForPostSaveProcessing.GetCount(); i++){
				EmrAction ea = m_aryDiagnosisActionsHeldForPostSaveProcessing.GetAt(i);
				ProcessSpawnedDiagnosisForTodoCreationInMisalignedModes(ea);
			}
			m_aryDiagnosisActionsHeldForPostSaveProcessing.RemoveAll();

			// (a.walling 2008-06-02 12:24) - PLID 22049 - Notify the interface
			// (a.walling 2008-08-13 13:33) - PLID 22049 - This should occur after updating the revision in SaveEMRObject
			/*
			if (GetInterface()) {
				// (a.walling 2008-08-12 16:43) - PLID 22049 - Send rather than Post the message
				GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 1);
			}
			*/

			//we could not audit at the time the record was created
			//because we did not have the template ID.
			//Now we do, so audit the creation.

			CString strDesc;

			// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
			strDesc.Format("EMN Created: %s (Status: %s)", m_strDescription, m_Status.strName);
			if(nAuditTransactionID == -1)
				nAuditTransactionID = BeginAuditTransaction();
			// (d.thompson 2013-11-06) - PLID 59352 - Bug fix.  We need to set m_strOldAuditValue as the old audit value on the new EMN audit.  This was implemented back in 2006 and
			//	somehow lost in the intervening years.  You can see this functionality by going into an EMR and copying an EMN.  There should be an audit that the new
			//	EMN came from the old EMN.
			AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditTransactionID, aeiEMNCreated, m_nID, m_strOldAuditValue, strDesc, aepHigh, aetCreated);
			//And just to be safe, erase the "old audit value" so it's not re-used again.
			m_strOldAuditValue.Empty();

			// (a.walling 2007-04-17 12:44) - PLID 25454 - All saving is done either in the Pic container when closing, opening, or in SaveEMRObject.

			// (j.jones 2011-07-11 15:06) - PLID 44509 - all our coding groups with a quantity > 0 need
			// to audit, they do not have their own object coming later in PropagateNewID
			for(int i=0; i<m_arypCodingGroups.GetSize(); i++) {
				CEmnCodingGroupInfo *pEMNGroupInfo = (CEmnCodingGroupInfo*)m_arypCodingGroups.GetAt(i);
				//ignore the m_bIsNew flag, because all groups on this EMN would have to be new
				if(pEMNGroupInfo->m_nGroupQuantity > 0) {
					if(nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}
					CString strNewValue;
					strNewValue.Format("%s: %li", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(pEMNGroupInfo->m_nEmrCodingGroupID), pEMNGroupInfo->m_nGroupQuantity);
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupQuantity, m_nID, "", strNewValue, aepMedium, aetCreated);
				}
			}
		}

		return TRUE;
	}
	else {
		//is it a Charge or Prescription?
		// (j.jones 2008-07-23 11:14) - PLID 30819 - added handling for diag codes
		if(esotSaveType == esotCharge || esotSaveType == esotPrescription || esotSaveType == esotDiagCode) {
			
			//check our MoreInfo contents, otherwise return FALSE because the
			//item would be in another EMN and we don't need to dig deeper

			// (j.jones 2008-07-23 11:14) - PLID 30819 - added handling for diag codes
			if(esotSaveType == esotDiagCode) {
				//search our diagnoses
				for(int i = 0; i < m_aryDiagCodes.GetSize(); i++) {
					EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
					if(pDiag == (EMNDiagCode*)nObjectPtr) {
						//we have a winner!
						//fail if an ID already exists
						if (pDiag->nID != -1) {
							ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a diagnosis code with an existing ID! (Current = %d nID = %d)", pDiag->nID, nID);
						}
						pDiag->nID = nID;

						// (j.jones 2008-07-29 17:33) - PLID 30880 - if any problems are on this diag code, update their regarding IDs
						// (z.manning 2009-05-22 14:51) - PLID 34332 - Handle problem links.
						for(int i = 0; i < pDiag->m_apEmrProblemLinks.GetSize(); i++) {
							CEmrProblemLink *pProblemLink = pDiag->m_apEmrProblemLinks.GetAt(i);
							if(pProblemLink != NULL && pProblemLink->GetType() == eprtEmrDiag) {
								pProblemLink->SetRegardingID(nID);
							}
						}

						if(GetInterface()) {
							GetInterface()->SendMessage(NXM_EMN_REFRESH_DIAG_CODES, (WPARAM)this);
						}
						return TRUE;
					}
				}
			}
			else if(esotSaveType == esotCharge) {
				//search our charges
				for(int i = 0; i < m_aryCharges.GetSize(); i++) {
					EMNCharge *pCharge = m_aryCharges.GetAt(i);
					if(pCharge == (EMNCharge*)nObjectPtr) {
						//we have a winner!
						// (c.haag 2007-06-19 17:32) - PLID 26388 - Fail if an ID already exists
						if (pCharge->nID != -1) {
							ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a charge with an existing ID! (Current = %d nID = %d)", pCharge->nID, nID);
						}
						pCharge->nID = nID;

						//TES 6/21/2012 - PLID 50983 - This is a new charge that was just saved, so add it to our array of saved charges
						EMNCharge *pOriginalCharge = new EMNCharge;
						*pOriginalCharge = *pCharge;
						m_aryOriginalCharges.Add(pOriginalCharge);

						// (j.jones 2008-07-29 17:33) - PLID 30880 - if any problems are on this charge, update their regarding IDs
						int j=0;
						// (z.manning 2009-05-22 14:51) - PLID 34332 - Handle problem links.
						for(int i = 0; i < pCharge->m_apEmrProblemLinks.GetSize(); i++) {
							CEmrProblemLink *pProblemLink = pCharge->m_apEmrProblemLinks.GetAt(i);
							if(pProblemLink != NULL && pProblemLink->GetType() == eprtEmrCharge) {
								pProblemLink->SetRegardingID(nID);
							}
						}

						if(GetInterface()) {
							GetInterface()->SendMessage(NXM_EMN_REFRESH_CHARGES, (WPARAM)this);
						}

						// (j.jones 2007-08-30 10:15) - PLID 27221 - added a pending audit info array, for E/M Checklist purposes

						// (j.jones 2007-08-30 11:41) - PLID 27221 - check our charges for any pending E/M checklist audits, and audit with the new EMN ID
						if(pCharge->m_bCreatedOnNewEMN) {
							for(j=0; j < pCharge->aryPendingEMAuditInfo.GetSize(); j++) {
								CPendingAuditInfo* pInfo = (CPendingAuditInfo*)(pCharge->aryPendingEMAuditInfo.GetAt(j));
								if(nAuditTransactionID == -1)
									nAuditTransactionID = BeginAuditTransaction();
								//ensure our record ID is the current EMN ID
								AuditPendingEvent(nAuditTransactionID, pInfo, m_nID);
							}
						}

						// We need to remove these pending audits once the new charge is saved, but
						// it has to be in PropagateNewID, NOT in PostSaveUpdate
						for(j=pCharge->aryPendingEMAuditInfo.GetSize()-1; j>= 0; j--) {
							delete (CPendingAuditInfo*)pCharge->aryPendingEMAuditInfo.GetAt(j);
						}
						pCharge->aryPendingEMAuditInfo.RemoveAll();

						// (j.jones 2011-07-14 08:56) - PLID 44509 - if added by a coding group, audit as such
						long nCodingGroupID = -1;
						if(m_mapChargesTo_CreatedByCodingGroupID.Lookup(pCharge, nCodingGroupID) && nCodingGroupID != -1) {

							if(nAuditTransactionID == -1) {
								nAuditTransactionID = BeginAuditTransaction();
							}

							CString strNewValue;
							strNewValue.Format("%s: Added Code %s", GetMainFrame()->GetEmrCodingGroupManager()->GetGroupNameByID(nCodingGroupID), pCharge->strCode);
							AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditTransactionID, aeiEMNCodingGroupAddedCharge, m_nID, "", strNewValue, aepMedium, aetCreated);

							// (j.jones 2011-07-14 09:24) - PLID 44509 - remove this key from the map
							m_mapChargesTo_CreatedByCodingGroupID.RemoveKey(pCharge);
						}

						return TRUE;
					}
				}
			}
			else if(esotSaveType == esotPrescription) {
				//search our prescriptions
				for(int i = 0; i < m_aryMedications.GetSize(); i++) {
					EMNMedication *pMedication = m_aryMedications.GetAt(i);
					if(pMedication == (EMNMedication*)nObjectPtr) {
						//we have a winner!
						// (c.haag 2007-06-19 17:32) - PLID 26388 - Fail if an ID already exists
						if (pMedication->nID != -1) {
							ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a medication with an existing ID! (Current = %d nID = %d)", pMedication->nID, nID);
						}
						pMedication->nID = nID;

						// (j.jones 2008-07-29 17:33) - PLID 30880 - if any problems are on this medication,
						// update their regarding IDs
						// (z.manning 2009-05-22 14:51) - PLID 34332 - Handle problem links.
						for(int i = 0; i < pMedication->m_apEmrProblemLinks.GetSize(); i++) {
							CEmrProblemLink *pProblemLink = pMedication->m_apEmrProblemLinks.GetAt(i);
							if(pProblemLink != NULL && pProblemLink->GetType() == eprtEmrMedication) {
								pProblemLink->SetRegardingID(nID);
							}
						}

						if(GetInterface()) {
							GetInterface()->SendMessage(NXM_EMN_REFRESH_PRESCRIPTIONS, (WPARAM)this);
						}
						return TRUE;
					}
				}
			}

			//if they are not in this EMN, we don't need to stick around
			return FALSE;
		}

		// (j.jones 2008-07-22 18:03) - PLID 30789 - handle EMNs, Charges, Diagnoses, and Medications
		if(esotSaveType == esotProblemLink)
		{
			int i = 0;
			// (z.manning 2009-05-22 15:14) - PLID 34332 - Need to handle problem links
			for(int nProblemLinkIndex = 0; nProblemLinkIndex < m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++)
			{
				CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
				if(pProblemLink == (CEmrProblemLink*)nObjectPtr)
				{
					if(pProblemLink->GetID() > 0) {
						ThrowNxException("Called CEMN::PropagateNewID on an existing problem link for a EMN! (Problem link ID: %li)", pProblemLink->GetID());
					}

					pProblemLink->SetID(nID);
					pProblemLink->Audit(aeiEMNProblemLinkCreated, nAuditTransactionID, GetExistingPatientName(GetParentEMR()->GetPatientID()));
					return TRUE;
				}
			}

			//try the Charges
			for(i = 0; i < m_aryCharges.GetSize(); i++) {
				EMNCharge *pCharge = (EMNCharge*)m_aryCharges.GetAt(i);
				if(pCharge) {
					//find each problem
					// (z.manning 2009-05-22 15:22) - PLID 34332 - Handle EMR problem links
					for(int nProblemLinkIndex = 0; nProblemLinkIndex < pCharge->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++) {
						CEmrProblemLink *pProblemLink = pCharge->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
						if(pProblemLink == (CEmrProblemLink*)nObjectPtr) {
							if(pProblemLink->GetID() > 0) {
								ThrowNxException("Called CEMN::PropagateNewID on an existing problem link for a charge! (Problem link ID: %li)", pProblemLink->GetID());
							}
							pProblemLink->SetID(nID);
							pProblemLink->Audit(aeiEMNProblemLinkCreated, nAuditTransactionID, GetExistingPatientName(GetParentEMR()->GetPatientID()));
							return TRUE;
						}
					}
				}
			}

			//try the Diagnoses
			for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
				EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDiagCodes.GetAt(i);
				if(pDiag) {
					//find each problem
					// (z.manning 2009-05-22 15:22) - PLID 34332 - Handle EMR problem links
					for(int nProblemLinkIndex = 0; nProblemLinkIndex < pDiag->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++) {
						CEmrProblemLink *pProblemLink = pDiag->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
						if(pProblemLink == (CEmrProblemLink*)nObjectPtr) {
							if(pProblemLink->GetID() > 0) {
								ThrowNxException("Called CEMN::PropagateNewID on an existing problem link for a diagnosis code! (Problem link ID: %li)", pProblemLink->GetID());
							}
							pProblemLink->SetID(nID);
							pProblemLink->Audit(aeiEMNProblemLinkCreated, nAuditTransactionID, GetExistingPatientName(GetParentEMR()->GetPatientID()));

							return TRUE;
						}
					}
				}
			}

			//try the Medications
			for(i = 0; i < m_aryMedications.GetSize(); i++) {
				EMNMedication *pMed = (EMNMedication*)m_aryMedications.GetAt(i);
				if(pMed) {
					//find each problem
					// (z.manning 2009-05-22 15:22) - PLID 34332 - Handle EMR problem links
					for(int nProblemLinkIndex = 0; nProblemLinkIndex < pMed->m_apEmrProblemLinks.GetSize(); nProblemLinkIndex++) {
						CEmrProblemLink *pProblemLink = pMed->m_apEmrProblemLinks.GetAt(nProblemLinkIndex);
						if(pProblemLink == (CEmrProblemLink*)nObjectPtr) {
							if(pProblemLink->GetID() > 0) {
								ThrowNxException("Called CEMN::PropagateNewID on an existing problem link for a medication! (Problem link ID: %li)", pProblemLink->GetID());
							}
							pProblemLink->SetID(nID);
							pProblemLink->Audit(aeiEMNProblemLinkCreated, nAuditTransactionID, GetExistingPatientName(GetParentEMR()->GetPatientID()));
							return TRUE;
						}
					}
				}
			}
		}

		//otherwise check all EMRTopics
		BOOL bFound = FALSE;
		// (a.walling 2007-09-04 10:49) - PLID 27284 - PropagateNewID also updates SourceDetailIDs, which can be
		// anywhere on an EMN, even in multiple disparate topics. By stopping this iteration as soon as we update
		// the ID of the actual item, we also prevent updating the SourceDetailID of any details following in the
		// search. However, those before the target item in the search will have their SourceDetailIDs updated!
		// There does not seem to be any way around forcing a scan through the entire structure.
		for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
			if(m_arypEMRTopics.GetAt(i)->PropagateNewID(nID, esotSaveType, nObjectPtr, nAuditTransactionID))
				bFound = TRUE;
		}

		if(esotSaveType == esotDetail) {

			// (j.jones 2007-01-12 14:35) - PLID 24027 - see if our SourceDetail pointer is this detail,
			// if so, update our SourceDetailID accordingly
			
			//first for the EMN
			if(m_sai.nSourceDetailID == -1 && m_sai.pSourceDetail != NULL
				&& m_sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {

				//this is our source detail! update the ID
				// (c.haag 2007-06-19 17:32) - PLID 26388 - Fail if an ID already exists
				if (m_sai.nSourceDetailID != -1) {
					ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on an EMN with an existing source detail ID! (Current = %d nID = %d)", m_sai.nSourceDetailID, nID);
				}
				m_sai.nSourceDetailID = nID;
			}

			// (a.walling 2007-11-05 16:08) - PLID 27980 - VS2008 - for() loops
			int i = 0;

			//Charges
			for(i = 0; i < m_aryCharges.GetSize(); i++) {
				EMNCharge *pCharge = m_aryCharges.GetAt(i);
				if(pCharge->sai.nSourceDetailID == -1 && pCharge->sai.pSourceDetail != NULL
					&& pCharge->sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {
					
					//this is our source detail! update the ID
					// (c.haag 2007-06-19 17:36) - PLID 26388 - Fail if an ID already exists
					if (pCharge->sai.nSourceDetailID != -1) {
						ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a charge with an existing source detail ID! (Current = %d nID = %d)", pCharge->sai.nSourceDetailID, nID);
					}
					pCharge->sai.nSourceDetailID = nID;
				}
			}

			//Diag Codes
			for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
				EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
				if(pDiag->sai.nSourceDetailID == -1 && pDiag->sai.pSourceDetail != NULL
					&& pDiag->sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {
					
					//this is our source detail! update the ID
					// (c.haag 2007-06-19 17:36) - PLID 26388 - Fail if an ID already exists
					if (pDiag->sai.nSourceDetailID != -1) {
						ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a diagnosis code with an existing source detail ID! (Current = %d nID = %d)", pDiag->sai.nSourceDetailID, nID);
					}
					pDiag->sai.nSourceDetailID = nID;
				}
			}

			//Procedures
			for(i = 0; i < m_aryProcedures.GetSize(); i++) {
				EMNProcedure *pProc = m_aryProcedures.GetAt(i);
				if(pProc->sai.nSourceDetailID == -1 && pProc->sai.pSourceDetail != NULL
					&& pProc->sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {
					
					//this is our source detail! update the ID
					// (c.haag 2007-06-19 17:36) - PLID 26388 - Fail if an ID already exists
					if (pProc->sai.nSourceDetailID != -1) {
						ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a procedure with an existing source detail ID! (Current = %d nID = %d)", pProc->sai.nSourceDetailID, nID);
					}
					pProc->sai.nSourceDetailID = nID;
				}
			}

			//Medications
			for(i = 0; i < m_aryMedications.GetSize(); i++) {
				EMNMedication *pPresc = m_aryMedications.GetAt(i);
				if(pPresc->sai.nSourceDetailID == -1 && pPresc->sai.pSourceDetail != NULL
					&& pPresc->sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {
					
					//this is our source detail! update the ID
					// (c.haag 2007-06-19 17:36) - PLID 26388 - Fail if an ID already exists
					if (pPresc->sai.nSourceDetailID != -1) {
						ASSERT(FALSE); ThrowNxException("Called CEMN::PropagateNewID on a prescription with an existing source detail ID! (Current = %d nID = %d)", pPresc->sai.nSourceDetailID, nID);
					}
					pPresc->sai.nSourceDetailID = nID;
				}
			}

			// (c.haag 2008-06-24 10:12) - PLID 17244 - If any todo's were spawned for unsaved
			// details, we need to update their regarding ID's
			for (i=0; i < m_apCreatedTodosWhileUnsaved.GetSize(); i++) {
				EMNTodo* pTodo = m_apCreatedTodosWhileUnsaved[i];
				if (ttEMNDetail == (TodoType)VarLong(pTodo->vRegardingType) && pTodo->sai.pSourceDetail == (CEMNDetail*)nObjectPtr) {
					// After the ID is assigned, we must make sure the EMN description is also up to date.
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					CSqlFragment sqlDescUpdateQ = TodoGetEmrDetailAlarmUpdateQ(-1, nID);
					long nTodoID = pTodo->nTodoID;
					ExecuteParamSql("UPDATE TodoList SET RegardingID = {INT} WHERE TaskID = {INT} AND RegardingType = {INT}\r\n{SQL}"						
						,nID
						,nTodoID
						,ttEMNDetail
						,sqlDescUpdateQ);
					// (c.haag 2012-12-06) - PLID 52863 - Don't delete the todo alarm. It will get deleted later in UpdateUnsavedTodos

					// Fire a table checker because we may have updated the todo notes
					// (s.tullis 2014-08-21 10:09) - 63344 -Changed to Ex Todo
					if ( pTodo->anAssignTo.GetSize() == 1 ){
						CClient::RefreshTodoTable(nTodoID, VarLong(pTodo->vPersonID,-1) ,VarLong(pTodo->anAssignTo[0]), TableCheckerDetailIndex::tddisChanged);
					}
					else{
						CClient::RefreshTodoTable(nTodoID, VarLong(pTodo->vPersonID,-1),-1, TableCheckerDetailIndex::tddisChanged);
					}
				}
			} // for (i=0; i < m_aryNonRegardingTodos.GetSize(); i++) {
		}

		// (z.manning 2011-01-03 16:04) - PLID 41974 - We need to propagate the detail image stamp ID to any objects
		// it may have spawned.
		if(esotSaveType == esotDetailImageStamp)
		{
			//first for the EMN
			if(m_sai.GetDetailStampID() == -1 && m_sai.GetDetailStampPointer() != NULL
				&& (long)m_sai.GetDetailStampPointer() == nObjectPtr)
			{
				m_sai.SetDetailStampID(nID);
			}

			int i = 0;

			//Charges
			for(i = 0; i < m_aryCharges.GetSize(); i++)
			{
				EMNCharge *pCharge = m_aryCharges.GetAt(i);
				if(pCharge->sai.GetDetailStampID() == -1 && pCharge->sai.GetDetailStampPointer() != NULL
					&& (long)pCharge->sai.GetDetailStampPointer() == nObjectPtr)
				{
					pCharge->sai.SetDetailStampID(nID);
				}
			}

			//Diag Codes
			for(i = 0; i < m_aryDiagCodes.GetSize(); i++)
			{
				EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
				if(pDiag->sai.GetDetailStampID() == -1 && pDiag->sai.GetDetailStampPointer() != NULL
					&& (long)pDiag->sai.GetDetailStampPointer() == nObjectPtr)
				{
					pDiag->sai.SetDetailStampID(nID);
				}
			}

			//Procedures
			for(i = 0; i < m_aryProcedures.GetSize(); i++)
			{
				EMNProcedure *pProc = m_aryProcedures.GetAt(i);
				if(pProc->sai.GetDetailStampID() == -1 && pProc->sai.GetDetailStampPointer() != NULL
					&& (long)pProc->sai.GetDetailStampPointer() == nObjectPtr)
				{
					pProc->sai.SetDetailStampID(nID);
				}
			}

			//Medications
			for(i = 0; i < m_aryMedications.GetSize(); i++)
			{
				EMNMedication *pPresc = m_aryMedications.GetAt(i);
				if(pPresc->sai.GetDetailStampID() == -1 && pPresc->sai.GetDetailStampPointer() != NULL
					&& (long)pPresc->sai.GetDetailStampPointer() == nObjectPtr)
				{
					pPresc->sai.SetDetailStampID(nID);
				}
			}
		}

		return bFound;
	}
}

// (a.walling 2010-03-31 11:23) - PLID 38006 - Now we need to ensure any cross-EMN IDs are updated
void CEMN::PropagateCrossEMNIDs()
{
	try {		
		// for now the only cross-EMN IDs are the source action info for the EMN

		// first update our source detail
		if (m_sai.pSourceDetail && m_sai.nSourceDetailID == -1) {
			m_sai.nSourceDetailID = m_sai.pSourceDetail->GetID();
			// it should never be -1 since we should have verified that all dependent EMNs (and therefore details) are saved before saving this emn
			ASSERT(m_sai.nSourceDetailID != -1);
		}

		// now we have all the other stuff in the SourceActionInfo.
		TableRowID* pTableRowID = (m_sai.GetTableRow() ? &m_sai.GetTableRow()->m_ID : NULL);
		// (c.haag 2012-10-26) - PLID 53440 - Use new utility methods to get the image stamp object and ID's.
		// Also removed any comparisons between internal variables of the table row; as of now there is no need
		// to "sync" the stamp object ID's and the TableRowID ID's from outside the TableRowID object.
		if (pTableRowID && pTableRowID->GetDetailImageStampObject()) {
//#if _DEBUG
			/*
			if (pTableRowID->nEmrDetailImageStampID != -1) {
				ASSERT(pTableRowID->nEmrDetailImageStampID == pTableRowID->pDetailImageStamp->nID || pTableRowID->nEmrDetailImageStampID == pTableRowID->pDetailImageStamp->nLoadedFromID);
			}

			if (pTableRowID->nStampID != -1) {
				ASSERT(pTableRowID->nStampID == pTableRowID->pDetailImageStamp->nStampID);
			}*/
			
			// (a.walling 2010-05-19 15:48) - PLID 38006 - The stamp index is only available for templates, apparently, except in memory
			//#pragma TODO("PLID 38006 - the stamp index does not seem to be available here...")
			/*
			if (m_sai.pSourceDetail) {				
				if (pTableRowID->nStampIndexInDetailByType != -1) {
					ASSERT(pTableRowID->nStampIndexInDetailByType == m_sai.pSourceDetail->GetStampIndexInDetailByType(pTableRowID->pDetailImageStamp));
				}
			}
			*/
//#endif

			/*
			if (pTableRowID->nEmrDetailImageStampID == -1) {
				pTableRowID->nEmrDetailImageStampID = pTableRowID->pDetailImageStamp->nID;
			}*/
			ASSERT(pTableRowID->GetDetailImageStampID() != -1);

			/*
			if (pTableRowID->nStampID == -1) {
				pTableRowID->nStampID = pTableRowID->pDetailImageStamp->nStampID;
			}*/
			ASSERT(pTableRowID->GetImageStampID() != -1);

			// (a.walling 2010-05-19 15:48) - PLID 38006 - The stamp index is only available for templates, apparently, except in memory
			//#pragma TODO("PLID 38006 - the stamp index does not seem to be available here...")
			/*
			if (m_sai.pSourceDetail) {				
				if (pTableRowID->nStampIndexInDetailByType == -1) {
					pTableRowID->nStampIndexInDetailByType = m_sai.pSourceDetail->GetStampIndexInDetailByType(pTableRowID->pDetailImageStamp);
				}
			}
			*/
		}
	} NxCatchAll("Error in CEMN::PropagateCrossEMNIDs()");
}

BOOL CEMN::IsUnsaved()
{
	//We are unsaved if m_bUnsaved is true, m_bMoreInfoUnsaved is true, if any of our topics are unsaved, 
	//or if we have any deleted topics pending.
	//TES 6/22/2006 - Also if our topic order has changed.
	//TES 2/12/2014 - PLID 60470 - Or if m_bCodesUnsaved is true 
	if(m_bUnsaved || m_bMoreInfoUnsaved || m_bTopicArrayChanged || m_bCodesUnsaved) {
		return TRUE;
	}

	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->IsUnsaved(TRUE)) 
			return TRUE;
	}
	if(m_arypDeletedTopics.GetSize()) 
		return TRUE;

	return FALSE;
}

// (j.jones 2011-07-15 13:45) - PLID 42111 - takes in an image file name (could be a path),
// and returns TRUE if any Image detail on this EMN references it
BOOL CEMN::IsImageFileInUse(const CString strFileName)
{
	long nTotalDetailCount = GetTotalDetailCount();
	for(int i = 0; i < nTotalDetailCount; i++) {
		CEMNDetail *pDetail = GetDetail(i);
		//if the file name is a full path or just a file name from the patient's documents folder,
		//it will match m_strBackgroundImageFilePath (which sometimes - but not always - has a \ in front of it)
		if(pDetail->m_EMRInfoType == eitImage) {
			CString strBackgroundImage = pDetail->GetBackgroundImageFilePath();
			if(strBackgroundImage.CompareNoCase(strFileName) == 0
				|| strBackgroundImage.CompareNoCase("\\" + strFileName) == 0) {
				return TRUE;
			}
		}
	}

	return FALSE;
}

// (j.jones 2008-07-23 15:07) - PLID 30789 - added ability to mark unsaved
void CEMN::SetUnsaved()
{
	m_bUnsaved = TRUE;
	
	//TES 2/26/2014 - PLID 60972 - SetMoreInfoUnsaved() should not have been called here; just because the EMN is unsaved
	// doesn't mean MoreInfo is.
	/*// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
	//TES 2/20/2014 - PLID 60740 - Added SetCodesUnsaved()
	SetCodesUnsaved();*/
}

void CEMN::SetSaved(BOOL bIsPostLoad /*= FALSE*/)
{
	// (j.jones 2007-01-30 12:01) - PLID 24353 - for the purposes of time tracking,
	// anytime we save a change, track that a change was indeed made
	if(!bIsPostLoad && IsUnsaved()) {
		m_bChangesMadeThisSession = TRUE;
		// (j.jones 2012-01-31 15:30) - PLID 47878 - set this flag to TRUE on the parent EMR as well
		GetParentEMR()->SetChangesMadeThisSession(TRUE);
	}

	//ensure that our EMR is marked saved too, because
	//any time we save an EMN, we save the EMR record,
	//but the EMR's SetSaved() propagates to all children
	GetParentEMR()->SetSavedNoPropagate(bIsPostLoad);

	// (j.jones 2006-08-24 11:43) - PLID 22183 - if this is a post save, as opposed
	// to a post load, then don't mark as saved if it is a locked EMN,
	// because it would not have been saved
	if(bIsPostLoad || !IsLockedAndSaved()) {
		m_bUnsaved = FALSE;
		m_bMoreInfoUnsaved = FALSE;
		m_bTopicArrayChanged = FALSE;
		//TES 2/12/2014 - PLID 60470 - Added m_bCodesUnsaved
		m_bCodesUnsaved = FALSE;
	}

	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		m_arypEMRTopics[i]->SetSaved(bIsPostLoad);
	}
}

// (j.jones 2007-08-02 11:42) - PLID 26915 - added ability to pass in a connection
void CEMN::LoadFromTopic(CEMRTopic *pTopic, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	try {

		_ConnectionPtr pCon;
		if(lpCon) pCon = lpCon;
		else pCon = GetRemoteData();

		m_bIsTemplate = pTopic->IsTemplate();
		if(!m_bIsTemplate) {		
			//first load the EMN-level data.
			//load a patient EMN
			// (z.manning, 05/07/2007) - PLID 25925 - Now load the location name.
			// (j.jones 2007-06-14 11:44) - PLID 26276 - Added Completion Status
			// (j.jones 2007-09-18 08:49) - PLID 27396 - added TotalTimeInSeconds
			// (a.walling 2008-07-01 15:05) - PLID 30586 - Added location logo
			// (a.walling 2010-10-29 10:33) - PLID 31435 - Added location logo width
			// (z.manning 2009-03-05 12:55) - PLID 33338 - SourceDataGroupID
			// (z.manning 2009-11-19 09:19) - PLID 35810 - Added patient created status
			// (z.manning 2010-02-25 10:13) - PLID 37532 - SourceDetailImageStampID
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			// (j.jones 2011-07-05 11:45) - PLID 43603 - added StatusName
			// (a.walling 2012-06-07 08:51) - PLID 50920 - Dates - Modified, Created
			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			_RecordsetPtr rsEMN = CreateParamRecordset(pCon, "SELECT EmrMasterT.ID, LocationID, Date, EmrMasterT.InputDate, EmrMasterT.ModifiedDate, PatientAge, PatientGender, "
				"Status, EMRMasterT.Description, AdditionalNotes, TemplateID, Status, EMRStatusListT.Name AS StatusName, EMRCollectionID, SourceActionID, SourceDetailID, "
				"PatientFirst, PatientMiddle, PatientLast, LocationsT.Name AS LocationName, "
				"LocationsT.LogoImagePath AS LocationLogo, LocationsT.LogoWidth AS LocationLogoWidth, "
				"EMRMasterT.CompletionStatus, EmrMasterT.VisitTypeID, EMRVisitTypesT.Name AS VisitTypeName, "
				// (j.jones 2007-09-18 08:49) - PLID 27396 - added TotalTimeInSeconds
				// (j.jones 2013-02-27 15:47) - PLID 55351 - Ignore all time slips with a null end time, which means they are uncommitted.
				"(SELECT Coalesce(Sum(DATEDIFF(second, StartTime, EndTime)),0) FROM EMRMasterSlipT WHERE EMRID = EMRMasterT.ID AND EndTime Is Not Null) AS TotalTimeInSeconds, "
				// (a.walling 2008-05-29 10:42) - PLID 22049 - added Revision
				"EmrMasterT.Revision, SourceDataGroupID, SourceType, PatientCreatedStatus, SourceDetailImageStampID, "
				"EMRMasterT.AppointmentID, EmrTemplateT.HideTitleOnPreview, EMRMasterT.DischargeStatusID, "
				"DischargeStatusT.Code AS DischargeStatusCode, DischargeStatusT.Description AS DischargeStatusDesc, "
				"EMRMasterT.AdmissionTime, EMRMasterT.DischargeTime "
				"FROM EMRMasterT "
				"LEFT JOIN EmrActionsT ON EmrMasterT.SourceActionID = EmrActionsT.ID "
				"LEFT JOIN LocationsT ON EmrMasterT.LocationID = LocationsT.ID "
				"LEFT JOIN EMRVisitTypesT ON EMRMasterT.VisitTypeID = EMRVisitTypesT.ID "
				"LEFT JOIN EMRStatusListT ON EMRMasterT.Status = EMRStatusListT.ID "
				"LEFT JOIN EmrTemplateT ON EmrMasterT.TemplateID = EmrTemplateT.ID "
				"LEFT JOIN DischargeStatusT ON EMRMasterT.DischargeStatusID = DischargeStatusT.ID "
				"WHERE EmrMasterT.ID = (SELECT EmrID FROM EmrTopicsT WHERE ID = {INT})", pTopic->GetID());
			
			if(rsEMN->eof) {
				AfxThrowNxException("CEMN::LoadFromTopicID called with invalid ID!");
			}
			
			m_nID = AdoFldLong(rsEMN, "ID");
			m_dtEMNDate = AdoFldDateTime(rsEMN, "Date",COleDateTime::GetCurrentTime());
			// (a.walling 2012-06-07 08:52) - PLID 50920 - Dates - Modified, Created
			m_dtEMNInputDate = AdoFldDateTime(rsEMN, "InputDate", COleDateTime::GetCurrentTime());
			m_dtEMNModifiedDate = AdoFldDateTime(rsEMN, "ModifiedDate", COleDateTime::GetCurrentTime());
			// (z.manning 2010-01-13 11:39) - PLID 22672 - Age is now a string
			m_strPatientAge = AdoFldString(rsEMN, "PatientAge","");
			m_strDescription = AdoFldString(rsEMN, "Description","");
			m_strNotes = AdoFldString(rsEMN, "AdditionalNotes","");
			m_nTemplateID = AdoFldLong(rsEMN, "TemplateID", -1);
			m_Status.nID = AdoFldLong(rsEMN, "Status", 0);
			m_Status.strName = AdoFldString(rsEMN, "StatusName", "Open");
			m_nPatientCreatedStatus = AdoFldByte(rsEMN, "PatientCreatedStatus", 0); // (z.manning 2009-11-19 09:10) - PLID 35810
			m_nEMRCollectionID = AdoFldLong(rsEMN, "EMRCollectionID", -1);
			m_sai.nSourceActionID = AdoFldLong(rsEMN, "SourceActionID", -1);
			// (j.jones 2007-01-11 10:32) - PLID 24027 - supported SourceDetailID
			m_sai.nSourceDetailID = AdoFldLong(rsEMN, "SourceDetailID", -1);
			// (z.manning 2009-03-04 14:49) - PLID 33338 - SourceDataGroupID
			m_sai.SetDataGroupID(AdoFldLong(rsEMN, "SourceDataGroupID", -1));
			m_sai.SetDetailStampID(AdoFldLong(rsEMN, "SourceDetailImageStampID", -1));
			m_sai.eaoSourceType = (EmrActionObject)AdoFldLong(rsEMN, "SourceType", eaoInvalid);
			// (a.walling 2013-01-16 13:04) - PLID 54650 - Appointment linked with this EMN
			m_Appointment = EMNAppointment(AdoFldLong(rsEMN, "AppointmentID", -1));  
			m_Location.nID = AdoFldLong(rsEMN, "LocationID", -1);
			m_Location.strName = AdoFldString(rsEMN, "LocationName", "");
			// (a.walling 2008-07-01 15:01) - PLID 30586 - Logo
			m_Location.strLogo = AdoFldString(rsEMN, "LocationLogo", "");
			// (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width
			m_Location.nLogoWidth = AdoFldLong(rsEMN, "LocationLogoWidth", 100);
			// (j.jones 2007-06-14 11:41) - PLID 26276 - CompletionStatus
			m_ecsCompletionStatus = (EMNCompletionStatus)AdoFldLong(rsEMN, "CompletionStatus", -1);

			// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
			m_nVisitTypeID = AdoFldLong(rsEMN, "VisitTypeID", -1);
			m_strVisitTypeName = AdoFldString(rsEMN, "VisitTypeName", "");

			// (j.jones 2007-10-02 10:09) - PLID 27054 - set the last saved info for VisitType
			m_nLastSavedVisitTypeID = m_nVisitTypeID;
			m_strLastSavedVisitTypeName = m_strVisitTypeName;

			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview = AdoFldBool(rsEMN, "HideTitleOnPreview", FALSE)?true:false;

			// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
			m_DischargeStatus.nID = AdoFldLong(rsEMN, "DischargeStatusID", -1);
			m_DischargeStatus.strCode = AdoFldString(rsEMN, "DischargeStatusCode", "");
			m_DischargeStatus.strDesc = AdoFldString(rsEMN, "DischargeStatusDesc", "");
			COleDateTime dtEmpty;
			dtEmpty.SetStatus(COleDateTime::null);
			m_dtAdmissionTime = AdoFldDateTime(rsEMN, "AdmissionTime", dtEmpty);
			m_dtDischargeTime = AdoFldDateTime(rsEMN, "DischargeTime", dtEmpty);

			// (j.jones 2007-09-18 08:49) - PLID 27396 - added TotalTimeInSeconds
			long nTotalTimeInSeconds = AdoFldLong(rsEMN, "TotalTimeInSeconds", -1);
			if(nTotalTimeInSeconds == -1)
				//set to 0, not invalid
				m_dtTotalTimeOpened_PreviousSessions.SetDateTimeSpan(0, 0, 0, 0);
			else
				SetTotalTimeOpened_PreviousSessions(nTotalTimeInSeconds);

			// (j.jones 2007-08-06 14:47) - PLID 26974 - We now will always use the patient info. from the saved EMN,
			// and never revert to the current patient info. Locked or unlocked, it doesn't matter.

			//m.hancock - 3/14/2006 - 19579 - Patient demographics shouldn't change after the EMN is locked.
			//if(m_nStatus == 2) { //The EMN is locked, so retrieve and display the stored values
				//Name
				m_strPatNameFirst = AdoFldString(rsEMN, "PatientFirst","");
				m_strPatNameMiddle = AdoFldString(rsEMN, "PatientMiddle","");
				m_strPatNameLast = AdoFldString(rsEMN, "PatientLast","");
				//If the name fields are blank (because of records created prior to this change), lookup the patient's name.
				//Only check the first and last name because it is common for middle name to be blank.
				// (c.haag 2006-07-31 17:46) - PLID 21719 - Moved to after the call m_pParentEMR = new CEMR(); to avoid memory leaks
				/*if(m_strPatNameFirst.IsEmpty() || m_strPatNameLast.IsEmpty()) {
					_RecordsetPtr rsPatientInfo = CreateRecordset("SELECT First, Middle, Last FROM PersonT WHERE ID = %li", GetParentEMR()->GetPatientID());
					if(!rsPatientInfo->eof) {
						m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
						m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
						m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					}
				}*/
				//Gender
				m_cbPatientGender = AdoFldByte(rsEMN, "PatientGender",0);
			//}

			//else { //The EMN is active, so retrieve and display the currently set values from the patient's data
				// (c.haag 2006-07-31 17:46) - PLID 21719 - Moved to after the call m_pParentEMR = new CEMR(); to avoid memory leaks
				/*_RecordsetPtr rsPatientInfo = CreateRecordset("SELECT First, Middle, Last, Gender FROM PersonT WHERE ID = %li", GetParentEMR()->GetPatientID());
				if(!rsPatientInfo->eof) {
					//Name
					m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
					m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
					m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					//Gender
					m_cbPatientGender = AdoFldByte(rsPatientInfo, "Gender", 0);
				}*/
			//}

			// (a.walling 2008-05-29 10:43) - PLID 22049 - Added Revision
			SetRevision(rsEMN->Fields->Item["Revision"]->Value);

			rsEMN->Close();

			//TES 5/3/2010 - PLID 24692 - If this function is called, it means we're doing "bottom-up" loading, which doesn't use
			// the position entries.
			/*//TES 4/15/2010 - PLID 24692 - We need to load a linked list of topic positions; this is our job, not the topics' job.
			_RecordsetPtr rsTopicPositions = CreateParamRecordset(pCon, "SELECT ID, EMRParentTopicID FROM EmrTopicsT "
				"WHERE EMRTopicsT.Deleted = 0 AND EMRTopicsT.EMRID = (SELECT EMRID FROM EmrTopicsT WHERE ID = {INT}) "
				"ORDER BY EMRParentTopicID ASC, OrderIndex ASC", pTopic->GetID());
			//TES 4/15/2010 - PLID 24692 - We shouldn't already have a list.
			ASSERT(m_pTopicPositionHead == NULL);
			while(!rsTopicPositions->eof) {
				TopicPositionEntry *tpe = new TopicPositionEntry;
				tpe->nTopicID = AdoFldLong(rsTopicPositions, "ID");
				tpe->bIsTemplateTopic = false;
				//TES 4/15/2010 - PLID 24692 - The recordset ordered it for us, so we can just add at the end.
				m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, AdoFldLong(rsTopicPositions, "EMRParentTopicID", -1));
				rsTopicPositions->MoveNext();
			}*/
		}
		else {
			//first load the EMN-level data.
			// (a.walling 2008-05-29 10:44) - PLID 22049 - Added revision
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			_RecordsetPtr rsEMN = CreateParamRecordset(pCon, "SELECT EMRTemplateT.ID, EMRTemplateT.Name, CollectionID, VisitTypeID, EMRVisitTypesT.Name AS VisitTypeName, Revision, "
				"HideTitleOnPreview "
				"FROM EMRTemplateT "
				"LEFT JOIN EMRVisitTypesT ON EMRTemplateT.VisitTypeID = EMRVisitTypesT.ID "
				"WHERE EMRTemplateT.ID = (SELECT TemplateID FROM EmrTemplateTopicsT WHERE ID = {INT})", pTopic->GetID());
			
			if(rsEMN->eof) {
				AfxThrowNxException("CEMN::LoadFromTemplateTopicID called with invalid ID!");
			}
			
			m_nID = AdoFldLong(rsEMN, "ID");
			m_strDescription = AdoFldString(rsEMN, "Name","");
			m_nEMRCollectionID = AdoFldLong(rsEMN, "CollectionID", -1);

			// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
			m_nVisitTypeID = AdoFldLong(rsEMN, "VisitTypeID", -1);
			m_strVisitTypeName = AdoFldString(rsEMN, "VisitTypeName", "");

			// (j.jones 2007-10-02 10:09) - PLID 27054 - set the last saved info for VisitType
			m_nLastSavedVisitTypeID = m_nVisitTypeID;
			m_strLastSavedVisitTypeName = m_strVisitTypeName;

			//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
			m_bLastSavedHideTitleOnPreview = m_bHideTitleOnPreview = AdoFldBool(rsEMN, "HideTitleOnPreview")?true:false;
			
			// (a.walling 2008-05-29 10:43) - PLID 22049 - Added Revision
			SetRevision(rsEMN->Fields->Item["Revision"]->Value);
			
			rsEMN->Close();

			//TES 5/3/2010 - PLID 24692 - If this function is called, it means we're doing "bottom-up" loading, which doesn't use
			// the position entries.
			/*//TES 4/15/2010 - PLID 24692 - We need to load a linked list of the topic positions, this is our job, not the topics' job.
			_RecordsetPtr rsTopicPositions = CreateParamRecordset("SELECT ID, EMRParentTemplateTopicID FROM EmrTemplateTopicsT "
				"WHERE EMRTemplateTopicsT.TemplateID = (SELECT TemplateID FROM EmrTemplateTopicsT WHERE ID = {INT}) "
				//		Also include all source topics
				// (c.haag 2007-07-23 10:12) - PLID 26344 - Do not include topics that are related by SourceTemplateTopicID
				"OR EMRTemplateTopicsT.ID IN (SELECT SourceTemplateTopicID FROM EMRTemplateTopicsT WHERE TemplateID = (SELECT TemplateID FROM EmrTemplateTopicsT WHERE ID = {INT})) "
				"ORDER BY EMRParentTemplateTopicID ASC, OrderIndex ASC", pTopic->GetID());
			//TES 4/15/2010 - PLID 24692 - We shouldn't already have a list.
			ASSERT(m_pTopicPositionHead == NULL);
			while(!rsTopicPositions->eof) {
				TopicPositionEntry *tpe = new TopicPositionEntry;
				tpe->nTopicID = AdoFldLong(rsTopicPositions, "ID");
				tpe->bIsTemplateTopic = true;
				//TES 4/15/2010 - PLID 24692 - The recordset ordered it for us, so we can just add to the end.
				m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, tpe, AdoFldLong(rsTopicPositions, "EMRParentTemplateTopicID", -1));
				rsTopicPositions->MoveNext();
			}*/
		}

		ASSERT(!m_arypEMRTopics.GetSize());
		m_arypEMRTopics.Add(pTopic);
		m_bOwnChildren = FALSE;

		//Now, load our parent.
		ASSERT(m_bOwnParentEMR);
		ASSERT(NULL == m_pParentEMR);
		// (a.walling 2010-10-18 17:32) - PLID 40260 - Allow using a default connection
		m_pParentEMR = new CEMR(FALSE, pCon);
		// (j.jones 2007-08-02 12:09) - PLID 26915 - pass in our connection
		m_pParentEMR->LoadFromEmn(this, pCon);

		// (c.haag 2006-07-31 17:41) - PLID 21719 - By moving the calls to GetParentEMR()->GetPatientID() down here,
		// we avoid a memory leak.
		if(!m_bIsTemplate) {

			// (j.jones 2007-08-06 14:47) - PLID 26974 - We now will always use the patient info. from the saved EMN,
			// and never revert to the current patient info. Locked or unlocked, it doesn't matter.
			
			//if(m_nStatus == 2) { //The EMN is locked, so retrieve and display the stored values
				//If the name fields are blank (because of records created prior to this change), lookup the patient's name.
				//Only check the first and last name because it is common for middle name to be blank.
				if(m_strPatNameFirst.IsEmpty() || m_strPatNameLast.IsEmpty()) {
					// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
					_RecordsetPtr rsPatientInfo = CreateParamRecordset(pCon, "SELECT First, Middle, Last FROM PersonT WHERE ID = {INT}", GetParentEMR()->GetPatientID());
					if(!rsPatientInfo->eof) {
						m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
						m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
						m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					}
				}
			//}

			/*
			else { //The EMN is active, so retrieve and display the currently set values from the patient's data
				_RecordsetPtr rsPatientInfo = CreateRecordset(pCon, "SELECT First, Middle, Last, Gender FROM PersonT WHERE ID = %li", GetParentEMR()->GetPatientID());
				if(!rsPatientInfo->eof) {
					//Name
					m_strPatNameFirst = AdoFldString(rsPatientInfo, "First", "");
					m_strPatNameMiddle = AdoFldString(rsPatientInfo, "Middle", "");
					m_strPatNameLast = AdoFldString(rsPatientInfo, "Last", "");
					//Gender
					m_cbPatientGender = AdoFldByte(rsPatientInfo, "Gender", 0);
				}
			}
			*/
		}

		// (a.walling 2008-06-02 12:24) - PLID 22049 - Notify the interface
		if (GetInterface()) {
			GetInterface()->SendMessage(NXM_EMN_LOADSAVE_COMPLETE, (WPARAM)this, 0);
		}

	}NxCatchAll("Error in CEMN::LoadFromTopicID()");
}

void CEMN::UpdateMergeConflicts(const CString &strMergeFieldName, CEMNDetail *pDetailToIgnore)
{	
	// (a.walling 2007-11-05 17:52) - PLID 27890 - VS2008 - for() loops
	int i = 0;

	//Find all items on this EMN that have the same name.
	CArray<CEMNDetail*,CEMNDetail*> arMatchingNames;
	long nTotalDetailCount = GetTotalDetailCount();
	for(i = 0; i < nTotalDetailCount; i++) {
		CEMNDetail *pDetail = GetDetail(i);
		if(pDetail->GetVisible() && pDetail != pDetailToIgnore && pDetail->GetMergeFieldName(TRUE) == strMergeFieldName) {
			arMatchingNames.Add(pDetail);
		}
	}
	if(arMatchingNames.GetSize() == 1) {
		arMatchingNames[0]->SetMergeNameConflict(FALSE);
	}
	else {
		for(i = 0; i < arMatchingNames.GetSize(); i++) {
			arMatchingNames[i]->SetMergeNameConflict(TRUE);
		}
		//TES 1/31/2007 - PLID 24492 - We just set these details to conflict, lets see if we can override them to not conflict.
		// We only want to call TryToOverrideMergeField() once, since we know these all have the same name, so the function
		// will go through all of them.
		bool bOverridden = false;
		for(i = 0; i < arMatchingNames.GetSize() && !bOverridden; i++) {
			if(arMatchingNames[i]->GetMergeFieldOverride().IsEmpty()) {
				TryToOverrideMergeField(arMatchingNames[i]);
				bOverridden = true;
			}
		}
	}
}

// (j.jones 2007-01-05 11:41) - PLID 24070 - sets the more info topic as unsaved
void CEMN::SetMoreInfoUnsaved()
{
	m_bMoreInfoUnsaved = TRUE;

	// (a.walling 2012-03-22 16:50) - PLID 49141 - Notify the interface
	NotifyMoreInfoChanged();
}

//TES 2/12/2014 - PLID 60470 - Added m_bCodesUnsaved
void CEMN::SetCodesUnsaved()
{
	m_bCodesUnsaved = TRUE;

	NotifyCodesChanged();
}

// (a.walling 2012-03-22 16:50) - PLID 49141 - This will post a message to the interface window, if we have one
void CEMN::NotifyMoreInfoChanged()
{
	CEmrTreeWnd* pTreeWnd = GetInterface();
	if (::IsWindow(pTreeWnd->GetSafeHwnd())) {
		pTreeWnd->PostMessage(NXM_EMN_MORE_INFO_CHANGED, (WPARAM)this, (LPARAM)0);
	}
}

//TES 2/12/2014 - PLID 60470 - Added m_bCodesUnsaved
void CEMN::NotifyCodesChanged()
{
	CEmrTreeWnd* pTreeWnd = GetInterface();
	if(::IsWindow(pTreeWnd->GetSafeHwnd())) {
		pTreeWnd->PostMessage(NXM_EMN_CODES_CHANGED, (WPARAM)this, (LPARAM)0);
	}
}

void CEMN::LoadDefaultProviderIDs()
{
	// (d.thompson 2013-08-16) - PLID 57809 - Refactored all the logic into its own class for clarity.
	CArray<long,long> arMainProviderIDs;
	CArray<long,long> arySecondaryProviders;
	CEMNDefaultProvider provs(m_pParentEMR, this);
	provs.CalculateDefaultEMNProviders(arMainProviderIDs, arySecondaryProviders);

	//TES 12/28/2006 - PLID 23400 - Also, let's just go ahead and set these defaults as our providers, that's what every 
	// caller of this function was doing anyway.
	SetProviders(arMainProviderIDs);

	// (j.jones 2011-04-14 11:05) - PLID 40257 - this may have loaded their secondary providers as well
	if(arySecondaryProviders.GetSize() > 0) {
		SetSecondaryProviders(arySecondaryProviders);
	}
}

// (d.lange 2011-03-24 10:25) - PLID 42987 - We want to autofill the Assistant/Technician field on More Info with the current user
// if they are flagged as one
void CEMN::SetCurrentUserTechnicianID()
{
	try {
		// (a.walling 2011-11-16 10:15) - PLID 46497 - Sanity check -- ensure the current user is actually a technician
		_ASSERTE(IsCurrentUserTechnician());
		if (!IsCurrentUserTechnician()) {
			return;
		}

		long nCurUserID = GetCurrentUserID();
		CArray<long,long> arTechnicianIDs;
		GetTechnicians(arTechnicianIDs);

		// Check to see if the current user is already selected
		for(int i = 0; i < arTechnicianIDs.GetSize(); i++) {
			if(arTechnicianIDs[i] == nCurUserID)
				return;
		}

		// The current user is flagged as an Assistant/Technician so we want to add them to the technician IDs
		arTechnicianIDs.Add(nCurUserID);
		SetTechnicians(arTechnicianIDs);
		SetUnsaved();

	} NxCatchAll("Error in SetCurrentUserTechnicianID");
}

// (a.walling 2007-09-27 14:01) - PLID 25548 - Option to retain the order index for topics
void CEMN::SetNew(BOOL bRetainOrderIndex /*=FALSE*/)
{
	m_nID = -1;
	// (c.haag 2007-06-26 12:33) - PLID 26460 - Reset the template ID!
	// (c.haag 2007-06-29 16:32) - PLID 26460 - Only applies to templates, not patient charts.
	// Otherwise, we'll lose the originating template ID for the chart
	if (m_bIsTemplate) {
		m_nTemplateID = -1;
	}

	// (a.walling 2007-11-05 17:52) - PLID 27890 - VS2008 - for() loops
	int i = 0;

	//Tell all our topics.
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		m_arypEMRTopics[i]->SetNew(bRetainOrderIndex);
	}

	//TES 9/12/2006 - Also tell our other child objects.
	for(i = 0; i <m_aryProcedures.GetSize(); i++) {
		m_aryProcedures[i]->bIsNew = TRUE;
	}
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		m_aryDiagCodes[i]->bIsNew = TRUE;
		// (j.jones 2008-07-30 14:50) - PLID 30819 - set the nID to -1
		m_aryDiagCodes[i]->nID = -1;

		// (j.jones 2008-07-23 14:05) - PLID 30792 - set all problems as new,
		// and reconfirm their pointers are correct with this object
		// (z.manning 2009-05-22 10:27) - PLID 34297 - Just have problem links now
		for(int j = 0; j < m_aryDiagCodes[i]->m_apEmrProblemLinks.GetSize(); j++)
		{
			CEmrProblemLink *pProblemLink = m_aryDiagCodes[i]->m_apEmrProblemLinks.GetAt(j);
			if(pProblemLink != NULL) {
				pProblemLink->SetID(-1);
				pProblemLink->SetRegardingID(-1);
				pProblemLink->UpdatePointersWithDiagCode(this, m_aryDiagCodes[i]);
			}
		}
	}
	for(i = 0; i < m_aryCharges.GetSize(); i++) {
		m_aryCharges[i]->nID = -1;

		// (j.jones 2008-07-23 14:05) - PLID 30792 - set all problems as new,
		// and reconfirm their pointers are correct with this object
		// (z.manning 2009-05-22 10:27) - PLID 34297 - Just have problem links now
		for(int j = 0; j < m_aryCharges[i]->m_apEmrProblemLinks.GetSize(); j++)
		{
			CEmrProblemLink *pProblemLink = m_aryCharges[i]->m_apEmrProblemLinks.GetAt(j);
			if(pProblemLink != NULL) {
				pProblemLink->SetID(-1);
				pProblemLink->SetRegardingID(-1);
				pProblemLink->UpdatePointersWithCharge(this, m_aryCharges[i]);
			}
		}
	}
	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		m_aryMedications[i]->nID = -1;

		// (j.jones 2008-07-23 14:05) - PLID 30792 - set all problems as new,
		// and reconfirm their pointers are correct with this object
		// (z.manning 2009-05-22 10:27) - PLID 34297 - Just have problem links now
		for(int j = 0; j < m_aryMedications[i]->m_apEmrProblemLinks.GetSize(); j++) {
			CEmrProblemLink *pProblemLink = m_aryMedications[i]->m_apEmrProblemLinks.GetAt(j);
			if(pProblemLink != NULL) {
				pProblemLink->SetID(-1);
				pProblemLink->SetRegardingID(-1);
				pProblemLink->UpdatePointersWithMedication(this, m_aryMedications[i]);
			}
		}
	}
	for(i = 0; i < m_aryProviders.GetSize(); i++) {
		m_aryProviders[i]->bIsNew = TRUE;
	}
	for(i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
		m_arySecondaryProviders[i]->bIsNew = TRUE;
	}

	// (j.gruber 2009-05-08 09:15) - PLID 33688 - other providers
	for(i = 0; i < m_aryOtherProviders.GetSize(); i++) {
		m_aryOtherProviders[i]->bIsNew = TRUE;
	}



	// (j.jones 2008-07-23 14:18) - PLID 30789 - set all problems as new,
	// and reconfirm their pointers are correct with this object
	// (z.manning 2009-05-22 10:27) - PLID 34297 - Just have problem links now
	for(i = 0; i < m_apEmrProblemLinks.GetSize(); i++) {
		CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(i);
		if(pProblemLink != NULL) {
			pProblemLink->SetID(-1);
			pProblemLink->SetRegardingID(-1);
			pProblemLink->UpdatePointersWithEMN(this);
		}
	}

	for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
		delete m_arypDeletedTopics[i];
	}
	m_arypDeletedTopics.RemoveAll();
}

void CEMN::SetCollectionID(long nCollectionID)
{
	m_nEMRCollectionID = nCollectionID;
}

void CEMN::operator =(CEMN &emnSource)
{
	CopyFromEmn(&emnSource, TRUE);
}

// (z.manning 2009-08-19 16:48) - PLID 35285
void CEMN::CopyFromEmn(CEMN *pemnSource, BOOL bCopyEmr)
{	
	// (a.walling 2010-10-18 17:07) - PLID 40260 - Allow using a default connection
	m_pDefaultConnection = pemnSource->m_pDefaultConnection;

	// (z.manning 2009-08-19 16:48) - PLID 35285 - Only copy the parent EMR if the caller chose to.
	if(bCopyEmr) {
		m_pParentEMR = pemnSource->m_pParentEMR;
	}
	m_bOwnParentEMR = FALSE;
	m_bOwnChildren = TRUE;
	
	m_nID = pemnSource->m_nID;
	m_bIsTemplate = pemnSource->m_bIsTemplate;

	m_dtEMNDate = pemnSource->m_dtEMNDate;
	// (a.walling 2012-06-07 08:53) - PLID 50920 - Dates - Modified, Created
	m_dtEMNInputDate = pemnSource->m_dtEMNDate;
	m_dtEMNModifiedDate = pemnSource->m_dtEMNDate;

	m_strPatientAge = pemnSource->m_strPatientAge;
	m_cbPatientGender = pemnSource->m_cbPatientGender;

	//m.hancock - 3/14/2006 - 19579
	m_strPatNameFirst = pemnSource->m_strPatNameFirst;
	m_strPatNameMiddle = pemnSource->m_strPatNameMiddle;
	m_strPatNameLast = pemnSource->m_strPatNameLast;

	m_strDescription = pemnSource->m_strDescription;

	//TES 4/15/2010 - PLID 24692 - We shouldn't already have a list, but if we do, clean it up.
	if(m_pTopicPositionHead) {
		ASSERT(FALSE);
		m_pTopicPositionHead->FreeDescendants();
		delete m_pTopicPositionHead;
		m_pTopicPositionHead = NULL;
	}
	// (a.walling 2007-11-05 17:52) - PLID 27890 - VS2008 - for() loops
	int i = 0;
	for(i = 0; i < pemnSource->m_arypEMRTopics.GetSize(); i++) {
		TopicPositionEntry *tpe = new TopicPositionEntry;
		CEMRTopic *pTopic = new CEMRTopic(this, tpe);
		*pTopic = *(pemnSource->m_arypEMRTopics[i]);
		m_arypEMRTopics.Add(pTopic);
		//TES 4/20/2010 - PLID 24692 - Now make sure our topic position is in the right spot in the list.
		m_pTopicPositionHead = AddTopicPositionEntryAtEnd(m_pTopicPositionHead, pTopic->GetTopicPositionEntry(), -1);
	}

	// (j.jones 2010-03-11 08:36) - PLID 37318 - any SmartStamp items need re-linked
	ReconfirmSmartStampLinks_PostEMNCopy();	

	m_bTopicArrayChanged = pemnSource->m_bTopicArrayChanged;
	
	m_bNeedRegenerateTableItemList = pemnSource->m_bNeedRegenerateTableItemList;
	m_strTableItemList = pemnSource->m_strTableItemList;

	m_Location.nID = pemnSource->m_Location.nID;
	m_Location.strName = pemnSource->m_Location.strName; // (z.manning, 05/07/2007) - PLID 25925
	m_Location.strLogo = pemnSource->m_Location.strLogo; // (a.walling 2008-07-01 15:02) - PLID 30586
	m_Location.nLogoWidth = pemnSource->m_Location.nLogoWidth; // (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width

	m_nTemplateID = pemnSource->m_nTemplateID;
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	m_Status = pemnSource->m_Status;
	m_nEMRCollectionID = pemnSource->m_nEMRCollectionID;

	m_nPatientCreatedStatus = pemnSource->m_nPatientCreatedStatus; // (z.manning 2009-11-19 09:07) - PLID 35810

	m_sai = pemnSource->m_sai; // (z.manning 2009-03-04 14:50) - PLID 33338

	m_bAddOnce = pemnSource->m_bAddOnce;

	//TES 11/2/2009 - PLID 35808 - Added NexWebUUID
	//(e.lally 2011-05-04) PLID 43537 - Changed to NexWebVisible bool
	m_bNexWebVisible = pemnSource->m_bNexWebVisible;

	// (j.gruber 2012-08-31 14:45) - PLID 52285
	m_bIsOMRTemplate = pemnSource->m_bIsOMRTemplate;

	// (z.manning, 04/12/2007) - PLID 25569 - Copy chart and category IDs.
	m_Category.nID = pemnSource->m_Category.nID;
	m_Chart.nID = pemnSource->m_Chart.nID;
	// (z.manning, 05/07/2007) - PLID 25731 - Also category and chart names.
	m_Category.strName = pemnSource->m_Category.strName;
	m_Chart.strName = pemnSource->m_Chart.strName;

	m_Appointment = pemnSource->m_Appointment;

	// (d.thompson 2009-05-27) - PLID 29909 - Confidential info
	m_strConfidentialInfo = pemnSource->m_strConfidentialInfo;
	m_bConfidentialInfoChanged = true;

	for(i = 0; i < pemnSource->m_aryProcedures.GetSize(); i++) {
		EMNProcedure *pProc = new EMNProcedure;
		*pProc = *(pemnSource->m_aryProcedures[i]);
		m_aryProcedures.Add(pProc);
	}
	for(i = 0; i < pemnSource->m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode *pDiag = new EMNDiagCode;
		// (z.manning 2009-08-18 10:12) - PLID 35207 - Set the new EMN as the override
		pDiag->pEmnOverride = this;
		*pDiag = *(pemnSource->m_aryDiagCodes[i]);
		m_aryDiagCodes.Add(pDiag);
	}

	// (z.manning 2011-07-12 10:08) - PLID 44469 - Moved the charge copying code to its own function.
	m_aryCharges.CopyNew(&pemnSource->m_aryCharges, this);

	for(i = 0; i < pemnSource->m_aryMedications.GetSize(); i++) {
		EMNMedication *pMed = new EMNMedication;
		// (z.manning 2009-08-18 10:12) - PLID 35207 - Set the new EMN as the override
		pMed->pEmnOverride = this;
		*pMed = *(pemnSource->m_aryMedications[i]);
		m_aryMedications.Add(pMed);
	}
	for(i = 0; i < pemnSource->m_aryProviders.GetSize(); i++) {
		EMNProvider *pProv = new EMNProvider;
		*pProv = *(pemnSource->m_aryProviders[i]);
		m_aryProviders.Add(pProv);
	}

	for(i = 0; i < pemnSource->m_arySecondaryProviders.GetSize(); i++) {
		EMNProvider *pProv = new EMNProvider;
		*pProv = *(pemnSource->m_arySecondaryProviders[i]);
		m_arySecondaryProviders.Add(pProv);
	}

	// (j.gruber 2009-05-08 09:15) - PLID 33688 - Other Providers
	for(i = 0; i < pemnSource->m_aryOtherProviders.GetSize(); i++) {
		EMNProvider *pProv = new EMNProvider;
		*pProv = *(pemnSource->m_aryOtherProviders[i]);
		m_aryOtherProviders.Add(pProv);
	}

	// (d.lange 2011-04-04 09:57) - PLID 42136 - Copy over the selected Technicians from the source EMN
	for(i = 0; i < pemnSource->m_aryTechnicians.GetSize(); i++) {
		EMNProvider *pTech = new EMNProvider;
		*pTech = *(pemnSource->m_aryTechnicians[i]);
		m_aryTechnicians.Add(pTech);
	}

	// (z.manning 2011-07-07 13:19) - PLID 44469
	m_arypCodingGroups.ClearAll();
	for(i = 0; i < pemnSource->m_arypCodingGroups.GetCount(); i++) {
		CEmnCodingGroupInfo *pCodingGroupInfo = new CEmnCodingGroupInfo;
		*pCodingGroupInfo = *(pemnSource->m_arypCodingGroups.GetAt(i));
		m_arypCodingGroups.Add(pCodingGroupInfo);
	}

	// (m.hancock 2006-10-16 16:25) - PLID 22375 - Copying an EMN should aslo copy the notes .
	m_strNotes = pemnSource->m_strNotes;
	
	SetInterface(pemnSource->GetInterface());

	// (j.jones 2007-08-24 08:40) - PLID 27054 - added VisitTypeID
	m_nVisitTypeID = pemnSource->GetVisitTypeID();
	m_strVisitTypeName = pemnSource->GetVisitTypeName();

	// (b.eyers 2016-02-22) - PLID 68321 - new fields discharge status, admission time, discharge time
	m_DischargeStatus.nID = pemnSource->m_DischargeStatus.nID;
	m_DischargeStatus.strCode = pemnSource->m_DischargeStatus.strCode;
	m_DischargeStatus.strDesc = pemnSource->m_DischargeStatus.strDesc;
	m_dtAdmissionTime = pemnSource->m_dtAdmissionTime;
	m_dtDischargeTime = pemnSource->m_dtDischargeTime;

	//TES 1/17/2014 - PLID 60397 - Added HideTitleOnPreview
	m_bHideTitleOnPreview = pemnSource->GetHideTitleOnPreview();

	// (j.jones 2008-07-23 14:18) - PLID 30789 - problems are now stored in an array of objects
	// (c.haag 2009-05-19 10:05) - PLID 34310 - We now copy EMR problem links
	for(i = 0; i < pemnSource->m_apEmrProblemLinks.GetSize(); i++) {
		// (c.haag 2009-07-09 10:49) - PLID 34829 - Now that the parent EMR is responsible for
		// problem allocation, we must try to ensure that the new link is bound to a problem for
		// this EMR. Determine the EMR that owns this EMN, and pass it into the EMR problem
		// link ctor so it can do this. (If NULL, we won't try to enforce this)
		CEmrProblemLink *pNewLink = new CEmrProblemLink(pemnSource->m_apEmrProblemLinks[i], GetParentEMR());
		pNewLink->UpdatePointersWithEMN(this);
		m_apEmrProblemLinks.Add(pNewLink);
	}

	// (z.manning 2010-03-11 11:31) - PLID 37412 - We need to create new copies of all detail image stamps
	// on any details that have any.
	CArray<CEMNDetail*,CEMNDetail*> arypDetails;
	GenerateTotalEMNDetailArray(&arypDetails);
	for(int nDetailIndex = 0; nDetailIndex < arypDetails.GetSize(); nDetailIndex++) {
		CEMNDetail *pDetail = arypDetails.GetAt(nDetailIndex);
		pDetail->CreateNewCopiesOfDetailStampPointers();
	}
}

//used to track whether details have been dragged between topics
void CEMN::SetDetailsHaveMoved(BOOL bDetailsHaveMoved)
{
	m_bDetailsHaveMoved = bDetailsHaveMoved;
}

BOOL CEMN::GetDetailsHaveMoved()
{
	return m_bDetailsHaveMoved;
}

CEMNDetail* CEMN::GetDetailByUniqueIdentifier(const CString &strID)
{
	CString strType = strID.Left(1);
	if(strType == "I") {
		return GetDetailByID(atol(strID.Mid(2)));
	}
	else if(strType == "T") {
		return GetDetailByTemplateDetailID(atol(strID.Mid(2)));
	}
	else if(strType == "P") {
		return (CEMNDetail*)atol(strID.Mid(2));
	}
	else {
		ASSERT(FALSE);
		return NULL;
	}
}

CEMNDetail* CEMN::AssignDetailByUniqueIdentifier(const CString &strID)
{
	// (c.haag 2007-08-13 17:36) - PLID 27049 - This is just like GetDetailByUniqueIdentifier except
	// that we are guaranteed a fully loaded detail that permanently resides in this EMN
	// when the initial load is done. You should call use this function when you actually
	// want a pointer to the detail to pass on to something else, such as 
	// TableElement::m_pLinkedDetail. The rest of the time, you should be using
	// GetDetailByUniqueIdentifier. Either way, if you actually change the detail data,
	// those changes will be carried to the EMN.
	CString strType = strID.Left(1);
	if(strType == "I") {
		return AssignDetailByID(atol(strID.Mid(2)));
	}
	else if(strType == "T") {
		return AssignDetailByTemplateDetailID(atol(strID.Mid(2)));
	}
	else if(strType == "P") {
		return (CEMNDetail*)atol(strID.Mid(2));
	}
	else {
		ASSERT(FALSE);
		return NULL;
	}
}

//lets us know if we have a pointer to a topic that is marked as to be deleted
BOOL CEMN::IsTopicMarkedDeleted(CEMRTopic *pTopicToCheck)
{
	if(!pTopicToCheck) {
		ASSERT(FALSE);
		return TRUE;
	}

	CArray<CEMRTopic*,CEMRTopic*> aryTotalEMNDeletedTopics;
	GetAllDeletedTopics(aryTotalEMNDeletedTopics);

	for(int i=0; i<aryTotalEMNDeletedTopics.GetSize(); i++) {
		CEMRTopic *pTopic = aryTotalEMNDeletedTopics.GetAt(i);
		if(pTopic == pTopicToCheck)
			return TRUE;
	}

	return FALSE;
}

// (a.walling 2012-07-09 12:35) - PLID 51441
CEMRTopic* CEMN::GetFirstDisplayedTreeTopic(CEMNDetail *pDetailToIgnore, BOOL bIgnoreBlankSubtopics, CEMRTopic* pTopicToIgnore)
{
	foreach(CEMRTopic* pTopic, GetSubtopics()) {
		if (pTopic->IsDisplayed(pDetailToIgnore, bIgnoreBlankSubtopics, pTopicToIgnore)) {
			return pTopic;
		}
	}

	return NULL;
}

// (a.walling 2012-07-09 12:35) - PLID 51441
CEMRTopic* CEMN::GetLastDisplayedTreeTopic(CEMNDetail *pDetailToIgnore, BOOL bIgnoreBlankSubtopics, CEMRTopic* pTopicToIgnore)
{
	CEMRTopic* pLastTopic = NULL;
	reverse_foreach(CEMRTopic* pTopic, GetSubtopics()) {
		if (pTopic->IsDisplayed(pDetailToIgnore, bIgnoreBlankSubtopics, pTopicToIgnore)) {
			pLastTopic = pTopic->GetDeepestLastTreeTopic();
			break;
		}
	}

	if (pLastTopic && !pLastTopic->IsDisplayed(pDetailToIgnore, bIgnoreBlankSubtopics, pTopicToIgnore)) {
		pLastTopic = pLastTopic->GetPrevDisplayedTreeTopic();
	}

	return pLastTopic;
}

// (z.manning 2009-03-04 16:03) - PLID 33338 - Replaced the calls to SetSource<whatever> with this
void CEMN::ClearSourceActionInfo()
{
	BOOL bPreviouslyBlank = m_sai.IsBlank();
	SourceActionInfo saiBlank;
	m_sai = saiBlank;

	// (a.walling 2010-08-23 17:30) - PLID 37923 - Clear out the EMN Spawning Text field	
	if (!bPreviouslyBlank) {
		CStringArray saErrors;
		EnsureSpawningEMNTextMergeField(&m_mapGenericMergeFields);
		UpdateSpawningEMNTextMergeFieldNarratives(saErrors);

		// (a.walling 2008-08-11 17:36) - PLID 30515 - Warn the user if any EMNs could not be updated.
		if (saErrors.GetSize() > 0) {
			CString strErrors = "The following errors occurred updating narratives in other EMNs due to conflicts of write access: \r\n\r\n";
			for (int f = 0; f < saErrors.GetSize(); f++) {
				strErrors += saErrors[f] + "\r\n";
			}
			strErrors += "\r\nThe narratives will be updated the next time the EMNs are loaded.";

			// don't display any errors if we don't have an interface for some reason
			if (GetInterface() && ::IsWindow(GetInterface()->GetSafeHwnd())) {
				GetInterface()->MessageBox(strErrors, NULL, MB_ICONEXCLAMATION);
			}
		}
	}
}

void CEMN::PostTopicLoad(CEMRTopic *pTopicLoaded)
{
	if(!m_bInitialLoadComplete) {
		//Maybe all our topics are loaded now.
		BOOL bUnloadedFound = FALSE;
		for(int i = 0; i < m_arypEMRTopics.GetSize() && !bUnloadedFound; i++) {
			if(!m_arypEMRTopics[i]->IsLoaded()) bUnloadedFound = TRUE;
		}
		
		if(!bUnloadedFound) {

			// (j.jones 2007-03-13 17:20) - PLID 25193 - topics may be loaded, but their actions may not
			// be finished yet, so check for pending actions as well
			
			if(GetParentEMR()->GetHasFinishedSpawning()) {
				PostInitialLoad();				
			}
			else {
				// (j.jones 2007-03-13 17:35) - PLID 25193 - track that we should be complete,
				// but were delayed by the EMR spawning
				m_bInitialLoadPendingCompletion = TRUE;
			}
		}
	}
}

void CEMN::UpdateAllMergeConflicts()
{	
	// (c.haag 2007-03-28 16:25) - PLID 25401 - Instead of doing a loop in a loop, we will use
	// map lookups for faster processing. This function has effectively been rewritten
	/*
	//Find all items on this EMN that have the same name.
	CArray<CEMNDetail*,CEMNDetail*> arDetails;
	GenerateTotalEMNDetailArray(&arDetails);
	for(int i = 0; i < arDetails.GetSize(); i++) {
		CEMNDetail *pDetail = arDetails[i];
		CString strName = pDetail->GetMergeFieldName(TRUE);
		if(pDetail->GetVisible()) {
			//Only compare going forwards, everything before us has been deal with earlier in the loop.
			BOOL bMatched = FALSE;
			for(int j = i+1; j < arDetails.GetSize(); j++) {
				CEMNDetail *pCompare = arDetails[j];
				if(pCompare->GetVisible() && pCompare->GetMergeFieldName(TRUE) == strName) {
					//This is a duplicate.
					bMatched = TRUE;
					pCompare->SetMergeNameConflict(TRUE);
					//TES 12/4/2006 - PLID 22304 - We just loaded a detail that conflicts, immediately try and override the name, 
					// so that data isn't being modified at unexpected times.
					if(pCompare->GetMergeFieldOverride().IsEmpty()) TryToOverrideMergeField(pCompare, FALSE);
					//Now take this out of the list so we don't recheck it.
					arDetails.RemoveAt(j);
					//And decrement the counter so we don't skip the next one.
					j--;
				}
			}
			pDetail->SetMergeNameConflict(bMatched);
			//TES 12/4/2006 - PLID 22304 - We just loaded a detail that conflicts, immediately try and override the name, 
			// so that data isn't being modified at unexpected times.
			if(bMatched && pDetail->GetMergeFieldOverride().IsEmpty()) TryToOverrideMergeField(pDetail, FALSE);
		}
	}*/

	// (c.haag 2007-03-28 16:25) - Gather the master list of all details in this EMN
	CArray<CEMNDetail*,CEMNDetail*> arDetails;
	GenerateTotalEMNDetailArray(&arDetails);
	const long nTotalDetailCount = arDetails.GetSize();
	CMap<CString,LPCTSTR,CArray<CEMNDetail*,CEMNDetail*>*,CArray<CEMNDetail*,CEMNDetail*>*>
		mapMergeNames;
	long i;

	// (c.haag 2007-03-28 16:26) - Now map all visible details to merge field names
	for (i=0; i < nTotalDetailCount; i++) {
		CArray<CEMNDetail*,CEMNDetail*>* pValue = NULL;
		CEMNDetail* pDetail = arDetails[i];
		if (pDetail->GetVisible()) {
			const CString strDetailMergeFieldName = pDetail->GetMergeFieldName(TRUE);
			if (!mapMergeNames.Lookup(strDetailMergeFieldName, pValue)) {
				pValue = new CArray<CEMNDetail*,CEMNDetail*>;
				mapMergeNames[strDetailMergeFieldName] = pValue;
			} else {
				// The array (pValue) already exists, meaning we found a duplicate
			}
			pValue->Add(pDetail);
		}
	}

	// (c.haag 2007-03-28 16:26) - Now that the map has been created, traverse the map
	// deleting memory we allocated and handling cases where multiple details have the
	// same merge name
	POSITION pos = mapMergeNames.GetStartPosition();
	while (pos) {
		CArray<CEMNDetail*,CEMNDetail*>* pValue = NULL;
		CString strMergeFieldName;
		mapMergeNames.GetNextAssoc(pos, strMergeFieldName, pValue);
		const long nArySize = pValue->GetSize();
		if (nArySize > 1) {
			for (i=0; i < nArySize; i++) {
				CEMNDetail* pDetail = pValue->GetAt(i);
				pDetail->SetMergeNameConflict(TRUE);
				if (pDetail->GetMergeFieldOverride().IsEmpty()) {
					TryToOverrideMergeField(pDetail, FALSE);
				}				
			}
		}
		delete pValue;
	}
}

// (j.jones 2008-10-30 17:24) - PLID 31869 - passed in a connection pointer
//TES 7/22/2011 - PLID 44665 - Added a parameter specifying whether this is being called during the initial load of the EMN.
void CEMN::LoadAllNarratives(BOOL bInitialLoad, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	try {

		// (j.jones 2008-10-30 17:38) - PLID 31869 - converted to support a passed-in connection
		_ConnectionPtr pCon;
		if(lpCon) {
			pCon = lpCon;
		}
		else {
			pCon = GetRemoteData();
		}

		//TES 2/20/2007 - PLID 24750 - Don't load narratives if we haven't finished loading.  This should always have been
		// true, but until this PLID was done, we couldn't fully rely on m_bInitialLoadComplete to be correct.
		if(!m_bInitialLoadComplete) return;

		// (c.haag 2006-10-03 13:45) - PLID 22823 - Do not load if we have the act
		// of updating narratives locked
		//TES 1/23/2008 - PLID 24157 - Renamed.
		if (m_nDetailChangeLocks > 0) return;

		// (c.haag 2006-10-03 13:45) - PLID 22823 - This lock will prevent LoadAllNarratives()
		// from recursively calling itself. This is is decremented when the function is terminated
		//TES 1/23/2008 - PLID 24157 - Renamed.
		m_nDetailChangeLocks++;

		//First, make an array of all our narrative fields.
		CArray<CEMNDetail*,CEMNDetail*> arDetails;
		GenerateTotalEMNDetailArray(&arDetails);

		// (j.jones 2008-06-25 11:06) - PLID 27840 - sort this array, which will order the
		// details by topic order, then by placement inside each topic
		if(arDetails.GetSize() > 1) {
			SortDetailArray(arDetails);
		}

		CArray<CEMNDetail*,CEMNDetail*> arNarratives;
		int nDetailCount = arDetails.GetSize();
		// (a.walling 2007-11-05 17:52) - PLID 27890 - VS2008 - for() loops
		int i = 0;
		for(i = 0; i < nDetailCount; i++) {
			if(arDetails[i]->m_EMRInfoType == eitNarrative) arNarratives.Add(arDetails[i]);
		}

		//Next, make an array with all the merge fields.
		// (a.walling 2009-11-17 16:47) - PLID 36365
		//CArray<NarrativeMergeField,NarrativeMergeField&> arMergeFields;

		m_mapGenericMergeFields.RemoveAll();
		m_mapGenericMergeFields.InitHashTable(29, TRUE);

		m_mapLWMergeFields.RemoveAll();
		m_mapLWMergeFields.InitHashTable(727, TRUE);

		//Go through and load all the patient related stuff.
		// (c.haag 2007-08-06 09:27) - PLID 26858 - Generic field population (he/she/age/name)
		// is now done in its own function

		// (a.walling 2009-11-17 16:47) - PLID 36365
		LoadGenericNarrativeFields(m_mapGenericMergeFields, pCon);
		//Load all the stuff specific to this EMN.

		// (a.walling 2009-11-17 16:48) - PLID 36365
		LoadEmnNarrativeFields(m_mapGenericMergeFields, pCon);

		LoadLWNarrativeFields(m_mapLWMergeFields);

		if(arNarratives.GetSize() == 0) {
			//Excellent, we're done.
			//TES 1/23/2008 - PLID 24157 - Renamed.
			m_nDetailChangeLocks--; // (c.haag 2006-10-03 13:47) - PLID 22823 - Release our self-lock
			return;
		}

		const int nNarrativeCount = arNarratives.GetSize();

		// (a.walling 2010-01-14 11:26) - PLID 36880 - Don't need to bother with LW merge fields if we are locked since nothing can change anyway!
		if (!IsLockedAndSaved()) {
			CMap<CString, LPCTSTR, long, long&> mapLWFieldsNeeded;

			for(i = 0; i < nNarrativeCount; i++) {			
				CEMNDetail *pNarrative = arNarratives[i];

				pNarrative->GetNarrativeLWFields(mapLWFieldsNeeded);
			}

			EnsureLWMergeFields(mapLWFieldsNeeded);
		}

		for(i = 0; i < nNarrativeCount; i++) {			
			CEMNDetail *pNarrative = arNarratives[i];
			CEMRTopic* pParentTopic = pNarrative->m_pParentTopic;
			BOOL bModified = pNarrative->IsModified();

			// (c.haag 2007-05-14 17:28) - PLID 25495 - Make sure that the rich text control,
			// if existent, is properly parsed and formatted.
			// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code
			if (eitNarrative == pNarrative->m_EMRInfoType) {
				pNarrative->ReflectCurrentContent();
				pNarrative->UpdateNarrativeFields();
			}

			//TES 7/22/2011 - PLID 44665 - We only want to reset the modified flag if this is the initial load process.  Otherwise,
			// we just processed some actions, so if that caused the narrative to be modified, then it should be flagged as such.
			if(!bModified && bInitialLoad) {
				pNarrative->SetSaved(TRUE);
				//
				// (c.haag 2006-07-24 10:38) - PLID 21535 - Even though the narrative is flagged
				// as saved, it's corresponding topic in the EMR tree needs to have its background
				// color and icon updated. To accomplish this, we first have to update the topic's
				// internal completion status by calling HandleDetailStateChange. Then we send a
				// NXM_TOPIC_MODIFIED_CHANGED (we send instead of post because all the preceeding
				// logic sent messages) message to make the tree update the icon and back color.
				//
				// Everything starting from SetSaved is actually a workaround to a problem where
				// the preceeding logic sets modified flags and looks for items to spawn and such.
				// In the future, we need to rethink this entire function.
				//
				pParentTopic->HandleDetailStateChange(pNarrative);
				if (GetInterface() && IsWindow(GetInterface()->GetSafeHwnd())) {
					GetInterface()->SendMessage(NXM_TOPIC_MODIFIED_CHANGED, (WPARAM)pParentTopic);
				}
			}
		} // for(i = 0; i < nNarrativeCount; i++) {	

		// (z.manning 2011-11-11 10:45) - PLID 37093 - If this is the initial load of a new EMN then we also
		// need to update narrative procedure fields.
		// (j.jones 2012-12-27 15:25) - PLID 54369 - the above item was never finished, and this created broken, half-working code
		/*
		if(m_nID == -1) {
			UpdateAllProcedureNarrativeFields();
		}
		*/
		
		// (j.jones 2008-10-31 13:03) - PLID 31869 - Use thread-safe exception handling
	}NxCatchAllThread("Error in CEMN::LoadAllNarratives()");

	//TES 1/23/2008 - PLID 24157 - Renamed.
	m_nDetailChangeLocks--; // (c.haag 2006-10-03 13:47) - PLID 22823 - Release our self-lock
}

// (a.walling 2009-11-19 15:08) - PLID 36365 - Load any needed merge fields that are not loaded
long CEMN::EnsureLWMergeFields(CMap<CString, LPCTSTR, long, long&>& mapFields)
{	
	long nRequested = 0;
	BOOL procMergeSelected = FALSE; // (v.maida 2014-12-17 10:29) - PLID 63472 - Use flag to indicate that procedure-related merge fields are being used in a narrative. 
	//first pass through and get the names of all the merge fields we need filled in
	CStringSortedArrayNoCase aryFieldList;

	POSITION pos = mapFields.GetStartPosition();
	while (pos) {
		long nCount = 0;
		CString strField;
		mapFields.GetNextAssoc(pos, strField, nCount);
		if (procMergeSelected == FALSE) { // (v.maida 2014-12-17 10:29) - PLID 63472 - Set flag for procedure-related merge fields being used in a narrative.
			if (strField.Left(strField.Find('_')).Compare("Procedure") == 0) {
				procMergeSelected = TRUE;
			}
			else {
				// do nothing, procMergeSelected remains FALSE because no procedure-related merge field was encountered
			}
		} 

		NarrativeMergeField nf;
		if (m_mapLWMergeFields.Lookup(strField, nf)) {
			if (!nf.bFilled || (nf.bFilled && procMergeSelected)) {  // (v.maida 2014-12-17 10:29) - PLID 63472 - Procedures could be added / deleted between the time a procedure merge field is first entered and the narrative finished, so ignore whether procedure merge fields have been filled before.
				aryFieldList.Insert(strField);
				nRequested++;
			}
		} else {
			// merge field does not exist?!@(
			ASSERT(FALSE);
		}
	}

	//now pull the merge data
	if(aryFieldList.GetSize() > 0) {

		long nPatientID = GetParentEMR() ? GetParentEMR()->GetPatientID() : -1;

		CMergeEngine mi;

		// Prepare the table with the patient id we're going to merge
		// (a.walling 2013-03-20 16:07) - PLID 55789 - Letter Writing field merge query taking too long for new EMNs
		// This used to create (and never drop!) a temp table based on the tick count
		// Which also eliminates any possibility of caching the exec plan for the merge query,
		// which is often the slowest part. In one situation, this reduces overall exec time from ~300ms to ~0ms.
		CString strMergeT = "@TempMergeSource";

		// (j.gruber 2013-01-17 14:56) - PLID 54689- if we are attached to an appt, then use that for our appt merge fields
		CString strResFilter;
		EMNAppointment emnAppt = GetAppointment();
		if (emnAppt.nID != -1) {
			strResFilter.Format("((AppointmentsT.Status)<>4) AND (AppointmentsT.ID = %li)", emnAppt.nID);
		}

		// (v.maida 2014-12-17 10:29) - PLID 63472 - Give the merge engine object's procedure array the IDs of the current EMN's procedures.
		if (m_aryProcedures.GetSize() > 0 && procMergeSelected)
		{
			CString strProcIDs;
			for (int i = 0; i < m_aryProcedures.GetSize(); i++) {
				CString strID;
				strID.Format("%li, ", VarLong(((EMNProcedure*)m_aryProcedures.GetAt(i))->nID));
				strProcIDs += strID;
			}
			strProcIDs = strProcIDs.Left(strProcIDs.GetLength() - 2);
			//TES 6/13/2007 - PLID 26269 - This was including all ProcInfoT records for the patient for some reason.  I changed
			// it to just filter on the current PIC.
			// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
			_RecordsetPtr prsProcInfoDetails = CreateParamRecordset("SELECT ID FROM ProcInfoDetailsT WHERE ProcedureID IN ({INTSTRING}) AND ProcInfoID IN (SELECT ProcInfoID FROM PicT WHERE EmrGroupID = {INT})",
				strProcIDs, GetParentEMR()->GetID());
			while (!prsProcInfoDetails->eof)
			{
				mi.m_arydwProcInfoIDs.Add(AdoFldLong(prsProcInfoDetails, "ID"));
				prsProcInfoDetails->MoveNext();
			}
		}
		mi.m_arydwEMRIDs.Add(m_nID);

		CString strRecordSql = mi.GenerateMergeRecordsetSql(aryFieldList, strMergeT, "", strResFilter);
		if(!strRecordSql.IsEmpty()) {

			//combine the sender check and merge recordset into one database call -
			//which means the sender info will NOT be in the merge recordset,
			//and we will have to add special handling for those fields
			CString strName, strSql;
			// (a.walling 2013-03-20 16:07) - PLID 55789 - Declare and populate our table var now
			strSql.Format(
				"SET NOCOUNT ON;\r\n"
				"DECLARE @TempMergeSource TABLE (ID INT NOT NULL, RowNumber INT IDENTITY);\r\n"
				"INSERT INTO @TempMergeSource(ID) VALUES({INT});\r\n"
				"SELECT First, Middle, Last, Title, Email FROM PersonT WHERE ID = {INT};\r\n"
				"%s\r\n"
				"SET NOCOUNT OFF;\r\n", strRecordSql);
			
			ADODB::_RecordsetPtr rsMergeInfo = CreateParamRecordset(strSql, nPatientID, GetCurrentUserID());
			if(!rsMergeInfo->eof) {
				mi.m_strSenderFirst = AdoFldString(rsMergeInfo, "First","");
				mi.m_strSenderMiddle = AdoFldString(rsMergeInfo, "Middle","");
				mi.m_strSenderLast = AdoFldString(rsMergeInfo, "Last","");
				strName = mi.m_strSenderFirst + (mi.m_strSenderMiddle.IsEmpty() ? "" : (" "+ mi.m_strSenderMiddle)) + " " + mi.m_strSenderLast;
				strName.TrimRight();
				mi.m_strSender = strName;
				mi.m_strSenderTitle = AdoFldString(rsMergeInfo, "Title","");
				mi.m_strSenderEmail = AdoFldString(rsMergeInfo, "Email","");
			}

			//now advance to the recordset with all our merge fields
			rsMergeInfo = rsMergeInfo->NextRecordset(NULL);

			
			//but first check to see if the field is any of the sender information,
			//in which case the data is not in the recordset
			//(*** this would have been in the recordset if we populated the
			//mi.m_strSender fields prior to calling GenerateMergeRecordsetSql,
			//but that would have resulted in two separate recordsets, so to
			//conserve sql access, we have to implement this special handling)
			
			{
				//TES 6/13/2013 - PLID 57166 - bIsFilledIn should only be set if we're on an EMN, not if we're on a template
				m_mapLWMergeFields["Sender"].SetData(mi.m_strSender, m_bIsTemplate?false:true);
				m_mapLWMergeFields["Sender_First"].SetData(mi.m_strSenderFirst, m_bIsTemplate?false:true);
				m_mapLWMergeFields["Sender_Middle"].SetData(mi.m_strSenderMiddle, m_bIsTemplate?false:true);
				m_mapLWMergeFields["Sender_Last"].SetData(mi.m_strSenderLast, m_bIsTemplate?false:true);
				m_mapLWMergeFields["Sender_Email"].SetData(mi.m_strSenderEmail, m_bIsTemplate?false:true);
				m_mapLWMergeFields["Sender_Title"].SetData(mi.m_strSenderTitle, m_bIsTemplate?false:true);
			}

			if(!rsMergeInfo->eof) {

				//now update the fields we needed to load
				FieldsPtr fields = rsMergeInfo->Fields;
				short nFieldCount = (short)fields->Count;
				for (short nField = 0; nField < nFieldCount; nField++) {
					FieldPtr field(fields->Item[nField]);
					//TES 6/13/2013 - PLID 57166 - bIsFilledIn should only be set if we're on an EMN, not if we're on a template
					m_mapLWMergeFields[(LPCTSTR)field->Name].SetData(AsString(field->Value), m_bIsTemplate?false:true);
				}
			}
		}
	}

	return nRequested;
}

// (a.walling 2009-11-17 09:40) - PLID 36365
BOOL CEMN::GetGenericMergeFieldValue(const CString& strField, CString& strValue, bool& bIsValid)
{
	NarrativeMergeField nmf;
	if (m_mapGenericMergeFields.Lookup(strField, nmf)) {
		// (a.walling 2010-01-08 11:52) - PLID 36817 - 'Generic' fields are always valid, since valid just means that a source of information exists
		// (for narrative fields, this usually means the detail exists). The generic fields will always be !bFilled and empty on templates, and 
		// always be filled bFilled on patient EMNs. So they are always valid. If they are not bFilled, then we just use the field as the value.
		if (nmf.bFilled) {
			strValue = nmf.GetValue();
			bIsValid = true;
		} else {
			strValue = strField;
			bIsValid = true;
		}

		return TRUE;
	} else if (m_mapLWMergeFields.Lookup(strField, nmf)) {
		if (nmf.bFilled) {
			strValue = nmf.GetValue();
			bIsValid = true;
		} else {
			strValue.Empty();
			bIsValid = false;
		}

		return TRUE;
	} else {
		return FALSE;
	}
}

class CEmrItem
{
public:
	CEmrItem()
	{
		bDefaultSelected = false;
	};

public:
	void LoadCategoriesForInfoItem(long nEMRInfoID)
	{
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset("SELECT EMRCategoryID FROM EMRInfoCategoryT WHERE EMRInfoID = {INT}", nEMRInfoID);
		arynCategoryIDs.RemoveAll();
		FieldPtr fldCatID = prs->GetFields()->GetItem("EMRCategoryID");
		while (!prs->eof) {
			arynCategoryIDs.Add(AdoFldLong(fldCatID));
			prs->MoveNext();
		}
	};

public:
	bool bDefaultSelected;
	CDWordArray arynCategoryIDs;
};

void CEMN::SetOldAuditValue(CString strOldAuditValue)
{
	m_strOldAuditValue = strOldAuditValue;
}

//TES 1/23/2008 - PLID 24157 - Renamed, to better reflect the purpose of this function.
void CEMN::LockHandlingDetailChanges()
{
	ASSERT(m_nDetailChangeLocks >= 0);
	m_nDetailChangeLocks++;
}

//TES 1/23/2008 - PLID 24157 - Renamed, to better reflect the purpose of this function.
void CEMN::UnlockHandlingDetailChanges()
{
	ASSERT(m_nDetailChangeLocks >= 1);
	m_nDetailChangeLocks--;

	if(m_nDetailChangeLocks <= 0)
	{
		//Now, go through all our tables and apply each pending update to them.
		CArray<CEMNDetail*,CEMNDetail*> arDetails;
		GenerateTotalEMNDetailArray(&arDetails);
		CArray<CEMNDetail*,CEMNDetail*> arTables;
		int nDetailCount = arDetails.GetSize();
		// (a.walling 2007-11-05 17:52) - PLID 27890 - VS2008 - for() loops
		int i = 0;
		for(i = 0; i < nDetailCount; i++) {
			if(arDetails[i]->m_EMRInfoType == eitTable) arTables.Add(arDetails[i]);
		}
		if(m_arPendingChangedDetails.GetSize() > 0)
		{
			UpdateTableItemList();
			for(i = 0; i < m_arPendingChangedDetails.GetSize(); i++) {
				CEMNDetail *pDetail = m_arPendingChangedDetails[i].pDetail;
				BOOL bRemovingItem = m_arPendingChangedDetails[i].bRemovingItem;
				for(int j = 0; j  < arTables.GetSize(); j++) {
					arTables[j]->UpdateTable(pDetail, bRemovingItem);
				}
				GetParentEMR()->RemoveEMNDetailReference(pDetail);

				//TES 1/23/2008 - PLID 24157 - Also, update our multi popup dialog, if any.
				if(m_pMultiPopupDlg) {
					m_pMultiPopupDlg->HandleDetailChange(pDetail);
				}
			}
			//TES 2/15/2007 - PLID 24717 - PLID 24494 will further optimize this, by determining when it would be faster
			// to call UpdateNarrativesAndLinkedTables() for each pending update.  For now we will call LoadAllNarratives() for
			// the narratives, because it is efficient if there were a lot of changes, and update the linked tables individually.
			// (z.manning 2008-12-12 16:11) - PLID 32427 - Don't call LoadAllNarratives if we are about to call
			// PostIntialLoad since that also calls LoadAllNarratives.
			if(!NeedToCallPostInitialLoad()) {
				//TES 7/22/2011 - PLID 44665 - Tell the function that this is not the initial load of an EMN
				LoadAllNarratives(FALSE);
			}
			m_arPendingChangedDetails.RemoveAll();
		}
		else {
			//We don't have to do anything.  Note that even if there are no tables, we still have to go through and 
			// de-reference all the details
		}
		
		// (z.manning 2008-12-12 14:54) - PLID 32427 - If we spawned anything during the load process
		// we may not have called PostIntialLoad yet. It was previously called when unlocking spawning,
		// but we now make sure to not call it if detail changes are locked. As such, we need to check
		// here if a call to PostInitialLoad is pending and if so, call it.
		if(NeedToCallPostInitialLoad()) {
			PostInitialLoad();
		}
		
		if(m_bNeedToHandleCheckSaveEMNForDrugInteractionsOnDetailUnlock)
		{
			CEmrTreeWnd *pTree = GetInterface();
			if(pTree != NULL) {
				pTree->PostMessage(NXM_EMR_CHECK_SAVE_SHOW_DRUG_INTERACTIONS, (WPARAM)this, (LPARAM)m_bAlreadySavedAnInteractionChange_WhenUnlockingDetail);
			}
		}
		m_bNeedToHandleCheckSaveEMNForDrugInteractionsOnDetailUnlock = FALSE;
		m_bAlreadySavedAnInteractionChange_WhenUnlockingDetail = TRUE;
	}
}


//returns TRUE if the EMN is locked and has been saved, meaning no further saves should be allowed
BOOL CEMN::IsLockedAndSaved()
{
	// (j.jones 2011-07-05 11:21) - PLID 43603 - changed to a class to store the name as well
	if(m_Status.nID == 2 && m_LastSavedStatus.nID == 2) {
		return TRUE;
	}

	return FALSE;
}

void CEMN::AuditCloseUnsaved()
{
	try {
		// (m.hancock 2006-10-06 16:36) - PLID 22302 - Audit when we close an unsaved EMN.  We can only do this if the EMN's ID
		// is not -1, which means this is only audited if the EMN previously existed.
		// (m.hancock 2006-11-13 09:40) - PLID 22302 - This was previously using GetDescription() to print the EMN name, but this
		// did not audit correctly if the description had been changed then the user exits.  This should have correctly used
		// the old description name, m_strLastSavedDescription.
		if(m_nID > -1) {
			long nAuditID = BeginNewAuditEvent();
			AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditID, 
				aeiEMNClosedUnsaved, m_nID, "", m_strLastSavedDescription, aepLow, aetChanged);
		}
	}NxCatchAll("Error in CEMN::AuditCloseUnsaved()");
}

void CEMN::AuditCloseUnsavedDeleted()
{
	try {
		// (m.hancock 2006-11-28 16:39) - PLID 22302 - Audit when we close an unsaved EMN that has been marked for deletion.  This
		// happens when we close an EMN and choose not to save the changes, effectively canceling the deletion of the EMN.
		if(m_nID > -1) {
			long nAuditID = BeginNewAuditEvent();
			AuditEvent(GetParentEMR()->GetPatientID(), m_strPatNameLast + ", " + m_strPatNameFirst + " " + m_strPatNameMiddle, nAuditID, 
				aeiEMNClosedUnsavedDeleted, m_nID, "", m_strLastSavedDescription, aepLow, aetChanged);
		}
	}NxCatchAll("Error in CEMN::AuditCloseUnsavedDeleted()");
}

BOOL CEMN::IsLoading()
{
	return !m_bInitialLoadComplete;
}

// (a.walling 2009-12-29 09:10) - PLID 36659 - Need to suppress preview generation when copying an EMN, for example
void CEMN::SetLoaded(bool bGeneratePreview /*= true*/)
{
	//TES 2/20/2007 - PLID 24750 - The caller is telling us that we are done loading, probably because we didn't actually
	// have to load any topics from data.
	// (c.haag 2007-04-18 08:10) - The initial load is also flagged as complete in CEMN::PostInitialLoad
	m_bInitialLoadComplete = TRUE;
	m_bInitialLoadPendingCompletion = FALSE;

	//These are expected to be done when the initial load is complete; probably they're not necessary here because if
	// we're manually being told that loading is complete, there probably aren't any details on this EMN, but by the same
	// token, these won't be much of a speed hit.
	//TES 7/22/2011 - PLID 44665 - Tell the function that we're in the initial load of an EMN
	LoadAllNarratives(TRUE);
	UpdateAllMergeConflicts();

	// (a.walling 2007-09-27 12:45) - PLID 25548 - When copying an EMN, PostInitialLoad was never called, hence the preview
	// was never created. This also happened if there were no topics and etc. In those cases, SetLoaded() is called. We worked
	// around this in the treewnd when creating a new blank EMN, but it really should be here. So generate an HTML file, send
	// the load message, but do not copy to documents because it is not yet saved.
	// (a.walling 2009-12-29 09:10) - PLID 36659 - Only generate when flagged to do so
	if (bGeneratePreview) {
		GenerateHTMLFile(TRUE, FALSE);
	}
}

void CEMN::GetProviders(OUT CArray<long,long> &arProviderIDs)
{
	arProviderIDs.RemoveAll();
	for(int i = 0; i < m_aryProviders.GetSize(); i++) {
		arProviderIDs.Add(m_aryProviders[i]->nID);
	}
}

void CEMN::SetProviders(const CArray<long,long> &arProviderIDs)
{
	// (a.walling 2007-11-05 17:59) - PLID 27980 - VS2008 - for() loops
	int i = 0;
	//Any of our existing providers that aren't in this list, move them over to the deleted side.
	for(i = 0; i < m_aryProviders.GetSize(); i++) {
		//Is this in the new list?
		bool bFoundInNewList = false;
		// (a.walling 2007-11-05 17:59) - PLID 27980 - VS2008 - for() loops
		int j = 0;
		for(j = 0; j < arProviderIDs.GetSize() && !bFoundInNewList; j++) {
			if(m_aryProviders[i]->nID == arProviderIDs[j]) bFoundInNewList = true;
		}
		if(!bFoundInNewList) {
			//Has it already been deleted?
			bool bFoundInDeletedList = false;
			//TES 2/8/2012 - PLID 19441 - The deleted list now stores the pointer, not just the ID.
			for(j = 0; j < m_aryDeletedProviders.GetSize() && !bFoundInDeletedList; j++) {
				if(m_aryProviders[i]->nID == m_aryDeletedProviders[j]->nID) bFoundInDeletedList = true;
			}
			if(!bFoundInDeletedList) {
				//OK, we're deleting it now.
				m_aryDeletedProviders.Add(m_aryProviders[i]);
			}
			else {
				//TES 2/8/2012 - PLID 19441 - Since we're not copying the pointer to the deleted list, clean it up.
				delete m_aryProviders[i];
			}
			//And remove it from our list.			
			m_aryProviders.RemoveAt(i);
			i--;
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}

	//Now, add any new ones.
	for(i=0; i < arProviderIDs.GetSize(); i++) {
		bool bFoundInList = false;
		for(int j = 0; j < m_aryProviders.GetSize(); j++) {
			if(arProviderIDs[i] == m_aryProviders[j]->nID) bFoundInList = true;
		}
		if(!bFoundInList) {
			//TES 1/19/2007 - PLID 23400 - check to make sure it isn't in the deleted list
			for (int h = 0; h < m_aryDeletedProviders.GetSize(); h++) {
				if (arProviderIDs[i] == m_aryDeletedProviders[h]->nID) {
					//It's not deleted any more, take it out
					//TES 2/8/2012 - PLID 19441 - Clean up the memory
					delete m_aryDeletedProviders.GetAt(h);
					m_aryDeletedProviders.RemoveAt(h);
				}
			}

			//We need to add it.

			// (j.jones 2011-04-28 14:39) - PLID 43122 - I moved the name recordset to be a proper recordset,
			// to also load FloatEMRData
			_RecordsetPtr rsProv = CreateParamRecordset("SELECT PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProvName, "
				"ProvidersT.FloatEMRData "
				"FROM PersonT "
				"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
				"WHERE PersonT.ID = {INT}", arProviderIDs[i]);

			EMNProvider *pNewProv = new EMNProvider;
			pNewProv->nID = arProviderIDs[i];
			pNewProv->bIsNew = TRUE;
			pNewProv->strName = VarString(rsProv->Fields->Item["ProvName"]->Value, "");
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to on)
			pNewProv->bFloatEMRData = VarBool(rsProv->Fields->Item["FloatEMRData"]->Value, TRUE);
			m_aryProviders.Add(pNewProv);
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}
}

int CEMN::GetProviderCount()
{
	return m_aryProviders.GetSize();
}

EMNProvider* CEMN::GetProvider(int nIndex)
{
	return m_aryProviders[nIndex];
}

// (j.jones 2007-07-17 10:42) - PLID 26702 - added ability to get the entire provider list,
// not just the IDs of the providers
void CEMN::GetProviderList(OUT CArray<EMNProvider*,EMNProvider*> &aryProviders)
{
	aryProviders.RemoveAll();
	for(int i = 0; i < m_aryProviders.GetSize(); i++) {
		aryProviders.Add(m_aryProviders[i]);
	}
}

// (j.jones 2007-07-17 10:42) - PLID 26702 - added ability to set the entire provider list,
// not just the IDs of the providers
void CEMN::SetProviderList(const CArray<EMNProvider*,EMNProvider*> &aryProviders)
{
	// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
	int i = 0;
	//Any of our existing providers that aren't in this list, move them over to the deleted side.
	for(i = 0; i < m_aryProviders.GetSize(); i++) {
		// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
		int j = 0;

		//Is this in the new list?
		bool bFoundInNewList = false;
		for(j = 0; j < aryProviders.GetSize() && !bFoundInNewList; j++) {
			if(m_aryProviders[i]->nID == aryProviders[j]->nID)
				bFoundInNewList = true;
		}
		if(!bFoundInNewList) {
			//Has it already been deleted?
			bool bFoundInDeletedList = false;
			//TES 2/8/2012 - PLID 19441 - The deleted list now stores the pointer, not just the ID.
			for(j = 0; j < m_aryDeletedProviders.GetSize() && !bFoundInDeletedList; j++) {
				if(m_aryProviders[i]->nID == m_aryDeletedProviders[j]->nID) bFoundInDeletedList = true;
			}
			if(!bFoundInDeletedList) {
				//OK, we're deleting it now.
				m_aryDeletedProviders.Add(m_aryProviders[i]);
			}
			else {
				//TES 2/8/2012 - PLID 19441 - Since we're not copying the pointer to the deleted list, clean it up.
				delete m_aryProviders[i];
			}
			//And remove it from our list.
			m_aryProviders.RemoveAt(i);
			i--;
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}

	//Now, add any new ones.
	for(i=0; i < aryProviders.GetSize(); i++) {
		bool bFoundInList = false;
		for(int j = 0; j < m_aryProviders.GetSize(); j++) {
			if(aryProviders[i]->nID == m_aryProviders[j]->nID)
				bFoundInList = true;
		}
		if(!bFoundInList) {
			//TES 1/19/2007 - PLID 23400 - check to make sure it isn't in the deleted list
			for (int h = 0; h < m_aryDeletedProviders.GetSize(); h++) {
				if (aryProviders[i]->nID == m_aryDeletedProviders[h]->nID) {
					//It's not deleted any more, take it out
					//TES 2/8/2012 - PLID 19441 - Clean up the memory
					delete m_aryDeletedProviders.GetAt(h);
					m_aryDeletedProviders.RemoveAt(h);
				}
			}
			//We need to add it.
			EMNProvider *pNewProv = new EMNProvider;
			pNewProv->nID = aryProviders[i]->nID;
			pNewProv->bIsNew = TRUE;
			pNewProv->strName = aryProviders[i]->strName;
			// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
			pNewProv->bFloatEMRData = aryProviders[i]->bFloatEMRData;
			m_aryProviders.Add(pNewProv);
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}
}

// (j.gruber 2007-01-08 11:39) - PLID 23399 - Support Secondary Providers
void CEMN::GetSecondaryProviders(OUT CArray<long,long> &arSecondaryProviderIDs)
{
	arSecondaryProviderIDs.RemoveAll();
	for(int i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
		arSecondaryProviderIDs.Add(m_arySecondaryProviders[i]->nID);
	}
}

// (j.gruber 2007-01-08 11:39) - PLID 23399 - Support Secondary Providers
void CEMN::SetSecondaryProviders(const CArray<long,long> &arSecondaryProviderIDs)
{
	// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//Any of our existing providers that aren't in this list, move them over to the deleted side.
	for(i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
		// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
		int j = 0;

		//Is this in the new list?
		bool bFoundInNewList = false;
		for(j = 0; j < arSecondaryProviderIDs.GetSize() && !bFoundInNewList; j++) {
			if(m_arySecondaryProviders[i]->nID == arSecondaryProviderIDs[j]) bFoundInNewList = true;
		}
		if(!bFoundInNewList) {
			//Has it already been deleted?
			bool bFoundInDeletedList = false;
			//TES 2/8/2012 - PLID 19441 - We store the pointer in the list now, not just the ID
			for(j = 0; j < m_aryDeletedSecondaryProviders.GetSize() && !bFoundInDeletedList; j++) {
				if(m_arySecondaryProviders[i]->nID == m_aryDeletedSecondaryProviders[j]->nID) bFoundInDeletedList = true;
			}
			if(!bFoundInDeletedList) {
				//OK, we're deleting it now.
				m_aryDeletedSecondaryProviders.Add(m_arySecondaryProviders[i]);
			}
			else {
				//TES 2/8/2012 - PLID 19441 - Since we're not copying the pointer to the deleted list, clean it up.
				delete m_arySecondaryProviders[i];
			}
			//And remove it from our list.			
			m_arySecondaryProviders.RemoveAt(i);
			i--;
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}

	//Now, add any new ones.
	for(i=0; i < arSecondaryProviderIDs.GetSize(); i++) {
		bool bFoundInList = false;
		for(int j = 0; j < m_arySecondaryProviders.GetSize(); j++) {
			if(arSecondaryProviderIDs[i] == m_arySecondaryProviders[j]->nID) bFoundInList = true;
		}
		if(!bFoundInList) {
			//check to make sure it isn't in the deleted list
			for (int h = 0; h < m_aryDeletedSecondaryProviders.GetSize(); h++) {
				if (arSecondaryProviderIDs[i] == m_aryDeletedSecondaryProviders[h]->nID) {
					//take it out
					//TES 2/8/2012 - PLID 19441 - Clean up the memory
					delete m_aryDeletedSecondaryProviders.GetAt(h);
					m_aryDeletedSecondaryProviders.RemoveAt(h);
				}
			}
			
			//We need to add it.
			
			// (j.jones 2011-04-28 14:39) - PLID 43122 - I moved the name recordset to be a proper recordset,
			// to also load FloatEMRData
			_RecordsetPtr rsProv = CreateParamRecordset("SELECT PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProvName, "
				"ProvidersT.FloatEMRData "
				"FROM PersonT "
				"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
				"WHERE PersonT.ID = {INT}", arSecondaryProviderIDs[i]);

			if(!rsProv->eof) {
				EMNProvider *pNewProv = new EMNProvider;
				pNewProv->nID = arSecondaryProviderIDs[i];
				pNewProv->bIsNew = TRUE;
				pNewProv->strName = VarString(rsProv->Fields->Item["ProvName"]->Value, "");
				// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to on)
				pNewProv->bFloatEMRData = VarBool(rsProv->Fields->Item["FloatEMRData"]->Value, TRUE);
				m_arySecondaryProviders.Add(pNewProv);
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
				SetMoreInfoUnsaved();
			}
			rsProv->Close();
		}
	}
}

// (j.gruber 2007-01-08 11:39) - PLID 23399 - Support Secondary Providers
int CEMN::GetSecondaryProviderCount()
{
	return m_arySecondaryProviders.GetSize();
}

// (j.gruber 2007-01-08 11:39) - PLID 23399 - Support Secondary Providers
EMNProvider* CEMN::GetSecondaryProvider(int nIndex)
{
	return m_arySecondaryProviders[nIndex];
}

// (d.lange 2011-03-23 09:04) - PLID 42136 - Support Assistant/Technician
void CEMN::GetTechnicians(OUT CArray<long,long> &arTechnicianIDs)
{
	arTechnicianIDs.RemoveAll();
	for(int i = 0; i < m_aryTechnicians.GetSize(); i++) {
		arTechnicianIDs.Add(m_aryTechnicians[i]->nID);
	}
}

// (d.lange 2011-03-23 09:04) - PLID 42136 - Support Assistant/Technician
void CEMN::SetTechnicians(const CArray<long,long> &arTechnicianIDs)
{
	int i = 0;

	for(i = 0; i < m_aryTechnicians.GetSize(); i++) {
		int j = 0;
		bool bFoundInNewList = false;
		for(j = 0; j < arTechnicianIDs.GetSize() && !bFoundInNewList; j++) {
			if(m_aryTechnicians[i]->nID == arTechnicianIDs[j]) bFoundInNewList = true;
		}
		if(!bFoundInNewList) {
			bool bFoundInDeletedList = false;
			//TES 2/8/2012 - PLID 19441 - We store the pointer in the deleted list now, not just the ID
			for(j = 0; j < m_aryDeletedTechnicians.GetSize() && !bFoundInDeletedList; j++) {
				if(m_aryTechnicians[i]->nID == m_aryDeletedTechnicians[j]->nID) bFoundInDeletedList = true;
			}
			if(!bFoundInDeletedList) {
				m_aryDeletedTechnicians.Add(m_aryTechnicians[i]);
			}
			else {
				//TES 2/8/2012 - PLID 19441 - Since we're not copying the pointer to the deleted list, clean it up.
				delete m_aryTechnicians[i];
			}
			m_aryTechnicians.RemoveAt(i);
			i--;
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}

	//Now let's add any new ones
	for(i = 0; i < arTechnicianIDs.GetSize(); i++) {
		bool bFoundInList = false;
		for(int j = 0; j < m_aryTechnicians.GetSize(); j++) {
			if(arTechnicianIDs[i] == m_aryTechnicians[j]->nID) bFoundInList = true;
		}

		if(!bFoundInList) {
			//Let's make sure they aren't in the deleted list
			//TES 8/1/2012 - PLID 48920 - If they are in the deleted list, that means that the user has removed them during this editing
			// session, and is now putting them back.  In which case, we should take the item out of the deleted array and put it back in the
			// official array, rather than taking it out of the deleted array (thus causing the existing record not to get deleted) and putting
			// in a new entry (thus causing a duplicate record to get inserted), which is what it was doing before.
			bool bAdded = false;
			for (int k = 0; k < m_aryDeletedTechnicians.GetSize(); k++) {
				if (arTechnicianIDs[i] == m_aryDeletedTechnicians[k]->nID) {
					//take it out
					m_aryTechnicians.Add(m_aryDeletedTechnicians[k]);
					m_aryDeletedTechnicians.RemoveAt(k);
					bAdded = true;
				}
			}

			//TES 8/1/2012 - PLID 48920 - Check whether we already added it from the deleted list.
			if(!bAdded) {
				//Add it
				EMNProvider *pNewTech = new EMNProvider;
				pNewTech->nID = arTechnicianIDs[i];
				pNewTech->bIsNew = TRUE;
				pNewTech->strName = VarString(GetTableField("PersonT", "Last + ', ' + First + ' ' + Middle", "ID", arTechnicianIDs[i]));
				m_aryTechnicians.Add(pNewTech);
			}
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}
}

// (d.lange 2011-03-23 09:04) - PLID 42136 - Support Assistant/Technician
int CEMN::GetTechnicianCount()
{
	return m_aryTechnicians.GetSize();
}

// (d.lange 2011-03-23 09:04) - PLID 42136 - Support Assistant/Technician
EMNProvider* CEMN::GetTechnician(int nIndex)
{
	return m_aryTechnicians[nIndex];
}

// (j.gruber 2009-05-07 16:59) - PLID 33688 - Other Providers
void CEMN::GetOtherProviders(OUT CArray<EMNProvider*, EMNProvider*> &arOtherProviderIDs)
{
	arOtherProviderIDs.RemoveAll();
	for(int i = 0; i < m_aryOtherProviders.GetSize(); i++) {

		//make a new provider
		EMNProvider *pProv = new EMNProvider();
		pProv->bIsNew = m_aryOtherProviders[i]->bIsNew;
		pProv->nID = m_aryOtherProviders[i]->nID;
		pProv->nTypeID = m_aryOtherProviders[i]->nTypeID;
		pProv->strName = m_aryOtherProviders[i]->strName;
		pProv->strTypeName = m_aryOtherProviders[i]->strTypeName;		
		// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
		pProv->bFloatEMRData = m_aryOtherProviders[i]->bFloatEMRData;

		arOtherProviderIDs.Add(pProv);
	}
}

// (j.gruber 2009-05-07 17:00) - PLID 33688 - Other Providers
void CEMN::SetOtherProviders(const CArray<EMNProvider*,EMNProvider*> &arOtherProviderIDs)
{
	// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//Any of our existing providers that aren't in this list, move them over to the deleted side.
	for(i = 0; i < m_aryOtherProviders.GetSize(); i++) {
		// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
		int j = 0;

		//Is this in the new list?
		bool bFoundInNewList = false;
		for(j = 0; j < arOtherProviderIDs.GetSize() && !bFoundInNewList; j++) {
			if(m_aryOtherProviders[i]->nID == arOtherProviderIDs[j]->nID && m_aryOtherProviders[i]->nTypeID == arOtherProviderIDs[j]->nTypeID) bFoundInNewList = true;
		}
		if(!bFoundInNewList) {
			//Has it already been deleted?
			bool bFoundInDeletedList = false;
			for(j = 0; j < m_aryDeletedOtherProviders.GetSize() && !bFoundInDeletedList; j++) {
				if(m_aryOtherProviders[i]->nID == m_aryDeletedOtherProviders[j]->nID && m_aryOtherProviders[i]->nTypeID == m_aryDeletedOtherProviders[j]->nTypeID) bFoundInDeletedList = true;
			}
			if(!bFoundInDeletedList) {
				//OK, we're deleting it now.
				EMNProvider *pProv = new EMNProvider();
				pProv->bIsNew = m_aryOtherProviders[i]->bIsNew;
				pProv->nID = m_aryOtherProviders[i]->nID;
				pProv->nTypeID = m_aryOtherProviders[i]->nTypeID;
				pProv->strName = m_aryOtherProviders[i]->strName;
				pProv->strTypeName = m_aryOtherProviders[i]->strTypeName;
				// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData
				pProv->bFloatEMRData = m_aryOtherProviders[i]->bFloatEMRData;
				m_aryDeletedOtherProviders.Add(pProv);
			}
			//And remove it from our list.
			delete m_aryOtherProviders[i];
			m_aryOtherProviders.RemoveAt(i);
			i--;
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
			SetMoreInfoUnsaved();
		}
	}

	//Now, add any new ones.
	for(i=0; i < arOtherProviderIDs.GetSize(); i++) {
		bool bFoundInList = false;
		for(int j = 0; j < m_aryOtherProviders.GetSize(); j++) {
			if(arOtherProviderIDs[i]->nID == m_aryOtherProviders[j]->nID && arOtherProviderIDs[i]->nTypeID == m_aryOtherProviders[j]->nTypeID) bFoundInList = true;
		}
		if(!bFoundInList) {
			//check to make sure it isn't in the deleted list
			for (int h = m_aryDeletedOtherProviders.GetSize() - 1; h >= 0 ; h--) {
				if (arOtherProviderIDs[i]->nID == m_aryDeletedOtherProviders[h]->nID && arOtherProviderIDs[i]->nTypeID == m_aryDeletedOtherProviders[h]->nTypeID) {
					//take it out
					EMNProvider *pProv = m_aryDeletedOtherProviders.GetAt(h);
					delete pProv;
					m_aryDeletedOtherProviders.RemoveAt(h);
				}
			}
			
			// (j.jones 2011-04-28 14:39) - PLID 43122 - I moved the name recordset to be a proper recordset,
			// to also load FloatEMRData
			_RecordsetPtr rsProv = CreateParamRecordset("SELECT PersonT.Last + ', ' + PersonT.First + ' ' + PersonT.Middle AS ProvName, "
				"ProvidersT.FloatEMRData "
				"FROM PersonT "
				"INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
				"WHERE PersonT.ID = {INT}", arOtherProviderIDs[i]->nID);

			if(!rsProv->eof) {				
				EMNProvider *pNewProv = new EMNProvider;
				pNewProv->nID = arOtherProviderIDs[i]->nID;
				pNewProv->bIsNew = TRUE;
				pNewProv->strName = VarString(rsProv->Fields->Item["ProvName"]->Value, "");
				pNewProv->nTypeID = arOtherProviderIDs[i]->nTypeID;
				pNewProv->strTypeName = arOtherProviderIDs[i]->strTypeName;
				// (j.jones 2011-04-28 14:39) - PLID 43122 - added FloatEMRData (defaults to on)
				pNewProv->bFloatEMRData = VarBool(rsProv->Fields->Item["FloatEMRData"]->Value, TRUE);
				m_aryOtherProviders.Add(pNewProv);
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
				SetMoreInfoUnsaved();
			}
			rsProv->Close();
		}
	}
}

// (j.gruber 2009-05-07 17:07) - PLID 33688 - Other Providers
int CEMN::GetOtherProviderCount()
{
	return m_aryOtherProviders.GetSize();
}

// (j.gruber 2009-05-07 17:07) - PLID 33688 - Other Providers
EMNProvider* CEMN::GetOtherProvider(int nIndex)
{
	return m_aryOtherProviders[nIndex];
}

void CEMN::SetCategory(long nCategoryID, CString strCategoryName)
{
	m_Category.nID = nCategoryID;
	m_Category.strName = strCategoryName;
	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();
}

// (z.manning, 04/11/2007) - PLID 25569
// (z.manning 2011-05-19 17:59) - PLID 33114 - SetChart is now returns a bool indicating whether or not it was successful
// Also added a bool for whether or not the chart permission check should be silent.
BOOL CEMN::SetChart(long nChartID, CString strChartName, BOOL bSlient /* = TRUE */)
{
	// (z.manning 2011-05-19 17:48) - PLID 33114 - As a failsafe, make sure patient EMNs can't be linked to 
	// a chart that the current user can't access.
	if(!m_bIsTemplate && (!IsLoading() || m_nID == -1) && nChartID != -1 && !CheckCurrentUserPermissions(bioEmrCharts, sptView, TRUE, nChartID, bSlient)) {
		return FALSE;
	}

	m_Chart.nID = nChartID;
	m_Chart.strName = strChartName;
	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();

	return TRUE;
}

// (a.walling 2013-01-16 13:04) - PLID 54650 - Appointment linked with this EMN
BOOL CEMN::SetAppointment(const EMNAppointment& appt)
{
	if (appt == m_Appointment) {
		return FALSE;
	}

	m_Appointment = appt;

	m_bUnsaved = TRUE;
	// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
	SetMoreInfoUnsaved();

	return TRUE;
}

// (d.thompson 2009-05-08) - PLID 29909 - Sets the confidential information for this EMN
void CEMN::SetConfidentialInfo(CString strNewData)
{
	//Ensure an actual change
	if(strNewData != m_strConfidentialInfo) {
		m_strConfidentialInfo = strNewData;
		m_bConfidentialInfoChanged = true;
		//The chart is unsaved, and this exists on the more info, so it is too.
		m_bUnsaved = TRUE;
		// (a.walling 2012-03-22 16:50) - PLID 49141 - Use SetMoreInfoUnsaved()
		SetMoreInfoUnsaved();
	}
}

// (d.thompson 2009-05-08) - PLID 29909 - Retrives the current confidential data for this EMN
CString CEMN::GetConfidentialInfo()
{
	return m_strConfidentialInfo;
}

//TES 7/10/2009 - PLID 25154
bool CEMN::GetSendBillToHL7()
{
	return m_bSendBillToHL7;
}

//TES 7/10/2009 - PLID 25154
void CEMN::SetSendBillToHL7(bool bSend)
{
	m_bSendBillToHL7 = bSend;
}
//(a.wilson 2013-06-13) PLID 57165
bool CEMN::GetChargesChanged()
{
	return m_bChargesChanged;
}
//(a.wilson 2013-06-13) PLID 57165
void CEMN::SetChargesChanged(bool bChanged)
{
	m_bChargesChanged = bChanged;
}

// (j.jones 2007-01-23 09:14) - PLID 24027 - reassigns source detail IDs/pointers due to an EMN copy
// Basic logic: for each spawnable item (topics, More Info, Details, {EMNs excluded}) that has a 
// source detail, we need to point it to the proper detail in the new copy of the EMN.
// We do this prior to wiping out the detail IDs for the new copy, so if we have the detail ID, 
// it's a matter of finding the detail with that ID, setting our pointer to it, and we're done.
// If all we have is a pointer though, it's a pointer to the old detail in the EMN we copied from.
// So the detail's operator = function keeps a pointer to each detail a new one was copied from,
// which then gets cleared out in SetNew later on. For the duration of this function though,
// this means that we can look at each detail on the new EMN, find the original detail's address,
// compare to our source detail pointer, and if they match, reassign the current detail's source
// detail pointer to the new detail that was linked to the original detail's address.
// In all cases make SourceDetailID be -1 since everything on the EMN is new and has no ID, or at
// least will soon have no ID because SetNew() is called right after this
//TES 5/20/2014 - PLID 52705 - The comment above this was incorrect, SetNew() is not always called right after this,
// because this function is now called when importing topics, not just when copying EMNs. 
// So, I added bResetIDs, so this function knows whether or not it should set everything to -1
void CEMN::UpdateSourceDetailsFromCopy(bool bResetIDs)
{
	//for this EMN, do NOT update source details, they are intentionally cleared out
	//as the copy is no longer considered to have been spawned

	// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//update all topics
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(i);
		//TES 5/20/2014 - PLID 52705 - Pass in bResetIDs
		pTopic->UpdateSourceDetailsFromCopy(bResetIDs);
	}

	//update all charges
	for(i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge *pCharge = m_aryCharges.GetAt(i);
		//first try the detail ID
		if(pCharge->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pCharge->sai.nSourceDetailID) : GetDetailByID(pCharge->sai.nSourceDetailID);
			pCharge->sai.pSourceDetail = pSourceDetail;
			//ensure our source detail ID is -1 now
			//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true
			if (bResetIDs) {
				pCharge->sai.nSourceDetailID = -1;
			}
		}
		else if(pCharge->sai.pSourceDetail) {
			//we have a pointer but no detail ID, so try to find the parent detail
			BOOL bFound = FALSE;
			long nDetails = GetTotalDetailCount();
			for(int j=0; j<nDetails && !bFound; j++) {
				//we have to compare to every detail in the EMN
				CEMNDetail *pDetailToCompare = GetDetail(j);
				if(pDetailToCompare) {
					//and we are temporarily storing a pointer to the copied-from detail,
					//which is what our sourcedetail currently links to
					CEMNDetail *pCopiedFromDetail = pDetailToCompare->GetCopiedFromDetail();
					if(pCopiedFromDetail == pCharge->sai.pSourceDetail) {
						//good, we found our source detail, now reassign our pointer
						pCharge->sai.pSourceDetail = pDetailToCompare;
						//ensure our source detail ID is -1 now
						//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true (although really we already know it is -1)
						if (bResetIDs) {
							pCharge->sai.nSourceDetailID = -1;
						}
						bFound = TRUE;
					}
				}
			}
		}
	}

	//update all diagnosis codes
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
		//first try the detail ID
		if(pDiag->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pDiag->sai.nSourceDetailID) : GetDetailByID(pDiag->sai.nSourceDetailID);
			pDiag->sai.pSourceDetail = pSourceDetail;
			//ensure our source detail ID is -1 now
			//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true
			if (bResetIDs) {
				pDiag->sai.nSourceDetailID = -1;
			}
		}
		else if(pDiag->sai.pSourceDetail) {
			//we have a pointer but no detail ID, so try to find the parent detail
			BOOL bFound = FALSE;
			long nDetails = GetTotalDetailCount();
			for(int j=0; j<nDetails && !bFound; j++) {
				//we have to compare to every detail in the EMN
				CEMNDetail *pDetailToCompare = GetDetail(j);
				if(pDetailToCompare) {
					//and we are temporarily storing a pointer to the copied-from detail,
					//which is what our sourcedetail currently links to
					CEMNDetail *pCopiedFromDetail = pDetailToCompare->GetCopiedFromDetail();
					if(pCopiedFromDetail == pDiag->sai.pSourceDetail) {
						//good, we found our source detail, now reassign our pointer
						pDiag->sai.pSourceDetail = pDetailToCompare;
						//ensure our source detail ID is -1 now
						//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true (although really we already know it is -1)
						if (bResetIDs) {
							pDiag->sai.nSourceDetailID = -1;
						}
						bFound = TRUE;
					}
				}
			}
		}
	}

	//update all procedures
	for(i = 0; i < m_aryProcedures.GetSize(); i++) {
		EMNProcedure *pProc = m_aryProcedures.GetAt(i);
		//first try the detail ID
		if(pProc->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pProc->sai.nSourceDetailID) : GetDetailByID(pProc->sai.nSourceDetailID);
			pProc->sai.pSourceDetail = pSourceDetail;
			//ensure our source detail ID is -1 now
			//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true
			if (bResetIDs) {
				pProc->sai.nSourceDetailID = -1;
			}
		}
		else if(pProc->sai.pSourceDetail) {
			//we have a pointer but no detail ID, so try to find the parent detail
			BOOL bFound = FALSE;
			long nDetails = GetTotalDetailCount();
			for(int j=0; j<nDetails && !bFound; j++) {
				//we have to compare to every detail in the EMN
				CEMNDetail *pDetailToCompare = GetDetail(j);
				if(pDetailToCompare) {
					//and we are temporarily storing a pointer to the copied-from detail,
					//which is what our sourcedetail currently links to
					CEMNDetail *pCopiedFromDetail = pDetailToCompare->GetCopiedFromDetail();
					if(pCopiedFromDetail == pProc->sai.pSourceDetail) {
						//good, we found our source detail, now reassign our pointer
						pProc->sai.pSourceDetail = pDetailToCompare;
						//ensure our source detail ID is -1 now
						//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true (although really we already know it is -1)
						if (bResetIDs) {
							pProc->sai.nSourceDetailID = -1;
						}
						bFound = TRUE;
					}
				}
			}
		}
	}

	//update all medications
	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		EMNMedication *pPresc = m_aryMedications.GetAt(i);
		//first try the detail ID
		if(pPresc->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pPresc->sai.nSourceDetailID) : GetDetailByID(pPresc->sai.nSourceDetailID);
			pPresc->sai.pSourceDetail = pSourceDetail;
			//ensure our source detail ID is -1 now
			//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true
			if (bResetIDs) {
				pPresc->sai.nSourceDetailID = -1;
			}
		}
		else if(pPresc->sai.pSourceDetail) {
			//we have a pointer but no detail ID, so try to find the parent detail
			BOOL bFound = FALSE;
			long nDetails = GetTotalDetailCount();
			for(int j=0; j<nDetails && !bFound; j++) {
				//we have to compare to every detail in the EMN
				CEMNDetail *pDetailToCompare = GetDetail(j);
				if(pDetailToCompare) {
					//and we are temporarily storing a pointer to the copied-from detail,
					//which is what our sourcedetail currently links to
					CEMNDetail *pCopiedFromDetail = pDetailToCompare->GetCopiedFromDetail();
					if(pCopiedFromDetail == pPresc->sai.pSourceDetail) {
						//good, we found our source detail, now reassign our pointer
						pPresc->sai.pSourceDetail = pDetailToCompare;
						//ensure our source detail ID is -1 now
						//TES 5/20/2014 - PLID 52705 - Only if bResetIDs is true (although really we already know it is -1)
						if (bResetIDs) {
							pPresc->sai.nSourceDetailID = -1;
						}
						bFound = TRUE;
					}
				}
			}
		}
	}
}

// (z.manning 2010-03-11 14:56) - PLID 37571 - Will reassasign the source detail stamp pointer to the given
// new pointer for any object in this EMN that could have potentially been spawned.
// (a.walling 2010-03-31 14:46) - PLID 38009 - Pass in the source EMN; if we are not the source EMN, we do not need to recurse into topics
void CEMN::UpdateSourceDetailStampPointers(EmrDetailImageStamp *pDetailStampOld, EmrDetailImageStamp *pDetailStampNew, CEMN* pSourceEMN)
{
	// (a.walling 2010-03-31 14:53) - PLID 38009 - Update our m_sai
	m_sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);

	// (a.walling 2010-03-31 14:53) - PLID 38009 - If we are not the source, don't recurse
	if (pSourceEMN != this) {
		return;
	}

	//update all topics
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(i);
		pTopic->UpdateSourceDetailStampPointers(pDetailStampOld, pDetailStampNew);
	}

	//update all charges
	for(i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge *pCharge = m_aryCharges.GetAt(i);
		pCharge->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}

	//update all diagnosis codes
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
		pDiag->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}

	//update all procedures
	for(i = 0; i < m_aryProcedures.GetSize(); i++) {
		EMNProcedure *pProc = m_aryProcedures.GetAt(i);
		pProc->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}

	//update all medications
	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		EMNMedication *pPresc = m_aryMedications.GetAt(i);
		pPresc->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}

	for(i = 0; i < m_aryLabs.GetSize(); i++) {
		EMNLab *pLab = m_aryLabs.GetAt(i);
		pLab->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}

	CArray<EMNTodo*,EMNTodo*> arypTodos;
	GenerateCreatedTodosWhileUnsavedList(arypTodos);
	for(i = 0; i < arypTodos.GetSize(); i++) {
		EMNTodo *pTodo = arypTodos.GetAt(i);
		pTodo->sai.UpdateDetailStampPointerIfMatch(pDetailStampOld, pDetailStampNew);
	}
}

// (j.jones 2007-01-23 11:00) - PLID 24027 - update the source details such that their pointers are set
// and if bClearEraseSourceDetailID is TRUE, then also clear their detail IDs
// Basic Logic: for every item that has a source detail ID (regardless of whether it has a pointer), find the source detail and ensure
// its pointer is set to that detail. Then based on the boolean, optionally set the SourceDetailID to -1.
// (Note: if the source detail itself is -1, this would happen anyways)
void CEMN::UpdateSourceDetailPointers(BOOL bClearEraseSourceDetailID)
{
	// (a.walling 2007-06-28 16:30) - PLID 26494 - The problem here is that we are getting details by ID which may not have even been loaded yet,
	// and additionally we call UpdateSourceDetailPointers into topics which also may not have loaded all they way so they think their source
	// detail id is -1 when it really is not!!

	// (a.walling 2007-08-28 15:53) - PLID 26494 - This was only ensuring top-level topics have been loaded! We can either recursively call
	// EnsureLoaded via a recurse flag, or even better to just call EnsureCompletelyLoaded()
	// Ensure every topic has loaded.
	EnsureCompletelyLoaded();	

	//only update the EMN if not a template, if we have a parent EMR, and if we have
	//a source detail ID and no source pointer
	if(!m_bIsTemplate && m_pParentEMR && m_sai.nSourceDetailID != -1) {
		long nEMNCount = m_pParentEMR->GetEMNCount();
		BOOL bFound = FALSE;
		for(int i=0; i<nEMNCount && !bFound; i++) {
			CEMN *pEMNToCheck = m_pParentEMR->GetEMN(i);
			//if not this EMN, check its details
			if(pEMNToCheck && pEMNToCheck != this) {
				//we can use GetDetailByID because this block of code is only called on non-templates
				CEMNDetail *pDetail = m_bIsTemplate ? pEMNToCheck->GetDetailByTemplateDetailID(m_sai.nSourceDetailID) : pEMNToCheck->GetDetailByID(m_sai.nSourceDetailID);
				m_sai.pSourceDetail = pDetail;
				if(bClearEraseSourceDetailID)
					m_sai.nSourceDetailID = -1;
			}
		}
	}

	// (a.walling 2007-11-06 08:26) - PLID 27980 - VS2008 - for() loops
	int i = 0;

	//update all topics
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(i);
		pTopic->UpdateSourceDetailPointers(bClearEraseSourceDetailID);
	}

	//update all charges, where we have a source detail ID and no source pointer
	for(i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge *pCharge = m_aryCharges.GetAt(i);
		if(pCharge->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pCharge->sai.nSourceDetailID) : GetDetailByID(pCharge->sai.nSourceDetailID);
			pCharge->sai.pSourceDetail = pSourceDetail;
			if(bClearEraseSourceDetailID)
				pCharge->sai.nSourceDetailID = -1;
		}
	}

	//update all diagnosis codes, where we have a source detail ID and no source pointer
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
		if(pDiag->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pDiag->sai.nSourceDetailID) : GetDetailByID(pDiag->sai.nSourceDetailID);
			pDiag->sai.pSourceDetail = pSourceDetail;
			if(bClearEraseSourceDetailID)
				pDiag->sai.nSourceDetailID = -1;
		}
	}

	//update all procedures, where we have a source detail ID and no source pointer
	for(i = 0; i < m_aryProcedures.GetSize(); i++) {
		EMNProcedure *pProc = m_aryProcedures.GetAt(i);
		if(pProc->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pProc->sai.nSourceDetailID) : GetDetailByID(pProc->sai.nSourceDetailID);
			pProc->sai.pSourceDetail = pSourceDetail;
			if(bClearEraseSourceDetailID)
				pProc->sai.nSourceDetailID = -1;
		}
	}

	//update all medications, where we have a source detail ID and no source pointer
	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		EMNMedication *pPresc = m_aryMedications.GetAt(i);
		if(pPresc->sai.nSourceDetailID != -1) {
			CEMNDetail *pSourceDetail = m_bIsTemplate ? GetDetailByTemplateDetailID(pPresc->sai.nSourceDetailID) : GetDetailByID(pPresc->sai.nSourceDetailID);
			pPresc->sai.pSourceDetail = pSourceDetail;
			if(bClearEraseSourceDetailID)
				pPresc->sai.nSourceDetailID = -1;
		}
	}
}

//TES 1/23/2007 - PLID 24377 - Used when processing EMR Links, this function returns TRUE if any one of the EmrDataT.IDs
// in the array is selected on any detail in the EMN, otherwise it returns FALSE.
BOOL CEMN::IsAnyItemChecked(const CArray<long,long> &arDataIDs, const CArray<CEMNDetail*,CEMNDetail*> &arDetailsToIgnore)
{
	//Check each of our topics.
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->IsAnyItemChecked(arDataIDs, arDetailsToIgnore)) return TRUE;
	}
	return FALSE;
}

// (c.haag 2011-05-19) - PLID 43696 - Populates a map with all EmrDataID's that correspond to checked-off single-select
// and multi-select list items. All details in mapDetailsToIgnore are ignored during the search.
void CEMN::GetAllCheckedItems(CMap<long,long,BOOL,BOOL>& mapDataIDs, const CMap<CEMNDetail*,CEMNDetail*,BOOL,BOOL> &mapDetailsToIgnore)
{
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		m_arypEMRTopics[i]->GetAllCheckedItems(mapDataIDs, mapDetailsToIgnore);
	}
}

void CEMN::ProcessAllergiesChange(CEMNDetail* pSourceDetail)
{
	//
	// (c.haag 2007-04-05 11:27) - PLID 25516 - When a user changes an Allergies table, we
	// need to retroactively update every Allergies detail in the entire EMN. This is because
	// the Allergies detail is one-per-EMN.
	//

	if (GetUpdatingAllergiesDetails()) {
		// (c.haag 2007-04-05 11:28) - PLID 25516 - If we get here, it means UpdateAllAllergiesDetails
		// was called earlier in the call stack. Therefore, we don't need to do anything.
		return;
	}

	// (j.jones 2007-07-23 10:39) - PLID 26742 - get the active medications info ID from the EMR if we can
	long nActiveCurrentAllergiesInfoID = -1;
	if(m_pParentEMR) {
		nActiveCurrentAllergiesInfoID = m_pParentEMR->GetCurrentAllergiesInfoID();
	}
	else {
		//why don't we have an EMR?
		ASSERT(FALSE);
		//get it the traditional way
		nActiveCurrentAllergiesInfoID = GetActiveAllergiesInfoID();
	}

	// Do nothing if the source detail is not based on the official Allergies item
	if (nActiveCurrentAllergiesInfoID != pSourceDetail->m_nEMRInfoID) {
		return;
	}

	// Update the details
	UpdateAllAllergiesListDetails(pSourceDetail->GetState(), pSourceDetail->m_nEMRInfoID, pSourceDetail);
}

BOOL CEMN::GetUpdatingAllergiesDetails() const
{
	// (c.haag 2007-04-05 11:29) - PLID 25516 - Returns TRUE if we are traversing
	// the EMR for Allergies details and making sure all of the states are the same
	return m_bUpdatingAllergiesDetails;
}

void CEMN::SetUpdatingAllergiesDetails(BOOL bProcessing)
{
	// (c.haag 2007-04-05 11:30) - PLID 25516 - Set to TRUE if we are traversing
	// the EMR for Allergies details and making sure all of the states are
	// the same. Set back to FALSE when done.
	m_bUpdatingAllergiesDetails = bProcessing;
}

// (c.haag 2009-03-05 17:07) - PLID 33367 - This is a utility function used in 
// ApplyOfficialAllergies and ApplyOfficialCurrentMedications to efficiently
// populate the state of a system table with values.
// (j.jones 2011-05-04 14:44) - PLID 43527 - added ptrmapCurMedDataIDsToSig, which is NULL
// when an allergies table, and a pointer to a map of data IDs to a current medications Sig
// when this is the current medications table
void CEMN::BuildSystemTableState(const CArray<long,long>& aY,
								 const CArray<long,long>& aYSortOrder,
								 const CArray<long,long>& anCurDataIDs,
								 CEMNDetail* pDetail,
								 CMap<long, long, CString, LPCTSTR> *ptrmapCurMedDataIDsToSig)
{
	const long nCurDataIDs = anCurDataIDs.GetSize();
	const long nSortOrders = aYSortOrder.GetSize();
	const long nExistingElements = pDetail->GetTableElementCount();
	ASSERT(aYSortOrder.GetSize() == aY.GetSize());

	// Copy the data ID and sort orders to maps for fast lookups
	CMap<long,long,BOOL,BOOL> mapCurDataIDs; // Maps medication ID to a TRUE boolean
	CMap<long,long,long,long> mapSortOrders; // Maps data ID to a sort order
	CMap<__int64, __int64, int, int> mapTable; // Maps row and column ID's to table element indices
	long i;
	// Create a map of selected data ID's
	for (i=0; i < nCurDataIDs; i++) {
		mapCurDataIDs.SetAt(anCurDataIDs[i],TRUE);
	}
	// Create a map of sort orders
	for (i=0; i < nSortOrders; i++) {
		mapSortOrders.SetAt(aY[i], aYSortOrder[i]);
	}
	// nExistingElements can be greater than zero if we're building a popup detail. We must be able 
	// to do fast lookups to pull the existing table element. Otherwise, we lose table element data
	// in creating a new one from scratch.
	for (i=0; i < nExistingElements; i++) {
		TableElement teTmp;
		pDetail->GetTableElementByIndex(i, teTmp);
		__int64 nKey = (((__int64)teTmp.m_pRow->m_ID.nDataID) << 32) + (__int64)teTmp.m_pColumn->nID;
		mapTable[nKey] = i;		
	}

	// (j.jones 2011-05-04 14:48) - PLID 43527 - get the Sig column, if we have it
	TableColumn *ptcSig = pDetail->GetColumnByListSubType(lstCurrentMedicationSig);

	const long nColumns = pDetail->GetColumnCount();
	const long nRows = pDetail->GetRowCount();
	// Do for all columns
	for (long nCol=0; nCol < nColumns; nCol++) {
		TableColumn* ptc = pDetail->GetColumnPtr(nCol);
		long nSortOrder = -1;
		mapSortOrders.Lookup(ptc->nID, nSortOrder);

		//make sure we found a sort order, because this code assumes that it always succeeds
		ASSERT(nSortOrder != -1);

		if (1 == nSortOrder) {
			// If we get here, this is the table's checkbox column. Go through all the rows and check
			// off the ones which apply to the current data ID's 
			for (long nRow=0; nRow < nRows; nRow++) {
				TableRow* ptr = pDetail->GetRowPtr(nRow);				
				TableElement te;
				int nExistingElement = -1;
				// (z.manning 2010-02-18 10:17) - PLID 37427 - We have multiple possible ID values for rows, so make
				// sure we get a non -1 value
				__int64 nKey = (((__int64)ptr->m_ID.nDataID) << 32) + (__int64)ptc->nID;
				if (mapTable.Lookup(nKey, nExistingElement)) {
					pDetail->GetTableElementByIndex(nExistingElement, te);
				} else {
					te.m_pColumn = ptc;
					te.m_pRow = ptr;
				}
				te.m_bChecked = FALSE;
				mapCurDataIDs.Lookup(ptr->m_ID.nDataID, te.m_bChecked);
				// (a.walling 2009-03-09 09:18) - PLID 33409 - We do not need to create empty table elements.
				// This brings the performance of this function on Waldman's data from over 500ms to less than 10ms.
				// (We should update existing ones though)
				if (te.m_bChecked || (nExistingElement != -1)) {
					pDetail->SetTableElement(te, (nExistingElement == -1) ? FALSE : TRUE, FALSE);

					// (j.jones 2011-05-04 14:45) - PLID 43527 - if we are filling the checkbox (or even clearing it),
					// apply the Sig, if it was given to us (will be NULL if an allergies table) and if we actually
					// have the Sig column
					if(ptrmapCurMedDataIDsToSig != NULL && ptcSig != NULL) {

						long nDataID = te.m_pRow->m_ID.nDataID;
						CString strSig = "";
						if(ptrmapCurMedDataIDsToSig->Lookup(nDataID, strSig)) {
							//only do something if we were given a sig (it may be blank)

							TableElement teSig;
							int nExistingSigElement = -1;
							__int64 nSigKey = (((__int64)ptr->m_ID.nDataID) << 32) + (__int64)ptcSig->nID;
							if (mapTable.Lookup(nSigKey, nExistingSigElement)) {
								pDetail->GetTableElementByIndex(nExistingSigElement, teSig);
							} else {
								teSig.m_pColumn = ptcSig;
								teSig.m_pRow = ptr;
							}

							teSig.m_strValue = strSig;

							if(strSig != "" || (nExistingSigElement != -1)) {
								pDetail->SetTableElement(teSig, (nExistingSigElement == -1) ? FALSE : TRUE, FALSE);
							}						
						}
					}
				}
			}
			// Only one column can have a sort order of 1; so we may as well stop the loop now.
			break;
		} else {
			// Not the checkbox column. Skip it.
		}
	}

	// Now we're clear to recreate the state from content
	pDetail->RecreateStateFromContent();
}

//TES 6/5/2008 - PLID 29416 - Like with CurrentMedications(), renamed (and redesigned) this function to take an existing
// state, and modify just the first column based on Medications tab data.
// (j.jones 2009-09-18 13:00) - PLID 35599 - added bUpdateExisting, if TRUE it means we want to load even on details
// that have already been saved, which should be rare and only with a really good reason
void CEMN::ApplyOfficialAllergies(CEMNDetail* pDetail, 
											  long nAllergiesEmrInfoID, BOOL bUpdateExisting /*= FALSE*/,
											  OPTIONAL IN ADODB::_Connection *lpCon /*= NULL */)
{
	//
	// (c.haag 2007-04-05 11:34) - PLID 25516 - Call this function to get the
	// official allergies state for this EMN.
	//
	// We start by trying to pull it from an existing detail if one exists.
	//
	// If no detail exists, we pull it from PatientAllergyT
	//
	_ConnectionPtr pCon;
	if(lpCon) pCon = lpCon;
	else pCon = GetRemoteData();

	//
	// First, search this EMN
	//
	const int nDetailCount = GetTotalDetailCount();
	for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
		CEMNDetail* pCurrentDetail = GetDetail(nDetail);

		//TES 6/5/2008 - PLID 29416 - Don't load from the detail we've been asked to modify.
		if (pCurrentDetail == pDetail) {
			continue;
		}
		// Skip details without perfectly matching info ID's
		else if (pCurrentDetail->m_nEMRInfoID != nAllergiesEmrInfoID) {
			continue;
		}
		else if (!pCurrentDetail->IsAllergiesTable()) {
			// (c.haag 2007-01-23 11:24) - This should never happen!!!
			ASSERT(FALSE);
			continue;
		}
		// (c.haag 2007-05-17 13:14) - PLID 26051 - If the state is empty, then the
		// detail hasn't been fully loaded yet. So, skip it.
		else if (VT_EMPTY == pCurrentDetail->GetStateVarType()) {
			continue;
		}
		//TES 6/23/2008 - PLID 29416 - If this detail hasn't loaded its "official" information yet, then we don't want to 
		// copy it.
		else if (!pCurrentDetail->GetHasLoadedSystemInfo()) {
			continue;
		}

		// If we get here, we found a detail. Pull its state, and we're done
		pDetail->SetState(pCurrentDetail->GetState());
		//TES 6/23/2008 - PLID 29416 - This detail has now loaded its "official" information.
		pDetail->SetHasLoadedSystemInfo();
		return;
	}

	//
	// (c.haag 2007-04-05 11:34) - PLID 25516 - If we get here, we found no allergies details based 
	// on the active info ID. We will need to get the defaults from the patient in the form of EmrDataT
	// ID's. If this is a template, we will build a state with no allergies selected. Users are
	// not allowed to edit the default allergies state on an EMR template, so this is
	// safe to do
	// (c.haag 2009-06-04 09:47) - PLID 34256 - Factor in the discontinued flag
	//
	CArray<long,long> anAllergies;
	if (!m_bIsTemplate) {
		_RecordsetPtr prs = CreateParamRecordset(pCon, "SELECT EMRDataT.ID AS EmrDataID FROM PatientAllergyT "
			"LEFT JOIN AllergyT ON AllergyT.ID = PatientAllergyT.AllergyID "
			"LEFT JOIN EMRDataT ON AllergyT.EMRDataID = EMRDataT.ID "
			"WHERE PersonID = {INT} AND Discontinued = 0 "
			"ORDER BY EMRDataT.Data ", GetParentEMR()->GetPatientID());
		while (!prs->eof) {
			anAllergies.Add(AdoFldLong(prs, "EmrDataID"));
			prs->MoveNext();
		}
		prs->Close();
	}

	// (c.haag 2009-05-14 16:53) - PLID 34256 - All the code from here to the end of this function has
	// been placed into its own function
	// (j.jones 2009-09-18 13:07) - PLID 35599 - pass in bUpdateExisting
	ApplyOfficialAllergies(pDetail, nAllergiesEmrInfoID, anAllergies, bUpdateExisting, lpCon);
}

// (c.haag 2009-05-14 16:50) - PLID 34256 - This function takes a given official allergy detail and synchronizes the 
// "Selected column" of its state with the patient's official allergy list as specified in anAllergies.
//
// All the code in this function used to exist in the original version of ApplyOfficialAllergies; which is right
// above this function.
//
// (j.jones 2009-09-18 13:00) - PLID 35599 - added bUpdateExisting, if TRUE it means we want to load even on details
// that have already been saved, which should be rare and only with a really good reason
void CEMN::ApplyOfficialAllergies(CEMNDetail* pDetail, long nAllergiesEmrInfoID,
								  const CArray<long,long>& anAllergies, BOOL bUpdateExisting /*= FALSE*/,
								  OPTIONAL IN ADODB::_Connection *lpCon /*= NULL */)
{
	// (j.jones 2009-09-18 10:50) - PLID 35599 - we should load allergies from the patient account
	// only on new details, not existing ones (unless bUpdateExisting is TRUE, indicating we
	// absolutely are sure we want to update existing details)
	if(!bUpdateExisting && pDetail->m_nEMRDetailID != -1) {
		//assert so we find out what code called this on a non-new detail
		ASSERT(FALSE);
		return;
	}

	_ConnectionPtr pCon;
	if(lpCon) pCon = lpCon;
	else pCon = GetRemoteData();

	//TES 6/5/2008 - PLID 29416 - Make sure the detail has its rows and columns loaded.
	// (c.haag 2009-03-04 17:34) - PLID 33270 - If we must load content, and the state is empty, then we need
	// to fill it with an empty string. If the state is left empty, LoadContent will panic and think that 
	// Practice will not properly recall patient information. As a result, an assertion would be fired.
	if (pDetail->GetNeedContentReload()) {
		if (VT_EMPTY == pDetail->GetStateVarType()) {
			pDetail->SetState("");
		}
		pDetail->LoadContent(FALSE, NULL, lpCon);
	}

	//
	// Now that we have the ID's,we need to build the state
	//
	CArray<long, long> aX, aY, aYListType, aYSortOrder;
	CString strState;

	//TES 6/6/2008 - PLID 29416 - Find the first column, and go through and fill it based on anAllergies.
	GetAllergiesTableElements(aX, aY, aYListType, aYSortOrder, nAllergiesEmrInfoID, pCon);

	// (c.haag 2009-03-05 17:12) - PLID 33367 - The former code to fill in the detail state is super slow.
	// Use this function instead. It will accomplish the same thing in much less time.
	// (j.jones 2011-05-04 14:43) - PLID 43527 - the Sig map is NULL because this is not a current medications tabl
	BuildSystemTableState(aY, aYSortOrder, anAllergies, pDetail, NULL);

	//TES 6/23/2008 - PLID 29416 - This detail has now loaded its "official" information.
	pDetail->SetHasLoadedSystemInfo();
}

void CEMN::UpdateAllAllergiesListDetails(const _variant_t& varState,
										  long nAllergiesEmrInfoID,
										  CEMNDetail* pDetailToIgnore)
{
	//
	// (c.haag 2007-04-05 11:44) - PLID 25516 - This function looks for all the
	// details on an EMN based on the nAllergies info ID (these are Allergies
	// table details) and updates their state to varState. This makes it possible
	// for changes in one Allergies detail to propagate to all of the details
	//
	try {
		CWaitCursor wc;

		if (-1 == nAllergiesEmrInfoID) {
			// (c.haag 2007-04-05 11:45) - PLID 25516 - Don't do anything if we don't have
			// a valid Allergies EMR info ID
			return;
		}

		if (GetUpdatingAllergiesDetails()) {
			// (c.haag 2007-04-05 11:45) - PLID 25516 - If we get here, it means UpdateAllAllergiesListDetails
			// was already called earlier in the call stack. Therefore, we don't need to do anything.
			return;
		}

		if (IsLockedAndSaved()) {
			// (c.haag 2007-04-05 11:45) - PLID 25516 - We should never get here if the EMN is locked and
			// saved!
			ASSERT(FALSE);
			return;
		}

		// (c.haag 2007-04-05 11:45) - PLID 25516 - Flag the fact that we are processing Allergies detail replication
		SetUpdatingAllergiesDetails(TRUE);

		// Do for all details
		const int nDetailCount = GetTotalDetailCount();
		for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
			CEMNDetail* pDetail = GetDetail(nDetail);

			// Skip details that we are ignoring (usually because they are already set)
			if (pDetail == pDetailToIgnore) {
				continue;
			}
			else if (NULL == pDetail->m_pParentTopic) {
				// (c.haag 2007-05-17 13:29) - PLID 25928 - If we get here, the detail
				// has not been officially loaded yet, so ignore it for now.
				continue;
			}
			// Skip details without perfectly matching info ID's
			else if (pDetail->m_nEMRInfoID != nAllergiesEmrInfoID) {
				continue;
			}
			else if (!pDetail->IsAllergiesTable()) {
				// (c.haag 2007-01-23 11:24) - This should never happen!!!
				ASSERT(FALSE);
				continue;
			}

			//
			// (c.haag 2007-04-05 11:46) - PLID 25516 - If we get here, we found a
			// fellow Allergies detail that needs to match the state of
			// pSourceDetail. So, update the state and apperance of the detail,
			// and make sure that it's marked as unsaved.
			//
			pDetail->RequestStateChange(varState);

		} // for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {

	}
	NxCatchAll("Error in CEMN::UpdateAllAllergiesListDetails");

	// (c.haag 2007-04-05 11:45) - PLID 25516 - Whether or not we errored out, reset
	// the flag because we are done here.
	SetUpdatingAllergiesDetails(FALSE);
}

void CEMN::ProcessCurrentMedicationsChange(CEMNDetail* pSourceDetail)
{
	//
	// (c.haag 2007-01-23 11:13) - PLID 24376 - When a user changes a Current Medications
	// table, we need to retroactively update every Current Medications detail in the entire
	// EMN as well as the current medications list. This is because the Current Medications 
	// detail is one-per-EMN.
	//

	if (GetUpdatingCurrentMedicationDetails()) {
		// (c.haag 2007-02-07 17:14) -  PLID 24376 - If we get here, it means UpdateAllMedicationListDetails
		// was already called earlier in the call stack. Therefore, we don't need to do anything.
		// We call this here to save ourselves a call to GetActiveCurrentMedicationsInfoID which
		// queries the data
		return;
	}

	// (j.jones 2007-07-23 10:39) - PLID 26742 - get the active medications info ID from the EMR if we can
	long nActiveCurrentMedicationsInfoID = -1;
	if(m_pParentEMR) {
		nActiveCurrentMedicationsInfoID = m_pParentEMR->GetCurrentMedicationsInfoID();
	}
	else {
		//why don't we have an EMR?
		ASSERT(FALSE);
		//get it the traditional way
		nActiveCurrentMedicationsInfoID = GetActiveCurrentMedicationsInfoID();
	}

	// Do nothing if the source detail is not based on the official Current Medications item
	if (nActiveCurrentMedicationsInfoID != pSourceDetail->m_nEMRInfoID) {
		return;
	}

	// Update the details
	UpdateAllMedicationListDetails(pSourceDetail->GetState(),
		pSourceDetail->m_nEMRInfoID, pSourceDetail);
}

BOOL CEMN::GetUpdatingCurrentMedicationDetails() const
{
	// (c.haag 2007-01-23 11:37) - PLID 24376 - Returns TRUE if we are traversing
	// the EMR for Current Medication details and making sure all of the states are
	// the same
	return m_bUpdatingCurrentMedicationDetails;
}

void CEMN::SetUpdatingCurrentMedicationDetails(BOOL bProcessing)
{
	// (c.haag 2007-01-23 11:37) - PLID 24376 - Set to TRUE if we are traversing
	// the EMR for Current Medication details and making sure all of the states are
	// the same. Set back to FALSE when done.
	m_bUpdatingCurrentMedicationDetails = bProcessing;
}


//TES 6/5/2008 - PLID 29416 - Changed the name of this function, there is no "Official State" for medications or allergies,
// the only thing that's "official" is the first column (reason #2,982 this was a bad design).  This takes a detail whose
// state has been set, and applies the official Current Medications to the first column.
// (j.jones 2009-09-18 13:00) - PLID 35599 - added bUpdateExisting, if TRUE it means we want to load even on details
// that have already been saved, which should be rare and only with a really good reason
void CEMN::ApplyOfficialCurrentMedications(CEMNDetail* pDetail, 
											  long nCurMedEmrInfoID, BOOL bUpdateExisting /*= FALSE*/,
											  OPTIONAL IN ADODB::_Connection *lpCon /*= NULL */)
{
	//
	// (c.haag 2007-01-29 09:40) - PLID 24376 - Call this function to get the
	// official current medications state for this EMN.
	//
	// We start by trying to pull it from an existing detail if one exists.
	//
	// If no detail exists, we pull it from the CurrentPatientMedsT
	//
	_ConnectionPtr pCon;
	if(lpCon) pCon = lpCon;
	else pCon = GetRemoteData();

	//
	// First, search this EMN
	//
	const int nDetailCount = GetTotalDetailCount();
	for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
		CEMNDetail* pCurrentDetail = GetDetail(nDetail);

		//Don't load from the detail we're being asked to set.
		if (pCurrentDetail == pDetail) {
			continue;
		}
		// Skip details without perfectly matching info ID's
		else if (pCurrentDetail->m_nEMRInfoID != nCurMedEmrInfoID) {
			continue;
		}
		else if (!pCurrentDetail->IsCurrentMedicationsTable()) {
			// (c.haag 2007-01-23 11:24) - This should never happen!!!
			ASSERT(FALSE);
			continue;
		}
		// (c.haag 2007-05-17 13:14) - PLID 26051 - If the state is empty, then the
		// detail hasn't been fully loaded yet. So, skip it.
		else if (VT_EMPTY == pCurrentDetail->GetStateVarType()) {
			continue;
		}
		//TES 6/23/2008 - PLID 29416 - If the detail hasn't loaded its "official" information yet, we don't want to pull from it.
		else if(!pCurrentDetail->GetHasLoadedSystemInfo()) {
			continue;
		}

		// If we get here, we found another Current Medications detail on the EMN. Pull its state, and we're done
		pDetail->SetState(pCurrentDetail->GetState());
		//TES 6/23/2008 - PLID 29416 - This detail has now loaded its "official" information.
		pDetail->SetHasLoadedSystemInfo();
		return;
	}

	//
	// If we get here, we found no current medications details based on the active
	// info ID. We will need to get the defaults from the patient in the form of EmrDataT ID's.
	// If this is a template, we will build a state with no medications selected. Users are
	// not allowed to edit the default Current Medications state on an EMR template, so this is
	// safe to do
	//
	// (c.haag 2009-06-02 10:35) - PLID 34271 - Filter out discontinued medications
	//
	CArray<long,long> anCurMeds;
	CMap<long, long, CString, LPCTSTR> mapDataIDsToSig;

	if (!m_bIsTemplate) {
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		_RecordsetPtr prs = CreateParamRecordset(pCon, "SELECT EMRDataT.ID AS EmrDataID, CurrentPatientMedsT.Sig "
			"FROM CurrentPatientMedsT "
			"LEFT JOIN DrugList ON DrugList.ID = CurrentPatientMedsT.MedicationID "
			"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
			"WHERE PatientID = {INT} AND Discontinued = 0 "
			"ORDER BY EMRDataT.Data ", GetParentEMR()->GetPatientID());
		while (!prs->eof) {
			long nDataID = AdoFldLong(prs, "EmrDataID");
			anCurMeds.Add(nDataID);
			// (j.jones 2011-05-04 14:29) - PLID 43527 - track the Sig
			mapDataIDsToSig.SetAt(nDataID, AdoFldString(prs, "Sig", ""));
			prs->MoveNext();
		}
		prs->Close();
	}

	// (c.haag 2009-05-15 10:06) - PLID 34271 - The code from here to the end of the function has been
	// moved into its own function
	// (j.jones 2009-09-18 13:07) - PLID 35599 - pass in bUpdateExisting
	// (j.jones 2011-05-04 14:09) - PLID 43527 - added mapDataIDsToSig, which tracks the Sig for each current medication
	ApplyOfficialCurrentMedications(pDetail, nCurMedEmrInfoID, anCurMeds, mapDataIDsToSig, bUpdateExisting, lpCon);
}

// (c.haag 2009-05-15 10:02) - PLID 34271 - This function takes a given official current medications detail and synchronizes
// the "Selected column" of its state with the patient's official current medications list as specified in anCurMeds
//
// All the code in this function used to exist in the original version of ApplyOfficialAllergies; which is right
// above this function.
//
// (j.jones 2009-09-18 13:00) - PLID 35599 - added bUpdateExisting, if TRUE it means we want to load even on details
// that have already been saved, which should be rare and only with a really good reason
// (j.jones 2011-05-04 14:09) - PLID 43527 - added mapDataIDsToSig, which tracks the Sig for each current medication
void CEMN::ApplyOfficialCurrentMedications(CEMNDetail* pDetail, long nCurMedEmrInfoID,
										   const CArray<long,long>& anCurMeds,
										   CMap<long, long, CString, LPCTSTR> &mapDataIDsToSig,
										   BOOL bUpdateExisting /*= FALSE*/,
										   OPTIONAL IN ADODB::_Connection *lpCon /* = NULL */)
{
	// (j.jones 2009-09-18 10:50) - PLID 35599 - we should load current medications from the
	// patient account only on new details, not existing ones (unless bUpdateExisting is TRUE,
	// indicating we absolutely are sure we want to update existing details)
	if(!bUpdateExisting && pDetail->m_nEMRDetailID != -1) {
		//assert so we find out what code called this on a non-new detail
		ASSERT(FALSE);
		return;
	}

	_ConnectionPtr pCon;
	if(lpCon) pCon = lpCon;
	else pCon = GetRemoteData();

	//TES 6/5/2008 - PLID 29416 - Make sure the detail has its rows and columns loaded.
	// (c.haag 2009-03-04 17:34) - PLID 33270 - If we must load content, and the state is empty, then we need
	// to fill it with an empty string. If the state is left empty, LoadContent will panic and think that 
	// Practice will not properly recall patient information. As a result, an assertion would be fired.
	if (pDetail->GetNeedContentReload()) {
		if (VT_EMPTY == pDetail->GetStateVarType()) {
			pDetail->SetState("");
		}
		pDetail->LoadContent(FALSE, NULL, lpCon);
	}

	//
	// Now that we have the ID's,we need to build the state
	//
	CArray<long, long> aX, aY, aYListType, aYSortOrder;
	CString strState;


	GetCurrentMedicationTableElements(aX, aY, aYListType, aYSortOrder, nCurMedEmrInfoID, pCon);

	// (c.haag 2009-03-05 17:12) - PLID 33367 - The former code to fill in the detail state is super slow.
	// Use this function instead. It will accomplish the same thing in much less time.
	// (j.jones 2011-05-04 14:43) - PLID 43527 - pass in our Sig map
	BuildSystemTableState(aY, aYSortOrder, anCurMeds, pDetail, &mapDataIDsToSig);

	//TES 6/23/2008 - PLID 29416 - This detail has now loaded its "official" information.
	pDetail->SetHasLoadedSystemInfo();
}

void CEMN::UpdateAllMedicationListDetails(const _variant_t& varState,
										  long nCurMedEmrInfoID,
										  CEMNDetail* pDetailToIgnore)
{
	//
	// (c.haag 2007-01-29 10:23) - PLID 24376 - This function looks for all the
	// details on an EMN based on the nCurMedEmrInfoID info ID (these are Current
	// Medications table details) and updates their state to varState. This makes
	// it possible for changes in one Current Medications detail or the More Info
	// section to propagate to all of the details
	//
	try {
		CWaitCursor wc;

		if (-1 == nCurMedEmrInfoID) {
			// (c.haag 2007-01-29 11:25) - PLID 24376 - Don't do anything if we don't have
			// a valid Current Medications EMR info ID
			return;
		}

		if (GetUpdatingCurrentMedicationDetails()) {
			// (c.haag 2007-01-23 11:35) - PLID 24376 - If we get here, it means UpdateAllMedicationListDetails
			// was already called earlier in the call stack. Therefore, we don't need to do anything.
			return;
		}

		if (IsLockedAndSaved()) {
			// (c.haag 2007-01-29 09:29) - PLID 24376 - We should never get here if the EMN is locked and
			// saved!
			ASSERT(FALSE);
			return;
		}

		// (c.haag 2007-01-23 11:35) - PLID 24376 - Flag the fact that we are processing current
		// medications replication
		SetUpdatingCurrentMedicationDetails(TRUE);

		// Do for all details
		const int nDetailCount = GetTotalDetailCount();
		for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
			CEMNDetail* pDetail = GetDetail(nDetail);

			// Skip details that we are ignoring (usually because they are already set)
			if (pDetail == pDetailToIgnore) {
				continue;
			}
			else if (NULL == pDetail->m_pParentTopic) {
				// (c.haag 2007-05-17 13:29) - PLID 25928 - If we get here, the detail
				// has not been officially loaded yet, so ignore it for now.
				continue;
			}
			// Skip details without perfectly matching info ID's
			else if (pDetail->m_nEMRInfoID != nCurMedEmrInfoID) {
				continue;
			}
			else if (!pDetail->IsCurrentMedicationsTable()) {
				// (c.haag 2007-01-23 11:24) - This should never happen!!!
				ASSERT(FALSE);
				continue;
			}

			//
			// (c.haag 2007-01-23 11:24) - If we get here, we found a fellow
			// Current Medications detail that needs to match the state of
			// pSourceDetail. So, update the state and apperance of the detail,
			// and make sure that it's marked as unsaved.
			//
			pDetail->RequestStateChange(varState);

		} // for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {

	}
	NxCatchAll("Error in CEMN::UpdateAllMedicationListDetails");

	// (c.haag 2007-01-23 11:36) - PLID 24376 - Whether or not we errored out, reset
	// the flag because we are done here.
	SetUpdatingCurrentMedicationDetails(FALSE);
}

//TES 6/4/2008 - PLID 30196 - Does this EMN have anywhere on it an (undeleted) system table of the specified type?
BOOL CEMN::HasSystemTable(EmrInfoSubType eistType)
{
	//TES 6/5/2008 - PLID 30196 - Do any of our subtopics have a detail with this type?
	long nTopics = GetTopicCount();
	BOOL bHasTable = FALSE;
	long i; 
	for(i = 0; i < nTopics && !bHasTable; i++) {
		CEMRTopic* pTopic = GetTopic(i);
		if(pTopic && pTopic->HasSystemTable(eistType)) {
			bHasTable = TRUE;
		}
	}
	return bHasTable;
}

// (j.jones 2007-01-29 13:28) - PLID 24353 - allow to begin/end the StartEditingTime
void CEMN::TryStartTrackingTime()
{
	//if not tracking, set the current time, otherwise do nothing
	if(!m_bIsTemplate && !m_bIsTrackingTime) {
		m_bIsTrackingTime = TRUE;
		//get the time from the server
		_RecordsetPtr rs = CreateRecordset("SELECT GetDate() AS Date");
		if(!rs->eof) {
			m_dtStartEditingTime = AdoFldDateTime(rs, "Date");
		}
		rs->Close();
	}
}

void CEMN::TryStopTrackingTime()
{
	//if tracking, save the time, and stop tracking
	if(!m_bIsTemplate && m_bIsTrackingTime) {

		//ensure we have a valid start time
		if(m_dtStartEditingTime.GetStatus() == COleDateTime::invalid) {
			ASSERT(FALSE);
			return;
		}

		//only save the time if a change was made during this session
		if(m_bChangesMadeThisSession && m_nID != -1) {

			//save the time
			// (a.walling 2010-11-01 10:36) - PLID 40965 - Parameterize this, it is filling up the cache!
			// Should have an identity column as well, but oh well. We can combine this all into a single statement though.
			// (j.jones 2013-02-26 15:52) - PLID 55338 - finally an identity
			ExecuteCachedParamSql(
				"INSERT INTO EMRMasterSlipT (EMRID, UserID, StartTime, EndTime) "
				"VALUES ({INT}, {INT}, {OLEDATETIME}, GetDate())"
				, m_nID
				, GetCurrentUserID()
				, m_dtStartEditingTime
			);
		}
		
		//now reset our tracking variables
		m_bIsTrackingTime = FALSE;
		m_dtStartEditingTime.SetStatus(COleDateTime::invalid);
		m_bChangesMadeThisSession = FALSE;
	}
}

COleDateTime CEMN::GetStartEditingTime()
{
	return m_dtStartEditingTime;
}

// (j.jones 2007-09-17 17:49) - PLID 27396 - set the total time this EMN has been opened in previous sessions,
// not counting the current session
void CEMN::SetTotalTimeOpened_PreviousSessions(COleDateTimeSpan dtTotalTimeOpened_PreviousSessions)
{
	m_dtTotalTimeOpened_PreviousSessions = dtTotalTimeOpened_PreviousSessions;	
}

void CEMN::SetTotalTimeOpened_PreviousSessions(long nSeconds)
{
	m_dtTotalTimeOpened_PreviousSessions.SetDateTimeSpan(0, 0, 0, nSeconds);
}

// (j.jones 2007-09-17 17:49) - PLID 27396 - return the total time this EMN has been opened, in previous sessions AND this session
COleDateTimeSpan CEMN::GetTotalTimeSpanOpened()
{
	COleDateTimeSpan dtTotalTimeOpened;
	dtTotalTimeOpened.SetStatus(COleDateTimeSpan::invalid);

	//shouldn't be called on templates
	if(m_bIsTemplate) {
		ASSERT(FALSE);
		return dtTotalTimeOpened;
	}

	CEMR *pEMR = GetParentEMR();
	if(pEMR == NULL) {
		//shouldn't be possible
		ASSERT(FALSE);
		return dtTotalTimeOpened;
	}

	//we must have a valid m_dtStartEditingTime
	if(m_dtStartEditingTime.GetStatus() == COleDateTime::invalid) {
		ASSERT(FALSE);
		return dtTotalTimeOpened;
	}
	
	//we must have a valid offset
	COleDateTimeSpan dtOffset = pEMR->GetServerTimeOffset();
	if(dtOffset.GetStatus() == COleDateTimeSpan::invalid) {
		ASSERT(FALSE);
		return dtTotalTimeOpened;
	}

	//check for a valid m_dtTotalTimeOpened_PreviousSessions
	if(m_dtTotalTimeOpened_PreviousSessions.GetStatus() == COleDateTimeSpan::invalid) {
		ASSERT(FALSE);
		return dtTotalTimeOpened;
	}

	//now calculate based on the current time, the offset, and m_dtTotalTimeOpened_PreviousSessions (which may be 0)
	dtTotalTimeOpened = ((COleDateTime::GetCurrentTime() + dtOffset) - m_dtStartEditingTime) + m_dtTotalTimeOpened_PreviousSessions;

	return dtTotalTimeOpened;
}

// (j.jones 2007-03-13 17:33) - PLID 25193 - return m_bInitialLoadPendingCompletion
BOOL CEMN::GetIsInitialLoadPendingCompletion()
{
	return m_bInitialLoadPendingCompletion;	
}

// (z.manning 2008-12-12 14:18) - PLID 32427 - This will tell us if we need to call PostInitalLoad
// because it's pending and both spawning and handling detail changes is unlocked.
BOOL CEMN::NeedToCallPostInitialLoad()
{
	return (GetIsInitialLoadPendingCompletion() && GetParentEMR()->IsSpawningUnlocked() && m_nDetailChangeLocks <= 0);
}

// (j.jones 2007-03-13 17:36) - PLID 25193 - called when the initial load has truly completed
// (c.haag 2007-04-18 08:10) - The initial load is also flagged as complete in CEMN::SetLoaded
// fix that; there should only be one place where m_bInitialLoadComplete is set to TRUE, and this is it.
void CEMN::PostInitialLoad()
{
	m_bInitialLoadComplete = TRUE;
	m_bInitialLoadPendingCompletion = FALSE;

	//We're done!  There are two more things to do: update all the narratives, and update the merge conflicts.
	//TES 7/22/2011 - PLID 44665 - Tell the function that this is the initial loading of the EMN.
	LoadAllNarratives(TRUE);
	UpdateAllMergeConflicts();
	// (c.haag 2007-02-27 11:24) - PLID 24949 - Apply EMR links here.
	//TES 8/8/2011 - PLID 44927 - Don't apply EMR links if we're just loading an existing EMN!
	if (!m_bIsTemplate && m_nID == -1) {
		GetParentEMR()->LockSpawning();
		CArray<CEMNDetail*,CEMNDetail*> aDetails;
		GenerateTotalEMNDetailArray(&aDetails);
		const int nSize = aDetails.GetSize();
		for (int i=0; i < nSize; i++) {
			GetParentEMR()->ApplyEmrLinks(aDetails[i]);
		}
		GetParentEMR()->UnlockSpawning();
	}

	// (z.manning 2009-06-22 11:18) - PLID 34286 - Now go through all the topics and reposition
	// details on them as needed.
	// Note: this logic was moved here from CEMRTopic::PostLoad to ensure that narratives have
	// been loaded (which we just did above) before calling this to ensure they always load
	// correctly.
	CArray<CEMRTopic*,CEMRTopic*> arypTopics;
	GetAllTopics(arypTopics);
	for(int nTopicIndex = 0; nTopicIndex < arypTopics.GetSize(); nTopicIndex++)
	{
		CEMRTopic *pTopic = arypTopics.GetAt(nTopicIndex);
		// (c.haag 2007-05-08 10:54) - PLID 25928 - If we had the need to reposition details during
		// the load, but had to wait for the load to finish, then reposition the details now.
		// (a.walling 2012-06-22 14:01) - PLID 51150 - Explicitly get the topic wnd
		if (pTopic->GetNeedsToRepositionDetailsInPostLoad() && pTopic->GetTopicWnd()) {
			pTopic->SetNeedsToRepositionDetailsInPostLoad(FALSE);
			// (j.jones 2007-07-26 09:31) - PLID 24686 - renamed this function
			pTopic->GetTopicWnd()->RepositionDetailsInTopicByInfoID(-1, FALSE);
		}
	}

	//TES 5/3/2010 - PLID 24692 - Now that the loading is completely done, make sure that all the topics know their last saved order;
	// if they calculated this during loading it could potentially have been incorrect, since it's a linked list so the order is dependent
	// on the order of all the other topics.
	if(m_pTopicPositionHead) {
		m_pTopicPositionHead->SetLastSavedOrderIndex(true);
	}

	// (c.haag 2007-08-13 11:21) - PLID 27049 - By this point in time, tables may have linked detail
	// columns with out-of-date dropdowns and missing linked details. We need to repopualte the dropdowns
	// and restore all possible linked details.
	// (c.haag 2007-08-18 11:18) - PLID 27049 - Do it for both patient charts and templates, regardless of
	// whether we are using an EMN loader
	UpdateTableItemList(); // Invalidate the master linked table column combo SQL
	const int nDetails = GetTotalDetailCount();
	for (int i=0; i < nDetails; i++) {
		CEMNDetail* p = GetDetail(i);
		if (eitTable == p->m_EMRInfoType) {
			// Update the table dropdown
			p->UpdateTable(NULL, FALSE);
			// Now check for any linked details that it tried to assign itself before those
			// details were actually spawned or loaded into the EMN.
			BOOL bWasModified = p->IsModified();
			if (p->TryRecoverMissingLinkedDetails()) {
				// If we get here, it means this table did have linked details assigned to it which
				// did not exist before the table was loaded. TryRecoverMissingLinkedDetails fixed it
				// so that those linked details are assigned. Now we have to recreate the state and
				// content to reflect those changes.
				p->RecreateStateFromContent();
				p->SetNeedContentReload();
				p->SetNeedSyncContentAndState();
				p->LoadContent();
				if (bWasModified) {
					p->SetUnsaved();
				} else {
					p->SetSaved();
				}
			}
		}
	}

	// (d.lange 2011-03-24 10:33) - PLID 42987 - Let's try to autofill the Assistant/Tech field with the current user
	// only if they are flagged as one
	// (d.lange 2011-04-29 14:46) - PLID 43380 - Moved this higher in the function so m_aryTechnicians would get updated appropriately before
	// GenerateHTMLFile() is called
	if(!IsLockedAndSaved() && !m_bIsTemplate && IsWritable() && IsCurrentUserTechnician()) {
		long nAutoFillTech = GetRemotePropertyInt("EmrTechnicianAutofillBehavior", 0, 0, "<None>", true);
		if(nAutoFillTech == 1) {
			SetCurrentUserTechnicianID();
		}
	}

	// (a.walling 2007-04-05 16:44) - PLID 25454
	// (a.walling 2007-10-15 14:16) - PLID 25548 - If we don't have an interfacewnd, there is no real point
	// in generating the HTML file.
	if (GetInterface()) {
		if (GetID() == -1) {
			// this is a new EMN. We want to generate the HTML and reload, but not copy anything to documents.
			
			GenerateHTMLFile(TRUE, FALSE);
		} else if (!IsPreviewCurrent()) {
			// (a.walling 2008-08-12 11:33) - PLID 31037 - If we have a current preview, don't bother doing this.
			// it will be handled when the active selection changes.

			// this is an existing EMN, so we should have already tried to load the HTML file.
			// this should only be necessary if we are the currently displayed EMN.
			CEmrTreeWnd* pTreeWnd = GetInterface();
			if (pTreeWnd->GetCurrentEMN() == this) {
				// (a.walling 2012-03-12 12:43) - PLID 48712 - We always reload when opening now, basically
				GenerateHTMLFile(TRUE, FALSE); // remake the file, load it in the preview
			}
		}
	}

	// (c.haag 2007-05-07 16:35) - Moved to after the HTML generation so that GenerateHTMLFile can indirectly
	// use the preloaded information in the CEMN loader object
	// (c.haag 2007-03-16 11:02) - PLID 25239 - Do a final release of the preloaded detail array. By now,
	// all of the details have been assigned to the EMN, and only those that will actually show up or reflect
	// on narratives or other details should have their states loaded.
	// (c.haag 2007-05-02 09:04) - PLID 26463 - We used to assert that the reference count would always be one
	// here. However, if an EMN with no interface window is loaded, things are different. The loader object itself
	// will be in the call stack, and we don't want to delete it here. To ensure that the loader object is not
	// deleted here, the EMN added an extra reference to the loader. We will proceed to release the loader object
	// as usual, but the EMN object is responsible for deleting it.
	// (c.haag 2007-08-04 09:34) - PLID 26945 - If the reference count is one, do special handling with it
	// (internal error checking, etc), and then ensure it's deleted.
	if (NULL != m_pLoader) {
		// (a.walling 2014-07-23 16:25) - PLID 63029 - LoadContent before retiring the loader so it does not go to waste.
		// last chance to load content before retiring the EMN loader...
		{
			const int nDetails = GetTotalDetailCount();
			for (int i = 0; i < nDetails; i++) {
				CEMNDetail* p = GetDetail(i);
				if (!p) {
					continue;
				}
				if (!p->GetNeedContentReload() || p->GetIsForcedReload()) {
					continue;
				}
				if (!p->IsAvailableInLoaderSpawner(m_pLoader)) {
					continue;
				}
				p->LoadContent(FALSE, m_pLoader);
			}
		}
		if (1 == m_pLoader->GetRefCnt()) {
			RetireInitialLoader();
		} else {
			m_pLoader->Release();
		}
	}

	// (j.jones 2006-10-13 09:31) - PLID 22461 - we warn the user beforehand now, so we don't need to tell
	// them again after it has changed
	//TES 6/15/2006 - Also, if loading the EMN updated office visits, we haven't warned the user yet, so do so.
	//CheckWarnOfficeVisitChanged();

	// (a.walling 2010-04-02 11:56) - PLID 37923 - Notify the EMR
	GetParentEMR()->PostInitialEMNLoadComplete(this);
}

// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code

// (a.walling 2007-06-11 15:44) - PLID 26278 - Moved to the preview ctrl
// void CEMN::EnsureCSSFile() {}

// (a.walling 2007-04-05 16:36) - PLID 25454 - Return an HTML string of the entire EMN
//(e.lally 2009-10-05) PLID 32503 - Added parameter to override the hidden demographics to display when printing/faxing.
// (a.walling 2013-03-13 08:40) - PLID 55632 - Ignore unsaved is no longer applicable
CString CEMN::GenerateHTMLString(BOOL bIgnoreUnsaved_Unused, BOOL bOverrideHiddenDemographics)
{
	try {
		CString strHTML;
		CString str;
		// (a.walling 2007-06-11 15:38) - PLID 26278 - No need to use relative references now, these will all be in the same path.
		CString strCSSPath = "emr.css";
		CString strCSSUserPath = "user.css";

		// (a.walling 2007-12-21 09:44) - PLID 28436 - Cosmetic changes to EMR.CSS - Explicitly define our doctype, MotW follows
		// immediately. We are using HTML 4.0 Strict
		// (a.walling 2014-05-02 16:57) - PLID 62001 - Now using HTML5
		CString strMarkOfTheWeb =  
			"<!doctype html>"
			"<!-- saved from url=(0022)http://www.nextech.com -->\r\n"; // oddly enough, this is needed to place our content
		// in the internet zone as defined by www.nextech.com, so www.nextech.com needs to be in the trusted zone to run script. This should work
		// by default (local machine files have all script disabled by default)

		// use both "..\\emr.css" and "emr.css"; last one takes precedence.
		// no need for relative links now, just use emr.css
		// let us store the emr.css file within the webarchive, but still link to a live version of user.css
		// CDO will ignore any external links within single quotes ('), so user.css goes there.

		// (a.walling 2007-10-12 13:45) - PLID 25605 - Use a function with exception handling for the image width expression
		// I am very pleased with myself for this one. Of course, we wouldn't need this if IE actually supported the CSS2 max-width standard.
		// Perhaps IE8 will, in 2012.
		// (a.walling 2008-07-01 15:36) - PLID 30586 - Another function to work around this. Also, IE8 in just a few months.
		// So I was 4 years off ;)
			// (a.walling 2010-03-26 12:44) - PLID 29099 - Set of functions to delay the showing and hiding of the interactive narrative text.
		// (a.walling 2010-03-31 08:58) - PLID 29099 - Using noscreen / noprint to avoid additional styles attached to hidescreen / hideprint
		// (a.walling 2014-05-02 16:57) - PLID 62001 - SafeBodyWidth removed entirely
		// (a.walling 2015-02-11 10:40) - PLID 64840 - Hyperlinks inside narratives no longer work in the preview pane. Use querySelector rather than .children.item
		// the latter only supports indexed/numerical access.
			CString strScript = R"(
<script type='text/javascript'>

var narrativeShowTimers = new Array();
var narrativeHideTimers = new Array();

function ShowNarrativeLinks(obj) {
    try {
        window.event.cancelBubble = true;
        var narrative = obj;
        if (narrative && narrative.id) {
            if (narrativeHideTimers[narrative.id]) {
                clearTimeout(narrativeHideTimers[narrative.id]);
                narrativeHideTimers[narrative.id] = null;
            }
        }
        if (narrative && narrative.children) {
            var childItem = narrative.querySelector('#textActive');
            if (childItem && childItem.className == 'noscreen noprint' && !narrativeShowTimers[narrative.id]) {
                narrativeShowTimers[narrative.id] = setTimeout(function() {
                    showNarrativeLinks(narrative)
                }, 200);
            }
        }
    } catch (err) {}
}

function showNarrativeLinks(obj) {
    try {
        var narrative = obj;
        if (narrative && narrative.id) {
            clearTimeout(narrativeShowTimers[narrative.id]);
            narrativeShowTimers[narrative.id] = null;
            if (narrative.children) {
                var childItemStatic = narrative.querySelector('#textStatic');
                var childItemActive = narrative.querySelector('#textActive');
                if (childItemStatic) {
                    childItemStatic.className = 'noscreen';
                }
                if (childItemActive) {
                    childItemActive.className = 'noprint';
                }
            }
        }
    } catch (err) {}
}

function HideNarrativeLinks(obj) {
    try {
        window.event.cancelBubble = true;
        var narrative = obj;
        if (narrative && narrative.id) {
            if (narrativeShowTimers[narrative.id]) {
                clearTimeout(narrativeShowTimers[narrative.id]);
                narrativeShowTimers[narrative.id] = null;
            }
            var childItemStatic = narrative.querySelector('#textStatic');
            if (childItemStatic && childItemStatic.className == 'noscreen' && !narrativeHideTimers[narrative.id]) {
                narrativeHideTimers[narrative.id] = setTimeout(function() {
                    hideNarrativeLinks(narrative)
                }, 200);
            }
        }
    } catch (err) {}
}

function hideNarrativeLinks(obj) {
    try {
        var narrative = obj;
        if (narrative && narrative.id) {
            clearTimeout(narrativeHideTimers[narrative.id]);
            narrativeHideTimers[narrative.id] = null;
            if (narrative.children) {
                var childItemStatic = narrative.querySelector('#textStatic');
                var childItemActive = narrative.querySelector('#textActive');
                if (childItemStatic) {
                    childItemStatic.className = '';
                }
                if (childItemActive) {
                    childItemActive.className = 'noscreen noprint';
                }
            }
        }
    } catch (err) {}
}
</script>)";
		// (a.walling 2013-08-21 13:28) - PLID 58049 - Remove nasty IE6 workarounds
		
		// (a.walling 2008-09-18 16:10) - PLID 31430 - Set a title which includes the patient name and birthdate
		CString strPageTitle;
		strPageTitle.Format("%s %s %s (%s)", GetPatientNameFirst(), GetPatientNameMiddle(), GetPatientNameLast(), (GetParentEMR() != NULL && GetParentEMR()->GetPatientBirthDate().GetStatus() == COleDateTime::valid) ? FormatDateTimeForInterface(GetParentEMR()->GetPatientBirthDate(), NULL, dtoDate) : "Unknown Birthdate");
		strPageTitle.Replace("  ", " ");

		//(e.lally 2009-10-05) PLID 32503 - Added an option to force the patient demographics to show when printing/faxing.
		//This can become a separate .css file if we end up collecting several that need to be stored in a new file
		CString strOverrides = "";
		if(bOverrideHiddenDemographics){
			strOverrides = "\r\n<style>"
				//Ensure that we are showing the patient demographics content
				"@media print {"
					".demographicscontent {"
						"display: block !important;"
					"} "
				"}"
				"</style>\r\n";
		}

		// (a.walling 2009-07-15 11:19) - PLID 34892 - Include cache control directives in preview pane HTML header
		// (a.walling 2013-01-24 15:15) - PLID 54835 - Emr preview pane should explicitly set a charset - using Windows-1252
		// (a.walling 2014-05-02 16:57) - PLID 62001 - Force IE8 compatibility mode
		str.Format("%s\r\n<html>"
			"<head>"
			"<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\"/>"
			"<meta http-equiv=\"pragma\" content=\"no-cache\"/>"
			"<meta http-equiv=\"expires\" content=\"-1\"/>"
			"<meta http-equiv=\"content-type\" content=\"text/html\" charset=\"Windows-1252\"/>"
			"<title>%s</title>"
			"<link rel=stylesheet type='text/css' href=\"%s\"/>"
			"<link rel=stylesheet type='text/css' href='%s'/>"
			"%s%s"
			"</head>"
			"<body>"
			"<div id='EMN' class='EMN'>\r\n",
			strMarkOfTheWeb, ConvertToHTMLEmbeddable(strPageTitle), strCSSPath, strCSSUserPath, strOverrides, strScript);

		strHTML += str;

		// (a.walling 2007-07-12 15:49) - PLID 26640 - Generate the header
		// (a.walling 2007-10-15 16:36) - PLID 27664 - Send the bIgnoreUnsaved flag
		strHTML += GenerateHeaderHTML();
		
		// the description is usually filled. Use <no description> if not.
		// (a.walling 2013-05-01 11:35) - PLID 55632 - No more last saved stuff in html generation
		//TES 1/17/2014 - PLID 32434 - If this template isn't set up to show the description, then don't show it here.
		if(!GetHideTitleOnPreview()) {
			CString strDescription = GetDescription();

			if (strDescription.IsEmpty()) {
				strDescription = "<No EMN Description>";
			}

			str.Format("<h1>%s</h1>", ConvertToHTMLEmbeddable(strDescription));
			strHTML += str;
		}

		// (a.walling 2007-04-03 08:45) - PLID 25454 - Sort the topics
		// (a.walling 2007-09-27 15:58) - PLID 25549 - It turns out the topic array
		// is already sorted, unlike the detail array of course. Awesome!
		// CArray<CEMRTopic*, CEMRTopic*> arSortedTopics;
		// GetSortedTopicArray(arSortedTopics);

		// (a.walling 2009-07-06 10:33) - PLID 34793
		CArray<CEMRTopic*, CEMRTopic*> arTopicsColumnOne;
		CArray<CEMRTopic*, CEMRTopic*> arTopicsColumnTwo;

		// (a.walling 2009-07-06 12:46) - PLID 34793 - Since this is the very root, we do not support the previewflags on the EMN
		// therefore it will always be group-adjacent behaviour here.

		for (int ixTopic = 0; ixTopic < m_arypEMRTopics.GetSize(); ixTopic++) {
			CEMRTopic* pTopic = m_arypEMRTopics.GetAt(ixTopic);

			if (pTopic) {
				if (pTopic->GetPreviewFlags() & epfColumnOne) {
					arTopicsColumnOne.Add(pTopic);
				} else if (pTopic->GetPreviewFlags() & epfColumnTwo) {
					arTopicsColumnTwo.Add(pTopic);
				} else {
					// (a.walling 2009-07-06 10:35) - PLID 34793 - If any topics in columns, flush them out.
					if (!arTopicsColumnOne.IsEmpty() && !arTopicsColumnTwo.IsEmpty()) {
						strHTML += "<table class='columntable'><tbody><tr>";

						{
							strHTML += "<td>";
							for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnOne.GetSize(); ixTopicColumnIndex++) {
								strHTML += arTopicsColumnOne[ixTopicColumnIndex]->GetHTML();
							}
							strHTML += "</td>";
						}
						
						{
							strHTML += "<td>";
							for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnTwo.GetSize(); ixTopicColumnIndex++) {
								strHTML += arTopicsColumnTwo[ixTopicColumnIndex]->GetHTML();
							}
							strHTML += "</td>";
						}
						
						strHTML += "</tr></tbody></table>";

						arTopicsColumnOne.RemoveAll();
						arTopicsColumnTwo.RemoveAll();
					} else if (!arTopicsColumnOne.IsEmpty()) {
						for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnOne.GetSize(); ixTopicColumnIndex++) {
							strHTML += arTopicsColumnOne[ixTopicColumnIndex]->GetHTML();
						}

						arTopicsColumnOne.RemoveAll();
					} else if (!arTopicsColumnTwo.IsEmpty()) {
						for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnTwo.GetSize(); ixTopicColumnIndex++) {
							strHTML += arTopicsColumnTwo[ixTopicColumnIndex]->GetHTML();
						}

						arTopicsColumnTwo.RemoveAll();
					}
					strHTML += pTopic->GetHTML();
				}
			}
		}		
		
		// (a.walling 2009-07-06 10:35) - PLID 34793 - If any topics in columns, flush them out.
		if (!arTopicsColumnOne.IsEmpty() && !arTopicsColumnTwo.IsEmpty()) {
			strHTML += "<table class='columntable'><tbody><tr>";
			
			{
				strHTML += "<td>";
				for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnOne.GetSize(); ixTopicColumnIndex++) {
					strHTML += arTopicsColumnOne[ixTopicColumnIndex]->GetHTML();
				}
				strHTML += "</td>";
			}
			
			{
				strHTML += "<td>";
				for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnTwo.GetSize(); ixTopicColumnIndex++) {
					strHTML += arTopicsColumnTwo[ixTopicColumnIndex]->GetHTML();
				}
				strHTML += "</td>";
			}
			
			strHTML += "</tr></tbody></table>";

			arTopicsColumnOne.RemoveAll();
			arTopicsColumnTwo.RemoveAll();
		} else if (!arTopicsColumnOne.IsEmpty()) {
			for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnOne.GetSize(); ixTopicColumnIndex++) {
				strHTML += arTopicsColumnOne[ixTopicColumnIndex]->GetHTML();
			}
			
			arTopicsColumnOne.RemoveAll();
		} else if (!arTopicsColumnTwo.IsEmpty()) {
			for (int ixTopicColumnIndex = 0; ixTopicColumnIndex <arTopicsColumnTwo.GetSize(); ixTopicColumnIndex++) {
				strHTML += arTopicsColumnTwo[ixTopicColumnIndex]->GetHTML();
			}

			arTopicsColumnTwo.RemoveAll();
		}

		// (a.walling 2007-07-11 16:56) - PLID 26640 - Return HTML for More Info
		// (a.walling 2007-10-15 16:36) - PLID 27664 - Send the bIgnoreUnsaved flag
		strHTML += GenerateMoreInfoHTML();

		// (b.savon 2012-05-24 11:08) - PLID 48092 - Add the Meds and Allergies
		strHTML += GenerateMedAllergyHTML();

		strHTML += "</div></body></html>";
		return strHTML;
	} NxCatchAll("Error generating HTML output!");

	return "";
}


// (a.walling 2007-04-09 12:47) - PLID 25549
// I am extremely uncomfortable referring to details and topics by pointers via HTML, but for unsaved objects, I have no choice. However, rather than blindly cast them to a memory location like our LinkedDetail implementation, I'll scan through our arrays of details until a pointer matches. That way I am not reinterpreting garbage memory as a corrupt CEMRDetail, and can return NULL if needed.
CEMRTopic* CEMN::GetTopicByPointer(long nTopicPtr)
{
	try {
		// search recursively through topics and subtopics
		for (int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
			long nCurrentTopicPtr = reinterpret_cast<long>(m_arypEMRTopics[i]);

			if (nCurrentTopicPtr == nTopicPtr) {
				return m_arypEMRTopics[i];
			} else {
				// this was not the topic, so search for subtopics
				CEMRTopic* pCurrentTopic = m_arypEMRTopics[i];
				if (pCurrentTopic) {
					CEMRTopic* pFoundTopic = pCurrentTopic->GetSubTopicByPointer(nTopicPtr);

					if (pFoundTopic)
						return pFoundTopic;
				}
			}
		}
	}NxCatchAll("Error in GetTopicByPointer");
	return NULL;
}

// (a.walling 2007-04-09 12:47) - PLID 25549 - Returns the CEMNDetail that matches the pointer.
CEMNDetail* CEMN::GetDetailByPointer(long nDetailPtr)
{
	try {
		for (int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
			CEMNDetail* pFoundDetail = NULL;

			CEMRTopic* pCurrentTopic = m_arypEMRTopics[i];
			if (pCurrentTopic) {
				pFoundDetail = pCurrentTopic->GetDetailByPointer(nDetailPtr);

				if (pFoundDetail)
					return pFoundDetail;
			}
		}
	}NxCatchAll("Error in GetDetailByPointer");
	return NULL;
}

// (a.walling 2012-10-04 12:41) - PLID 52878 - Verify that the given emr object pointer is a child

CEMRTopic* CEMN::VerifyPointer(CEMRTopic* pTopic)
{
	foreach (CEMRTopic* p, m_arypEMRTopics) {
		if (p == pTopic) {
			return pTopic;
		}
		if (p && p->VerifyPointer(pTopic)) {
			return pTopic;
		}
	}
	return NULL;
}

CEMNDetail* CEMN::VerifyPointer(CEMNDetail* pDetail)
{
	foreach (CEMRTopic* p, m_arypEMRTopics) {
		if (p && p->VerifyPointer(pDetail)) {
			return pDetail;
		}
	}
	return NULL;
}

namespace
{
	void CreateMHTDocument(CString strFileIn, CString strFileOut, SYSTEMTIME stModifiedDate, BOOL bEncrypt, BOOL bFailIfExists)
	{
		CNxPerform nxp(__FUNCTION__);

		NxCDO::CreateMHTFromFile(strFileIn, strFileOut, stModifiedDate, bEncrypt, bFailIfExists);
	}

	static long nUniqueEmrPreviewNum = 0;

	// (a.walling 2013-09-05 11:24) - PLID 58369 - Always returns a new, unique file name for temp html file
	HANDLE CreateEmrPreviewTempFile(const CString& strSuffix, OUT CString* pFilePath)
	{
		long nUnique = InterlockedIncrement(&nUniqueEmrPreviewNum);

		CString strFileName;
		strFileName.Format("nexemrt_EMN_%s_%lu.html", strSuffix, nUnique);

		CString strFilePath = GetNxTempPath() / strFileName;

		Nx::Handle hFile(::CreateFile(strFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL));
		if (!hFile) {
			DWORD error = ::GetLastError();
			CString strError;
			FormatError(strError, error, "Error writing EMR preview temp file %s", strFilePath);
			ThrowNxException("%s", strError);
		}

		if (pFilePath) {
			*pFilePath = strFilePath;
		}

		return hFile.Detach();
	}
}

// (a.walling 2007-04-10 16:28) - PLID 25454
//(e.lally 2009-10-05) PLID 32503 - Added parameter to override the hidden demographics to display when printing/faxing.
// (a.walling 2010-01-13 12:55) - PLID 36840 - Added parameter to prevent overwriting an existing file
// (a.walling 2013-09-05 11:24) - PLID 58369 - Returns path to newly-generated html file
CString CEMN::GenerateHTMLFile(BOOL bSendMessage /*= TRUE*/, BOOL bCopyToDocuments /*= TRUE*/, BOOL bIgnoreUnsaved_Unused /*= FALSE*/, BOOL bOverrideHiddenDemographics /*=FALSE*/, BOOL bFailIfExists /*= FALSE*/)
{
	CString strEMRPreviewTempFile;

	BOOL bIsPreviewCurrentOriginal = m_bIsPreviewCurrent;
	// (a.walling 2008-08-12 11:01) - PLID 31037 - We have a current preview in the temp folder, so set the flag
	// we will reset this if we have an exception anywhere
	// (a.walling 2008-08-12 13:57) - PLID 31037 - Set this flag regardless of whether we are sending messages or not
	m_bIsPreviewCurrent = TRUE;
	try {
		if (!IsTemplate()) {
			CEMR* pEMR = GetParentEMR();
			if (pEMR) {

				DWORD dwStart = GetTickCount();
				//(e.lally 2009-10-05) PLID 32503 - pass in parameter to override the hidden demographics
				CString strHTML = GenerateHTMLString(FALSE, bOverrideHiddenDemographics);
				//LogDetail("HTML (%li b) generated in %li ms", strHTML.GetLength(), GetTickCount() - dwStart);

				if (strHTML.GetLength() == 0) {
					// this is an error state.
					strHTML = "<body><p>Error generating HTML output.</p></body>";
					bCopyToDocuments = FALSE;
				}

				// (a.walling 2007-08-08 16:42) - PLID 27017 - This way a preview can be updated for a locked EMN even though
				// they can't save (where it is copied to documents normally), and can be updated for an EMN that has had no
				// unsaved changes without have to make a change to force a copy and refresh.
				if ( (IsLockedAndSaved() || !IsUnsaved()) && (GetID() != -1) ) {
					bCopyToDocuments = TRUE;
				}

				// (a.walling 2009-11-23 11:42) - PLID 24194 - Use a unique temp file so mulitple temp files can co-exist for multiple EMN printing
				CString strPrefix;
				if (GetID() != -1) {
					strPrefix.Format("ID%li", GetID());
				} else {
					strPrefix.Format("PT%lu", this);
				}
			
				// (a.walling 2013-03-14 08:51) - PLID 55640 - Already a cdo thread in progress? wait for it to complete before writing to underlying html file			
				WaitForCDOThread();

				// (a.walling 2013-09-05 11:24) - PLID 58369 - Always returns a new, unique file name for temp html file. The underlying file handle has a tendency
				// to get locked by the MSHTML browser, or antivirus, or even CDO's components oddly. Since the HTML file itself is rather
				// small, this is not really a big deal.
				Nx::Handle hFile(CreateEmrPreviewTempFile(strPrefix, &strEMRPreviewTempFile));

				m_arTempPreviewFiles.Add(strEMRPreviewTempFile);
	
				DWORD dwWritten = 0;
				::WriteFile(hFile, (LPCTSTR)strHTML, strHTML.GetLength(), &dwWritten, NULL);

				hFile.Close();

				CString strFile;
				strFile.Format("EMN_%li.mht", GetID());
				// (a.walling 2007-06-11 13:06) - PLID 26278 - Keep EMN previews in their own directory
				CString strDocPath = GetSharedPath() ^ "EMNPreview\\";

				// (a.walling 2012-03-12 12:43) - PLID 48712 - Copy to documents if it does not already exist there...

				if (GetID() != -1) {
					if (!bCopyToDocuments) {
						if (INVALID_FILE_ATTRIBUTES == ::GetFileAttributes(strDocPath ^ strFile)) {
							bCopyToDocuments = TRUE;
						}
					}
				} else {
					bCopyToDocuments = FALSE;
				}

				if (bCopyToDocuments) {
					ASSERT(GetID() != -1);

					//BOOL bCopy = FALSE;

					//CString strDocPath = GetPatientDocumentPath(pEMR->GetPatientID()) ^ "EMNPreview\\";

					// (a.walling 2010-01-13 12:56) - PLID 36840 - Send the bFailIfExists param
					// (a.walling 2013-03-14 08:51) - PLID 55640 - Create the MHT document in a thread; CDO is notoriously slow, taking between 1 and 3 seconds sometimes
					m_cdoThread = NxThread(boost::bind(&CreateMHTDocument, strEMRPreviewTempFile, strDocPath ^ strFile, AsSystemTime(m_dtEMNModifiedDate), TRUE, bFailIfExists));
					//NxCDO::CreateMHTFromFile(m_strEMRPreviewTempFile, strDocPath ^ strFile, AsSystemTime(m_dtEMNModifiedDate), TRUE, bFailIfExists);
				}

				if(bSendMessage && GetInterface()) {
					// (a.walling 2012-03-12 12:43) - PLID 48712 - Pass an LPCSTR, not a CString*
					LRESULT lrVal = GetInterface()->SendMessage(NXM_EMN_PREVIEW_LOAD, (WPARAM)this, (LPARAM)(LPCTSTR)strEMRPreviewTempFile);
				}
			}
		}

		return strEMRPreviewTempFile;
	} NxCatchAll("Error generating HTML File!");

	// (a.walling 2008-08-12 11:16) - PLID 31037 - Restore this value if we failed.
	m_bIsPreviewCurrent = bIsPreviewCurrentOriginal;

	return strEMRPreviewTempFile;
}

// (a.walling 2012-03-12 12:43) - PLID 48712 - No MHT HTMLPreviewTempFile anymore basically
//CString CEMN::GetHTMLPreviewTempFile()
//{
//	return m_strEMRPreviewTempFile;
//}
//
//void CEMN::SetHTMLPreviewTempFile(CString &str)
//{
//	m_strEMRPreviewTempFile = str;
//}

// (a.walling 2007-08-22 14:50) - PLID 27160 - handle multiple items that are popped up
void CEMN::AddPoppedUpDetail(CEMNDetail *pDetail)
{
	// (a.walling 2009-10-13 13:57) - PLID 36024
	pDetail->__AddRef("CEMN::AddPoppedUpDetail");
	m_lstPoppedUpDetails.AddHead(pDetail);
}

// (a.walling 2007-08-22 14:50) - PLID 27160 - handle multiple items that are popped up
void CEMN::RemovePoppedUpDetail(CEMNDetail *pDetail)
{
	POSITION pos = m_lstPoppedUpDetails.Find(pDetail);
	if (pos) {	
		// (a.walling 2009-10-13 13:57) - PLID 36024	
		pDetail->__Release("CEMN::RemovePoppedUpDetail");
		m_lstPoppedUpDetails.RemoveAt(pos);
	}
}

// (a.walling 2007-04-12 12:21) - PLID 25605 - Add a reference to the temp image file
void CEMN::AddTempImageFileReference(CString str)
{
	try {
		if (str == "<Missing Image>")
			return;

		BOOL bAdd = TRUE;

		// don't add duplicates
		for (int i = 0; i < m_arTempPreviewFiles.GetSize(); i++) {
			if (m_arTempPreviewFiles[i].CompareNoCase(str) == 0) {
				bAdd = FALSE;
				break;
			}
		}

		if (bAdd)
			m_arTempPreviewFiles.Add(str);


		// (a.walling 2007-06-11 12:37) - PLID 26263 - We don't need to move anything now, it's all compiled
		// in the MHT.

		/*
		// check for the 'nxt_' prefix which means the detail is unsaved and has no ID yet.
		// we do not want to copy these to documents.
		CString strFilename = FileUtils::GetFileName(str);
		if (strFilename.Left(4).CompareNoCase("nxt_") != 0) {
			bAdd = TRUE;

			for (i = 0; i < m_arTempImageFilesPendingMove.GetSize(); i++) {
				if (m_arTempImageFilesPendingMove[i].CompareNoCase(str) == 0) {
					bAdd = FALSE;
					break;
				}
			}
			if (bAdd)
				m_arTempImageFilesPendingMove.Add(str);
		}
		*/

	} NxCatchAll("Error adding temp image file reference!");
}

void CEMN::SetNeedToSavePreview(BOOL bSet /*= TRUE*/)
{
	m_bNeedToSavePreview = bSet;
}

BOOL CEMN::GetNeedToSavePreview()
{
	return m_bNeedToSavePreview;
}

// (a.walling 2007-04-25 12:38) - PLID 25549 - Fill array with sorted topics
// (a.walling 2007-10-18 15:35) - PLID 25549 - No longer necessary
/*
void CEMN::GetSortedTopicArray(CArray<CEMRTopic*, CEMRTopic*> &arTopics)
{
	try {
		arTopics.Copy(m_arypEMRTopics);
		SortTopicArray(arTopics);
	} NxCatchAll("Could not get top-level sorted topic array");
}
*/

// (j.jones 2007-06-14 11:58) - PLID 26276 - calculate the completion status from the loaded topics
EMNCompletionStatus CEMN::CalculateCompletionStatus()
{			
	//for every topic on this EMN, find out if the topic's details
	//are all empty, all set, or partially set
	int nEmptyCount = 0;
	int nNonEmptyCount = 0;
	int nCompletedCount = 0;

	CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
	GetAllTopics(arAllTopics);

	for (long i=0; i<arAllTopics.GetSize(); i++) {
		CEMRTopic *pTopic = arAllTopics.GetAt(i);
		// (j.jones 2007-06-14 15:04) - PLID 26276 - pass in TRUE for bCompleteIfNoDetails,
		// so that if the topic has no details, it doesn't count as an unfilled detail
		EmrTopicCompletionStatus etcsStatus = pTopic->GetCompletionStatus();
		if(etcsStatus == etcsIncomplete || etcsStatus == etcsInvalid) {
			//this topic is empty
			nEmptyCount++;
		}
		else if(etcsStatus == etcsComplete) {
			//this topic is complete
			nCompletedCount++;
		}
		else if(etcsStatus == etcsReconstructed) {
			//that's all we need, leave now
			return ecsReconstructed;
		} 
		else if(etcsStatus == etcsPartiallyComplete) {
			//this topic is non-empty
			nNonEmptyCount++;
		}
		else if (etcsStatus == etcsRequired) {
			// (b.cardillo 2012-03-08 11:40) - PLID 42207 - Required details
			// If any topic has required details that haven't been filled, then the whole EMN is in that state
			return ecsRequired;
		}
		else {
			// (z.manning, 04/07/2008) - PLID 29495 - The only other status we have is blank.
			ASSERT(etcsStatus == etcsBlank);
		}
	}

	if(nCompletedCount > 0 && nEmptyCount == 0 && nNonEmptyCount == 0) {
		return ecsComplete;
	}
	// (z.manning, 04/01/2008) - PLID 29495 - If we have at least one completed or partially completed
	// topic then this EMN is considered partially complete.
	else if(nNonEmptyCount > 0 || nCompletedCount > 0) {
		return ecsPartiallyComplete;
	}
	else {
		return ecsEmpty;
	}
}

// (a.walling 2007-07-11 16:56) - PLID 26640 - Return HTML for More Info
// (a.walling 2013-03-13 08:40) - PLID 55632 - Ignore unsaved is no longer applicable
CString CEMN::GenerateMoreInfoHTML()
{
	CString strHTML;

	// (d.lange 2011-04-27 17:18) - PLID 43380 - Changed 127 to 255
	long nOptions = GetRemotePropertyInt("EMRPreviewMoreInfoFields", 255, 0, "<None>", true);
	long nHideOptions = GetRemotePropertyInt("EMRPreview_HideDetails", g_dhPreviewDisplayHideDefaults, 0, "<None>", true);
	// (j.jones 2012-02-20 10:25) - PLID 47886 - optionally hide unbillable CPT codes
	BOOL bHideUnbillableCPTCodes = (GetRemotePropertyInt("EMN_HideUnbillableCPTCodes", 0, 0, GetCurrentUserName(), true) == 1);

	// (a.walling 2010-11-11 15:47) - PLID 40848 - Format the section according to the appropriate options, as a topic or not
	struct MoreInfoFormatter
	{
		MoreInfoFormatter(long nOptions, long nHideOptions)
			: m_nOptions(nOptions)
			, m_nHideOptions(nHideOptions)
		{};

		long m_nOptions;
		long m_nHideOptions;

		LPCTSTR GetSectionTitle(long nSection)
		{
			switch (nSection & mipValidFields) {
				case mipNotes:
					return "Notes";
				case mipProcedures:
					return "Procedures";
				// (b.eyers 2016-02-23) - PLID 68322
				case mipASCTimes:
					return "Admission/Discharge Times";
				case mipASCStatus:
					return "Discharge Status";
				case mipProviders:
					return "Providers";
				case mipSecondaryProviders:
					return "Secondary Providers";
				// (d.lange 2011-04-25 16:34) - PLID 43380
				case mipTechnicians:
					return "Assistant/Technicians";
				case mipDiagCodes:
					return "Diagnosis Codes";
				case mipCharges:
					return "Charges";
				case mipMedications:
					return "Prescriptions Given";
				default:
					ASSERT(FALSE);
					return "Unknown";
			}
		}

		CString operator()(long nSection, const CString& strContent) {
			if (!(m_nOptions & nSection & mipValidFields)) {
				return "";
			}
			if (m_nOptions & mipDisplayAsTopics) {
				CString strClass;
				if (strContent.IsEmpty()) {
					if (m_nOptions & mipShowEmpty) {
						if (m_nHideOptions & dhEmptyTopics)
							strClass += " hidescreen";
						if (m_nHideOptions & dhEmptyTopicsPrint)
							strClass += " hideprint";
					} else {
						return "";
					}
				}

				return FormatString(
					"<div class='topic%s'>\r\n"
					"<span><h2><a href='nexemr://moreinfo?1'>%s</a></h2></span>\r\n"
					"<div class='detail'>\r\n"
					"<div class='content'>\r\n"
					"%s\r\n"
					"</div>\r\n"
					"</div>\r\n"
					"</div>\r\n"
					, strClass
					, GetSectionTitle(nSection)
					, strContent
				);
			} else {
				if (strContent.IsEmpty()) {
					return "";
				}
				return FormatString(
					"<h3>%s</h3>\r\n"
					"%s\r\n"
					, GetSectionTitle(nSection)
					, strContent
				);
			}
		};
	};
	MoreInfoFormatter formatter(nOptions, nHideOptions);

	// (a.walling 2010-11-11 15:47) - PLID 40848 - Generate the strContent string and pass to the formatter
	CString strContent;
	
	// Notes

	strContent.Empty();
	if ((nOptions & mipNotes) && m_strNotes.GetLength()) {
		strContent += "<div class='notes'>";
		strContent += ConvertToHTMLEmbeddable(m_strNotes);
		strContent += "</div>";
	}
	strHTML += formatter(mipNotes, strContent);

	// Procedures

	CStringSortedArrayNoCase arSorted;

	strContent.Empty();
	if ((nOptions & mipProcedures) && m_aryProcedures.GetSize()) {
		strContent += "<ul>";
		arSorted.RemoveAll();

		for (int i = 0; i < m_aryProcedures.GetSize(); i++) {
			// is the name stored?
			EMNProcedure* pProc = m_aryProcedures.GetAt(i);
			if (pProc->strName.IsEmpty()) {
				// (a.walling 2007-10-15 14:17) - PLID 25548 - Ask the interface to update our procedure name
				if(GetInterface()) {
					GetInterface()->SendMessage(NXM_UPDATE_NAME_EMNPROCEDURE, (WPARAM)pProc, (LPARAM)this);
				}
			}
			_ASSERTE(pProc->strName.GetLength() > 0);

			arSorted.Insert(ConvertToHTMLEmbeddable(pProc->strName));
		}

		for (int j = 0; j < arSorted.GetSize(); j++) {
			strContent += FormatString("<li>%s</li>", arSorted[j]);
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipProcedures, strContent);

	// (b.eyers 2016-02-23) - PLID 68322
	//asc time fields
	strContent.Empty();
	if (nOptions & mipASCTimes && (m_dtAdmissionTime.GetStatus() == COleDateTime::valid || m_dtDischargeTime.GetStatus() == COleDateTime::valid)) {
		strContent += "<ul>";
		//admission time
		if (m_dtAdmissionTime.GetStatus() == COleDateTime::valid) {
			strContent += FormatString("<li>Admission Time: %s</li>\r\n", ConvertToHTMLEmbeddable(ConvertToQuotableWordCSVString(FormatDateTimeForInterface(m_dtAdmissionTime, DTF_STRIP_SECONDS, dtoTime))));
		}

		//discharge time
		if (m_dtDischargeTime.GetStatus() == COleDateTime::valid) {
			strContent += FormatString("<li>Discharge Time: %s</li>\r\n", ConvertToHTMLEmbeddable(ConvertToQuotableWordCSVString(FormatDateTimeForInterface(m_dtDischargeTime, DTF_STRIP_SECONDS, dtoTime))));
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipASCTimes, strContent);

	// (b.eyers 2016-02-23) - PLID 68322
	//asc discharge status
	strContent.Empty();
	if (nOptions & mipASCStatus && m_DischargeStatus.nID != -1) {
		//discharge status
		strContent += FormatString("<ul><li>%s - %s</li></ul>\r\n", ConvertToHTMLEmbeddable(m_DischargeStatus.strCode), ConvertToHTMLEmbeddable(m_DischargeStatus.strDesc));
	}
	strHTML += formatter(mipASCStatus, strContent);


	// Primary Providers

	strContent.Empty();
	if ((nOptions & mipProviders) && m_aryProviders.GetSize()) {
		strContent += "<ul>";
		arSorted.RemoveAll();
		for(int i = 0; i < m_aryProviders.GetSize(); i++) {
			arSorted.Insert(ConvertToHTMLEmbeddable(m_aryProviders[i]->strName));
		}
		for(int j = 0; j < arSorted.GetSize(); j++) {
			strContent += "<li>" + arSorted[j] + "</li>";
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipProviders, strContent);

	// Secondary Providers

	strContent.Empty();
	if ((nOptions & mipSecondaryProviders) && m_arySecondaryProviders.GetSize()) {
		strContent += "<ul>";
		arSorted.RemoveAll();
		for(int i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
			arSorted.Insert(ConvertToHTMLEmbeddable(m_arySecondaryProviders[i]->strName));
		}
		for(int j = 0; j < arSorted.GetSize(); j++) {
			strContent += "<li>" + arSorted[j] + "</li>";
		}


		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipSecondaryProviders, strContent);

	// Assistant/Technicians
	// (d.lange 2011-04-25 16:35) - PLID 43380 - Added Assistant/Technician
	strContent.Empty();
	if ((nOptions & mipTechnicians) && m_aryTechnicians.GetSize()) {
		strContent += "<ul>";
		arSorted.RemoveAll();
		for(int i = 0; i < m_aryTechnicians.GetSize(); i++) {
			arSorted.Insert(ConvertToHTMLEmbeddable(m_aryTechnicians[i]->strName));
		}
		for(int j = 0; j < arSorted.GetSize(); j++) {
			strContent += "<li>" + arSorted[j] + "</li>";
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipTechnicians, strContent);

	// Diag Codes

 	strContent.Empty();
	if ((nOptions & mipDiagCodes) && m_aryDiagCodes.GetSize()) {
		strContent += "<ul>";
		// (a.walling 2007-09-26 11:55) - PLID 25548 - Sort the diag codes based on their nOrderIndex
		CArray<EMNDiagCode*, EMNDiagCode*> arySortedDiagCodes;
		arySortedDiagCodes.Copy(m_aryDiagCodes);
		SortDiagCodeArray(arySortedDiagCodes);

		for(int i = 0; i < arySortedDiagCodes.GetSize(); i++) {
			const EMNDiagCode* pDiag = arySortedDiagCodes.GetAt(i);

			// (r.farnworth 2014-02-27 10:25) - PLID 60785 - UPDATE - Add preview pane functionality for icd-10 diag code logic
			//If both codes are present
			if (pDiag->strCode != "" && pDiag->strCode_ICD10 != "")
			{
				strContent += "<li>" + ConvertToHTMLEmbeddable(pDiag->strCode_ICD10) + " - " + ConvertToHTMLEmbeddable(pDiag->strCodeDesc_ICD10) + 
					" (" + ConvertToHTMLEmbeddable(pDiag->strCode) + ")</li>";
			}
			//If only ICD9 is present
			else if (pDiag->strCode != "")
			{
				strContent += "<li>" + ConvertToHTMLEmbeddable(pDiag->strCode) + " - " + ConvertToHTMLEmbeddable(pDiag->strCodeDesc) + "</li>";
			}
			//If only ICD10 is present
			else if (pDiag->strCode_ICD10 != "")
			{
				strContent += "<li>" + ConvertToHTMLEmbeddable(pDiag->strCode_ICD10) + " - " + ConvertToHTMLEmbeddable(pDiag->strCodeDesc_ICD10) + "</li>";
			}
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipDiagCodes, strContent);

	// Service Codes

	strContent.Empty();
	if ((nOptions & mipCharges) && m_aryCharges.GetSize()) {
		// (a.walling 2007-09-27 15:58) - PLID 25548 - Updated to say Charge instead of Service Code
		strContent += "<ul>";
		// (a.walling 2007-09-28 18:07) - PLID 25548 - Don't sort charges
		for(int i = 0; i < m_aryCharges.GetSize(); i++) {

			const EMNCharge *ecCharge = m_aryCharges.GetAt(i);

			// (j.jones 2012-02-20 10:26) - PLID 47886 - skip this charge if unbillable, per the preference
			if(bHideUnbillableCPTCodes && !ecCharge->bBillable) {
				continue;
			}

			CString strLine;

			//remember we could be outputting products with no CPT Code
			strLine = Trim(ecCharge->strCode);
			
			// (a.walling 2010-08-31 18:50) - PLID 34334 - Include modifiers and subcode
			CString strSubCode = Trim(ecCharge->strSubCode);
			if (!strSubCode.IsEmpty() && strSubCode != "0") { // Need to ignore 0s since lots of offices have 0 as a subcode, and they will almost definitely not want them here.
				if (!strLine.IsEmpty()) {
					strLine += "-";
				}
				strLine += strSubCode;
			}

			{
				CString strMods = " (";
				if (!Trim(ecCharge->strMod1).IsEmpty()) {
					strMods += Trim(ecCharge->strMod1);
					strMods += ", ";
				}
				if (!Trim(ecCharge->strMod2).IsEmpty()) {
					strMods += Trim(ecCharge->strMod2);
					strMods += ", ";
				}
				if (!Trim(ecCharge->strMod3).IsEmpty()) {
					strMods += Trim(ecCharge->strMod3);
					strMods += ", ";
				}
				if (!Trim(ecCharge->strMod4).IsEmpty()) {
					strMods += Trim(ecCharge->strMod4);
					strMods += ", ";
				}

				strMods.TrimRight(", ");
				strMods.TrimRight("(");
				strMods.TrimRight();

				if (!strMods.IsEmpty()) {
					strMods += ")";

					strLine += strMods;
				}
			}

			// (a.walling 2007-09-28 17:40) - PLID 25548 - Include quantity
			if (ecCharge->dblQuantity > 1) {
				strLine += FormatString(" (qty:%g)", ecCharge->dblQuantity);
			}

			// (a.walling 2010-08-31 18:50) - PLID 34334 - Also trim and check the description
			if (!Trim(ecCharge->strDescription).IsEmpty()) {
				if(!strLine.IsEmpty())
					strLine += " - ";

				strLine += Trim(ecCharge->strDescription);
			}
			
			strContent += "<li>" + ConvertToHTMLEmbeddable(strLine) + "</li>";
		}
		
		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipCharges, strContent);

	// Medications

	strContent.Empty();
	// (j.jones 2010-10-15 13:18) - PLID 40851 - renamed "Medications" to "Prescriptions Given"
	if ((nOptions & mipMedications) && m_aryMedications.GetSize()) {
		strContent += "<ul>";
		// (a.walling 2007-09-28 18:07) - PLID 25548 - Don't sort meds
		for(int i = 0; i < m_aryMedications.GetSize(); i++) {
			const EMNMedication* pMed = m_aryMedications.GetAt(i);

			CString strLine;

			CString strPatientExplanation = pMed->strPatientExplanation;
			strPatientExplanation.Remove('\r');
			strPatientExplanation.Replace("\n", " / ");

			strLine = ConvertToHTMLEmbeddable(pMed->m_strDrugName);
			strLine += " - ";
			strLine += ConvertToHTMLEmbeddable(pMed->strQuantity) + " " + ConvertToHTMLEmbeddable(pMed->strUnit) + " (" + ConvertToHTMLEmbeddable(pMed->strRefillsAllowed) + " refills)";
			if (!strPatientExplanation.IsEmpty()) {
				strLine += " - " + ConvertToHTMLEmbeddable(strPatientExplanation);
			}

			strContent += "<li>" + strLine + "</li>";
		}

		strContent += "</ul>\r\n";
	}
	strHTML += formatter(mipMedications, strContent);

	// (a.walling 2007-12-18 09:13) - PLID 28391 - Hide moreinfo if empty and that is our desired effect
	
	// (a.walling 2010-11-11 15:47) - PLID 40848 - When displaying as topics, the output must be somewhat different
	CString strFull;
	if (nOptions & mipDisplayAsTopics) {
		strFull.Format("<div id='moreinfo'>\r\n%s\r\n</div>", strHTML);
	} else {
		CString strClass;

		if (strHTML.GetLength()) {
			strHTML = "<div class='content'>" + strHTML + "</div>";
		} else {
			if (nHideOptions & dhEmptyTopics)
				strClass += " hidescreen";
			if (nHideOptions & dhEmptyTopicsPrint)
				strClass += " hideprint";
		}

		strFull.Format("<div class='moreinfo%s' id='moreinfo'><h2><a href='nexemr://moreinfo?1'>&lt;More Info&gt;</a></h2>\r\n%s\r\n</div>", strClass, strHTML);
	}

	// (a.walling 2007-10-15 16:31) - PLID 27664 - Store our last saved HTML
	// (a.walling 2013-05-01 10:33) - PLID 55632 - Removed all the last saved html (m_strLastSavedMoreInfoHTML, m_strLastSavedHeaderHTML)

	return strFull;
}

// (b.savon 2012-05-23 17:13) - PLID 48092 - Generate and return the Meds and Allergies HTML for the Preview Pane
CString CEMN::GenerateMedAllergyHTML()
{
	CString strMedications = "";
	CString strAllergies = "";
	CString strContent = "";

	try{

		long nOptions = GetRemotePropertyInt("EMRPreview_MedAllergy", 5, 0, "<None>", true);

		// (j.jones 2013-06-05 14:37) - PLID 57049 - if we aren't showing meds or allergies, don't bother
		// running the recordsets
		bool bShowMedicationsInPreview = (nOptions & maoDisplayMedications) > 0;
		bool bShowAllergiesInPreview = (nOptions & maoDisplayAllergies) > 0;
		if(!bShowMedicationsInPreview && !bShowAllergiesInPreview) {
			return "";
		}

		long nPatientID = GetParentEMR()->GetPatientID();

		// Get all the Meds and Allergies.  The Meds are flagged with a 1 and the Allergies with a 2 so that we can simply run through 1 recordset
		// and place the meds/allergies in their specified lists
		// (j.jones 2013-06-05 14:12) - PLID 57049 - load the HasNoMeds, HasNoAllergies flags, in the event that the patient
		// has no current meds or allergies
		// (j.jones 2013-08-12 15:52) - PLID 57977 - Used snapshot isolation here.
		_RecordsetPtr prs = CreateParamRecordset(GetRemoteDataSnapshot(),
			"SELECT HasNoMeds, HasNoAllergies FROM PatientsT WHERE PersonID = {INT} \r\n"
			"SELECT	1 AS MedAllergyFlag, Data AS MedAllergy, Convert(nvarchar(4000), CurrentPatientMedsQ.Sig) AS Extra, Discontinued, DiscontinuedDate, GETDATE() AS EnteredDateForAllergyBlahOtherwise \r\n"
			"FROM	(SELECT * FROM CurrentPatientMedsT WHERE PatientID = {INT}) CurrentPatientMedsQ  \r\n"
			"		INNER JOIN DrugList on DrugList.ID = CurrentPatientMedsQ.MedicationID  \r\n"
			"		INNER JOIN EmrDataT ON EmrDataT.ID = DrugList.EmrDataID  \r\n"
			"UNION \r\n"
			"SELECT  2 AS MedAllergyFlag, Data AS MedAllergy, Description AS Extra, Discontinued, DiscontinuedDate, EnteredDate AS EnteredDateForAllergyBlahOtherwise \r\n"
			"FROM	(SELECT * FROM PatientAllergyT WHERE PersonID = {INT}) PatientAllergyQ  \r\n"
			"		INNER JOIN AllergyT ON PatientAllergyQ.AllergyID = AllergyT.ID  \r\n"
			"		INNER JOIN EmrDataT ON AllergyT.EmrDataID = EmrDataT.ID  \r\n", nPatientID, nPatientID, nPatientID);

		BOOL bHasNoMeds = FALSE;
		BOOL bHasNoAllergies = FALSE;
		if(!prs->eof) {
			bHasNoMeds = AdoFldBool(prs->Fields, "HasNoMeds", FALSE);
			bHasNoAllergies = AdoFldBool(prs->Fields, "HasNoAllergies", FALSE);
		}

		prs = prs->NextRecordset(NULL);

		// If we have a recordset, run through and concatenate the details
		while( !prs->eof ){
			long nMedAllergyFlag = AdoFldLong(prs->Fields, "MedAllergyFlag", -1);

			CString strMedAllergy = AdoFldString(prs->Fields, "MedAllergy", "");
			CString strExtra = AdoFldString(prs->Fields, "Extra", "");
			BOOL bDiscontinued = AdoFldBool(prs->Fields, "Discontinued", FALSE);
			COleDateTime dtDiscontinuedDate = AdoFldDateTime(prs->Fields, "DiscontinuedDate", COleDateTime(0, 0, 0, 0, 0, 0));
			
			// Route them in the correct place
			switch( nMedAllergyFlag ){
				case 1: // Medication
					{
						// If Discontinued (in data) and our settings tell us to display it, do it.
						if( bDiscontinued && (nOptions & maoDiscontinuedMeds) ){
							if( dtDiscontinuedDate.GetStatus() == COleDateTime::valid ){ 
								strMedications += "<li>" + ConvertToHTMLEmbeddable(strMedAllergy) + ((strExtra != "") ? "   -   Sig: " + ConvertToHTMLEmbeddable(strExtra) : "") + "   -   Discontinued on " + FormatDateTimeForInterface(dtDiscontinuedDate, NULL) + "</li>\n";
							}else{
								strMedications += "<li>" + ConvertToHTMLEmbeddable(strMedAllergy) + ((strExtra != "") ? "   -   Sig: " + ConvertToHTMLEmbeddable(strExtra) : "") + "   -   Discontinued</li>\n";
							}
						}else if( !bDiscontinued ){ //We always want to display active meds
							strMedications += "<li>" + ConvertToHTMLEmbeddable(strMedAllergy) + ((strExtra != "") ? "   -   Sig: " + ConvertToHTMLEmbeddable(strExtra) : "") + "</li>\n";
						}
					}
					break;
				case 2: // Allergy
					{
						COleDateTime dtDateEntered = AdoFldDateTime(prs->Fields, "EnteredDateForAllergyBlahOtherwise", COleDateTime(0, 0, 0, 0, 0, 0));
						if( dtDateEntered.GetStatus() == COleDateTime::valid ){
							strAllergies += "<li>" + ConvertToHTMLEmbeddable(strMedAllergy) + "   -   Date Entered: " + FormatDateTimeForInterface(dtDateEntered, NULL) + ((strExtra != "") ? "   -   Notes: " + ConvertToHTMLEmbeddable(strExtra) : "") + "</li>\n";
						}else{
							strAllergies += "<li>" + ConvertToHTMLEmbeddable(strMedAllergy) + ((strExtra != "") ? "   -   Notes: " + ConvertToHTMLEmbeddable(strExtra) : "") + "</li>\n";
						}
					}
					break;
				default:
					{
						// We shouldn't get here
						ASSERT(FALSE);
					}
					break;
			}

			prs->MoveNext();
		}

		// If we want to display meds, do it
		if (bShowMedicationsInPreview) {
			// (j.jones 2013-06-05 14:16) - PLID 57049 - if there are no medications, but
			// 'Has No Meds' is checked, say so
			if(strMedications.GetLength() == 0 && bHasNoMeds) {
				strMedications += "<li>" + ConvertToHTMLEmbeddable("No Current Medications") + "</li>\n";
			}
			if(strMedications.GetLength() > 0) {
				strContent += "<h3>Medications</h3>\r\n";
				strContent += "<div class='medications'>";
				strContent += "<ul>";
				strContent += strMedications;
				strContent += "</ul>";
				strContent += "</div>\r\n";
			}
		}

		// Likewise
		if (bShowAllergiesInPreview) {
			// (j.jones 2013-06-05 14:16) - PLID 57049 - if there are no allergies, but
			// 'Has No Allergies' is checked, say so
			if(strAllergies.GetLength() == 0 && bHasNoAllergies) {
				strAllergies += "<li>" + ConvertToHTMLEmbeddable("No Known Allergies") + "</li>\n";
			}
			if(strAllergies.GetLength() > 0) {
				strContent += "<h3>Allergies</h3>\r\n";
				strContent += "<div class='allergies'>";
				strContent += "<ul>";
				strContent += strAllergies;
				strContent += "</ul>";
				strContent += "</div>\r\n";
			}
		}

	}NxCatchAll(__FUNCTION__);

	// Return our formatted HTML
	return strContent;
}

// (a.walling 2007-07-11 16:56) - PLID 26640 - Return HTML for header info (patient demographics + location)
// (a.walling 2013-03-13 08:40) - PLID 55632 - Ignore unsaved is no longer applicable
CString CEMN::GenerateHeaderHTML()
{
	// (a.walling 2007-10-02 12:06) - PLID 26640 - I did not put whitespace between the first and middle name!
	CString strDemo = GetPatientNameFirst() + " " + GetPatientNameMiddle();
	strDemo.TrimRight();
	strDemo += " " + GetPatientNameLast();

	// (z.manning 2010-01-14 09:27) - PLID 22672 - Patient age is now a string
	if (!GetPatientAge().IsEmpty()) {
		strDemo += ", " + GetPatientAge();
	}

	CString strGender;
	switch(GetPatientGender()) {
	case 1:
		strGender = "M";
		break;
	case 2:
		strGender = "F";
		break;
	}

	if (strGender.GetLength()) {
		strDemo += ", " + strGender;
	}

	// (a.walling 2008-07-01 15:24) - PLID 30586 - Include the location's logo if available
	// this will be superseded eventually by further developments in EMR Preview customization.
	long nOptions = GetRemotePropertyInt("EMRPreviewIncludeLocationLogo", TRUE, 0, "<None>", true);
	CString strLogo;
	CString strSecondaryLogo;
	CString strLogoPath = GetLocationImagePath() ^ m_Location.strLogo;
	if (!m_Location.strLogo.IsEmpty() && nOptions != 0) {
		// (a.walling 2007-10-12 13:45) - PLID 25605 - Use a function with exception handling for the image width expression
		// (a.walling 2014-05-02 16:57) - PLID 62001 - Now handle by max-width, huzzah
		// (a.walling 2014-07-10 09:50) - PLID 62823 - Use a max-width of 256px as before; ensure centered as well.
		strLogo.Format("<span class='hideprint'><img src=\"%s\" style='display: block; margin-left: auto; margin-right: auto; border-style:none; width:100%%; max-width:256px;'/><br/></span>", strLogoPath);
		
		// (a.walling 2010-10-29 10:33) - PLID 31435 - Logo width
		// (a.walling 2014-07-10 09:50) - PLID 62823 - Ensure the logo width percentage is used here!
		strSecondaryLogo.Format("<div id='printlogo' style='width:100%%; text-align:center;' class='hidescreen'><img src=\"%s\" style='display: block; margin-left: auto; margin-right: auto; border-style:none; width:%lu%%;'/></div>"
			, strLogoPath
			, m_Location.nLogoWidth
		);
	}

	// (a.walling 2008-11-21 10:40) - PLID 32120 - the logo for printing needs to be outside of the demographics span
	// (a.walling 2008-12-16 12:37) - PLID 32120 - well this turns out to have a problem. when we refresh the demographics due to a change in moreinfo,
	// it replaces the demographics span, but since the logo was outside of that it ended up duplicating the logo.
	// (a.walling 2008-08-01 12:50) - PLID 30586 - Put the logo above the demographics section so it can be the full width of the body

	// (a.walling 2009-09-24 10:22) - PLID 35652 - Pad the header date text so it is not obscured by the preview toggle button.
	// I am having this always pad for consistency. It looks fine even if the button is hidden.
	CString strPadding;
	//if (GetRemotePropertyInt("EmrShowTogglePreviewButton", 1, 0, GetCurrentUserName())) {
		strPadding.Format("; padding-left:%lipx", gc_nTogglePreviewBtnWidth);
	//}
	CString strFull;	
	strFull.Format(
		"<span class='demographics' ID='demographics'><span class='demographicscontent' ID='demographicscontent'><table><tr><td style='text-align:left; vertical-align:top%s'>"
		"%s"
		"</td><td style='text-align:center;'>&nbsp;</td><td style='text-align:right; vertical-align:top;'>"
		"%s"
		"</td></tr><tr><td colspan='3' style='text-align:center;'>%s<strong>"
		"%s"
		"</strong></td></tr></table></span>%s</span>",
		strPadding,
		ConvertToHTMLEmbeddable(FormatDateTimeForInterface(GetEMNDate(), NULL, dtoDate)),
		ConvertToHTMLEmbeddable(strDemo),
		strLogo,
		ConvertToHTMLEmbeddable(m_Location.strName),
		strSecondaryLogo);

	// (a.walling 2007-10-15 16:31) - PLID 27664 - Store our last saved HTML
	// (a.walling 2013-05-01 10:33) - PLID 55632 - Removed all the last saved html (m_strLastSavedMoreInfoHTML, m_strLastSavedHeaderHTML)

	return strFull;
}

void CEMN::EnsureCompletelyLoaded()
{
	EMRLOGINDENT(1,"CEMN::EnsureCompletelyLoaded called for EMN \"%s\" (ID=%d TemplateID=%d)", m_strDescription, m_nID, m_nTemplateID); // (c.haag 2010-05-19 9:04) - PLID 38759

	//DRT 8/3/2007 - PLID 26914
	//Per c.haag, calling GetAllTopics() forces the EMN to finish loading.  This function will
	//	do just that.  It's designed to just be a "clearer" way of waiting than for some random
	//	function to call GetAllTopics then ignore the results.
	// (c.haag 2007-08-20 17:15) - If spawning operations are locked, then this will only finish
	// non-spawning-related loading.


	// (c.haag 2007-08-13 13:01) - PLID 25239 - Force all the topics to finish loading if an initial
	// load which involves the preloader is in progress
	if (IsLoading() && NULL != m_pLoader && m_pLoader->IsManagingEMNDetailArray()) {
		CArray<CEMRTopic*,CEMRTopic*> arAllTopics;
		GetAllTopics(arAllTopics);
		// (a.walling 2013-03-20 16:09) - PLID 55790 - No more loading behavior
		for (int i=0; i < arAllTopics.GetSize(); i++) {
			arAllTopics[i]->ForceLoadToFinish();
		}
		// (c.haag 2007-08-13 13:02) - PLID 25239 - Now that all the topics are done loading,
		// we no longer rely on the source loader as the iterator for all EMN details
		// (c.haag 2007-08-16 15:58) - Check if m_pLoader is NULL. If it is, that means the user
		// manually induced a spawning action while the initial load was in progress, and the 
		// initial load finished.
		if (NULL != m_pLoader) {
			m_pLoader->SetManagingEMNDetailArray(FALSE);	
		}
	}
	// (c.haag 2007-08-20 17:13) - PLID 25239 - Don's code will handle all other possible cases
	// that we don't anticipate
	else {
		CArray<CEMRTopic*, CEMRTopic*> aryAllTopics;
		GetAllTopics(aryAllTopics);
	}

	EMRLOGINDENT(-1,"CEMN::EnsureCompletelyLoaded END"); // (c.haag 2010-05-19 9:04) - PLID 38759
}

// (a.walling 2007-07-27 10:41) - PLID 23714
// (j.jones 2008-07-23 10:20) - PLID 30819 - changed to reference the diag code ID
//TES 2/26/2014 - PLID 60807 - Added ICD10
EMNDiagCode* CEMN::GetDiagCodeByDiagID(long nICD9DiagCodeID, long nICD10DiagCodeID)
{
	//TES 2/28/2014 - PLID 61080 - Moved code to GetDiagCodeIndexByDiagID
	long nIndex = GetDiagCodeIndexByDiagID(nICD9DiagCodeID, nICD10DiagCodeID);
	if(nIndex != -1) {
		return m_aryDiagCodes[nIndex];
	}
	else {
		return NULL;
	}
}

//TES 2/28/2014 - PLID 61080 - Returns the index in m_aryDiagCodes, or -1
long CEMN::GetDiagCodeIndexByDiagID(long nICD9DiagCodeID, long nICD10DiagCodeID)
{
	for (int i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode* pDiag = m_aryDiagCodes[i];
		if (pDiag) {
			if (pDiag->nDiagCodeID == nICD9DiagCodeID && pDiag->nDiagCodeID_ICD10 == nICD10DiagCodeID)
				return i;
		}
	}

	return -1;
}
//TES 2/26/2014 - PLID 60807 - A single ID might have multiple codes associated now, so this outputs an array
void CEMN::GetDiagCodesByDiagID(long nDiagCodeID, OUT CArray<EMNDiagCode*,EMNDiagCode*> &arCodes)
{
	for (int i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode* pDiag = m_aryDiagCodes[i];
		if (pDiag) {
			if (pDiag->nDiagCodeID == nDiagCodeID || pDiag->nDiagCodeID_ICD10 == nDiagCodeID) {
				arCodes.Add(pDiag);
			}
		}
	}
}

// (a.walling 2007-08-06 10:57) - PLID 23714
EMNProcedure* CEMN::GetProcedureByID(long nID)
{
	for (int i = 0; i < m_aryProcedures.GetSize(); i++) {
		EMNProcedure* pProc = m_aryProcedures[i];
		if (pProc) {
			if (pProc->nID == nID)
				return pProc;
		}
	}

	return NULL;
}

// (a.walling 2007-08-06 10:57) - PLID 23714
EMNProvider* CEMN::GetProviderByID(long nID)
{
	for (int i = 0; i < m_aryProviders.GetSize(); i++) {
		EMNProvider* pProv = m_aryProviders[i];
		if (pProv) {
			if (pProv->nID == nID)
				return pProv;
		}
	}

	return NULL;
}

// (a.walling 2007-08-06 10:57) - PLID 23714
EMNProvider* CEMN::GetSecondaryProviderByID(long nID)
{
	for (int i = 0; i < m_arySecondaryProviders.GetSize(); i++) {
		EMNProvider* pProv = m_arySecondaryProviders[i];
		if (pProv) {
			if (pProv->nID == nID)
				return pProv;
		}
	}

	return NULL;
}

// (a.walling 2007-08-06 11:25) - PLID 23714
EMNCharge* CEMN::GetChargeByServiceID(long nServiceID)
{
	for (int i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge* pCharge = m_aryCharges[i];

		if (pCharge->nServiceID == nServiceID)
			return pCharge;
	}

	return NULL;
}

//TES 1/16/2008 - PLID 24157 - CEMR calls this from its ProcessEmrActionsComplete() function, so we can pop up our details.
void CEMN::ProcessEmrActionsComplete()
{
	//TES 1/11/2008 - PLID 24157 - Do we have any details to popup?
	if(m_pMultiPopupDlg) {
		//TES 1/11/2008 - PLID 24157 - We do, have we already popped them up?
		if(!m_pMultiPopupDlg->GetSafeHwnd()) {
			//TES 1/23/2008 - PLID 24157 - Moved the popup code into its own function.
			PopupMultiPopupDlg();

			//TES 1/11/2008 - PLID 24157 - We're done with this dialog now, clean it up until the next time
			// things get spawned.
			delete m_pMultiPopupDlg;
			m_pMultiPopupDlg = NULL;
		}
	}
}

//TES 1/9/2008 - PLID 24157 - Adds a detail to the list that needs to be popped up, or to the already popped-up dialog.
void CEMN::AddDetailToPopup(CEMNDetail *pDetail, CEMNDetail *pSourceDetail)
{
	//TES 1/11/2008 - PLID 24157 - If we haven't already created our popup dialog, create it.
	if(!m_pMultiPopupDlg) {
		m_pMultiPopupDlg = new CEMRItemAdvMultiPopupDlg(GetInterface());

		//TES 1/28/2008 - PLID 28673 - We need to tell it where it's being spawned from, so that later we can
		// go back and tie that spawning thing to the popped up info.
		m_pMultiPopupDlg->m_pSourceDetail = pSourceDetail;
		if(pSourceDetail && (pSourceDetail->m_EMRInfoType == eitMultiList || pSourceDetail->m_EMRInfoType == eitSingleList) ) {
			//TES 1/31/2008 - PLID 28673 - We also need to store the ID of the item that spawned it, as well as the
			// DataGroupID, because if a detail is loaded new (not from a template detail) it doesn't bother to load
			// the source DataGroupID, because it knows that the SourceID is enough to correctly identify it.  But
			// we want to keep storing the DataGroupID as well, because if it is loaded from a detail or template detail,
			// then we may need to use it.
			m_pMultiPopupDlg->m_nSourceDataGroupID = pDetail->GetSourceActionSourceDataGroupID();
			m_pMultiPopupDlg->m_nSourceDataID = pDetail->GetSourceActionSourceID();
		}
		else {
			//TES 1/31/2008 - PLID 28673 - If this wasn't a list, it must have been an image hotspot, which we can't
			// (at the present time) restore from.
			m_pMultiPopupDlg->m_nSourceDataGroupID = -1;
			m_pMultiPopupDlg->m_nSourceDataID = -1;
		}
	}
	//TES 1/11/2008 - PLID 24157 - Now add the detail to the dialog.
	m_pMultiPopupDlg->AddDetail(pDetail, pSourceDetail);
}


void CEMN::RemoveDetailFromPopup(CEMNDetail *pDetail)
{
	// (c.haag 2009-07-10 15:48) - PLID 34760 - At the time of this writing, there is an issue
	// where if you delete a detail, and it has a corresponding DetailPopup object, than the
	// DetailPopup object is not deleted. This PL item was meant to remedy that. However, DetailPopup
	// objects are in a tree structure with Next nodes and Child nodes; so it's not as simple as 
	// removing and deleting just one DetailPopup item from m_arDetailPopups like I had thought.
	//
	// (c.haag 2009-08-03 09:22) - PLID 34760 - Decided not to change any further code here. Leaving
	// legacy functionality intact because it's not causing any actual problems; and changing it could
	// cause problems or even require rethinking or reprogramming how we manage popup memory objects.
	//

	//TES 1/11/2008 - PLID 24157 - If we have a popup dialog, remove the detail, otherwise we don't need to do anything.
	if(m_pMultiPopupDlg) {
		m_pMultiPopupDlg->RemoveDetail(pDetail);
	}
}


CEMRItemAdvMultiPopupDlg* CEMN::GetOpenMultiPopupDlg()
{
	//TES 1/16/2008 - PLID 24157 - If we have a valid open popup dialog, return it, otherwise return null.
	if(m_pMultiPopupDlg && m_pMultiPopupDlg->GetSafeHwnd() && ::IsWindow(m_pMultiPopupDlg->GetSafeHwnd())) {
		return m_pMultiPopupDlg;
	}
	else {
		return NULL;
	}
}

void CEMN::RestoreMultiPopup(DetailPopup *pDetailPopup)
{
	if(m_pMultiPopupDlg) {
		//TES 1/23/2008 - PLID 28673 - This should never happen (this function should only be accessible by clicking
		// a label on a CEMRItemAdvListDlg, and m_pMultiPopupDlg should only be valid during processing spawning, 
		// when interaction with the Adv dlgs shouldn't be possible (this function shouldn't be reachable from the 
		// popped-up versions).  We'll ASSERT and return, if it does happen, it should be clear to the user why
		// nothing happened.
		ASSERT(FALSE);
		return;
	}

	//TES 1/23/2008 - PLID 28673 - Create the dialog.
	m_pMultiPopupDlg = new CEMRItemAdvMultiPopupDlg(GetInterface());
	
	//TES 1/23/2008 - PLID 28673 - Now display it.
	//TES 1/28/2008 - PLID 28673 - Pass in our details to popup.
	PopupMultiPopupDlg(pDetailPopup);

	//TES 1/23/2008 - PLID 28673 - We're done with this dialog now, clean it up until the next time
	// things get spawned.
	delete m_pMultiPopupDlg;
	m_pMultiPopupDlg = NULL;
}

void CEMN::PopupMultiPopupDlg(DetailPopup* pInitWithDetails /*= NULL*/)
{
	// TES 1/15/2008 - PLID 24157 - Copied out of CEMNDetail::Popup(), need to disable ink input 
	// on any existing images.
	long nEMNTotalDetailCount = GetTotalDetailCount();
	long nDetail;
	for (nDetail=0; nDetail < nEMNTotalDetailCount; nDetail++) {
		CEMNDetail *p = GetDetail(nDetail);
		if (NULL != p && eitImage == p->m_EMRInfoType && NULL != p->m_pEmrItemAdvDlg &&
			IsWindow(p->m_pEmrItemAdvDlg->GetSafeHwnd())) 
		{
			((CEmrItemAdvImageDlg*)p->m_pEmrItemAdvDlg)->EnableInkInput(FALSE);
		}
	}
	
	//TES 1/21/2008 - PLID 24157 - These actions may have been spawned by actions chosen on a popped-up narrative.
	// So, disable any popped up narrative while we deal with the spawned actions.
	POSITION pos = m_lstPoppedUpDetails.GetHeadPosition();
	CEMRItemAdvPopupDlg* pDlg = NULL;
	while(pos) {
		CEMNDetail* pPoppedUpDetail = m_lstPoppedUpDetails.GetNext(pos);
		pDlg = pPoppedUpDetail->GetPopupDlg();
		if(pDlg) {
			pDlg->EnableWindow(FALSE);
		}
	}

	//TES 2/13/2008 - PLID 28673 - We need to track the source detail of our passed-in tree.  If the detail tree gets
	// deleted while it's popped up, we need to update the source detail appropriately.
	CEMNDetail *pInitSource = NULL;
	if(pInitWithDetails) {
		//TES 1/23/2008 - PLID 28673 - Initialize it with the passed-in detail tree.
		pInitSource = pInitWithDetails->m_pSourceDetail;
		m_pMultiPopupDlg->SetPoppedUpDetails(pInitWithDetails);
	}

	//TES 1/11/2008 - PLID 24157 - OK, we're ready to pop up our dialog now.
	m_pMultiPopupDlg->DoModal();

	//TES 1/28/2008 - PLID 28673 - Now, read the details out of the dialog.
	DetailPopup* pDetailPopup = m_pMultiPopupDlg->TakeDetailsToPopup();
	if(pInitWithDetails) {
		//TES 1/28/2008 - PLID 28673 - If we were passed in some details, then the only thing we need to check for
		// is if the dialog's pDetailPopup is now NULL.  If so, that means all the details have been deleted, and the
		// dialog went ahead and deleted the whole tree.  So, take it out of our list of trees that need cleaning up.
		if(!pDetailPopup) {
			for(int i = m_arDetailPopups.GetSize()-1; i >= 0; i--) {
				if(m_arDetailPopups[i] == pInitWithDetails) {
					m_arDetailPopups.RemoveAt(i);
					//TES 2/13/2008 - PLID 28673 - Since all the details were deleted, we need to update the source
					// detail to not have an asterisk.
					if(pInitSource) {
						bool bContentChanged = false;
						long nListCount = pInitSource->GetListElementCount();
						for(int nListElement = 0; nListElement < nListCount; nListElement++) {
							ListElement le = pInitSource->GetListElement(nListElement);
							if(le.pDetailPopup == pInitWithDetails) {
								le.pDetailPopup = NULL;
								pInitSource->SetListElement(nListElement, le);
								bContentChanged = true;								
							}
						}
						if(bContentChanged) {
							//TES 2/13/2008 - PLID 28673 - Now, refresh the screen.  This code is taken out
							// of CEMNDetail::SyncContentAndState(), which admits that it's kind of clunky, but I 
							// don't know a better way to do it.
							pInitSource->ReflectCurrentContent();
							pInitSource->ReflectCurrentState();
							if(pInitSource->m_pEmrItemAdvDlg) {
								CRect rc;
								pInitSource->m_pEmrItemAdvDlg->GetWindowRect(&rc);
								CSize sz(rc.Width(), rc.Height());
								pInitSource->m_pEmrItemAdvDlg->RepositionControls(sz, FALSE);
							}
						}
					}
					
				}
			}
		}
	}
	else {
		//TES 1/28/2008 - PLID 28673 - It is now our responsibility to clean up this detail tree.  So, add it to 
		// our list of trees to clean up (first making sure that we don't already have it in there).
		bool bFound = false;
		for(int i = 0; i < m_arDetailPopups.GetSize() && !bFound; i++) {
			if(m_arDetailPopups[i] == pDetailPopup) bFound = true;
		}
		if(!bFound) m_arDetailPopups.Add(pDetailPopup);
	}

	//TES 1/28/2008 - PLID 28673 - Now we need to assign the popup information from this dialog to the checkbox
	// that spawned it.  That way, we will be able to restore the information from that checkbox.
	if(m_pMultiPopupDlg->m_pSourceDetail) {
		//TES 1/28/2008 - PLID 28673 - We can only do this for cases where the spawner was a data item.  Image hotspots,
		// for example, won't have this capability, at least for now.
		if(m_pMultiPopupDlg->m_nSourceDataGroupID != -1 || m_pMultiPopupDlg->m_nSourceDataID != -1) {
			for(int i = 0; i < m_pMultiPopupDlg->m_pSourceDetail->GetListElementCount(); i++) {
				ListElement le = m_pMultiPopupDlg->m_pSourceDetail->GetListElement(i);
				//TES 1/28/2008 - PLID 28673 - We also check against the Data ID now, as well as the DataGroupID.  
				// Depending on how this detail was loaded, it may have one or the other.
				if(le.nDataGroupID == m_pMultiPopupDlg->m_nSourceDataGroupID || le.nID == m_pMultiPopupDlg->m_nSourceDataID) {
					//TES 1/28/2008 - PLID 28673 - We've found the right list element, assign the popup info to it.
					le.pDetailPopup = pDetailPopup;
					m_pMultiPopupDlg->m_pSourceDetail->SetListElement(i, le);
					
					//TES 1/28/2008 - PLID 28673 - Now, we need to refresh the screen.
					m_pMultiPopupDlg->m_pSourceDetail->ReflectCurrentContent();
					CEmrItemAdvDlg *pDlg = m_pMultiPopupDlg->m_pSourceDetail->m_pEmrItemAdvDlg;
					if(pDlg) {
						CRect rc;
						pDlg->GetWindowRect(&rc);
						CSize sz(rc.Width(), rc.Height());
						pDlg->RepositionControls(sz, FALSE);
					}
				}
			}
		}
	}
	
	
	//TES 1/21/2008 - PLID 24157 - Now, re-enable any popped up details that we disabled.
	pos = m_lstPoppedUpDetails.GetHeadPosition();
	while(pos) {
		CEMNDetail* pPoppedUpDetail = m_lstPoppedUpDetails.GetNext(pos);
		CEMRItemAdvPopupDlg* pDlg = pPoppedUpDetail->GetPopupDlg();
		if(pDlg) {
			pDlg->EnableWindow(TRUE);
		}
	}
	
	// TES 1/15/2008 - PLID 24157 - Copied out of CEMNDetail::Popup(), need to re-enable ink input 
	// on any existing images.
	// TES 1/15/2008 - PLID 24157 - Need to recalculate the total detail count, it may have changed.
	nEMNTotalDetailCount = GetTotalDetailCount();
	for (nDetail=0; nDetail < nEMNTotalDetailCount; nDetail++) {
		CEMNDetail *p = GetDetail(nDetail);
		if (NULL != p && eitImage == p->m_EMRInfoType && NULL != p->m_pEmrItemAdvDlg &&
			IsWindow(p->m_pEmrItemAdvDlg->GetSafeHwnd())) 
		{
			((CEmrItemAdvImageDlg*)p->m_pEmrItemAdvDlg)->EnableInkInput(TRUE);
		}
	}
}

// (a.walling 2008-05-22 12:52) - PLID 22049 - EMR Multi-User - Request write access and token from data.
BOOL CEMN::RequestWriteToken(OUT CWriteTokenInfo& wtInfo, OPTIONAL IN BOOL bExpropriate)
{
	try {
		if(GetID() == -1)
			ThrowNxException("Attempted to request write token without an EMN");

		// (j.armen 2012-07-02 11:24) - PLID 49831 - Don't give out a write token unless we have access to write to an EMN
		if(!CheckCurrentUserPermissions(bioPatientEMR, sptWrite, FALSE, 0, TRUE, TRUE))
			return FALSE;

		// (j.armen 2012-07-02 11:40) - PLID 51313 - Don't give out a write token unless we have a current EMR license
		if(g_pLicense->HasEMR(CLicense::cflrSilent) != 2)
			return FALSE;

		// (z.manning 2009-11-19 09:59) - PLID 35810 - Do not allow them to acquire a write token
		// if this is a non-finalized patient created EMN (such as from NexWeb).
		if(GetPatientCreatedStatus() == pcsCreatedByPatientNotFinalized)
			return FALSE;

		if(!m_strWriteToken.IsEmpty())
			ThrowNxException("Attempted to request write token while already holding a token!");

		wtInfo.bIsOldRevision = FALSE;

		try {
			if (m_varRevision.vt != (VT_UI1 | VT_ARRAY)) {
				ThrowNxException("Cannot acquire write token; current revision is invalid.");
			}

			// (a.walling 2008-06-12 11:26) - PLID 30371 - Use parameterized query
			// (j.armen 2013-05-14 11:23) - PLID 56680 - Use a sql batch.  
			CParamSqlBatch sql;

			sql.Add("SET NOCOUNT ON");
			sql.Add("DECLARE @uid UNIQUEIDENTIFIER");
			sql.Add("DECLARE @emnID INT");
			sql.Add("DECLARE @tokenID INT");
			sql.Add("DECLARE @revision TIMESTAMP");
			sql.Add("DECLARE @revokedAccessT TABLE (EmnID INT NOT NULL)");
			sql.Add("DECLARE @forceAccess BIT");
			sql.Add("SELECT @uid = NEWID(), @emnID = {INT}, @tokenID = {INT}, @revision = {TIMESTAMP}, @forceAccess = {BOOL}",
				GetID(), GetAPIUserLoginTokenID(), m_varRevision, bExpropriate);

			if(IsTemplate())
			{
				// (j.armen 2013-05-14 11:24) - PLID 56680 - Handle acquiring EMN Template Access
				sql.Add("DELETE EMNTemplateAccessT\r\n"
						"OUTPUT deleted.EmnID INTO @revokedAccessT\r\n"
						"FROM EMNTemplateAccessT TA\r\n"
						"LEFT JOIN sys.dm_exec_connections C ON TA.ConnectionUID = C.connection_id\r\n"
						"WHERE TA.EmnID = @emnID AND C.connection_id IS NULL");

				sql.Add("IF (@forceAccess = 1)");
				sql.Add("BEGIN");
				sql.Add("	DELETE FROM EMNTemplateAccessT WHERE EmnID = @emnID");
				sql.Add("END");

				sql.Add("IF EXISTS (SELECT EmnID FROM EMNTemplateAccessT WITH(UPDLOCK, HOLDLOCK) WHERE EmnID = @emnID)");
				sql.Add("BEGIN");
				sql.Add("	SET @uid = NULL");
				sql.Add("END");
				sql.Add("ELSE");
				sql.Add("BEGIN");
				sql.Add("	INSERT INTO EMNTemplateAccessT (EmnID, UserLoginTokenID, UID)\r\n"
						"		SELECT @emnID, @tokenID, @uid");
				sql.Add("END");

				sql.Add("IF @revision <> (SELECT Revision FROM EMRTemplateT WHERE ID = @emnID)");
				sql.Add("BEGIN");
				sql.Add("	RAISERROR('Template cannot be modified; revision is out of date', 16, 42)");
				sql.Add("	ROLLBACK TRAN");
				sql.Add("	RETURN");
				sql.Add("END");
			}
			else
			{
				// (j.armen 2013-05-14 11:24) - PLID 56680 - Handle acquiring EMN Access
				// (c.haag 2013-11-04) - PLID 59266 - Updated based off a newer query by j.armen
				// that is more deadlock-safe and closer to how the API does it.

				sql.Add("DELETE EMNAccessT\r\n"
						"OUTPUT deleted.EmnID INTO @revokedAccessT\r\n"
						"FROM EMNAccessT A WITH(READPAST)\r\n"
						"INNER JOIN UserLoginTokensT T ON A.UserLoginTokenID = T.ID AND T.DeviceType = -2 /* Practice */\r\n"
						"LEFT JOIN sys.dm_exec_connections C ON A.ConnectionUID = C.connection_id\r\n"
						"WHERE A.OpenExclusive = 1 AND A.EmnID = @emnID AND C.connection_id IS NULL");

				sql.Add("IF (@forceAccess = 1)");
				sql.Add("BEGIN");
				sql.Add("	DELETE EMNDetailAccessT\r\n"
						"	FROM EMNDetailAccessT DA\r\n"
						"	INNER JOIN EMRDetailsT D ON DA.EMRDetailID = D.ID\r\n"
						"	WHERE D.EmrID = @emnID");
				sql.Add("	DELETE FROM EMNAccessT WHERE EmnID = @emnID");
				sql.Add("END");

				sql.Add("IF EXISTS (SELECT EmnID FROM EMNAccessT WITH(UPDLOCK, HOLDLOCK) WHERE EmnID = @emnID)");
				sql.Add("BEGIN");
				sql.Add("	SET @uid = NULL");
				sql.Add("END");
				sql.Add("ELSE");
				sql.Add("BEGIN");
				sql.Add("	INSERT INTO EMNAccessT (EmnID, UserLoginTokenID, UID, OpenExclusive)\r\n"
						"		SELECT @emnID, @tokenID, @uid, 1");
				sql.Add("END");

				sql.Add("IF @revision <> (SELECT Revision FROM EMRMasterT WHERE ID = @emnID)");
				sql.Add("BEGIN");
				sql.Add("	RAISERROR('EMN cannot be modified; revision is out of date', 16, 42)");
				sql.Add("	ROLLBACK TRAN");
				sql.Add("	RETURN");
				sql.Add("END");
			}

			sql.Add("SELECT @uid AS UID, (SELECT DISTINCT EmnID FROM @revokedAccessT) AS RevokedAccess");

			_RecordsetPtr prs = sql.CreateRecordset(GetRemoteData());

			// (j.armen 2013-05-14 11:25) - PLID 56680 - If we acquired access, we will have a UID, otherwise it will be NULL
			m_strWriteToken = AdoFldString(prs, "UID", "");

			if (!m_strWriteToken.IsEmpty())
			{
				TRACE("* Acquired write token %s for EMN %li ('%s')\n", m_strWriteToken, m_nID, GetDescription());

				if (bExpropriate)
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), BeginNewAuditEvent(), IsTemplate() ? aeiEMNTemplateAccessStolen : aeiEMNAccessStolen, GetID(), "", FormatString("Taken by %s", GetCurrentUserName()), aepHigh, aetChanged);

				// (j.jones 2012-07-24 11:23) - PLID 47550 - audit when access is dropped due to a lost connection
				if (-1 != AdoFldLong(prs, "RevokedAccess", -1))
					AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), BeginNewAuditEvent(), IsTemplate() ? aeiEMNTemplateAccessReleased_ConnectionDrop : aeiEMNAccessReleased_ConnectionDrop, GetID(), "", FormatString("Taken by %s", GetCurrentUserName()), aepHigh, aetChanged);

				if (IsWindow(GetInterface()->GetSafeHwnd()))
					GetInterface()->SendMessage(NXM_EMN_WRITEACCESS, (WPARAM)GetID(), TRUE);

				CClient::RefreshTable(IsTemplate() ? NetUtils::EMNTemplateAccessT : NetUtils::EMNAccessT, GetID(), NULL, FALSE);

				return TRUE;
			}
		}
		catch (_com_error& e)
		{
			// (j.armen 2013-05-14 11:27) - PLID 56680 - The only com error we should recieve would be from 
			//	the revision being out of date
			m_strWriteToken.Empty();

			CSQLErrorInfo eSqlError;
			// (a.walling 2008-08-27 14:23) - PLID 30855 - Use the shared function (I left a bug in the copied code that I fixed in other
			// situations, ack! I suppose that is as good a reason as any to move things to the shared function)
			if (GetSQLErrorInfo(e, eSqlError) && eSqlError.IsNxRaisedError() && eSqlError.nState == 42)
			{
				// revision is out of date
				wtInfo.bIsOldRevision = TRUE;
			}
			else
			{
				HandleException(e, "COM Error requesting write token in CEMN::RequestWriteToken", __LINE__, __FILE__);
			}
		}
		catch (CException* e)
		{
			HandleException(e, "Error requesting write token in CEMN::RequestWriteToken", __LINE__, __FILE__);
		}
		catch (...)
		{
			HandleException(NULL, "Unknown error requesting write token in CEMN::RequestWriteToken", __LINE__, __FILE__); 
		}

		// get further information on the token
		VerifyWriteToken(wtInfo);

		return FALSE;
	} NxCatchAll("Failed to acquire write token in CEMN::RequestWriteToken");

	return FALSE;
}

// (a.walling 2008-05-22 12:52) - PLID 22049 - EMR Multi-User - Release write access and clear the token in data.
BOOL CEMN::ReleaseWriteToken()
{
	try {
		// (a.walling 2013-10-01 10:20) - PLID 58827 - If we don't have a write token, or are a new EMN, just return
		if (GetID() == -1) {
			ASSERT(m_strWriteToken.IsEmpty());
			return TRUE;
		}

		if (m_strWriteToken.IsEmpty()) {
			return TRUE;
		}

		// (j.armen 2013-05-14 11:31) - PLID 56680 EMN Access Refactoring
		ExecuteParamSql(
			"DELETE FROM {CONST_STRING}\r\n"
			"WHERE EmnID = {INT} AND UserLoginTokenID = {INT} AND UID = CONVERT(UNIQUEIDENTIFIER, {STRING})",
			IsTemplate() ? "EMNTemplateAccessT" : "EMNAccessT", GetID(), GetAPIUserLoginTokenID(), m_strWriteToken);

			TRACE("* Released write token %s for EMN %li ('%s')\n", m_strWriteToken, m_nID, GetDescription());
			m_strWriteToken.Empty();
			
			if (IsWindow(GetInterface()->GetSafeHwnd()))
				GetInterface()->SendMessage(NXM_EMN_WRITEACCESS, (WPARAM)GetID(), FALSE);

			CClient::RefreshTable(IsTemplate() ? NetUtils::EMNTemplateAccessT : NetUtils::EMNAccessT, GetID(), NULL, FALSE);

	} NxCatchAll("Failed to release write token in CEMN::ReleaseWriteToken");

	return m_strWriteToken.IsEmpty();
}

// (a.walling 2008-05-22 12:52) - PLID 22049 - EMR Multi-User - Ensure the stored write token matches that in data.
BOOL CEMN::VerifyWriteToken(OUT CWriteTokenInfo& wtInfo)
{
	try {
		if (GetID() == -1) {
			wtInfo.bIsVerified = FALSE;
			return FALSE;
		}

		wtInfo.dtHeld.SetStatus(COleDateTime::null);

		// (j.armen 2013-05-14 11:33) - PLID 56680 - EMN Access Refactoring
		_RecordsetPtr prs = CreateParamRecordset(
			"SELECT M.Revision, M.Deleted, A.UID, A.Date, T.UserID, U.UserName, T.DeviceInfo, A.UserLoginTokenID,\r\n"
			"	CASE WHEN DeviceType = -2 THEN CONVERT(BIT, 0) ELSE CONVERT(BIT, 1) END AS IsExternal\r\n"
			"FROM {CONST_STRING} M\r\n"
			"LEFT JOIN {CONST_STRING} A ON M.ID = A.EmnID\r\n"
			"LEFT JOIN UserLoginTokensT T ON A.UserLoginTokenID = T.ID\r\n"
			"LEFT JOIN UsersT U ON T.UserID = U.PersonID\r\n"
			"WHERE M.ID = {INT}",
			IsTemplate() ? "EMRTemplateT" : "EMRMasterT", 
			IsTemplate() ? "EMNTemplateAccessT" : "EMNAccessT",
			GetID());

		if (prs->eof)
		{
			// this should be impossible; there should at least be a record for the EMN!
			ASSERT(FALSE);
			ThrowNxException("No records returned!");
		}
		else
		{
			// first off compare revisions.
			_variant_t varCurrentRevision = prs->Fields->Item["Revision"]->Value;

			ASSERT(varCurrentRevision.vt == (VT_UI1|VT_ARRAY));

			wtInfo.bIsOldRevision = !(
				(varCurrentRevision.vt == m_varRevision.vt) &&
				(VARCMP_EQ == VariantCompare(&varCurrentRevision, &m_varRevision)));

			// (a.walling 2008-08-13 14:18) - PLID 22049 - Now check for deleted. This also implies that the revision is probably
			// out of date, since another user is most likely the one to delete it, but this may not be true in the future.
			wtInfo.bIsDeleted = AdoFldBool(prs, "Deleted");

			const CString strUID = AdoFldString(prs, "UID", "");

			if(strUID.IsEmpty())
			{
				// no one has this object held
				wtInfo.bIsVerified = FALSE;
				return FALSE;
			}
			else
			{
				// (j.armen 2013-05-14 11:34) - PLID 56680 - Store the external status instead of a tokenid
				wtInfo.dtHeld = AdoFldDateTime(prs, "Date");
				wtInfo.nHeldByUserID = AdoFldLong(prs, "UserID");
				wtInfo.strHeldByUserName = AdoFldString(prs, "UserName");
				wtInfo.strDeviceInfo = AdoFldString(prs, "DeviceInfo");
				wtInfo.bIsExternal = AdoFldBool(prs, "IsExternal");

				if (strUID != m_strWriteToken)
				{
					if (!m_strWriteToken.IsEmpty())
					{
						// we have a write token but it is ours. So we should clear it out.
						m_strWriteToken.Empty();
					}

					wtInfo.bIsVerified = FALSE;
					return FALSE;
				}
				else
				{
					// it's us!
					wtInfo.bIsVerified = TRUE;
					return TRUE;
				}
			}
		}
	} NxCatchAllThrow("Failed to verify write token in CEMN::VerifyWriteToken");

	wtInfo.bIsVerified = FALSE;
	return FALSE;
}

// (a.walling 2008-05-22 12:52) - PLID 22049 - EMR Multi-User - Return the write token
CString CEMN::GetWriteToken()
{
	return m_strWriteToken;
}

// (a.walling 2008-05-22 12:52) - PLID 22049 - EMR Multi-User - Is this EMN writable?
BOOL CEMN::IsWritable()
{
	if(m_nID == -1) {
		return TRUE;
	}
	else {
		// (z.manning 2009-11-19 09:47) - PLID 35810 - If this is a patient created EMN (NexWeb)
		// but it is not yet finalized then the EMN cannot be writable.
		return (!m_strWriteToken.IsEmpty() && m_nPatientCreatedStatus != pcsCreatedByPatientNotFinalized);
	}
}

// (a.walling 2008-05-29 14:44) - PLID 22049 - EMR Multi-User - Sets the stored revision of this EMN
void CEMN::SetRevision(_variant_t &var)
{
	if (m_varRevision.vt == (VT_UI1 | VT_ARRAY)) {
		m_varRevision.Clear();
	} else if (m_varRevision.vt != VT_NULL && m_varRevision.vt != VT_EMPTY) {
		ASSERT(FALSE);
	}
	m_varRevision.Attach(var.Detach());

#ifdef _DEBUG
	CString str = CreateByteStringFromSafeArrayVariant(m_varRevision);
	TRACE("Current EMN (%li) revision: '%s'\n", GetID(), str);
#endif
}

// (a.walling 2008-05-29 15:52) - PLID 22049 - EMR Multi-User - Return the revision
_variant_t CEMN::GetRevision()
{
	return m_varRevision;
}

// (a.walling 2014-08-27 18:02) - PLID 63502 - Force reload of revision when modified by API. This is a dirty hack.
void CEMN::ForceReloadRevision()
{
	long id = GetID();
	if (id == -1) {
		return;
	}
	ADODB::_RecordsetPtr prs = CreateParamRecordset("SELECT Revision FROM EMRMasterT WHERE ID = {INT}", GetID());
	if (prs->eof) {
		return;
	}
	SetRevision(AdoFldVar(prs, "Revision"));
}

// (a.walling 2009-11-19 15:08) - PLID 36365 - Deprecated massive amounts of recordset-related narrative code


// (c.haag 2009-06-29 17:55) - PLID 34750 - Called to delete an EMN detail. This used to be called
// by the topic at the CEMR level; now we pass through the CEMN level first to make sure that the
// equivalent pop-up object is also deleted.
void CEMN::DeleteEMNDetail(CEMNDetail *pDetail)
{
	// Make sure the detail doesn't exist in the detail popup array
	RemoveDetailFromPopup(pDetail); // (c.haag 2009-07-02 10:14) - PLID 34760 - Use this function now

	// Now forward the delete request to the EMR
	GetParentEMR()->DeleteEMNDetail(pDetail);
}

// (a.walling 2008-06-27 15:10) - PLID 30482
void CEMN::SetParentEMRChanged()
{
	m_bUnsaved = TRUE;
	m_bParentEMRChanged = TRUE;
}

// (c.haag 2008-07-14 11:19) - PLID 30696 - This function is called when a todo is either spawned or
// added to the EMN by means of the "New ToDo" button. We track the todo ID for the unlikely event 
// that theuser wants to cancel out of the EMN.
// (z.manning 2009-02-26 15:09) - PLID 33141 - Added SourceDataGroupID
// (z.manning 2010-02-24 17:04) - PLID 37532 - Replaced SourceDataGroupID with ptrSourceTableRow
// (c.haag 2012-10-17) - PLID 52863 - Overload for not-spawned todo alarms
void CEMN::AddCreatedTodoWhileUnsaved(long nTodoID, _variant_t vRemind, _variant_t vDone, 
	_variant_t vDeadline, _variant_t vEnteredBy, _variant_t vPersonID, _variant_t vNotes, _variant_t vPriority, 
	_variant_t vTask, _variant_t vLocationID, _variant_t vCategoryID, _variant_t vRegardingType,
	const CArray<long,long>& anAssignTo, _variant_t vAssignToNames)
{
	if (m_bIsTemplate) {
		ASSERT(FALSE);
		return; // We don't actually create alarms in templates; this should never happen
	}

	// First, check the array of deleted todos. If we find it, the two will cancel each other out.
	const int nUnspawned = m_apDeletedTodosWhileUnsaved.GetSize();
	for (int i=0; i < nUnspawned; i++) 
	{
		// (a.walling 2009-12-22 14:03) - PLID 36671 - Match on the SourceActionID and SourceDataGroupID. Otherwise this can match
		// in wrong situations, such as when a task was deleted and a new one created. The previous TodoList ID is reused.
		// (c.haag 2012-10-17) - PLID 52863 - Only search on unspawned todo alarms. All I did was replace the latter part of the operator
		// with -1's.
		if (m_apDeletedTodosWhileUnsaved[i]->sai.nSourceActionID == -1 && 
			m_apDeletedTodosWhileUnsaved[i]->sai.GetDataGroupID() == -1 && 
			m_apDeletedTodosWhileUnsaved[i]->vRegardingType == vRegardingType && 
			m_apDeletedTodosWhileUnsaved[i]->nTodoID == nTodoID) {
			// Yep, it was deleted before the topic was saved. So, we're right back to
			// square one, and the deleted array entry no longer belongs.
			delete m_apDeletedTodosWhileUnsaved[i];
			m_apDeletedTodosWhileUnsaved.RemoveAt(i);
			return;
		}
	}

	// Add to the array
	EMNTodo* pTodo = new EMNTodo;
	pTodo->nTodoID = nTodoID;
	pTodo->vRemind = vRemind;
	pTodo->vDone = vDone;
	pTodo->vDeadline = vDeadline;
	pTodo->vEnteredBy = vEnteredBy;
	pTodo->vPersonID = vPersonID;
	pTodo->vNotes = vNotes;
	pTodo->vPriority = vPriority;
	pTodo->vTask = vTask;
	pTodo->vLocationID = vLocationID;
	pTodo->vCategoryID = vCategoryID;
	// (c.haag 2008-07-14 16:05) - PLID 30696 - RegardingID is always -1 for new EMR todos
	pTodo->vRegardingID = (long)-1;
	pTodo->vRegardingType = vRegardingType;
	pTodo->anAssignTo.Copy(anAssignTo);
	pTodo->vAssignToNames = vAssignToNames;
	m_apCreatedTodosWhileUnsaved.Add(pTodo);
	// (c.haag 2008-07-14 16:42) - PLID 30696 - Set the unsaved flag to guarantee a user cannot
	// dismiss the EMN without being asked what to do about created todos
	m_bUnsaved = TRUE;
}

// (c.haag 2012-10-17) - PLID 52863 - Overload for spawned todo alarms
void CEMN::AddCreatedTodoWhileUnsaved(long nTodoID, const EmrAction& ea, const SourceActionInfo &sai,
	_variant_t vRemind, _variant_t vDone, _variant_t vDeadline, _variant_t vEnteredBy,
	_variant_t vPersonID, _variant_t vNotes, _variant_t vLocationID, _variant_t vRegardingType,
	const CArray<long,long>& anAssignTo, _variant_t vAssignToNames)
{
	if (m_bIsTemplate) {
		ASSERT(FALSE);
		return; // We don't actually create alarms in templates; this should never happen
	}

	// First, check the array of deleted todos. If we find it, the two will cancel each other out.
	const int nUnspawned = m_apDeletedTodosWhileUnsaved.GetSize();
	for (int i=0; i < nUnspawned; i++) 
	{
		EMNTodo *pDeletedTodo =  m_apDeletedTodosWhileUnsaved[i];
		if (pDeletedTodo->sai.HasSameSource(sai, TRUE) &&
			pDeletedTodo->vRegardingType == vRegardingType && 
			pDeletedTodo->nTodoID == nTodoID)
		{
			// Yep, it was deleted before the topic was saved. So, we're right back to
			// square one, and the deleted array entry no longer belongs.
			delete m_apDeletedTodosWhileUnsaved[i];
			m_apDeletedTodosWhileUnsaved.RemoveAt(i);
			return;
		}
	}

	// Add to the array
	EMNTodo* pTodo = new EMNTodo;
	pTodo->nTodoID = nTodoID;
	pTodo->sai = sai;
	pTodo->vRemind = vRemind;
	pTodo->vDone = vDone;
	pTodo->vDeadline = vDeadline;
	pTodo->vEnteredBy = vEnteredBy;
	pTodo->vPersonID = vPersonID;
	pTodo->vNotes = vNotes;
	pTodo->vPriority = (BYTE)ea.nTodoPriority;
	pTodo->vTask = _bstr_t(ea.strTodoMethod);
	pTodo->vLocationID = vLocationID;
	pTodo->vCategoryID = (long)ea.nTodoCategoryID;
	// (c.haag 2008-07-14 16:05) - PLID 30696 - RegardingID is always -1 for new EMR todos
	pTodo->vRegardingID = (long)-1;
	pTodo->vRegardingType = vRegardingType;
	pTodo->anAssignTo.Copy(anAssignTo);
	pTodo->vAssignToNames = vAssignToNames;
	m_apCreatedTodosWhileUnsaved.Add(pTodo);
	// (c.haag 2008-07-14 16:42) - PLID 30696 - Set the unsaved flag to guarantee a user cannot
	// dismiss the EMN without being asked what to do about created todos
	m_bUnsaved = TRUE;
}

// (c.haag 2008-07-14 11:21) - PLID 30696 - This function is called when a todo is either unspawned or
// deleted from the EMN by means of the "More Info" todo list
// (z.manning 2009-02-26 15:11) - PLID 33141 - Use the source action info class
void CEMN::AddDeletedTodoWhileUnsaved(long nTodoID, CEMNDetail* pSourceDetail, long nSourceActionID,
	TableRow *ptrSourceTableRow, _variant_t vRemind, _variant_t vDone, _variant_t vDeadline, _variant_t vEnteredBy,
	_variant_t vPersonID, _variant_t vNotes, _variant_t vPriority, _variant_t vTask,
	_variant_t vLocationID, _variant_t vCategoryID, _variant_t vRegardingID, _variant_t vRegardingType,
	const CArray<long,long>& anAssignTo, _variant_t vAssignToNames)
{
	if (m_bIsTemplate) {
		ASSERT(FALSE);
		return; // We don't actually delete alarms in templates; this should never happen
	}

	// First, check the array of created todos. If we find it, the two will cancel each other out.
	const int nSpawned = m_apCreatedTodosWhileUnsaved.GetSize();
	for (int i=0; i < nSpawned; i++) {
		// (a.walling 2009-12-22 14:03) - PLID 36671 - Match on the SourceActionID and SourceDataGroupID. Otherwise this can match
		// in wrong situations, such as when a task was deleted and a new one created. The previous TodoList ID is reused.
		if (m_apCreatedTodosWhileUnsaved[i]->sai.nSourceActionID == nSourceActionID && 
			m_apCreatedTodosWhileUnsaved[i]->sai.GetDataGroupID() == ptrSourceTableRow->nGroupID && 
			m_apCreatedTodosWhileUnsaved[i]->vRegardingType == vRegardingType && 
			m_apCreatedTodosWhileUnsaved[i]->nTodoID == nTodoID) {
			// Yep, it was created before the topic was saved. So, we're right back to
			// square one, and the created array entry no longer belongs.
			delete m_apCreatedTodosWhileUnsaved[i];
			m_apCreatedTodosWhileUnsaved.RemoveAt(i);
			return;
		}
	}

	// Add to the array
	EMNTodo* pTodo = new EMNTodo;
	pTodo->nTodoID = nTodoID;
	pTodo->sai = SourceActionInfo(eaoTodo, nSourceActionID, pSourceDetail, ptrSourceTableRow);
	pTodo->vRemind = vRemind;
	pTodo->vDone = vDone;
	pTodo->vDeadline = vDeadline;
	pTodo->vEnteredBy = vEnteredBy;
	pTodo->vPersonID = vPersonID;
	pTodo->vNotes = vNotes;
	pTodo->vPriority = vPriority;
	pTodo->vTask = vTask;
	pTodo->vLocationID = vLocationID;
	pTodo->vCategoryID = vCategoryID;
	pTodo->vRegardingID = vRegardingID;
	pTodo->vRegardingType = vRegardingType;
	pTodo->anAssignTo.Copy(anAssignTo);
	pTodo->vAssignToNames = vAssignToNames;
	m_apDeletedTodosWhileUnsaved.Add(pTodo);
	// (c.haag 2008-07-14 16:42) - PLID 30696 - Set the unsaved flag to guarantee a user cannot
	// dismiss the EMN without being asked what to do about deleted todos
	m_bUnsaved = TRUE;
}

// (c.haag 2008-07-09 13:15) - PLID 30648 - Appends apTodos with this EMN's list of todos spawned prior to having been saved
// (c.haag 2008-07-14 11:39) - PLID 30696 - Now appends apTodos with todos either spawned, or created from the "New ToDo" button
void CEMN::GenerateCreatedTodosWhileUnsavedList(CArray<EMNTodo*,EMNTodo*>& apTodos)
{
	apTodos.Append(m_apCreatedTodosWhileUnsaved);
}

// (c.haag 2008-07-09 13:15) - PLID 30648 - Appends apTodos with this EMN's list of todos unspawned prior to having been saved
// (c.haag 2008-07-14 11:56) - PLID 30696 - Now appends apTodos with todos either unspawned, or deleted from the More Info topic.
void CEMN::GenerateDeletedTodosWhileUnsavedList(CArray<EMNTodo*,EMNTodo*>& apTodos)
{
	apTodos.Append(m_apDeletedTodosWhileUnsaved);
}

// (c.haag 2008-07-16 11:30) - PLID 30752 - Copies todo alarms from one EMN to another. This will invoke a prompt for which the
// user has to choose which alarms to copy.
void CEMN::CopyTodoAlarms(CEMN* pSourceEMN)
{
	CArray<EMNTodo*,EMNTodo*> apCreatedTodos;
	CArray<EMNTodo*,EMNTodo*> apDataTodos;
	CArray<long,long> anAllTodoIDs;
	CStringArray astrAllTodoDetailNames;
	long nSourceEMNID = pSourceEMN->GetID();
	int i,j;

	// If the EMN is locked and saved, we cannot copy todo alarms. This is because the locked alarms
	// do not have all the original todo alarm information; it only has the information necessary to
	// display on the screen. This is by design so that they cannot be altered by people changing other
	// related tables (such as category).
	if (pSourceEMN->IsLockedAndSaved()) {
		return;
	}

	// First, gather a list of existing todo alarms
	if (nSourceEMNID > 0) {
		_RecordsetPtr prs = CreateParamRecordset(FormatString("SELECT TaskID, RegardingType, RegardingID FROM TodoList WHERE "
			"(RegardingType = %d AND RegardingID = {INT}) "
			"OR "
			"(RegardingType = %d AND RegardingID IN (SELECT ID FROM EMRDetailsT WHERE EMRID = %d))"
			,ttEMN, ttEMNDetail), nSourceEMNID, nSourceEMNID);
		FieldsPtr f = prs->Fields;
		while (!prs->eof) {
			EMNTodo* pTodo = new EMNTodo;
			pTodo->nTodoID = AdoFldLong(f, "TaskID");
			pTodo->vRegardingType = f->Item["RegardingType"]->Value;
			pTodo->vRegardingID = f->Item["RegardingID"]->Value;
			anAllTodoIDs.Add(pTodo->nTodoID);
			if (ttEMNDetail == VarLong(pTodo->vRegardingType)) {
				astrAllTodoDetailNames.Add( pSourceEMN->GetDetailByID( VarLong(pTodo->vRegardingID) )->GetLabelText() );
			} else {
				astrAllTodoDetailNames.Add("");
			}
			apDataTodos.Add(pTodo);
			prs->MoveNext();
		}
	}

	pSourceEMN->GenerateCreatedTodosWhileUnsavedList(apCreatedTodos);
	for (i=0; i < apCreatedTodos.GetSize(); i++) {
		EMNTodo* pTodo = apCreatedTodos[i];
		anAllTodoIDs.Add(pTodo->nTodoID);
		if (NULL != pTodo->sai.pSourceDetail) {
			astrAllTodoDetailNames.Add(pTodo->sai.pSourceDetail->GetLabelText());
		} else {
			astrAllTodoDetailNames.Add("");
		}
	}

	// Quit right away if there are no todo alarms to copy
	if (0 == anAllTodoIDs.GetSize()) {
		return;
	}

	// Now invoke the copy dialog and have the user decide what todo alarms to copy
	CEMRCopyTodosDlg dlg(anAllTodoIDs, astrAllTodoDetailNames, pSourceEMN->GetID(), GetInterface());
	dlg.DoModal();

	// Quit if the user unselected all the todo alarms
	if (0 == anAllTodoIDs.GetSize()) {
		return;
	}

	// Now query the data for all the todo information, go through all the alarms and copy them
	// (z.manning 2010-02-25 10:20) - PLID 37532 - SourceDetailImageStampID
	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	_RecordsetPtr prsSrcTodos = CreateParamRecordset(
		"SELECT TodoList.TaskID, Remind, Done, Deadline, PersonID, Notes, Priority, Task, LocationID, CategoryID, RegardingType, RegardingID, SourceActionID, "
		"dbo.GetTodoAssignToIDString(TodoList.TaskID) AS AssignToIDs, SourceDataGroupID, SourceDetailImageStampID, "
		"dbo.GetTodoAssignToNamesString(TodoList.TaskID) AS AssignToNames, (SELECT Description FROM NoteCatsF WHERE ID = TodoList.CategoryID) AS Category "
		"FROM TodoList LEFT JOIN EMRTodosT ON EMRTodosT.TaskID = TodoList.TaskID "
		"WHERE TodoList.TaskID IN ({INTARRAY})"
		,anAllTodoIDs);
	FieldsPtr f = prsSrcTodos->Fields;
	while (!prsSrcTodos->eof) {
		const long nSrcTodoID = AdoFldLong(f, "TaskID");
		TodoType RegardingType = (TodoType)AdoFldLong(f, "RegardingType");
		const long nRegardingID = AdoFldLong(f, "RegardingID");
		CString strAssignToIDs = AdoFldString(f, "AssignToIDs");
		CEMNDetail* pSourceDetail = NULL;
		CEMNDetail* pDestDetail = NULL;

		// Get the assign to ID's
		CArray<long,long> anAssignToIDs;
		ParseDelimitedStringToLongArray(strAssignToIDs, " ", anAssignToIDs);

		// Get the source detail
		if (ttEMNDetail == RegardingType) {

			// First check the created todo list
			for (j=0; j < apCreatedTodos.GetSize() && NULL == pSourceDetail; j++) {
				if (apCreatedTodos[j]->nTodoID == nSrcTodoID) {
					// Found it
					pSourceDetail = apCreatedTodos[j]->sai.pSourceDetail;
				}
			} // for (j=0; j < apCreatedTodos.GetSize() && NULL == pSourceDetail; j++) {

			// Now check by detail ID
			if (NULL == pSourceDetail && nRegardingID > 0) {
				pSourceDetail = pSourceEMN->GetDetailByID(nRegardingID);
			}

			if (NULL == pSourceDetail) {
				// The source detail could not be found, so skip this alarm since there's
				// nothing more we can do
				prsSrcTodos->MoveNext();
				continue;
			}
			
			// Find the corresponding detail in the current EMN
			CArray<CEMNDetail*,CEMNDetail*> apDetails;
			GenerateTotalEMNDetailArray(&apDetails);
			for (j=0; j < apDetails.GetSize() && NULL == pDestDetail; j++) {
				CEMNDetail* p = apDetails[j];
				if (p->GetCopiedFromDetail() == pSourceDetail) {
					pDestDetail = p;
				}
			}

			if (NULL == pDestDetail) {
				// The corresponding detail could not be found, so skip this alarm since
				// there's nothing more we can do
				prsSrcTodos->MoveNext();
				continue;
			}
		}

		// Create the alarm
		long nNewTodoID = TodoCreate(
			AdoFldDateTime(f, "Remind"),
			AdoFldDateTime(f, "Deadline"),
			anAssignToIDs,
			AdoFldString(f, "Notes"),
			AdoFldString(f, "Task"),
			-1,
			RegardingType,
			AdoFldLong(f, "PersonID"),
			AdoFldLong(f, "LocationID", -1),
			(TodoPriority)AdoFldByte(f, "Priority"),
			AdoFldLong(f, "CategoryID", -1),
			AdoFldDateTime(f, "Done", (DATE)0),
			GetCurrentUserID(),
			AdoFldLong(f, "SourceActionID", -1),
			AdoFldLong(f, "SourceDataGroupID", -1),
			AdoFldLong(f, "SourceDetailImageStampID", -1)
			);

		// Audit
		CString strAssignTo = AdoFldString(f, "AssignToNames");
		CString strCategory = AdoFldString(f, "Category", "");
		CString strAuditNotes = AdoFldString(f, "Notes");
		long nAuditID = BeginNewAuditEvent();
		// CR and LF's don't show up in the audit trail elegantly; replace them with spaces or else the note will look ugly
		strAuditNotes.Replace(10, ' ');
		strAuditNotes.Replace(13, ' ');
		CString strNew = FormatString("Assigned To: %s, Deadline: %s, Category: %s, Note: %s", 
			strAssignTo, FormatDateTimeForInterface(AdoFldDateTime(f, "Deadline"), 0, dtoDate), strCategory, strAuditNotes);
		AuditEvent(GetParentEMR()->GetPatientID(), GetExistingPatientName(GetParentEMR()->GetPatientID()), nAuditID, aeiPatientToDoCreated, nNewTodoID, "", strNew, aepMedium, aetCreated);

		// Add it to our unsaved array
		// (c.haag 2012-10-17) - PLID 52863 - Use the overload that takes in source action info. Assign more values
		// to this on a need-to basis when AddCreatedTodoWhileUnsaved ever changes.
		EmrAction ea;
		ea.nTodoPriority = AdoFldByte(f, "Priority", -1); // (a.walling 2014-02-03 08:46) - PLID 60604 - ToDoList.Priority is a tinyint / Byte
		ea.strTodoMethod = AdoFldString(f, "Task", "");
		ea.nTodoCategoryID = AdoFldLong(f, "CategoryID", -1);
		AddCreatedTodoWhileUnsaved(
			nNewTodoID,
			ea,
			SourceActionInfo(eaoTodo, AdoFldLong(f, "SourceActionID", -1), pDestDetail, &TableRow(AdoFldLong(f, "SourceDataGroupID", -1), AdoFldLong(f, "SourceDetailImageStampID", -1), -1, -1)),
			f->Item["Remind"]->Value,
			f->Item["Done"]->Value,
			f->Item["Deadline"]->Value,
			GetCurrentUserID(),
			f->Item["PersonID"]->Value,
			f->Item["Notes"]->Value,
			f->Item["LocationID"]->Value,
			f->Item["RegardingType"]->Value,
			anAssignToIDs,
			f->Item["AssignToNames"]->Value);

		prsSrcTodos->MoveNext();

	} // while (!prsTodos->eof) {

	// Fire a tablechecker. One table checker to rule them all as far as changes.
	CClient::RefreshTable(NetUtils::TodoList);

	// Cleanup
	for (i=0; i < apDataTodos.GetSize(); i++) {
		delete apDataTodos[i];
	}
}

// (j.jones 2008-07-21 17:28) - PLID 30729 - add all of this EMN's problems,
// its topics' problems, and problems on diagnoses and charges, to the passed-in array
// (c.haag 2008-08-14 12:05) - PLID 30820 - Added bIncludeDeletedProblems
// (c.haag 2009-05-19 12:20) - PLID 34310 - Use the new problem linking structure. Use EnsureProblemInArray
// to ensure no array content is duplicated
void CEMN::GetAllProblems(CArray<CEmrProblem*, CEmrProblem*> &aryProblems, BOOL bIncludeDeletedProblems /* = FALSE */)
{
	try {

		//add problems from this EMN
		int i = 0;
		for(i=0; i<m_apEmrProblemLinks.GetSize(); i++) {
			CEmrProblem *pProblem = m_apEmrProblemLinks.GetAt(i)->GetProblem();
			if(pProblem != NULL && (!pProblem->m_bIsDeleted || bIncludeDeletedProblems)) {
				EnsureProblemInArray(aryProblems, pProblem);
			}
		}

		//add problems from charges
		for(i = 0; i < m_aryCharges.GetSize(); i++) {
			EMNCharge *pCharge = (EMNCharge*)m_aryCharges.GetAt(i);
			if(pCharge) {
				//find each problem
				for(int j=0; j<pCharge->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblem *pProblem = pCharge->m_apEmrProblemLinks.GetAt(j)->GetProblem();
					if(pProblem != NULL && (!pProblem->m_bIsDeleted || bIncludeDeletedProblems)) {
						EnsureProblemInArray(aryProblems, pProblem);
					}
				}
			}
		}

		if(bIncludeDeletedProblems) {
			//add problems from deleted charges
			for(i = 0; i < m_aryDeletedCharges.GetSize(); i++) {
				EMNCharge *pCharge = (EMNCharge*)m_aryDeletedCharges.GetAt(i);
				if(pCharge) {
					//find each problem
					for(int j=0; j<pCharge->m_apEmrProblemLinks.GetSize(); j++) {
						CEmrProblem *pProblem = pCharge->m_apEmrProblemLinks.GetAt(j)->GetProblem();
						if(pProblem != NULL) {
							EnsureProblemInArray(aryProblems, pProblem);
						}
					}
				}
			}
		}

		//add problems from diagnoses
		for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
			EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDiagCodes.GetAt(i);
			if(pDiag) {
				//find each problem
				for(int j=0; j<pDiag->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblem *pProblem = pDiag->m_apEmrProblemLinks.GetAt(j)->GetProblem();
					if(pProblem != NULL && (!pProblem->m_bIsDeleted || bIncludeDeletedProblems)) {
						EnsureProblemInArray(aryProblems, pProblem);
					}
				}
			}
		}

		if(bIncludeDeletedProblems) {
			//add problems from deleted diagnoses
			for(i = 0; i < m_aryDeletedDiagCodes.GetSize(); i++) {
				EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDeletedDiagCodes.GetAt(i);
				if(pDiag) {
					//find each problem
					for(int j=0; j<pDiag->m_apEmrProblemLinks.GetSize(); j++) {
						CEmrProblem *pProblem = pDiag->m_apEmrProblemLinks.GetAt(j)->GetProblem();
						if(pProblem != NULL) {
							EnsureProblemInArray(aryProblems, pProblem);
						}
					}
				}
			}
		}

		//add problems from medications
		for(i = 0; i < m_aryMedications.GetSize(); i++) {
			EMNMedication *pMed = (EMNMedication*)m_aryMedications.GetAt(i);
			if(pMed) {
				//find each problem
				for(int j=0; j<pMed->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblem *pProblem = pMed->m_apEmrProblemLinks.GetAt(j)->GetProblem();
					if(pProblem != NULL && (!pProblem->m_bIsDeleted || bIncludeDeletedProblems)) {
						EnsureProblemInArray(aryProblems, pProblem);
					}
				}
			}
		}

		//add problems from deleted medications
		if(bIncludeDeletedProblems) {
			for(i = 0; i < m_aryDeletedMedications.GetSize(); i++) {
				EMNMedication *pMed = (EMNMedication*)m_aryDeletedMedications.GetAt(i);
				if(pMed) {
					//find each problem
					for(int j=0; j<pMed->m_apEmrProblemLinks.GetSize(); j++) {
						CEmrProblem *pProblem = pMed->m_apEmrProblemLinks.GetAt(j)->GetProblem();
						if(pProblem != NULL) {
							EnsureProblemInArray(aryProblems, pProblem);
						}
					}
				}
			}
		}

		//add problems from the topics
		for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
			CEMRTopic *pTopic = (CEMRTopic*)m_arypEMRTopics.GetAt(i);
			if(pTopic) {
				//get the topic's problems
				pTopic->GetAllProblems(aryProblems, bIncludeDeletedProblems);
			}
		}

		//add problems from the deleted topics
		if(bIncludeDeletedProblems) {
			for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
				CEMRTopic *pTopic = (CEMRTopic*)m_arypDeletedTopics.GetAt(i);
				if(pTopic) {
					//get the topic's problems
					pTopic->GetAllProblems(aryProblems, bIncludeDeletedProblems);
				}
			}
		}

	}NxCatchAll("Error in CEMN::GetAllProblems");
}

// (j.jones 2008-07-22 08:48) - PLID 30789 - returns true if there are any undeleted problems on the EMN
// (c.haag 2009-05-19 12:08) - PLID 34310 - Use new problem linking structure
BOOL CEMN::HasProblems()
{
	try {

		for(int i=0; i<m_apEmrProblemLinks.GetSize(); i++) {
			CEmrProblem *pProblem = m_apEmrProblemLinks.GetAt(i)->GetProblem();
			if(pProblem != NULL && !pProblem->m_bIsDeleted && !m_apEmrProblemLinks.GetAt(i)->IsDeleted()) {

				return TRUE;
			}
		}

	}NxCatchAll("Error in CEMN::HasProblems");

	return FALSE;
}

// (j.jones 2008-07-22 08:48) - PLID 30789 - returns true if there are only undeleted, closed problems on the EMN
// (c.haag 2009-05-19 12:08) - PLID 34310 - Use new problem linking structure
BOOL CEMN::HasOnlyClosedProblems()
{
	try {

		BOOL bHasProblems = FALSE;
		BOOL bHasOnlyClosed = TRUE;

		for(int i=0; i<m_apEmrProblemLinks.GetSize(); i++) {
			CEmrProblem *pProblem = m_apEmrProblemLinks.GetAt(i)->GetProblem();
			if(pProblem != NULL && !pProblem->m_bIsDeleted) {

				bHasProblems = TRUE;
				
				if(pProblem->m_nStatusID != 2) {
					bHasOnlyClosed = FALSE;
				}
			}
		}

		if(bHasProblems && bHasOnlyClosed) {
			return TRUE;
		}
		else {
			return FALSE;
		}

	}NxCatchAll("Error in CEMN::HasOnlyClosedProblems");

	return FALSE;
}

// (c.haag 2008-07-23 12:16) - PLID 30820 - Populate apProblems with a list of all deleted problems for this object and
// all its children. If a child or related EMR object is deleted, all its problems are considered deleted as well.
// (c.haag 2009-05-19 12:09) - PLID 34310 - Use new problem link structure
// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now, not problems
void CEMN::GetAllDeletedEmrProblemLinks(CArray<CEmrProblemLink*,CEmrProblemLink*>& apProblemLinks, BOOL bIncludeThisObject)
{
	int i,j;

	// Do nothing if this EMN is locked
	if (IsLockedAndSaved()) {
		return;
	}

	// Deleted topics
	for (i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
		m_arypDeletedTopics[i]->GetAllDeletedEmrProblemLinks(apProblemLinks, TRUE);
	}

	// Deleted charges
	for (i=0; i < m_aryDeletedCharges.GetSize(); i++) {
		CArray<CEmrProblemLink*,CEmrProblemLink*>& apTmp = m_aryDeletedCharges[i]->m_apEmrProblemLinks;
		for (j=0; j < apTmp.GetSize(); j++) {
			CEmrProblemLink *pLink = apTmp[j];
			// Don't check the deleted flag of the problem link. It's possible for a problem's
			// deleted flag to be set even if only its bound EMR object is deleted.
			// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now
			// also we need to include -1 ID links that we created but then deleted,
			// so we can reconcile against the problems in memory
			if(pLink != NULL /* && pLink->GetID() > 0*/) {
				EnsureProblemLinkInArray(apProblemLinks, pLink);
			}
		}
	}

	// Deleted diagnosis codes
	for (i=0; i < m_aryDeletedDiagCodes.GetSize(); i++) {
		CArray<CEmrProblemLink*,CEmrProblemLink*>& apTmp = m_aryDeletedDiagCodes[i]->m_apEmrProblemLinks;
		for (j=0; j < apTmp.GetSize(); j++) {
			CEmrProblemLink *pLink = apTmp[j];
			// Don't check the deleted flag of the problem link. It's possible for a problem's
			// deleted flag to be set even if only its bound EMR object is deleted.
			// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now
			// also we need to include -1 ID links that we created but then deleted,
			// so we can reconcile against the problems in memory
			if(pLink != NULL /*&& pLink->GetID() > 0*/) {
				EnsureProblemLinkInArray(apProblemLinks, pLink);
			}
		}
	}

	// Deleted medications
	for (i=0; i < m_aryDeletedMedications.GetSize(); i++) {
		CArray<CEmrProblemLink*,CEmrProblemLink*>& apTmp = m_aryDeletedMedications[i]->m_apEmrProblemLinks;
		for (j=0; j < apTmp.GetSize(); j++) {
			CEmrProblemLink *pLink = apTmp[j];
			// Don't check the deleted flag of the problem link. It's possible for a problem's
			// deleted flag to be set even if only its bound EMR object is deleted.
			// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now
			// also we need to include -1 ID links that we created but then deleted,
			// so we can reconcile against the problems in memory
			if(pLink != NULL /*&& pLink->GetID() > 0*/) {
				EnsureProblemLinkInArray(apProblemLinks, pLink);
			}
		}
	}

	// Live topics
	for (i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		m_arypEMRTopics[i]->GetAllDeletedEmrProblemLinks(apProblemLinks, FALSE);
	}

	CArray<CEmrProblemLink*,CEmrProblemLink*> apTmp;
	GetAllProblemLinks(apTmp, NULL, TRUE);
	// If the following is true, it means that this EMN is going to be deleted, so include all
	// the existing problems for presently undeleted objects.
	if (bIncludeThisObject) {
		for (i=0; i < apTmp.GetSize(); i++) {
			CEmrProblemLink *pLink = apTmp[i];
			// Don't check the deleted flag of the problem link. It's possible for a problem's
			// deleted flag to be set even if only its bound EMR object is deleted.
			// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now
			// also we need to include -1 ID links that we created but then deleted,
			// so we can reconcile against the problems in memory
			if(pLink != NULL /*&& pLink->GetID() > 0*/) {
				EnsureProblemLinkInArray(apProblemLinks, pLink);
			}
		}
	}
	// If we get here, this EMN itself is not going to be deleted. So, go through apTmp and just
	// check for deleted problems
	else {
		for (i=0; i < apTmp.GetSize(); i++) {
			CEmrProblemLink *pLink = apTmp[i];
			// (j.jones 2009-05-29 09:46) - PLID 34301 - returns links now
			// also we need to include -1 ID links that we created but then deleted,
			// so we can reconcile against the problems in memory
			if(pLink != NULL && pLink->GetIsDeleted() /*&& pLink->GetID() > 0*/) {
				EnsureProblemLinkInArray(apProblemLinks, pLink);
			}
		}
	}
}

// (j.jones 2008-07-23 15:19) - PLID 30789 - returns true if any problems are marked as modified,
// including deleted items
// (c.haag 2009-05-19 12:12) - PLID 34310 - Use the new problem structure
BOOL CEMN::HasChangedProblems()
{
	try {

		for(int i=0; i<m_apEmrProblemLinks.GetSize(); i++) {
			CEmrProblem *pProblem = m_apEmrProblemLinks.GetAt(i)->GetProblem();
			if(pProblem != NULL) {

				if(pProblem->m_bIsModified) {
					return TRUE;
				}
			}
		}

	}NxCatchAll("Error in CEMN::HasChangedProblems");

	return FALSE;
}

// (c.haag 2008-07-24 09:49) - PLID 30826 - Returns TRUE if there is at least one saved problem for this EMN or any of
// its children. This does not check deleted EMR objects.
BOOL CEMN::DoesEmnOrChildrenHaveSavedProblems()
{
	CArray<CEmrProblem*,CEmrProblem*> apProblems;
	GetAllProblems(apProblems);
	const int nProblems = apProblems.GetSize();
	for (int i=0; i < nProblems; i++) {
		CEmrProblem* p = apProblems[i];
		if (p && !p->m_bIsDeleted && p->m_nID > 0) {
			return TRUE;
		}
	}
	return FALSE;
}

// (c.haag 2008-07-25 16:10) - PLID 30826 - Returns TRUE if there is at least one saved problem for a given charge
BOOL CEMN::DoesChargeHaveSavedProblems(EMNCharge* pCharge)
{
	CArray<CEmrProblemLink*,CEmrProblemLink*>& apLinks = pCharge->m_apEmrProblemLinks;
	const int nLinks = apLinks.GetSize();
	for (int i=0; i < nLinks; i++) {
		CEmrProblem* p = apLinks[i]->GetProblem();
		if (p && !p->m_bIsDeleted && p->m_nID > 0) {
			return TRUE;
		}
	}
	return FALSE;
}

// (c.haag 2008-07-25 16:10) - PLID 30826 - Returns TRUE if there is at least one saved problem for a given diagnosis code
BOOL CEMN::DoesDiagCodeHaveSavedProblems(EMNDiagCode* pDiagCode)
{
	CArray<CEmrProblemLink*,CEmrProblemLink*>& apLinks = pDiagCode->m_apEmrProblemLinks;
	const int nLinks = apLinks.GetSize();
	for (int i=0; i < nLinks; i++) {
		CEmrProblem* p = apLinks[i]->GetProblem();
		if (p && !p->m_bIsDeleted && p->m_nID > 0) {
			return TRUE;
		}
	}
	return FALSE;
}

// (c.haag 2008-07-25 16:10) - PLID 30826 - Returns TRUE if there is at least one saved problem for a given diagnosis code
BOOL CEMN::DoesMedicationHaveSavedProblems(EMNMedication* pMedication)
{
	CArray<CEmrProblemLink*,CEmrProblemLink*>& apLinks = pMedication->m_apEmrProblemLinks;
	const int nLinks = apLinks.GetSize();
	for (int i=0; i < nLinks; i++) {
		CEmrProblem* p = apLinks[i]->GetProblem();
		if (p && !p->m_bIsDeleted && p->m_nID > 0) {
			return TRUE;
		}
	}
	return FALSE;
}

// (b.cardillo 2012-03-08 11:40) - PLID 42207 - Required details
// Safely checks all topics and subtopics of this EMN to find if there are any visible details that are marked as required and aren't filled in.
BOOL CEMN::HasVisibleUnfilledRequiredDetails()
{
	if (this != NULL) {
		// Just check all our topics
		for (int i = 0, nCount = this->GetTopicCount(); i < nCount; i++) {
			if (this->GetTopic(i)->HasVisibleUnfilledRequiredDetails()) {
				// This topic is visible and it (or one of its visible descendents) has at least one visible required detail that was not filled in
				return TRUE;
			}
		}
		// And if none contained any, then we don't contain any
		return FALSE;
	} else {
		// If null, we can't be considered to have any details
		return FALSE;
	}
}

// (b.cardillo 2012-03-08 11:40) - PLID 42207 - Required details
// Static because it checks against data for the specified EMN, not any EMN loaded into memory.
// Checks for the existence of any visible details belonging to the specified EMN that are marked as required and aren't filled in.
BOOL CEMN::HasVisibleUnfilledRequiredDetails(long nEMNID)
{
	// (b.cardillo 2012-03-28 21:54) - PLID 42207 - (additional) Finished implementing this function (narratives wasn't done and now is)
	// (j.jones 2016-05-25 16:37) - NX-100636 - images did not have the same rules as the API, I copied the more detailed API logic
	// to this code such that they are now identical

	_RecordsetPtr prs = CreateParamRecordset(
		_T("DECLARE @hasRequiredUnfilledDetails BIT \r\n")
		_T("SET @hasRequiredUnfilledDetails = \r\n")
		_T("CASE WHEN EXISTS (\r\n")
		_T(" SELECT * \r\n")
		_T(" FROM EMRDetailsT D \r\n")
		_T(" INNER JOIN EMRInfoT I ON D.EMRInfoID = I.ID \r\n")
		_T(" WHERE D.EMRID = {INT} \r\n")
		_T("  AND D.Deleted = 0 \r\n")
		_T("  AND (I.InfoFlags & {CONST_INT}) = {CONST_INT} \r\n")
		_T("  AND /*D.IsFilledIn()*/ (CASE \r\n")
		_T("      WHEN I.DataType = {CONST_INT} THEN (\r\n") // eitText
		_T("        CASE WHEN D.Text IS NOT NULL AND D.Text NOT LIKE '' THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END \r\n")
		_T("    ) WHEN I.DataType IN ({CONST_INT}, {CONST_INT}) THEN (\r\n") // (eitSingleList, eitMultiList)
		_T("        CASE WHEN D.ID IN (SELECT S.EMRDetailID FROM EMRSelectT S) THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END \r\n")
		_T("    ) WHEN I.DataType = {CONST_INT} THEN (\r\n") // eitImage
		// Images are filled if there is ink or stamps stored, if a hotspot is filled,
		// or if the background image type or path has changed, unless the info type is undefined(-1) and the detail type is forced blank(5)
		_T("        CASE WHEN (D.InkData Is Not Null OR D.ImageTextData Is Not Null  \r\n")
		_T("        OR (Coalesce(I.BackgroundImageType, -1) <> Coalesce(D.InkImageTypeOverride, -1) AND NOT(Coalesce(I.BackgroundImageType, -1) = -1 AND Coalesce(D.InkImageTypeOverride, -1) = 5))  \r\n")
		_T("        OR UPPER(Coalesce(I.BackgroundImageFilePath, '')) <> UPPER(Coalesce(D.InkImagePathOverride, ''))  \r\n")
		_T("        OR EXISTS(SELECT HS.ID FROM EMRHotSpotSelectT HS WHERE HS.EMRDetailID = D.ID)) THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END \r\n")
		_T("    ) WHEN I.DataType = {CONST_INT} THEN (\r\n") // eitSlider
		_T("        CASE WHEN D.SliderValue IS NOT NULL THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END \r\n")
		_T("    ) WHEN I.DataType = {CONST_INT} THEN (\r\n") // skip checking any eitNarrative details by always returning 1
		_T("        CONVERT(BIT, 1) \r\n")
		_T("    ) WHEN I.DataType = {CONST_INT} THEN (\r\n") // eitTable
		_T("        CASE WHEN D.ID IN (SELECT T.EMRDetailID FROM EMRDetailTableDataT T INNER JOIN EMRDataT C ON T.EMRDataID_Y = C.ID) THEN CONVERT(BIT, 1) ELSE CONVERT(BIT, 0) END \r\n")
		_T("    ) \r\n")
		_T("    ELSE CONVERT(BIT, 0) END \r\n")
		_T("   ) = CONVERT(BIT, 0) \r\n")
		_T(") \r\n")
		_T("THEN CONVERT(BIT, 1) \r\n")
		_T("ELSE CONVERT(BIT, 0) \r\n")
		_T("END \r\n")
		_T("SELECT @hasRequiredUnfilledDetails AS HasRequiredUnfilledNonNarrativeDetails \r\n")
		_T("IF (@hasRequiredUnfilledDetails = 0) BEGIN \r\n") 
		_T("  SELECT Text AS NarrativeText \r\n")
		_T("  FROM EMRDetailsT D \r\n")
		_T("  INNER JOIN EMRInfoT I ON D.EMRInfoID = I.ID \r\n")
		_T("  WHERE D.EMRID = {INT} \r\n")
		_T("   AND D.Deleted = 0 \r\n")
		_T("   AND (I.InfoFlags & {CONST_INT}) = {CONST_INT} \r\n")
		_T("   AND I.DataType = {CONST_INT} \r\n") // eitNarrative
		_T("END \r\n")
		, nEMNID
		, eifRequired, eifRequired
		, eitText
		, eitSingleList, eitMultiList
		, eitImage
		, eitSlider
		, eitNarrative
		, eitTable
		, nEMNID
		, eifRequired, eifRequired
		, eitNarrative
		);

	// Check the results
	if (AdoFldBool(prs, _T("HasRequiredUnfilledNonNarrativeDetails"))) {
		// Already has some non-narrative required details that aren't filled in, so no need to check narratives
		return TRUE;
	} else {
		// No non-narrative required details that aren't filled in, so we'll have to check each required narrative's header
		prs = prs->NextRecordset(NULL);
		while (!prs->eof) {
			// If this visible required narrative is not set, then we have our answer
			//TES 7/7/2012 - PLID 50854 - This now takes the full narrative text, not just the header, and works for RTF or HTML
			if (!CEMNDetail::IsStateSet_Narrative(AdoFldString(prs, _T("NarrativeText")))) {
				// Answer: this emn contains a visible required unfilled detail
				return TRUE;
			}
			// So far so good, move on
			prs->MoveNext();
		}
		// If we made it here, no visible required narratives were left unfilled (and we already determined 
		// that no other kinds of visible required details were unfilled) so we can now positively return 
		// our answer of false.
		return FALSE;
	}
}

// (a.walling 2008-10-06 16:52) - PLID 31430 - Generate header and footer html for printing
// (a.walling 2008-10-14 11:50) - PLID 31404 - Consolidated into single function
// (a.walling 2008-11-14 08:57) - PLID 32024 - Now a static function, which accepts either a CEMN object or an ID for querying data
void CEMN::GeneratePrintHeaderFooterHTML(IN CEMN* pEMN, IN long nID, OUT CString& strHeader, OUT CString& strFooter) 
{
	try {
		if (pEMN == NULL) {
			if (nID == -1) {
				ThrowNxException("Called with no object!");
			}
		}

		CHeaderFooterInfo hfi;
		hfi.Load();

		CPreviewFields pf;
		
		CString strFirst, strMiddle, strLast, strEMNLocation, strEMNDescription, strEMRDescription, strAge;
		COleDateTime dtEMNDate;
		dtEMNDate.SetStatus(COleDateTime::invalid);
		BYTE cGender = 0;

		// (a.walling 2008-11-14 08:58) - PLID 32024 - Gather some common attributes which can be acquired in a single recordset
		if (pEMN) {
			strMiddle = pEMN->GetPatientNameMiddle();
			strFirst = pEMN->GetPatientNameFirst();
			strLast = pEMN->GetPatientNameLast();
			// (z.manning 2010-01-13 11:09) - PLID 22672 - Age is now a string
			strAge = pEMN->GetPatientAge();
			cGender = pEMN->GetPatientGender();
			dtEMNDate = pEMN->GetEMNDate();
			// (a.walling 2012-04-09 09:03) - PLID 49515 - Location - Return const ref
			strEMNLocation = pEMN->GetLocation().strName;
			strEMNDescription = pEMN->GetDescription();
			strEMRDescription = pEMN->GetParentEMR()->GetDescription();
		} else {
			_RecordsetPtr rs = CreateParamRecordset("SELECT PatientFirst, PatientMiddle, PatientLast, PatientAge, PatientGender, EMRMasterT.Description AS EMNDescription, Date, LocationsT.Name AS LocationName, EMRGroupsT.Description AS EMRDescription FROM EmrMasterT LEFT JOIN LocationsT ON LocationID = LocationsT.ID LEFT JOIN EMRGroupsT ON EmrMasterT.EmrGroupID = EMRGroupsT.ID WHERE EmrMasterT.ID = {INT}", nID);
			if (!rs->eof) {
				strFirst = AdoFldString(rs, "PatientFirst", "");
				strMiddle = AdoFldString(rs, "PatientMiddle", "");
				strLast = AdoFldString(rs, "PatientLast", "");
				strEMNDescription = AdoFldString(rs, "EMNDescription", "");
				strEMNLocation = AdoFldString(rs, "LocationName", "");
				strAge = AdoFldString(rs, "PatientAge", "");
				cGender = AdoFldByte(rs, "PatientGender", 0);
				dtEMNDate = AdoFldDateTime(rs, "Date");
				strEMRDescription = AdoFldString(rs, "EMRDescription", "");
			} else {
				ThrowNxException("Could not find patient");
			}
		}
		
		// (z.manning 2010-01-13 14:59) - PLID 22672 - We now store age as a string so that we can display it
		// in months, however, the text "yr." is hardcoded as the default for the header text for the preview
		// so for this we'll just stick with 0.
		if(!strAge.IsEmpty() && strAge != strAge.SpanIncluding("0123456789")) {
			strAge = "0";
		}

		for (int i = 0; i < pf.arFields.GetSize(); i++) {
			CPreviewFields::CField* f = pf.arFields[i];

			switch (f->nID) {
				case CPreviewFields::fFirstMLast:
					{
						CString strMI = strMiddle;
						if (strMI.GetLength() > 0) {
							strMI = strMI.Left(1) + ".";
						}
						f->strOutput.Format("%s %s %s", strFirst, strMI, strLast);
						f->strOutput = ConvertToHTMLEmbeddable(f->strOutput);
					} break;
				case CPreviewFields::fFirstMiddleLast:
					{
						f->strOutput.Format("%s %s %s", strFirst, strMiddle, strLast);
						f->strOutput.Replace("  ", " ");
						f->strOutput = ConvertToHTMLEmbeddable(f->strOutput);
					} break;
				case CPreviewFields::fID:
					{
						_RecordsetPtr prs;

						if (pEMN) {
							long nPersonID = pEMN->GetParentEMR()->GetPatientID();
							prs = CreateParamRecordset("SELECT UserDefinedID FROM PatientsT WHERE PersonID = {INT}", nPersonID);
						} else {
							prs = CreateParamRecordset("SELECT UserDefinedID FROM PatientsT WHERE PersonID = (SELECT PatientID FROM EmrMasterT WHERE ID = {INT})", nID);
						}

						if (!prs->eof) {
							f->strOutput.Format("%li", AdoFldLong(prs, "UserDefinedID"));
						} else {
							ThrowNxException("Could not find patient");
						}
					} break;
				case CPreviewFields::fFirst:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strFirst);
					} break;
				case CPreviewFields::fMiddle:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strMiddle);
					} break;
				case CPreviewFields::fMiddleInitial:
					{
						f->strOutput = strMiddle;
						if (f->strOutput.GetLength() > 0) {
							f->strOutput = f->strOutput.Left(1) + ".";
						}

						f->strOutput = ConvertToHTMLEmbeddable(f->strOutput);
					} break; // (a.walling 2010-03-12 17:20) - PLID 37739 - Missing break
				case CPreviewFields::fLast:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strLast);
					} break;
				case CPreviewFields::fBirthDate:
					{
						COleDateTime dtBirthDate;
						if (pEMN) {
							dtBirthDate = pEMN->GetParentEMR()->GetPatientBirthDate();
						} else {
							_RecordsetPtr prs = CreateParamRecordset("SELECT BirthDate FROM PersonT WHERE ID = (SELECT PatientID FROM EmrMasterT WHERE ID = {INT})", nID);

							if (!prs->eof) {
								_variant_t vBirthdate = prs->Fields->Item["BirthDate"]->Value;

								if (vBirthdate.vt == VT_DATE) {
									dtBirthDate = VarDateTime(vBirthdate);
								} else {
									dtBirthDate.SetStatus(COleDateTime::null);
								}
							} else {
								ThrowNxException("Could not find patient");
							}
						}

						if (dtBirthDate.GetStatus() == COleDateTime::valid) {
							f->strOutput = ConvertToHTMLEmbeddable(FormatDateTimeForInterface(dtBirthDate, NULL, dtoDate));
						} else {
							f->strOutput = "Unknown Birthdate";
						}
					} break;
				case CPreviewFields::fAge:
					{
						if (!strAge.IsEmpty()) {
							f->strOutput = ConvertToHTMLEmbeddable(strAge);
						} else {
							f->strOutput = "?";
						}
					} break;
				case CPreviewFields::fGenderMaleFemale:
					{	
						switch(cGender) {
						case 1:
							f->strOutput = "Male";
							break;
						case 2:
							f->strOutput = "Female";
							break;
						}
					} break;
				case CPreviewFields::fGenderMF:
					{
						switch(cGender) {
						case 1:
							f->strOutput = "M";
							break;
						case 2:
							f->strOutput = "F";
							break;
						}
					} break; // (a.walling 2010-03-12 17:20) - PLID 37739 - Missing break
				case CPreviewFields::fInsuranceCompany:
					{
						_RecordsetPtr prs;

						if (pEMN) {
							long nPatientID = pEMN->GetParentEMR()->GetPatientID();

							prs = CreateParamRecordset("SELECT TOP 1 InsuranceCoT.Name FROM InsuredPartyT INNER JOIN InsuranceCoT ON InsuranceCoID = InsuranceCoT.PersonID WHERE PatientID = {INT} AND RespTypeID >= 0 ORDER BY RespTypeID ASC",
								nPatientID);
						} else {							
							prs = CreateParamRecordset("SELECT TOP 1 InsuranceCoT.Name FROM InsuredPartyT INNER JOIN InsuranceCoT ON InsuranceCoID = InsuranceCoT.PersonID WHERE PatientID = (SELECT PatientID FROM EmrMasterT WHERE ID = {INT}) AND RespTypeID >= 0 ORDER BY RespTypeID ASC",
								nID);
						}					

						if (!prs->eof) {
							f->strOutput = ConvertToHTMLEmbeddable(AdoFldString(prs, "Name", ""));
						} else {
							f->strOutput.Format("No Insurance");
						}
					} break;
				case CPreviewFields::fEMNDate:
					{
						f->strOutput = ConvertToHTMLEmbeddable(FormatDateTimeForInterface(dtEMNDate, NULL, dtoDate));					
					} break;
				case CPreviewFields::fEMNLocation:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strEMNLocation);
					} break;
				case CPreviewFields::fEMNDescription:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strEMNDescription);
					} break;
				case CPreviewFields::fEMRDescription:
					{
						f->strOutput = ConvertToHTMLEmbeddable(strEMRDescription);					
					} break;
				case CPreviewFields::fPrintDate:
					{
						f->strOutput = ConvertToHTMLEmbeddable(FormatDateTimeForInterface(COleDateTime::GetCurrentTime(), NULL, dtoDate));
					} break;
				// (r.gonet 09-17-2010) - PLID 38968 - Adding Print_Time field support to headers and footers
				case CPreviewFields::fPrintTime:
					{
						f->strOutput = ConvertToHTMLEmbeddable(FormatDateTimeForInterface(COleDateTime::GetCurrentTime(), DTF_STRIP_SECONDS, dtoTime));
					} break;
				// (r.gonet 09-17-2010) - PLID 38968 - Adding Print_Date_Time field support to headers and footers
				case CPreviewFields::fPrintDateTime:
					{
						f->strOutput = ConvertToHTMLEmbeddable(FormatDateTimeForInterface(COleDateTime::GetCurrentTime(), DTF_STRIP_SECONDS, dtoDateTime));
					} break;
				case CPreviewFields::fPage:
					{
						f->strOutput = "<SPAN class=hfPage>{{NXPAGENUM}}</SPAN>";
					} break;
				case CPreviewFields::fPageTotal:
					{
						f->strOutput = "<SPAN class=hfPageTotal>Y</SPAN>";
					} break;
				default:
					ASSERT(FALSE);
			}
		}

		// build the header
		BuildPrintHeader(strHeader, hfi);

		// build the footer
		BuildPrintFooter(strFooter, hfi);

		// replace the fields
		ReplaceHeaderFooterFields(strHeader, pf);
		ReplaceHeaderFooterFields(strFooter, pf);
	} NxCatchAllThrow("GeneratePrintHeaderFooterHTML");
}

// (a.walling 2008-10-14 11:50) - PLID 31404 - Replace customized fields in the header/footer strings
// (a.walling 2008-11-13 15:35) - PLID 32024 - Made print header functions static
void CEMN::ReplaceHeaderFooterFields(IN OUT CString& strHTML, IN const CPreviewFields& pf)
{
	for (int i = 0; i < pf.arFields.GetSize(); i++) {
		strHTML.Replace(pf.GetFieldCode(pf.arFields[i]->strFieldName), pf.arFields[i]->strOutput);
	}

	// special formatting codes for advanced options (ie, bold, etc)
	strHTML.Replace("[b]", "<b>");
	strHTML.Replace("[/b]", "</b>");

	strHTML.Replace("[i]", "<i>");
	strHTML.Replace("[/i]", "</i>");

	strHTML.Replace("[u]", "<u>");
	strHTML.Replace("[/u]", "</u>");

	strHTML.Replace("[big]", "<big>");
	strHTML.Replace("[/big]", "</big>");

	strHTML.Replace("[small]", "<small>");
	strHTML.Replace("[/small]", "</small>");

	strHTML.Replace("[light]", "<span style='color:#808080;'>");
	strHTML.Replace("[/light]", "</span>");

	strHTML.Replace("[blank]", "&nbsp;");
	strHTML.Replace("[/blank]", ""); // not technically supported, but should be replaced nonetheless
}

// (a.walling 2008-10-15 10:22) - PLID 31404 - Build the header/footer HTML
// (a.walling 2008-11-13 15:35) - PLID 32024 - Made print header functions static
void CEMN::BuildPrintHeader(IN OUT CString& strHTML, IN const CHeaderFooterInfo& hfi)
{
	if (hfi.strHeaderLeft.IsEmpty() && hfi.strHeaderRight.IsEmpty() && hfi.strHeader2Left.IsEmpty() && hfi.strHeader2Right.IsEmpty()) {
		// nothing!
		// (a.walling 2008-11-24 11:03) - PLID 32169 - Return an empty div.
		strHTML = "<DIV CLASS='headerstyle' ID='nxheader'></DIV>";
		return;
	}

	// (a.walling 2008-11-17 12:50) - PLID 32052 - Specify an ID for the header
	strHTML = 
		"<DIV CLASS='headerstyle' ID='nxheader'>"
			"<TABLE STYLE='width:100%;'>";
	
	if (!hfi.strHeaderLeft.IsEmpty() || !hfi.strHeaderRight.IsEmpty()) {
		if (hfi.strHeaderLeft.IsEmpty() || hfi.strHeaderRight.IsEmpty()) {
			// make one column

			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:center;' COLSPAN=2>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strHeaderLeft.IsEmpty() ? hfi.strHeaderRight : hfi.strHeaderLeft));
		} else {
			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:left;'>%s</TD>"
					"<TD STYLE='text-align:right;'>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strHeaderLeft),
				ConvertToHTMLEmbeddable(hfi.strHeaderRight));
		}
	}
	if (!hfi.strHeader2Left.IsEmpty() || !hfi.strHeader2Right.IsEmpty()) {
		if (hfi.strHeader2Left.IsEmpty() || hfi.strHeader2Right.IsEmpty()) {
			// make one column

			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:center;' COLSPAN=2>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strHeader2Left.IsEmpty() ? hfi.strHeader2Right : hfi.strHeader2Left));
		} else {
			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:left;'>%s</TD>"
					"<TD STYLE='text-align:right;'>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strHeader2Left),
				ConvertToHTMLEmbeddable(hfi.strHeader2Right));
		}
	}

	strHTML += 
			"</TABLE>"
		"</DIV>";
}

// (a.walling 2008-10-15 10:22) - PLID 31404 - Build the header/footer HTML
// (a.walling 2008-11-13 15:35) - PLID 32024 - Made print header functions static
void CEMN::BuildPrintFooter(IN OUT CString& strHTML, IN const CHeaderFooterInfo& hfi)
{
	if (hfi.strFooterLeft.IsEmpty() && hfi.strFooterRight.IsEmpty() && hfi.strFooter2Left.IsEmpty() && hfi.strFooter2Right.IsEmpty()) {
		// nothing!
		// (a.walling 2008-11-24 11:03) - PLID 32169 - Return an empty div.
		strHTML = "<DIV CLASS='footerstyle' ID='nxfooter'></DIV>";
		return;
	}

	// (a.walling 2008-11-17 12:50) - PLID 32052 - Specify an ID for the footer
	strHTML = 
		"<DIV CLASS='footerstyle' ID='nxfooter'>"
			"<TABLE STYLE='width:100%;'>";
	
	if (!hfi.strFooter2Left.IsEmpty() || !hfi.strFooter2Right.IsEmpty()) {
		if (hfi.strFooter2Left.IsEmpty() || hfi.strFooter2Right.IsEmpty()) {
			// make one column

			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:center;' COLSPAN=2>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strFooter2Left.IsEmpty() ? hfi.strFooter2Right : hfi.strFooter2Left));
		} else {
			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:left;'>%s</TD>"
					"<TD STYLE='text-align:right;'>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strFooter2Left),
				ConvertToHTMLEmbeddable(hfi.strFooter2Right));
		}
	}
	if (!hfi.strFooterLeft.IsEmpty() || !hfi.strFooterRight.IsEmpty()) {
		if (hfi.strFooterLeft.IsEmpty() || hfi.strFooterRight.IsEmpty()) {
			// make one column

			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:center;' COLSPAN=2>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strFooterLeft.IsEmpty() ? hfi.strFooterRight : hfi.strFooterLeft));
		} else {
			// (a.walling 2010-01-12 16:32) - PLID 36845 - The header and footer text itself must be escaped for HTML
			strHTML += FormatString(
				"<TR>"
					"<TD STYLE='text-align:left;'>%s</TD>"
					"<TD STYLE='text-align:right;'>%s</TD>"
				"</TR>", 
				ConvertToHTMLEmbeddable(hfi.strFooterLeft),
				ConvertToHTMLEmbeddable(hfi.strFooterRight));
		}
	}

	strHTML += 
			"</TABLE>"
		"</DIV>";
}

// (z.manning 2008-10-09 16:05) - PLID 31628 - Gets all details with the given lab ID
void CEMN::GetDetailsByLabID(IN const long nLabID, OUT CArray<CEMNDetail*,CEMNDetail*> &m_arypDetails)
{
	for(int nTopic = 0; nTopic < m_arypEMRTopics.GetSize(); nTopic++) {
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(nTopic);
		pTopic->GetDetailsByLabID(nLabID, m_arypDetails);
	}
}

// (j.jones 2009-04-01 15:03) - PLID 33736 - added ability to reload medications from data
// if bForceReload is FALSE, we will only perform this reload if we have any medication objects already loaded
// (j.jones 2013-02-07 09:25) - PLID 55045 - now takes in an optional parameter to disable
// showing drug interactions when the requery finishes
void CEMN::ReloadPatientMedicationsFromData(BOOL bForceReload, BOOL bShowDrugInteractions /*= TRUE*/)
{
	//throw exceptions to the caller

	if(m_bIsTemplate) {
		//this is supported on patient EMNs only
		ASSERT(FALSE);
		return;
	}

	//if we have no medications and aren't forcing a reload, return now
	if(m_aryMedications.GetSize() == 0 && !bForceReload) {
		return;
	}

	long nEMNID = GetID();

	if(IsUnsaved() || nEMNID == -1) {
		//this should have never be called on an unsaved EMN, but if so, force a save
		CEmrTreeWnd *pTreeWnd = GetInterface();
		//TES 2/12/2014 - PLID 60740 - No need to check IsMoreInfoUnsaved() if we've already checked IsUnsaved()
		if(!IsLoading() && pTreeWnd && (IsUnsaved() || GetID() == -1)) {
			BOOL bFailed = FALSE;
			if(!IsWritable() || FAILED(pTreeWnd->SaveEMR(esotEMN, (long)this, FALSE))) {
				bFailed = TRUE;
			}
			if(bFailed) {
				//if the EMN is new, we cannot possibly continue, so tell them that
				if(nEMNID == -1) {
					pTreeWnd->MessageBox("The EMN must be saved before medications can be added or modified.", "Practice", MB_ICONEXCLAMATION|MB_OK);
					return;
				}
			}
		}
	}

	BOOL bHadMedicationsBeforeReload = (m_aryMedications.GetSize() > 0);

	//clear all our loaded meds
	for(int i=0; i<m_aryMedications.GetSize(); i++) {
		delete (EMNMedication*)m_aryMedications.GetAt(i);
	}
	m_aryMedications.RemoveAll();

	//and reload from data
	// (d.thompson 2009-04-02) - PLID 33571 - added strength unit
	// (a.walling 2009-04-22 13:50) - PLID 33948 - EPrescribe option	
	// (a.walling 2009-05-04 09:49) - PLID 28495 - Diag code
	// (a.walling 2009-05-04 09:50) - PLID 33751 - Chronicity
	// (c.haag 2009-05-12 12:19) - PLID 34234 - Problem link table
	//TES 5/14/2009 - PLID 28519 - Added SampleExpirationDate
	// (c.haag 2009-05-20 10:15) - PLID 34310 - Added EmrProblemLinkID
	// (a.walling 2009-07-01 13:35) - PLID 34052 - Added AgentID, SupervisorID
	//TES 8/3/2009 - PLID 35008 - Added DEASchedule
	// (z.manning 2010-02-25 10:22) - PLID 37532
	// (j.jones 2010-05-07 11:02) - PLID 36062 - added EnglishDescription
	// (j.jones 2012-10-29 16:06) - PLID 53259 - added QueueStatus
	// (b.savon 2013-01-16 16:10) - PLID 54656 - Removed AgentID
	// (s.dhole 2013-03-07 12:29) - PLID 55509 Added StrengthUnitID , DosageFormID ,QuantityUnitID
	// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
	// (b.spivey, October 22, 2013) - PLID 58677 - added codeID
	_RecordsetPtr rsMedications = CreateParamRecordset("SELECT EmrMedicationsT.EmrID, PatientMedications.ID, PatientMedications.MedicationID, "
			"PatientMedications.PatientExplanation, PatientMedications.EnglishDescription, RefillsAllowed, Quantity, "
			" CASE WHEN QuantityUnitQ.ID IS NOT NULL THEN QuantityUnitQ.Name ELSE PatientMedications.Unit END AS unit, "
			" SourceActionID, SourceDetailID, EmrDataT.Data AS DrugName, "
			"PatientMedications.ProviderID, PatientMedications.LocationID, PatientMedications.PharmacyID, PatientMedications.PrescriptionDate, "
			"PatientMedications.Strength, DrugDosageFormsT.Name AS DosageForm, StrengthUnitT.Name AS StrengthUnit, "
			"PatientMedications.DaysSupply, PatientMedications.NoteToPharmacist, PatientMedications.AllowSubstitutions, "
			"PatientMedications.PriorAuthorization, PatientMedications.PriorAuthorizationIsSample, SourceType, "
			"SourceDataGroupID, NewCropGUID, Discontinued, EPrescribe, PatientMedications.SampleExpirationDate, "
			"SupervisorID, DrugList.DEASchedule, SourceDetailImageStampID, PatientMedications.QueueStatus, "
			"PatientMedications.StrengthUnitID , PatientMedications.DosageFormID ,PatientMedications.QuantityUnitID,  "
			"PatientMedications.DosageUnitID, PatientMedications.DosageRouteID, PatientMedications.DosageQuantity, PatientMedications.DosageFrequency "
			"FROM PatientMedications INNER JOIN EmrMedicationsT ON PatientMedications.ID = EmrMedicationsT.MedicationID "
			"LEFT JOIN DrugList ON PatientMedications.MedicationID = DrugList.ID "
			"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
			"LEFT JOIN DrugDosageFormsT ON PatientMedications.DosageFormID = DrugDosageFormsT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS StrengthUnitT ON PatientMedications.StrengthUnitID = StrengthUnitT.ID "
			"LEFT JOIN EmrActionsT ON EmrMedicationsT.SourceActionID = EmrActionsT.ID "
			"LEFT JOIN DrugStrengthUnitsT AS QuantityUnitQ ON PatientMedications.QuantityUnitID = QuantityUnitQ.ID "
			"WHERE EMRMedicationsT.Deleted = 0 AND EmrMedicationsT.EmrID = {INT} "
			""
			"SELECT EMRMedicationsT.EMRID, EMRMedicationsT.MedicationID AS ID, PatientMedicationDiagCodesT.DiagCodeID, "
			"DiagCodes.CodeNumber, DiagCodes.CodeDesc, PatientMedicationDiagCodesT.SortOrder "
			"FROM PatientMedicationDiagCodesT LEFT JOIN DiagCodes ON PatientMedicationDiagCodesT.DiagCodeID = DiagCodes.ID "
			"LEFT JOIN EMRMedicationsT ON PatientMedicationDiagCodesT.PatientMedicationID = EMRMedicationsT.MedicationID "
			"WHERE EMRMedicationsT.Deleted = 0 AND EMRMedicationsT.EMRID = {INT} "
			"ORDER BY DiagCodes.CodeNumber "
			""
			// (z.manning 2009-05-27 10:09) - PLID 34297 - Added patient ID
			// (j.jones 2014-02-24 15:44) - PLID 61010 - EMR problems now have ICD-9 and 10 IDs
			// (a.walling 2014-07-23 09:09) - PLID 63003 - Filter on EMRProblemsT.PatientID when possible
			// (s.tullis 2015-02-23 15:44) - PLID 64723 
			// (r.gonet 2015-03-09 18:21) - PLID 65008 - Added DoNotShowOnProblemPrompt
			"SELECT EMRProblemsT.ID, (SELECT EMRID FROM EMRMedicationsT WHERE MedicationID = EmrRegardingID) AS EMRID, Description, EnteredDate, ModifiedDate, StatusID, OnsetDate, "
			"EmrRegardingType, EmrRegardingID, EMRDataID, EmrProblemActionID, DiagCodeID, DiagCodeID_ICD10, ChronicityID, EmrProblemLinkT.ID AS EmrProblemLinkID, EmrProblemsT.PatientID, "
			"EMRProblemsT.CodeID, EmrProblemsT.DoNotShowOnCCDA, EMRProblemsT.DoNotShowOnProblemPrompt "
			"FROM EMRProblemsT "
			"INNER JOIN EMRProblemLinkT ON EMRProblemLinkT.EMRProblemID = EMRProblemsT.ID "
			"WHERE PatientID = {INT} AND Deleted = 0 AND EmrRegardingType = {CONST_INT} AND EmrRegardingID IN "
			"(SELECT MedicationID FROM EMRMedicationsT WHERE Deleted = 0 AND EMRID IN (SELECT ID FROM EmrMasterT WHERE Deleted = 0 AND ID = {INT})) "
			, nEMNID, nEMNID, GetParentEMR()->GetPatientID(), eprtEmrMedication, nEMNID);

	while(!rsMedications->eof) {
		AddMedicationFromRecordset(rsMedications);
		rsMedications->MoveNext();
	}

	// (j.jones 2013-02-07 09:33) - PLID 55045 - Assume medications changed unless
	// we had no prescriptions before or after reloading. bMedicationsChanged will
	// intentionally be true if the list is non-empty, but otherwise unchanged,
	// since it is possible the contents of medications may have changed.
	BOOL bHasMedicationsAfterReload = (m_aryMedications.GetSize() > 0);
	BOOL bMedicationsChanged = TRUE;
	if(!bHadMedicationsBeforeReload && !bHasMedicationsAfterReload) {
		bMedicationsChanged = FALSE;
	}

	//now load diagnosis codes
	rsMedications = rsMedications->NextRecordset(NULL);
	while(!rsMedications->eof) {
		//We just need to append each code to its EMNMedication
		long nMedID = AdoFldLong(rsMedications, "ID");
		long nDiagID = AdoFldLong(rsMedications, "DiagCodeID");
		CString strCodeNumber = AdoFldString(rsMedications, "CodeNumber");
		CString strCodeDesc = AdoFldString(rsMedications, "CodeDesc");
		long nSortOrder = AdoFldLong(rsMedications, "SortOrder");

		BOOL bFound = FALSE;
		for(int i = 0; i < m_aryMedications.GetSize() && !bFound; i++) {
			EMNMedication *pMed = m_aryMedications.GetAt(i);
			if(pMed->nID == nMedID) {
				bFound = TRUE;
				Med_DiagCodeInfo dci;
				dci.nID = nDiagID;
				dci.strCodeNumber = strCodeNumber;
				dci.strCodeDesc = strCodeDesc;
				dci.nSortOrder = nSortOrder;
				pMed->aryDiagnoses.Add(dci);
			}
		}

		rsMedications->MoveNext();
	}

	//now load problems
	rsMedications = rsMedications->NextRecordset(NULL);

	FieldsPtr f = rsMedications->Fields;

	// (c.haag 2009-05-16 11:19) - PLID 34310 - Traverse through the recordset, which
	// has one entry for every record in the Emr Problem Link table.
	//
	CEmnLoaderProblemLinkMap mapProblemLinks;
	CMap<long,long,CEmrProblem*,CEmrProblem*> mapLoadedProblems;
	ASSERT(NULL != GetParentEMR());

	while(!rsMedications->eof) {
		EMRProblemRegardingTypes RegardingType = (EMRProblemRegardingTypes)AdoFldLong(f, "EmrRegardingType");
		const long nEmrProblemLinkID = AdoFldLong(f, "EmrProblemLinkID");
		const long nRegardingID = AdoFldLong(f, "EmrRegardingID");
		const long nEMRProblemID = AdoFldLong(f, "ID");
		const long nEMRDataID = AdoFldLong(f, "EMRDataID", -1);

		// Ensure the problem exists in memory
		CEmrProblem* pProblem = NULL;
		if (!mapLoadedProblems.Lookup(nEMRProblemID, pProblem)) {
			// The problem wasn't loaded from this recordset. The EMR is responsible for
			// allocating the problem for us. If it already exists in memory, however, the
			// EMR will give that one to us.
			pProblem = GetParentEMR()->AllocateEmrProblem(f);
			mapLoadedProblems.SetAt(nEMRProblemID, pProblem);
		} else {
			// The problem itself was already loaded. If we get here, it means
			// this problem is linked with multiple items.
		}
		// (c.haag 2009-05-16 11:27) - PLID 34310 - Now create the problem link item
		CEmrProblemLink pl(pProblem, nEmrProblemLinkID, RegardingType, nRegardingID, nEMRDataID);

		// Add this problem to the problem map
		CEmrProblemLinkAry* pary = NULL;
		
		// Get the array. Create it if it doesn't exist
		mapProblemLinks.Lookup(nRegardingID, pary);
		if (NULL == pary) {
			pary = new CEmrProblemLinkAry;
			mapProblemLinks.SetAt(nRegardingID, pary);
		}
		// Add the element to the array
		if (NULL != pary) {
			pary->Add(pl);
		} else {
			ASSERT(FALSE); // This should never happen
		}

		rsMedications->MoveNext();
	}
	rsMedications->Close();

	//attach the problems to our medications
	for(int i=0; i<m_aryMedications.GetSize(); i++) {
		EMNMedication *pMed = m_aryMedications.GetAt(i);
		CEmrProblemLinkAry *pAry = NULL;

		if(mapProblemLinks.Lookup(pMed->nID, pAry)) {
			//Found problems
			for(int j = 0; j < pAry->GetSize(); j++) {
				CEmrProblemLink *pNewLink = new CEmrProblemLink(pAry->GetAt(j));
				pNewLink->UpdatePointersWithMedication(this, pMed);
				pMed->m_apEmrProblemLinks.Add(pNewLink);
			}
		}
	}

	//now clear our problem link map
	POSITION pos = mapProblemLinks.GetStartPosition();
	while (pos != NULL) {
		CEmrProblemLinkAry* pAry;
		long nRegardingID;
		mapProblemLinks.GetNextAssoc( pos, nRegardingID, pAry );
		if(pAry) {
			delete pAry;
		}
	}
	mapProblemLinks.RemoveAll();

	// (c.haag 2009-05-16 11:32) - PLID 34310 - At this point, all the CEMRProblem objects
	// we created have one reference for every problem link item, as well as one reference
	// which belongs to the map. Since the map is being destroyed, we must dereference every
	// problem.
	pos = mapLoadedProblems.GetStartPosition();
	while (pos != NULL) {
		long nEMRProblemID;
		CEmrProblem* pProblem;
		mapLoadedProblems.GetNextAssoc( pos, nEMRProblemID, pProblem );
		ASSERT(pProblem->GetRefCnt() > 1);
		pProblem->Release();
	}

	//almost done - we need to update the more info screen if it exists
	if(GetInterface()) {
		GetInterface()->SendMessage(NXM_EMN_REFRESH_PRESCRIPTIONS, (WPARAM)this);
	}

	// (j.jones 2012-10-01 08:45) - PLID 52922 - this function will check their preference
	// to save the EMN and warn about drug interactions
	// We should not do this if the EMN is loading. This function will be called again
	// when loading is finished, if meds. exist.
	if(!m_bIsTemplate && bMedicationsChanged) {
		if(!IsLoading() && bShowDrugInteractions) {
			// (j.jones 2012-11-13 10:10) - PLID 52869 - changed to be a posted message
			// (j.jones 2013-02-06 16:28) - PLID 55045 - Medication changes save immediately now,
			// so pass in TRUE for the lParam to tell this function that we already saved the changes
			// and the interactions should open if it was otherwise waiting for a save to succeed.
			CheckSaveEMNForDrugInteractions(TRUE);
		}
		else {
			//flag that interactions could have changed, such that we try to warn when closing the EMN,
			//if the preference says to do so
			CEmrTreeWnd *pTree = GetInterface();
			if(pTree != NULL) {
				pTree->m_bDrugInteractionsChangedThisSession = TRUE;
			}
		}
	}
}

// (j.jones 2009-04-01 15:21) - PLID 33736 - shared this function between loading from an EMN, and ReloadPatientMedicationsFromData
void CEMN::AddMedicationFromRecordset(ADODB::_RecordsetPtr &rsMedications, OPTIONAL IN ADODB::_Connection *lpCon /*= NULL*/)
{
	//throw exceptions to the caller

	if(rsMedications->eof) {
		//shouldn't be possible
		ASSERT(FALSE);
		ThrowNxException("CEMN::AddMedicationFromRecordset called with an empty recordset!");
	}

	_ConnectionPtr pCon;
	if(lpCon) {
		pCon = lpCon;
	}
	else {
		pCon = GetRemoteData();
	}

	EMNMedication *pNewMedication = new EMNMedication;
	pNewMedication->nID = AdoFldLong(rsMedications, "ID");
	pNewMedication->nMedicationID = AdoFldLong(rsMedications, "MedicationID");
	//TES 2/10/2009 - PLID 33034 - Renamed Description to PatientExplanation
	pNewMedication->strPatientExplanation = AdoFldString(rsMedications, "PatientExplanation","");
	// (j.jones 2010-05-07 11:05) - PLID 36062 - load the EnglishDescription
	pNewMedication->strEnglishDescription = AdoFldString(rsMedications, "EnglishDescription","");
	pNewMedication->strRefillsAllowed = AdoFldString(rsMedications, "RefillsAllowed","");
	//TES 2/10/2009 - PLID 33034 - Renamed PillsPerBottle to Quantity
	pNewMedication->strQuantity = AdoFldString(rsMedications, "Quantity","");
	pNewMedication->strUnit = AdoFldString(rsMedications, "Unit","");
	pNewMedication->SetUnchanged();
	pNewMedication->sai.nSourceActionID = AdoFldLong(rsMedications, "SourceActionID", -1);
	// (j.jones 2007-01-11 10:20) - PLID 24027 - supported SourceDetailID
	pNewMedication->sai.nSourceDetailID = AdoFldLong(rsMedications, "SourceDetailID", -1);
	// (z.manning 2009-02-26 16:41) - PLID 33141 - SourceDataGroupID
	pNewMedication->sai.SetDataGroupID(AdoFldLong(rsMedications, "SourceDataGroupID", -1));
	// (z.manning 2010-02-25 10:21) - PLID 37532
	pNewMedication->sai.SetDetailStampID(AdoFldLong(rsMedications, "SourceDetailImageStampID", -1));
	pNewMedication->sai.eaoSourceType = (EmrActionObject)AdoFldLong(rsMedications, "SourceType", eaoInvalid);
	pNewMedication->m_strDrugName = AdoFldString(rsMedications, "DrugName", "");

	// (j.jones 2008-05-20 10:03) - PLID 30079 - added other fields that the prescription editor uses
	pNewMedication->nProviderID = AdoFldLong(rsMedications, "ProviderID", -1);
	pNewMedication->nLocationID = AdoFldLong(rsMedications, "LocationID", -1);
	pNewMedication->nPharmacyID = AdoFldLong(rsMedications, "PharmacyID", -1);
	if(GetParentEMR()) {
		pNewMedication->nPatientID = GetParentEMR()->GetPatientID();
		// (j.jones 2008-10-31 13:30) - PLID 31869 - send our connection into this function
		// (a.walling 2014-01-06 12:43) - PLID 59996 - No connection pointers for these existing patient functions
		pNewMedication->strPatientName = GetExistingPatientName(pNewMedication->nPatientID);
	}
	else {
		pNewMedication->nPatientID = -1;
		pNewMedication->strPatientName = "";
	}
	pNewMedication->dtPrescriptionDate = AdoFldDateTime(rsMedications, "PrescriptionDate", COleDateTime::GetCurrentTime());

	//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
	//TES 3/31/2009 - PLID 33750 - Removed DosageFormID
	pNewMedication->strStrength = AdoFldString(rsMedications, "Strength", "");
	pNewMedication->strDosageForm = AdoFldString(rsMedications, "DosageForm", "");
	// (d.thompson 2009-04-02) - PLID 33571 - added strength unit
	pNewMedication->strStrengthUnit = AdoFldString(rsMedications, "StrengthUnit", "");
	//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
	pNewMedication->nDaysSupply = AdoFldLong(rsMedications, "DaysSupply", -1);
	pNewMedication->strNoteToPharmacist = AdoFldString(rsMedications, "NoteToPharmacist", "");
	pNewMedication->bAllowSubstitutions = AdoFldBool(rsMedications, "AllowSubstitutions", TRUE);
	pNewMedication->strPriorAuthorization = AdoFldString(rsMedications, "PriorAuthorization", "");
	pNewMedication->bPriorAuthIsSample = AdoFldBool(rsMedications, "PriorAuthorizationIsSample", FALSE);
	//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	pNewMedication->dtSampleExpirationDate = AdoFldDateTime(rsMedications, "SampleExpirationDate", dtInvalid);

	// (j.jones 2009-04-01 15:59) - PLID 33736 - added NewCropGUID and Discontinued
	pNewMedication->strNewCropGUID = AdoFldString(rsMedications, "NewCropGUID", "");
	pNewMedication->bIsDiscontinued = AdoFldBool(rsMedications, "Discontinued", FALSE);

	// (a.walling 2009-04-22 11:19) - PLID 33948 - added EPrescribe
	pNewMedication->bEPrescribe = AdoFldBool(rsMedications, "EPrescribe", FALSE);

	// (a.walling 2009-07-01 13:38) - PLID 34052 - added AgentID and SupervisorID
	// (b.savon 2013-01-16 16:10) - PLID 54656 - Removed AgentID
	pNewMedication->nSupervisorID = AdoFldLong(rsMedications, "SupervisorID", -1);

	//TES 8/3/2009 - PLID 35008 - Added DEASchedule
	pNewMedication->strDEASchedule = AdoFldString(rsMedications, "DEASchedule", "");

	// (j.jones 2012-10-29 16:06) - PLID 53259 - added the E-Rx status
	pNewMedication->eQueueStatus = (PrescriptionQueueStatus)AdoFldLong(rsMedications, "QueueStatus");
	
	// (s.dhole 2013-03-07 12:36) - PLID  55509
	pNewMedication->nStrengthUnitID = AdoFldLong(rsMedications, "StrengthUnitID", -1);
	pNewMedication->nDosageFormID = AdoFldLong(rsMedications, "DosageFormID", -1);
	pNewMedication->nQuantityUnitID = AdoFldLong(rsMedications, "QuantityUnitID", -1);
	// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
	pNewMedication->nDosageUnitID = AdoFldLong(rsMedications, "DosageUnitID", -1);
	pNewMedication->nDosageRouteID = AdoFldLong(rsMedications, "DosageRouteID", -1);
	pNewMedication->strDosageQuantity = AdoFldString(rsMedications, "DosageQuantity", "");
	pNewMedication->strDosageFrequency = AdoFldString(rsMedications, "DosageFrequency", "");

	m_aryMedications.Add(pNewMedication);

	//do not close the recordset or move next, the caller is responsible for both
}

// (j.jones 2012-11-21 14:19) - PLID 53818 - shared this function from loading a template and ReloadTemplateMedicationsFromData
void CEMN::AddTemplateMedicationFromRecordset(BOOL bIsTemplate, ADODB::_RecordsetPtr &rsMedications)
{
	//throw exceptions to the caller

	if(rsMedications->eof) {
		//shouldn't be possible
		ASSERT(FALSE);
		ThrowNxException("CEMN::AddTemplateMedicationFromRecordset called with an empty recordset!");
	}

	EMNMedication *pNewMedication = new EMNMedication;
	if(bIsTemplate)
		pNewMedication->nID = AdoFldLong(rsMedications, "ID", -1);
	else
		pNewMedication->nID = -1;
	pNewMedication->nMedicationID = AdoFldLong(rsMedications, "MedicationID");
	//TES 2/10/2009 - PLID 33034 - Renamed Description to PatientExplanation
	pNewMedication->strPatientExplanation = AdoFldString(rsMedications, "PatientExplanation","");
	// (j.jones 2010-05-07 11:05) - PLID 36062 - calculate the EnglishDescription
	pNewMedication->strEnglishDescription = GetLatinToEnglishConversion(pNewMedication->strPatientExplanation);
	pNewMedication->strRefillsAllowed = AdoFldString(rsMedications, "RefillsAllowed","");			
	//TES 2/10/2009 - PLID 33034 - Renamed PillsPerBottle to Quantity
	pNewMedication->strQuantity = AdoFldString(rsMedications, "Quantity","");
	pNewMedication->strUnit = AdoFldString(rsMedications, "Unit","");
	if(bIsTemplate)
		pNewMedication->SetUnchanged();
	else
		pNewMedication->SetChanged_Deprecated();
	pNewMedication->m_strDrugName = AdoFldString(rsMedications, "DrugName","");
	//TES 2/12/2009 - PLID 33034 - Added Strength and DosageFormID
	//TES 3/31/2009 - PLID 33750 - Removed DosageFormID
	pNewMedication->strStrength = AdoFldString(rsMedications, "Strength", "");
	pNewMedication->strDosageForm = AdoFldString(rsMedications, "DosageForm", "");
	// (d.thompson 2009-04-02) - PLID 33571 - Added strength unit
	pNewMedication->strStrengthUnit = AdoFldString(rsMedications, "StrengthUnit", "");
	//TES 2/17/2009 - PLID 33140 - Added more SureScripts fields
	pNewMedication->nDaysSupply = AdoFldLong(rsMedications, "DaysSupply", -1);
	pNewMedication->strNoteToPharmacist = AdoFldString(rsMedications, "NoteToPharmacist", "");
	pNewMedication->bAllowSubstitutions = AdoFldBool(rsMedications, "AllowSubstitutions", TRUE);
	pNewMedication->strPriorAuthorization = AdoFldString(rsMedications, "PriorAuthorization", "");
	pNewMedication->bPriorAuthIsSample = AdoFldBool(rsMedications, "PriorAuthorizationIsSample", FALSE);
	//TES 5/11/2009 - PLID 28519 - Added SampleExpirationDate
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	pNewMedication->dtSampleExpirationDate = AdoFldDateTime(rsMedications, "SampleExpirationDate", dtInvalid);
	//TES 8/3/2009 - PLID 35008 - Added DEASchedule
	pNewMedication->strDEASchedule = AdoFldString(rsMedications, "DEASchedule", "");
	
	pNewMedication->nStrengthUnitID = AdoFldLong(rsMedications, "StrengthUnitID", -1);
	pNewMedication->nDosageFormID = AdoFldLong(rsMedications, "DosageFormID", -1);
	pNewMedication->nQuantityUnitID = AdoFldLong(rsMedications, "QuantityUnitID", -1);
	// (j.fouts 2013-04-23 14:55) - PLID 55101 - Added Dosage Unit, Quantity, Route, and Frequency
	pNewMedication->nDosageUnitID = AdoFldLong(rsMedications, "DosageUnitID", -1);
	pNewMedication->nDosageRouteID = AdoFldLong(rsMedications, "DosageRouteID", -1);
	pNewMedication->strDosageQuantity = AdoFldString(rsMedications, "DosageQuantity", "");
	pNewMedication->strDosageFrequency = AdoFldString(rsMedications, "DosageFrequency", "");

	// (j.jones 2008-05-20 10:03) - PLID 30079 - added other fields that the prescription editor uses
	pNewMedication->nProviderID = -1;
	
	if(!m_bIsTemplate) {
		//try to use the first provider, if we have one
		if(m_aryProviders.GetSize() > 0) {
			EMNProvider *pProv = GetProvider(0);
			if(pProv) {
				pNewMedication->nProviderID = pProv->nID;
			}
		}
	}

	pNewMedication->nLocationID = -1;

	if(!m_bIsTemplate) {
		//try to use the EMN location, otherwise the current location
		pNewMedication->nLocationID = GetLocationID();
		if(pNewMedication->nLocationID == -1) {
			pNewMedication->nLocationID = GetCurrentLocationID();
		}
	}

	pNewMedication->nPharmacyID = -1;
	
	pNewMedication->nPatientID = -1;
	pNewMedication->strPatientName = "";

	if(!m_bIsTemplate && GetParentEMR()) {
		pNewMedication->nPatientID = GetParentEMR()->GetPatientID();
		pNewMedication->strPatientName = GetExistingPatientName(pNewMedication->nPatientID);
	}

	pNewMedication->dtPrescriptionDate = COleDateTime::GetCurrentTime();

	m_aryMedications.Add(pNewMedication);
}

// (c.haag 2009-05-13 15:22) - PLID 34256 - Added the ability to resynchronize all allergy details
// for all possible EMN's with the patient's official allergies.
// (j.jones 2009-09-18 13:12) - PLID 35599 - this should only be done from NewCrop usage, so I renamed accordingly
// (z.manning 2011-09-22 15:17) - PLID 45623 - Moved this here from CEMR
// (j.jones 2013-02-12 15:38) - PLID 55139 - this is now callable outside of NewCrop, so I renamed it back
void CEMN::ReloadPatientAllergiesFromData(long nOldAllergiesInfoID, long nNewAllergiesInfoID)
{
	//throw exceptions to the caller

	if(m_bIsTemplate) {
		//this is supported on patient EMRs only
		ASSERT(FALSE);
		return;
	}

	// (c.haag 2009-07-21 17:26) - PLID 34256 - In this reload, also reset the cached "Official"
	// allergy ID.
	m_pParentEMR->SetCurrentAllergiesInfoID(-2);

	// Load the selected patient allergies
	CArray<long,long> anAllergies;
	_RecordsetPtr prs = CreateParamRecordset("SELECT EMRDataT.ID AS EmrDataID FROM PatientAllergyT "
		"LEFT JOIN AllergyT ON AllergyT.ID = PatientAllergyT.AllergyID "
		"LEFT JOIN EMRDataT ON AllergyT.EMRDataID = EMRDataT.ID "
		"WHERE PersonID = {INT} AND Discontinued = 0 "
		"ORDER BY EMRDataT.Data ", m_pParentEMR->GetPatientID());
	while (!prs->eof) {
		anAllergies.Add(AdoFldLong(prs, "EmrDataID"));
		prs->MoveNext();
	}
	prs->Close();

	ReloadPatientAllergiesFromData(nOldAllergiesInfoID, nNewAllergiesInfoID, anAllergies);
}

// (c.haag 2009-05-15 09:57) - PLID 34271 - Added the ability to resynchronize all current medications details
// for all possible EMN's with the patient's official current medications.
// Links that have been deleted are not returned by default, unless bIncludeDeletedLinks is TRUE
// (j.jones 2009-09-18 13:12) - PLID 35599 - this should only be done from NewCrop usage, so I renamed accordingly
// (c.haag 2010-02-18 11:16) - PLID 37424 - We now include the entire browser result so that we can also read which
// patient prescriptions were added in the same session
// (z.manning 2011-09-22 15:17) - PLID 45623 - Moved this here from CEMR
void CEMN::ReloadPatientCurrentMedicationsFromData_ForNewCrop(NewCropBrowserResult* pNCBR)
{
	//throw exceptions to the caller

	if(m_bIsTemplate) {
		//this is supported on patient EMRs only
		ASSERT(FALSE);
		return;
	}

	// (c.haag 2009-07-21 17:26) - PLID 34271 - In this reload, also reset the cached "Official" current
	// medication ID.
	m_pParentEMR->SetCurrentMedicationsInfoID(-2);

	// Load the selected patient current medications
	CArray<long,long> anCurMeds;
	CMap<long, long, CString, LPCTSTR> mapDataIDsToSig;
	
	_RecordsetPtr prs = CreateParamRecordset("SELECT EMRDataT.ID AS EmrDataID, CurrentPatientMedsT.Sig "
		"FROM CurrentPatientMedsT "
		"LEFT JOIN DrugList ON DrugList.ID = CurrentPatientMedsT.MedicationID "
		"LEFT JOIN EMRDataT ON DrugList.EMRDataID = EMRDataT.ID "
		"WHERE PatientID = {INT} AND Discontinued = 0 "
		"ORDER BY EMRDataT.Data ", m_pParentEMR->GetPatientID());
	while (!prs->eof) {
		long nDataID = AdoFldLong(prs, "EmrDataID");
		anCurMeds.Add(nDataID);
		// (j.jones 2011-05-04 14:29) - PLID 43527 - track the Sig
		mapDataIDsToSig.SetAt(nDataID, AdoFldString(prs, "Sig", ""));
		prs->MoveNext();
	}
	prs->Close();

	// (j.jones 2013-01-08 09:56) - PLID 47302 - We used to open medication reconciliation here,
	// but that has been moved so that it happens prior to this function being called. We always
	// have to reconcile medications, but we might not always be reloading the current meds.
	// (j.jones 2013-01-11 13:45) - PLID 54462 - We now have a preference that dictates whether
	// reconciliation updates the blue table. That means that reconciliation can now optionally
	// be called either before or after this function - but never inside it.

	ReloadPatientCurrentMedicationsFromData_ForNewCrop(pNCBR->nOldCurrentMedicationsInfoID, pNCBR->nNewCurrentMedicationsInfoID, anCurMeds, mapDataIDsToSig);
}

// (c.haag 2009-05-13 15:25) - PLID 34256 - Added ability to load patient allergies from data
// and resynchronize all official Allergies details with it
// (j.jones 2009-09-18 13:12) - PLID 35599 - this should only be done from NewCrop usage, so I renamed accordingly
// (j.jones 2013-02-12 15:38) - PLID 55139 - this is now callable outside of NewCrop, so I renamed it back
void CEMN::ReloadPatientAllergiesFromData(long nOldAllergiesInfoID, long nNewAllergiesInfoID, const CArray<long,long>& anAllergies)
{
	//throw exceptions to the caller

	if(m_bIsTemplate) {
		//this is supported on patient EMNs only
		ASSERT(FALSE);
		return;
	}

	// Make sure this EMN is completely loaded.
	EnsureCompletelyLoaded();

	// Do nothing if this EMN is locked
	if (IsLockedAndSaved()) {
		return;
	}

	BOOL bForceSaveEMN = FALSE;

	// At this point, we should have a fully loaded, saved, unlocked EMN. We should be good to
	// find all the allergy details and update them now
	const int nDetailCount = GetTotalDetailCount();
	for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
		CEMNDetail* pCurrentDetail = GetDetail(nDetail);

		// See whether this detail is based on the old active Allergies EMR info item, and needs to
		// be brought up to date
		// (j.jones 2011-08-15 14:12) - PLID 45033 - It is possible that the allergy data has since been updated
		// by another user, and the table is still blue, but is not actually the prior info ID anymore. 
		// Because the current user still thinks the table is up to date, bring it up to date as well even though
		// if is not the old info ID we expected.
		// So now we bring up to date if the table is an allergies table, and it is out of date,
		// and the EMRInfoID is either the old info ID, or if the table window thinks it is active,
		// or if the detail pointer thinks its active
		if(pCurrentDetail->IsAllergiesTable() && pCurrentDetail->m_nEMRInfoID != nNewAllergiesInfoID
			&& ((pCurrentDetail->m_nEMRInfoID == nOldAllergiesInfoID && nOldAllergiesInfoID != nNewAllergiesInfoID)
				|| (pCurrentDetail->m_pEmrItemAdvDlg && ((CEmrItemAdvTableDlg*)(pCurrentDetail->m_pEmrItemAdvDlg))->GetIsActiveAllergiesTable())
				|| pCurrentDetail->IsActiveInfo()))
		{
			// Yes, changes were made to the allergies table; and this detail used to be active before
			// those changes, but no longer is. Bring it up to date using code modeled from EmrItemAdvDlg.

			//Now, set that in data (otherwise, the detail will re-set itself to the old info ID.)
			// (c.haag 2009-08-17 10:11) - PLID 35246 - This belongs in a transaction
			{
				CSqlTransaction sqlTrans("ReloadPatientAllergiesFromData_UpdateItem");
				sqlTrans.Begin();

				if(pCurrentDetail->m_nEMRDetailID != -1) {
					ExecuteParamSql("UPDATE EmrDetailsT SET EmrInfoID = {INT} WHERE ID = {INT}", 
						nNewAllergiesInfoID, pCurrentDetail->m_nEMRDetailID);

					// (j.jones 2010-11-11 17:26) - PLID 29075 - force the EMN to save
					bForceSaveEMN = TRUE;
				}
				// Update the detail's EMR info ID now. If we don't do this, UpdateInfoID will throw an exception because
				// it calls LoadContent, and throws an eof error because it queries on EMR details with the ID of m_nEMRDetailID
				// and the EMR Info ID of nNewAllergiesInfoID
				// (c.haag 2009-07-21 17:27) - This no longer appears to happen. But FYI: This code was modeled from CEmrItemAdvDlg::UpdateItem
				//pCurrentDetail->m_nEMRInfoID = nNewAllergiesInfoID;
				//Now, tell the detail to reload its content.
				// (j.jones 2011-08-15 15:04) - PLID 45033 - the old ID might be older than the current "old ID", so be sure to send
				// the actual InfoID of the detail
				pCurrentDetail->UpdateInfoID(pCurrentDetail->m_nEMRInfoID, nNewAllergiesInfoID, NULL, pCurrentDetail->m_nEMRDetailID);

				// Commit the transaction
				sqlTrans.Commit();

				pCurrentDetail->SetNeedContentReload();
				pCurrentDetail->SetNeedSyncContentAndState();
				// Now if the detail is on the screen, we should inform the main frame that it has changed. Do this for consistency
				// with times where users manually edit EMR items on a topic.
				if (NULL != pCurrentDetail->m_pEmrItemAdvDlg && IsWindow(pCurrentDetail->m_pEmrItemAdvDlg->GetSafeHwnd())) {
					//Now, post a message that will call PostEmrItemEntryDlgSaved(), see Chris's note in OpenEmrItemEntryDlg()
					// for why we don't call it directly.
					GetMainFrame()->PostMessage(NXM_EMRITEMADVDLG_ITEM_SAVED, (WPARAM)pCurrentDetail);
				}
				//Tell it that it's now up to date.
				pCurrentDetail->RefreshIsActiveInfo();
			}
		}

		// Now see if this detail is based on the active current allergy item; and if so, update the
		// checkbox column
		if(pCurrentDetail->m_nEMRInfoID == nNewAllergiesInfoID) {
			_variant_t vOldState = pCurrentDetail->GetState();
			// (j.jones 2009-09-18 13:00) - PLID 35599 - bUpdateExisting is TRUE here because if this came
			// from NewCrop, we DO want to update saved medication items
			ApplyOfficialAllergies(pCurrentDetail, nNewAllergiesInfoID, anAllergies, TRUE);
			_variant_t vNewState = pCurrentDetail->GetState();
			if (VARCMP_EQ != VariantCompare(&vOldState, &vNewState)) {
				// If the state changed, then do a formal request for the change. If we don't do
				// this, then the detail can be unsaved.
				pCurrentDetail->RequestStateChange(vNewState, vOldState);
			}
			// Make sure the content reflects the state
			pCurrentDetail->ReflectCurrentContent();
		}
		else {
			// No, it's a non-allergy (or an outdated) detail. Skip it.
		}
	}

	// (j.jones 2010-11-11 17:26) - PLID 29075 - force the EMN to save
	if(bForceSaveEMN) {
		// We used to call CEmrTreeWnd::SaveEMR here. However, that has all sorts of possible prompts
		// that allow the user to potentially cancel the save and if that happens then this detail
		// has bad data that may result in data being lost. Let's call the save function directly
		// to make it as likely as possible that this save happens to ensure data integrity. If the
		// EMN has other changes then it will still require a full save at some point and if it doesn't
		// have changes then we should be fine anyway.
		SaveEMRObject(esotEMN, (long)this, TRUE);
	}
}

// (c.haag 2009-05-15 10:00) - PLID 34271 - Added ability to load patient current medications from data
// and resynchronize all official Current Medications details with it
// (j.jones 2009-09-18 13:12) - PLID 35599 - this should only be done from NewCrop usage, so I renamed accordingly
// (j.jones 2011-05-04 14:33) - PLID 43527 - added mapDataIDsToSig, which tracks the Sig for each current medication
void CEMN::ReloadPatientCurrentMedicationsFromData_ForNewCrop(long nOldCurrentMedicationsInfoID, long nNewCurrentMedicationsInfoID,
															  const CArray<long,long>& anCurMeds, CMap<long, long, CString, LPCTSTR> &mapDataIDsToSig)
{
	//throw exceptions to the caller

	if(m_bIsTemplate) {
		//this is supported on patient EMNs only
		ASSERT(FALSE);
		return;
	}

	// Make sure this EMN is completely loaded.
	EnsureCompletelyLoaded();

	// Do nothing if this EMN is locked
	if (IsLockedAndSaved()) {
		return;
	}

	BOOL bForceSaveEMN = FALSE;

	// At this point, we should have a fully loaded, saved, unlocked EMN. We should be good to
	// find all the current medication details and update them now
	const int nDetailCount = GetTotalDetailCount();
	for (int nDetail = 0; nDetail < nDetailCount; nDetail++) {
		CEMNDetail* pCurrentDetail = GetDetail(nDetail);

		// See whether this detail is based on the old active Allergies EMR info item, and needs to
		// be brought up to date
		// (j.jones 2011-08-15 14:12) - PLID 45033 - It is possible that the medication data has since been updated
		// by another user, and the table is still blue, but is not actually the prior info ID anymore. 
		// Because the current user still thinks the table is up to date, bring it up to date as well even though
		// if is not the old info ID we expected.
		// So now we bring up to date if the table is a current medications table, and it is out of date,
		// and the EMRInfoID is either the old info ID, or if the table window thinks it is active,
		// or if the detail pointer thinks its active
		if(pCurrentDetail->IsCurrentMedicationsTable() && pCurrentDetail->m_nEMRInfoID != nNewCurrentMedicationsInfoID
			&& ((pCurrentDetail->m_nEMRInfoID == nOldCurrentMedicationsInfoID && nOldCurrentMedicationsInfoID != nNewCurrentMedicationsInfoID)
				|| (pCurrentDetail->m_pEmrItemAdvDlg && ((CEmrItemAdvTableDlg*)(pCurrentDetail->m_pEmrItemAdvDlg))->GetIsActiveCurrentMedicationsTable())
				|| pCurrentDetail->IsActiveInfo()))
		{
			// Yes, changes were made to the current medications (DrugList) table; and this detail used to be active before
			// those changes, but no longer is. Bring it up to date using code modeled from EmrItemAdvDlg.
			//Now, set that in data (otherwise, the detail will re-set itself to the old info ID.)
			// (c.haag 2009-08-17 10:11) - PLID 35246 - This belongs in a transaction
			{
				CSqlTransaction sqlTrans("ReloadPatientCurrentMedicationsFromData_ForNewCrop_UpdateItem");
				sqlTrans.Begin();

				if(pCurrentDetail->m_nEMRDetailID != -1) {
					ExecuteParamSql("UPDATE EmrDetailsT SET EmrInfoID = {INT} WHERE ID = {INT}", 
						nNewCurrentMedicationsInfoID, pCurrentDetail->m_nEMRDetailID);

					// (j.jones 2010-11-11 17:26) - PLID 29075 - force the EMN to save
					bForceSaveEMN = TRUE;
				}
				// Update the detail's EMR info ID now. If we don't do this, UpdateInfoID will throw an exception because
				// it calls LoadContent, and throws an eof error because it queries on EMR details with the ID of m_nEMRDetailID
				// and the EMR Info ID of nNewCurrentMedicationsInfoID
				// (c.haag 2009-07-21 17:27) - This no longer appears to happen. But FYI: This code was modeled from CEmrItemAdvDlg::UpdateItem
				//pCurrentDetail->m_nEMRInfoID = nNewCurrentMedicationsInfoID;

				//Now, tell the detail to reload its content.
				// (j.jones 2011-08-15 15:04) - PLID 45033 - the old ID might be older than the current "old ID", so be sure to send
				// the actual InfoID of the detail
				pCurrentDetail->UpdateInfoID(pCurrentDetail->m_nEMRInfoID, nNewCurrentMedicationsInfoID, NULL, pCurrentDetail->m_nEMRDetailID);

				// Commit the transaction
				sqlTrans.Commit();

				pCurrentDetail->SetNeedContentReload();
				pCurrentDetail->SetNeedSyncContentAndState();
				// Now if the detail is on the screen, we should inform the main frame that it has changed. Do this for consistency
				// with times where users manually edit EMR items on a topic.
				if (NULL != pCurrentDetail->m_pEmrItemAdvDlg && IsWindow(pCurrentDetail->m_pEmrItemAdvDlg->GetSafeHwnd())) {
					//Now, post a message that will call PostEmrItemEntryDlgSaved(), see Chris's note in OpenEmrItemEntryDlg()
					// for why we don't call it directly.
					GetMainFrame()->PostMessage(NXM_EMRITEMADVDLG_ITEM_SAVED, (WPARAM)pCurrentDetail);
				}
				//Tell it that it's now up to date.
				pCurrentDetail->RefreshIsActiveInfo();
			}
		}

		// Now see if this detail is based on the active current medications item; and if so, update the
		// checkbox column
		if(pCurrentDetail->m_nEMRInfoID == nNewCurrentMedicationsInfoID) {
			_variant_t vOldState = pCurrentDetail->GetState();
			// (j.jones 2009-09-18 13:00) - PLID 35599 - bUpdateExisting is TRUE here because if this came
			// from NewCrop, we DO want to update saved medication items
			// (j.jones 2011-05-04 14:09) - PLID 43527 - added mapDataIDsToSig, which tracks the Sig for each current medication
			ApplyOfficialCurrentMedications(pCurrentDetail, nNewCurrentMedicationsInfoID, anCurMeds, mapDataIDsToSig, TRUE);
			_variant_t vNewState = pCurrentDetail->GetState();
			if (VARCMP_EQ != VariantCompare(&vOldState, &vNewState)) {
				// If the state changed, then do a formal request for the change. If we don't do
				// this, then the detail can be unsaved.
				pCurrentDetail->RequestStateChange(vNewState, vOldState);
			}
			// Make sure the content reflects the state
			pCurrentDetail->ReflectCurrentContent();
		}
		else {
			// No, it's a non-allergy (or an outdated) detail. Skip it.
		}
	}

	// (j.jones 2010-11-11 17:26) - PLID 29075 - force the EMN to save
	if(bForceSaveEMN) {
		// We used to call CEmrTreeWnd::SaveEMR here. However, that has all sorts of possible prompts
		// that allow the user to potentially cancel the save and if that happens then this detail
		// has bad data that may result in data being lost. Let's call the save function directly
		// to make it as likely as possible that this save happens to ensure data integrity. If the
		// EMN has other changes then it will still require a full save at some point and if it doesn't
		// have changes then we should be fine anyway.
		SaveEMRObject(esotEMN, (long)this, TRUE);
	}
}

// (j.jones 2009-05-21 15:58) - PLID 34325 - recurses through all children and returns all problem links within the entire EMN,
// or just the problem links that reference pFilterProblem, if pFilterProblem is not NULL
// Links that have been deleted are not returned by default, unless bIncludeDeletedLinks is TRUE
void CEMN::GetAllProblemLinks(CArray<CEmrProblemLink*, CEmrProblemLink*> &aryProblemLinks, CEmrProblem *pFilterProblem /*= NULL*/, BOOL bIncludeDeletedLinks /*= FALSE*/)
{
	//throw exceptions to the caller

	//add problem links from this EMN
	int i = 0;
	for(i=0; i<m_apEmrProblemLinks.GetSize(); i++) {
		CEmrProblemLink *pProblemLink = m_apEmrProblemLinks.GetAt(i);
		CEmrProblem *pProblem = pProblemLink->GetProblem();
		if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)
			&& (!pProblem->m_bIsDeleted || bIncludeDeletedLinks)) {
			
			//add if it doesn't already exist
			BOOL bFound = FALSE;
			for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
				if(aryProblemLinks.GetAt(p) == pProblemLink) {
					bFound = TRUE;
				}
			}

			if(!bFound) {
				aryProblemLinks.Add(pProblemLink);
			}
		}
	}

	//add problem links from charges
	for(i = 0; i < m_aryCharges.GetSize(); i++) {
		EMNCharge *pCharge = (EMNCharge*)m_aryCharges.GetAt(i);
		if(pCharge) {
			//find each problem link
			for(int j=0; j<pCharge->m_apEmrProblemLinks.GetSize(); j++) {
				CEmrProblemLink *pProblemLink = pCharge->m_apEmrProblemLinks.GetAt(j);
				CEmrProblem *pProblem = pProblemLink->GetProblem();
				if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)
					&& (!pProblem->m_bIsDeleted || bIncludeDeletedLinks)) {

					//add if it doesn't already exist
					BOOL bFound = FALSE;
					for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
						if(aryProblemLinks.GetAt(p) == pProblemLink) {
							bFound = TRUE;
						}
					}

					if(!bFound) {
						aryProblemLinks.Add(pProblemLink);
					}
				}
			}
		}
	}

	//add problem links from deleted charges
	if(bIncludeDeletedLinks) {
		for(i = 0; i < m_aryDeletedCharges.GetSize(); i++) {
			EMNCharge *pCharge = (EMNCharge*)m_aryDeletedCharges.GetAt(i);
			if(pCharge) {
				//find each problem link
				for(int j=0; j<pCharge->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblemLink *pProblemLink = pCharge->m_apEmrProblemLinks.GetAt(j);
					CEmrProblem *pProblem = pProblemLink->GetProblem();
					if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)) {

						//add if it doesn't already exist
						BOOL bFound = FALSE;
						for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
							if(aryProblemLinks.GetAt(p) == pProblemLink) {
								bFound = TRUE;
							}
						}

						if(!bFound) {
							aryProblemLinks.Add(pProblemLink);
						}
					}
				}
			}
		}
	}

	//add problem links from diagnoses
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++) {
		EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDiagCodes.GetAt(i);
		if(pDiag) {
			//find each problem link
			for(int j=0; j<pDiag->m_apEmrProblemLinks.GetSize(); j++) {
				CEmrProblemLink *pProblemLink = pDiag->m_apEmrProblemLinks.GetAt(j);
				CEmrProblem *pProblem = pProblemLink->GetProblem();
				if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)
					&& (!pProblem->m_bIsDeleted || bIncludeDeletedLinks)) {
					
					//add if it doesn't already exist
					BOOL bFound = FALSE;
					for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
						if(aryProblemLinks.GetAt(p) == pProblemLink) {
							bFound = TRUE;
						}
					}

					if(!bFound) {
						aryProblemLinks.Add(pProblemLink);
					}
				}
			}
		}
	}

	//add problem links from deleted diagnoses
	if(bIncludeDeletedLinks) {
		for(i = 0; i < m_aryDeletedDiagCodes.GetSize(); i++) {
			EMNDiagCode *pDiag = (EMNDiagCode*)m_aryDeletedDiagCodes.GetAt(i);
			if(pDiag) {
				//find each problem link
				for(int j=0; j<pDiag->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblemLink *pProblemLink = pDiag->m_apEmrProblemLinks.GetAt(j);
					CEmrProblem *pProblem = pProblemLink->GetProblem();
					if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)) {
						
						//add if it doesn't already exist
						BOOL bFound = FALSE;
						for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
							if(aryProblemLinks.GetAt(p) == pProblemLink) {
								bFound = TRUE;
							}
						}

						if(!bFound) {
							aryProblemLinks.Add(pProblemLink);
						}
					}
				}
			}
		}
	}

	//add problem links from medications
	for(i = 0; i < m_aryMedications.GetSize(); i++) {
		EMNMedication *pMed = (EMNMedication*)m_aryMedications.GetAt(i);
		if(pMed) {
			//find each problem link
			for(int j=0; j<pMed->m_apEmrProblemLinks.GetSize(); j++) {
				CEmrProblemLink *pProblemLink = pMed->m_apEmrProblemLinks.GetAt(j);
				CEmrProblem *pProblem = pProblemLink->GetProblem();
				if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)
					&& (!pProblem->m_bIsDeleted || bIncludeDeletedLinks)) {

					//add if it doesn't already exist
					BOOL bFound = FALSE;
					for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
						if(aryProblemLinks.GetAt(p) == pProblemLink) {
							bFound = TRUE;
						}
					}

					if(!bFound) {
						aryProblemLinks.Add(pProblemLink);
					}
				}
			}
		}
	}

	//add problem links from deleted medications
	if(bIncludeDeletedLinks) {
		for(i = 0; i < m_aryDeletedMedications.GetSize(); i++) {
			EMNMedication *pMed = (EMNMedication*)m_aryDeletedMedications.GetAt(i);
			if(pMed) {
				//find each problem link
				for(int j=0; j<pMed->m_apEmrProblemLinks.GetSize(); j++) {
					CEmrProblemLink *pProblemLink = pMed->m_apEmrProblemLinks.GetAt(j);
					CEmrProblem *pProblem = pProblemLink->GetProblem();
					if(pProblem != NULL && (pFilterProblem == NULL || pFilterProblem == pProblem)) {

						//add if it doesn't already exist
						BOOL bFound = FALSE;
						for(int p=0; p<aryProblemLinks.GetSize() && !bFound; p++) {
							if(aryProblemLinks.GetAt(p) == pProblemLink) {
								bFound = TRUE;
							}
						}

						if(!bFound) {
							aryProblemLinks.Add(pProblemLink);
						}
					}
				}
			}
		}
	}

	//add problem links from the topics
	for(i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		CEMRTopic *pTopic = (CEMRTopic*)m_arypEMRTopics.GetAt(i);
		if(pTopic) {
			//get the topic's problem links
			pTopic->GetAllProblemLinks(aryProblemLinks, pFilterProblem, bIncludeDeletedLinks);
		}
	}

	//add problem links from deleted topics
	if(bIncludeDeletedLinks) {
		for(i = 0; i < m_arypDeletedTopics.GetSize(); i++) {
			CEMRTopic *pTopic = (CEMRTopic*)m_arypDeletedTopics.GetAt(i);
			if(pTopic) {
				//get the topic's problem links
				pTopic->GetAllProblemLinks(aryProblemLinks, pFilterProblem, bIncludeDeletedLinks);
			}
		}
	}
}

// (z.manning 2009-07-07 11:39) - PLID 34078 - Returns true if the EMN has at least one e-prescribed medication.
BOOL CEMN::HasEPrescriptions()
{
	for(int nMedIndex = 0; nMedIndex < m_aryMedications.GetSize(); nMedIndex++)
	{
		EMNMedication *pMed = m_aryMedications.GetAt(nMedIndex);
		if(pMed != NULL && pMed->bEPrescribe) {
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CEMN::IsNexWebTemplate()
{
	//(e.lally 2011-05-04) PLID 43537 - Use the bool member variable now.
	if(m_bIsTemplate) {
		return m_bNexWebVisible;
	}
	return FALSE;
}

// (j.gruber 2012-08-31 14:41) - PLID 52285 - check OMR
BOOL CEMN::IsOMRTemplate()
{	
	if(m_bIsTemplate) {
		return m_bIsOMRTemplate;
	}
	return FALSE;
}

// (j.jones 2010-02-12 14:19) - PLID 37318 - called whenever any detail is added to the EMN, to determine
// whether the detail is a SmartStamp image or table, and links to its related item if it exists or
// creates a new table if the image was just added
// (z.manning 2010-05-10 12:10) - PLID 38527 - Added bImageBeingSpawned
void CEMN::EnsureSmartStampLinks(CEMNDetail *pDetail, BOOL bImageBeingSpawned /* = FALSE */)
{
	try {

		//remember that when loading existing content, one of the items
		//is going to exist prior to the other, so each item needs to
		//search for its counterpart when added, and we must not make
		//a new table unless we are absolutely certain the image is new

		// (z.manning 2010-07-21 09:24) - PLID 39591 - When a smart stamp image and table exist in a template, that link is
		// stored in EmrTemplateDetailsT.ChildEmrTemplateDetailID. However, if a user later changes that image to no longer
		// be a smart stamp image, we do not break any links in EmrTemplateDetailsT (whether or not we should is debatable
		// and a matter for another pl item). So it's possible we may attempt to ensure smart stamp links on an image that
		// is not actually a smart stamp image, so for safety (and efficiency) let's check right away if we are trying to link
		// a non-smart stamp image and not bother if that is the case.
		if(pDetail->m_EMRInfoType == eitImage && !pDetail->m_bSmartStampsEnabled) {
			return;
		}

		//verify that this detail belongs to this EMN
		// (a.walling 2010-09-13 13:58) - PLID 40500 - Use safer method to get the parent EMN
		if(pDetail->GetParentEMN() != this) {
			ThrowNxException("EnsureSmartStampLinks called on a mismatched EMN / detail!");
		}

		if(pDetail->m_EMRInfoType == eitImage && pDetail->m_bSmartStampsEnabled && pDetail->m_nChildEMRInfoMasterID != -1)
		{
			//this detail is a SmartStamp image linked to a table

			//store as pImage for ease of code readability
			CEMNDetail *pImage = pDetail;

			if(pImage->GetSmartStampTableDetail()) {
				//we are already linked to a table, so simply confirm it is also linked to us
				pImage->GetSmartStampTableDetail()->EnsureSmartStampImageDetail(pImage);
				// (z.manning 2011-02-23 10:22) - PLID 42549 - Only return here if the image and linked table have
				// the same EMN. It's possible the image could be linked to a detail that was created by the 
				// EMNLoader that was never actually added to the EMN.
				if(pImage->GetParentEMN() == pImage->GetSmartStampTableDetail()->GetParentEMN()) {
					return;
				}
			}

			if(!m_bIsTemplate && pImage->m_nChildEMRDetailID != -1)
			{
				//see if we have the ID yet for the table
				CEMNDetail *pTable = GetDetailByID(pImage->m_nChildEMRDetailID);
				// (z.manning 2011-01-21 08:42) - PLID 42338 - Removed the check to see if the table was already
				// associated with an image because we can now have multiple images per smart stamp table.
				// (z.manning 2011-01-26 10:44) - PLID 42235 - I fixed the below comparison to check
				// the images child info master id to the table's info master id (it had been checking
				// the images child master id against its own master id, which is obviously not what was intended).
				if(pTable != NULL && pImage->m_nChildEMRInfoMasterID == pImage->m_nEMRInfoMasterID) {
					//link them up
					pImage->SetSmartStampTableDetail(pTable);
					pTable->EnsureSmartStampImageDetail(pImage);				
				}

				//if we don't find anything, return, it means the table hasn't been loaded yet
				return;
			}
			else if(pImage->m_nChildEMRTemplateDetailID != -1)
			{
				//this could be a template, or loading from a template
				//GetSmartStampImageDetail_ByTemplateDetailID should only return a table that has a null image link
				// (z.manning 2011-01-27 10:42) - PLID 42336 - Updated this to allow multiple images per smart stamp
				// table (however, the same image item may not be linked to a table more than once).
				CEMNDetail *pTable = GetDetailByTemplateDetailID(pImage->m_nChildEMRTemplateDetailID);
				if(pTable != NULL) {
					if(pTable->SmartStampTableAlreadyHasImageItem(pImage)) {
						pTable = NULL;
					}
				}
				// (z.manning 2011-01-21 08:42) - PLID 42338 - Removed the check to see if the table was already
				// associated with an image because we can now have multiple images per smart stamp table.
				if(pTable != NULL) {
					if(pImage->m_nChildEMRInfoMasterID == pTable->m_nEMRInfoMasterID) {
						//link them up
						pImage->SetSmartStampTableDetail(pTable);
						pTable->EnsureSmartStampImageDetail(pImage);
					}
					else {
						//the SmartStamp setup has changed, these are no longer linked together,
						//and have not been updated in the template, so break the link
						pImage->m_nChildEMRTemplateDetailID = -1;
						// (z.manning 2011-01-25 16:45) - PLID 42336 - Parent ID has been deprecated
						//pTable->m_nParentEMRTemplateDetailID = -1;
					}
				}

				if(pTable == NULL && bImageBeingSpawned && !m_bIsTemplate) {
					// (z.manning 2010-05-10 17:32) - PLID 38527 - We didn't find a table which means it hasn't
					// been loaded yet. But if the image just spawned then we need to load it, so let's go ahead
					// and do that now.
					if(pImage->m_pParentTopic != NULL && pImage->m_pParentTopic->GetParentEMN() != NULL) {
						pImage->m_pParentTopic->GetParentEMN()->PostSmartStampImageAdded(pImage);
						// (c.haag 2010-05-27 16:31) - PLID 38709 - If we're in the initial load, do not force the modified
						// flag to persist after PostLoad. Otherwise this detail can be flagged as modified when a template is
						// finished with its initial load even though the user didn't change anything.
						pImage->SetUnsaved(m_bInitialLoadComplete);
						return;
					}
				}

				//If m_nChildEMRTemplateDetailID is still not -1, return, this means the table hasn't been loaded yet,
				//but if m_nChildEMRTemplateDetailID is -1, we will continue, and auto-add a new table shortly
				if(pImage->m_nChildEMRTemplateDetailID != -1) {
					return;
				}
			}
			
			//if the image is new, we'll add the table, but we'll also do this if the image is loaded
			//on or from a template where m_nChildEMRTemplateDetailID was not set
			if((m_bIsTemplate && (pImage->m_nEMRTemplateDetailID == -1 || pImage->m_nChildEMRTemplateDetailID == -1))
				|| (!m_bIsTemplate && (pImage->m_nEMRDetailID == -1 || pImage->m_nChildEMRTemplateDetailID == -1)))
			{

				if(IsLockedAndSaved()) {
					ThrowNxException("CEMN::EnsureSmartStampLinks called for a new Image on a locked EMN!");
				}

				//before adding a new table, see if the table already exists without a parent

				//do not try to acquire an orphan table if we already have stamps (from remembered values)
				if(!pImage->HasImageStamps())
				{
					long nDetailCount = GetTotalDetailCount();
					for(long i = 0; i < nDetailCount; i++)
					{
						CEMNDetail *pTableDetail = GetDetail(i);
						//we are looking for a table that has the InfoMasterID we're looking for, 
						//that is not linked to an image, and isn't expecting to be linked to one
						// (z.manning 2011-01-21 08:42) - PLID 42338 - Removed the check to see if the table was already
						// associated with an image because we can now have multiple images per smart stamp table.
						if(pTableDetail->m_EMRInfoType == eitTable && pTableDetail->m_nEMRInfoMasterID == pImage->m_nChildEMRInfoMasterID)
						{
							// (z.manning 2011-01-25 16:55) - PLID 42336 - We now support multiple images for one smart stamp
							// table so we no longer need this check.
							//if(pTableDetail->m_nParentEMRTemplateDetailID == -1 && pImage->m_nChildEMRTemplateDetailID == -1
							//	&& pTableDetail->m_nParentEMRDetailID == -1 && pImage->m_nChildEMRDetailID == -1)
							// (z.manning 2011-01-26 16:03) - PLID 42336 - However, we can only have the same EMR item
							// associated with a table once, so check that first.
							if(!pTableDetail->SmartStampTableAlreadyHasImageItem(pImage))
							{								
								//we found an orphan table, let's adopt it, but only if it is the active info ID

								BOOL bIsCurrentVersion = m_bIsTemplate;
								if(!bIsCurrentVersion) {
									//if not a template, refresh the current version of the table
									pTableDetail->RefreshIsActiveInfo();
									bIsCurrentVersion = pTableDetail->IsActiveInfo();
								}

								//we will not link to old versions of the table,
								//and we will not try to force the table to bring up to date,
								//so we would add a new table momentarily

								if(bIsCurrentVersion) {
									//this is the current version of the table, so use it
									pImage->SetSmartStampTableDetail(pTableDetail);
									pTableDetail->EnsureSmartStampImageDetail(pImage);
									// (c.haag 2010-05-27 16:31) - PLID 38709 - If we're in the initial load, do not force the modified
									// flag to persist after PostLoad. Otherwise this detail can be flagged as modified when a template is
									// finished with its initial load even though the user didn't change anything.
									//pImage->SetUnsaved(TRUE);
									//pTableDetail->SetUnsaved(TRUE);
									pImage->SetUnsaved(m_bInitialLoadComplete);
									pTableDetail->SetUnsaved(m_bInitialLoadComplete);
									return;
								}
							}
						}
					}
				}
				
				//this image is new, and not from a template, which means we are just now adding this image
				pImage->m_pParentTopic->GetParentEMN()->PostSmartStampImageAdded(pImage);
				// (c.haag 2010-05-27 16:31) - PLID 38709 - If we're in the initial load, do not force the modified
				// flag to persist after PostLoad. Otherwise this detail can be flagged as modified when a template is
				// finished with its initial load even though the user didn't change anything.
				//pImage->SetUnsaved(TRUE);
				pImage->SetUnsaved(m_bInitialLoadComplete);
			}
			else if((m_bIsTemplate && pImage->m_nChildEMRTemplateDetailID != -1)
				|| (!m_bIsTemplate && (pImage->m_nChildEMRDetailID != -1 || pImage->m_nEMRTemplateDetailID != -1))) {

				//it's an existing image, that is already linked to a table in data,
				//(this includes template items being added to a patient EMN)
				//so we need to connect the pointers

				long nDetailCount = GetTotalDetailCount();
				for(long i = 0; i < nDetailCount; i++) {
					CEMNDetail *pTableDetail = GetDetail(i);
					//we are looking for the table that is the child of the passed-in image
					if(pTableDetail->m_EMRInfoType == eitTable && pTableDetail->m_nEMRInfoMasterID == pImage->m_nChildEMRInfoMasterID) {

						BOOL bIsChild = FALSE;

						if(m_bIsTemplate
							&& pTableDetail->m_nEMRTemplateDetailID != -1 && pImage->m_nChildEMRTemplateDetailID != -1
							&& pTableDetail->m_nEMRTemplateDetailID == pImage->m_nChildEMRTemplateDetailID) {
							//this is a template, and the template detail IDs match
							bIsChild = TRUE;
						}

						if(!bIsChild && !m_bIsTemplate
							&& pTableDetail->m_nEMRDetailID != -1 && pImage->m_nChildEMRDetailID != -1
							&& pTableDetail->m_nEMRDetailID == pImage->m_nChildEMRDetailID) {
							//this is a patient EMN, and the detail IDs match
							bIsChild = TRUE;
						}

						if(!bIsChild && !m_bIsTemplate
							&& pTableDetail->m_nEMRDetailID == -1 && pImage->m_nEMRDetailID == -1
							&& pTableDetail->m_nEMRTemplateDetailID != -1 && pImage->m_nChildEMRTemplateDetailID != -1
							&& pTableDetail->m_nEMRTemplateDetailID == pImage->m_nChildEMRTemplateDetailID) {
							//this is a patient EMN, and the details are both newly loaded from a template,
							//and the loaded template IDs match
							bIsChild = TRUE;
						}

						if(bIsChild) {
							//it's a table with the right ID, set it as our table detail, and vice versa
							pImage->SetSmartStampTableDetail(pTableDetail);
							pTableDetail->EnsureSmartStampImageDetail(pImage);
							return;
						}
					}
				}
			}
		}
		else if(pDetail->m_EMRInfoType == eitTable)
		{
			//this detail is a table, does it need to be linked to an image?

			//store as pTable for ease of code readability
			CEMNDetail *pTable = pDetail;

			if(pTable->GetSmartStampImageDetails()->GetCount() > 0) {
				//we are already linked to a image, so simply confirm it is also linked to us
				// (z.manning 2011-01-21 09:01) - PLID 42338 - Support multiple images per smart stamp table
				pTable->GetSmartStampImageDetails()->SetSmartStampTableDetail(pTable);
				// (z.manning 2011-02-23 10:22) - PLID 42549 - Only return here if the image and linked table have
				// the same EMN. It's possible the image could be linked to a detail that was created by the 
				// EMNLoader that was never actually added to the EMN.
				BOOL bSameEmn = TRUE;
				for(int nImageIndex = 0; nImageIndex < pTable->GetSmartStampImageDetails()->GetCount(); nImageIndex++) {
					CEMNDetail *pTempImage = pTable->GetSmartStampImageDetails()->GetAt(nImageIndex);
					if(pTempImage->GetParentEMN() != pTable->GetParentEMN()) {
						bSameEmn = FALSE;
						break;
					}
				}
				if(bSameEmn) {
					return;
				}
			}

			if(!m_bIsTemplate && pTable->m_nEMRDetailID != -1)
			{
				// (z.manning 2011-01-25 17:52) - PLID 42336 - Need to support multiple images for one smart stamp table
				CEMNDetailArray aryParentDetails;
				GetParentDetailsByDetailID(pTable->m_nEMRDetailID, &aryParentDetails);
				for(int nParentDetailIndex = 0; nParentDetailIndex < aryParentDetails.GetCount(); nParentDetailIndex++)
				{
					//see if we have the ID yet for the image
					CEMNDetail *pImage = aryParentDetails.GetAt(nParentDetailIndex);
					if(pImage != NULL && pImage->GetSmartStampTableDetail() == NULL
						&& pImage->m_bSmartStampsEnabled && pImage->m_nChildEMRInfoMasterID == pTable->m_nEMRInfoMasterID) {
						//link them up
						pImage->SetSmartStampTableDetail(pTable);
						pTable->EnsureSmartStampImageDetail(pImage);
					}
				}
			}
			else if(pTable->m_nEMRTemplateDetailID != -1)
			{
				// (z.manning 2011-01-25 17:52) - PLID 42336 - Need to support multiple images for one smart stamp table
				CEMNDetailArray aryParentDetails;
				GetParentDetailsByDetailID(pTable->m_nEMRDetailID, &aryParentDetails);
				for(int nParentDetailIndex = 0; nParentDetailIndex < aryParentDetails.GetCount(); nParentDetailIndex++)
				{
					//this could be a template, or loading from a template
					//GetSmartStampImageDetail_ByTemplateDetailID should only return an image that has a null table link
					CEMNDetail *pImage = aryParentDetails.GetAt(nParentDetailIndex);
					if(pImage != NULL && pImage->GetSmartStampTableDetail() == NULL) {
						if(pImage->m_bSmartStampsEnabled && pImage->m_nChildEMRInfoMasterID == pTable->m_nEMRInfoMasterID) {
							//link them up
							pImage->SetSmartStampTableDetail(pTable);
							pTable->EnsureSmartStampImageDetail(pImage);
						}
						else {
							//the SmartStamp setup has changed, these are no longer linked together,
							//and have not been updated in the template, so break the link
							pImage->m_nChildEMRTemplateDetailID = -1;
							// (z.manning 2011-01-25 17:56) - PLID 42336 - Parent IDs have been deprecated
							//pTable->m_nParentEMRTemplateDetailID = -1;

							//re-ensure the image so it can try to auto-create the table
							EnsureSmartStampLinks(pImage);
						}
					}
				}
			}

			//is it an existing table?
			if((m_bIsTemplate && pTable->m_nEMRTemplateDetailID != -1)
				|| (!m_bIsTemplate && (pTable->m_nEMRDetailID != -1 || pTable->m_nEMRTemplateDetailID != -1)))
			{
				//it's an existing table (could be loaded from a template), let's see if we currently have an image that points to it

				long nDetailCount = GetTotalDetailCount();
				for(long i = 0; i < nDetailCount; i++) {
					CEMNDetail *pImageDetail = GetDetail(i);
					//we are looking for an image that has this table as a child
					if(pImageDetail->m_EMRInfoType == eitImage && pImageDetail->m_bSmartStampsEnabled
						&& pImageDetail->m_nChildEMRInfoMasterID == pTable->m_nEMRInfoMasterID) {

						BOOL bParent = FALSE;

						if(m_bIsTemplate
							&& pTable->m_nEMRTemplateDetailID != -1 && pImageDetail->m_nChildEMRTemplateDetailID != -1
							&& pTable->m_nEMRTemplateDetailID == pImageDetail->m_nChildEMRTemplateDetailID) {
							//this is a template, and the template detail IDs match
							bParent = TRUE;
						}

						if(!bParent && !m_bIsTemplate
							&& pTable->m_nEMRDetailID != -1 && pImageDetail->m_nChildEMRDetailID != -1
							&& pTable->m_nEMRDetailID == pImageDetail->m_nChildEMRDetailID) {
							//this is a patient EMN, and the detail IDs match
							bParent = TRUE;
						}

						if(!bParent && !m_bIsTemplate
							&& pTable->m_nEMRDetailID == -1 && pImageDetail->m_nEMRDetailID == -1
							&& pTable->m_nEMRTemplateDetailID != -1 && pImageDetail->m_nChildEMRTemplateDetailID != -1
							&& pTable->m_nEMRTemplateDetailID == pImageDetail->m_nChildEMRTemplateDetailID) {

							//this is a patient EMN, and the details are both newly loaded from a template,
							//and the loaded template IDs match
							bParent = TRUE;
						}

						if(bParent) {
							// (j.jones 2011-03-04 17:01) - PLID 42685 - Now we have to make sure the image is not already
							// linked to another table, because it may be the image we are looking for, but another copy of
							// the same image. We can take it though if it is still linked to a table in the loader, and
							// our table is not in the loader. Also this code make sure both details have the same loader
							// ownership state, but I am pretty sure they should always be owned by the EMN, not the loader.
							if(pTable->IsOwnedByEMNLoader() == pImageDetail->IsOwnedByEMNLoader()
								&& (pImageDetail->GetSmartStampTableDetail() == NULL || pImageDetail->GetSmartStampTableDetail() == pTable
									|| (pImageDetail->GetSmartStampTableDetail()->IsOwnedByEMNLoader() && !pTable->IsOwnedByEMNLoader()))) {

								//this parent is ok
								bParent = TRUE; //this line is really only here for breakpoint uses
							}
							else {													
								//we cannot take this image for ourselves
								bParent = FALSE;
							}
						}

						if(bParent) {
							//it's our parent image, so swap pointers
							pImageDetail->SetSmartStampTableDetail(pTable);
							pTable->EnsureSmartStampImageDetail(pImageDetail);
							// (z.manning 2011-02-21 10:21) - PLID 42338 - We may have multiple images so don't return here
							//return;
						}
					}
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2010-02-12 08:36) - PLID 37318 - called whenever a smart stamp image is added, creates the
// linked table and returns a pointer to the detail representing that table
CEMNDetail* CEMN::PostSmartStampImageAdded(CEMNDetail *pImage)
{
	try {

		if(pImage == NULL || pImage->m_EMRInfoType != eitImage
			|| !pImage->m_bSmartStampsEnabled || pImage->m_nChildEMRInfoMasterID == -1) {
			//this function should never have been called
			ASSERT(FALSE);
			return NULL;
		}

		//should be impossible to get here on a locked EMN, but do NOT try to add a table if we do
		if(IsLockedAndSaved()) {
			return NULL;
		}
		
		//we need to add the table to the same topic as the image

		//Yazi managed to get this assertion in a recordset when the new table was added,
		//by getting to this function through the Problem List loading thread.
		//Nobody could reproduce it, we don't know how it's possible. However, the solution
		//is likely not to propagate the thread connection into this function,
		//as it has many other non-thread-safe behaviors. Instead we need to find out
		//how this function is being called at all in a thread, and stop it.
		ASSERT_MAIN_THREAD();

		// (z.manning 2010-05-10 17:21) - PLID 38527 - We may have a template detail ID to load so check that first.
		CEMNDetail *pNewDetail = NULL;
		BOOL bIsExistingTable = FALSE;
		CEMNDetail *pExistingTable = NULL;
		if(pImage->m_nChildEMRTemplateDetailID != -1) {
			// (z.manning 2011-01-27 09:52) - PLID 42336 - We now allow multiple images per smart stamp table
			// so let's check and see if the linked table already exists.
			pExistingTable = GetDetailByTemplateDetailID(pImage->m_nChildEMRTemplateDetailID);
		}
		if(pExistingTable == NULL && pImage->m_nChildEMRInfoMasterID != -1) {
			// (z.manning 2011-01-28 13:08) - PLID 42336 -  Couldn't find an exact match so let's see any instance
			// of this table is already on the EMN.
			pExistingTable = GetSmartStampTableDetailByInfoMasterID(pImage->m_nChildEMRInfoMasterID, pImage->m_nEMRInfoMasterID);
		}

		// (z.manning 2011-01-27 09:53) - PLID 42336 - However, we can only have the same image associated with a table once.
		if(pExistingTable != NULL) {
			if(!pExistingTable->SmartStampTableAlreadyHasImageItem(pImage)) {
				pNewDetail = pExistingTable;
				bIsExistingTable = TRUE;
			}
		}

		if(pNewDetail == NULL && pImage->m_nChildEMRTemplateDetailID != -1)
		{
			// (z.manning 2010-05-10 17:21) - PLID 38527 - We do have a valid template detail ID so lookup what topic
			// this detail is on.
			CEMRTopic *pTableTopic = NULL;
			_RecordsetPtr prsTemplateTopicID = CreateParamRecordset(
				"SELECT EmrTemplateTopicID FROM EmrTemplateDetailsT WHERE EmrTemplateDetailsT.ID = {INT}"
				, pImage->m_nChildEMRTemplateDetailID);
			if(!prsTemplateTopicID->eof) {
				long nTableTemplateTopicID = AdoFldLong(prsTemplateTopicID->GetFields(), "EmrTemplateTopicID", -1);
				if(nTableTemplateTopicID != -1) {
					pTableTopic = GetTopicByTemplateTopicIDOnly(nTableTemplateTopicID);
				}
				if(pTableTopic != NULL) {
					// (z.manning 2010-05-10 17:22) - PLID 38527 - We found the topic that this template detail is on so
					// add the detail to that topic.
					pNewDetail = CEMNDetail::CreateDetail(pTableTopic, "PostSmartStampImageAdded table detail from template");
					long nPatientID = -1, nEmrGroupID = -1;
					if(GetParentEMR() != NULL) {
						nPatientID = GetParentEMR()->GetPatientID();
						nEmrGroupID = GetParentEMR()->GetID();
					}
					// (a.walling 2012-06-22 14:01) - PLID 51150 - No parent window param
					pNewDetail->LoadFromTemplateDetailID(pImage->m_nChildEMRTemplateDetailID, m_bIsTemplate, FALSE, IsLoading(), nPatientID, nEmrGroupID);
					pTableTopic->AddDetail(pNewDetail, IsLoading(), FALSE);

					// (a.walling 2012-06-22 14:01) - PLID 51150 - Use the EMN's interface wnd
					if(GetInterface()) {
						GetInterface()->SendMessage(NXM_EMR_ITEM_ADDED, (WPARAM)pNewDetail, (LPARAM)IsLoading());
					}
				}
				else {
					// (z.manning 2010-05-10 17:22) - PLID 38527 - We could not find the right topic so we'll simply add
					// it to the same topic as the image in the code below.
				}
			}
		}
		
		if(pNewDetail == NULL) {
			SourceActionInfo saiBlank;
			//pass in the image pointer so we can link it up immediately prior to loading the table content
			pNewDetail = pImage->m_pParentTopic->AddNewDetailFromEmrInfoMasterID(pImage->m_nChildEMRInfoMasterID, m_bIsTemplate, saiBlank, IsLoading(),
				-1, 0, -1, -1, -1, pImage);
			if(pNewDetail != NULL) {
				CEmrTopicWndPtr pTopicWnd = pImage->m_pParentTopic->GetTopicWnd();
				if(pTopicWnd) {
					pTopicWnd->AddDetail(pNewDetail);
				}
			}
		}

		if(pNewDetail) {
			//the addnewdetail function should have already done this, but make sure the image & table are linked
			pImage->SetSmartStampTableDetail(pNewDetail);
			// (c.haag 2010-05-27 16:31) - PLID 38709 - If we're in the initial load, do not force the modified
			// flag to persist after PostLoad. Otherwise this detail can be flagged as modified when a template is
			// finished with its initial load even though the user didn't change anything.
			//pImage->SetUnsaved(TRUE);
			pImage->SetUnsaved(m_bInitialLoadComplete);
			pNewDetail->EnsureSmartStampImageDetail(pImage);
			return pNewDetail;
		}

	}NxCatchAll(__FUNCTION__);

	return NULL;
}

// (j.jones 2010-03-11 09:51) - PLID 37318 - added an ability to reconfirm all SmartStamp links
// on this EMN, after we've copied SmartStamps from another EMN (could be the EMN Copy feature, Import Topics,
// using the loader, etc.)
void CEMN::ReconfirmSmartStampLinks_PostEMNCopy()
{
	try {

		int i=0;
		long nDetailCount = GetTotalDetailCount();
		for(i=0; i<nDetailCount; i++)
		{
			CEMNDetail *pDetail = GetDetail(i);
			// (z.manning 2011-01-21 09:32) - PLID 42338 - Support multiple images per smart stamp table
			CEMNDetailArray arySmartStampImages;
			arySmartStampImages.Copy(*(pDetail->GetSmartStampImageDetails()));
			for(int nImageIndex = 0; nImageIndex < arySmartStampImages.GetCount(); nImageIndex++)
			{
				CEMNDetail *pOldImage = arySmartStampImages.GetAt(nImageIndex);
				if(pOldImage->m_pParentTopic->GetParentEMN() != this)
				{
					//this is a table, and its linked image is not on this EMN
					CEMNDetail *pNewTable = pDetail;
					CEMNDetail *pOldTable = pOldImage->GetSmartStampTableDetail();
					ASSERT(pOldTable);

					//the old image should still be pointing to the old table on the other EMN,
					//find the new image on this EMN that is also pointing to that old table

					BOOL bFound = FALSE;
					int j=0;
					for(j=0; j<nDetailCount && !bFound; j++) {
						CEMNDetail *pDetailToCheck = GetDetail(j);
						if(pDetailToCheck->GetSmartStampTableDetail() == pOldTable) {
							//this detail is on our current EMN, but pointing to the old table,
							//change it to point to the current table, and vice versa
							pDetailToCheck->SetSmartStampTableDetail(pNewTable);
							pNewTable->EnsureSmartStampImageDetail(pDetailToCheck);
							bFound = TRUE;
						}
					}
				}
			}

			if(pDetail->GetSmartStampTableDetail() != NULL && pDetail->GetSmartStampTableDetail()->m_pParentTopic->GetParentEMN() != this)
			{
				//this is an image, and its linked table is not on this EMN
				CEMNDetail *pNewImage = pDetail;
				CEMNDetail *pOldTable = pDetail->GetSmartStampTableDetail();
				// (z.manning 2011-01-21 09:39) - PLID 42338 - Support multiple images per smart stamp table
				CEMNDetailArray arySmartStampImages;
				arySmartStampImages.Copy(*(pOldTable->GetSmartStampImageDetails()));
				for(int nOldImageIndex = 0; nOldImageIndex < arySmartStampImages.GetCount(); nOldImageIndex++)
				{
					CEMNDetail *pOldImage = arySmartStampImages.GetAt(nOldImageIndex);
					ASSERT(pOldImage);

					//the old table should still be pointing to the old image on the other EMN,
					//find the new table on this EMN that is also pointing to that old image

					BOOL bFound = FALSE;
					int j=0;
					for(j=0; j<nDetailCount && !bFound; j++) {
						CEMNDetail *pDetailToCheck = GetDetail(j);
						if(pDetailToCheck->GetSmartStampImageDetails()->Contains(pOldImage)) {
							//this detail is on our current EMN, but pointing to the old image,
							//change it to point to the current image, and vice versa
							pDetailToCheck->EnsureSmartStampImageDetail(pNewImage);
							pNewImage->SetSmartStampTableDetail(pDetailToCheck);
							bFound = TRUE;
						}
					}
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2010-04-02 15:34) - PLID 37980 - added function to determine if the EMN is editable,
// based on permissions, writeable token, and locked status
BOOL CEMN::CanBeEdited()
{
	//is the EMN locked?
	BOOL bCanWriteToEMN = !IsLockedAndSaved();

	if(bCanWriteToEMN) {
		//do we have a write token?
		bCanWriteToEMN = IsWritable();
	}

	if(bCanWriteToEMN) {
		//do we have permission?
		bCanWriteToEMN = CheckCurrentUserPermissions(bioPatientEMR, sptWrite, FALSE, 0, TRUE, TRUE) && (g_pLicense->HasEMR(CLicense::cflrSilent) == 2);
	}

	return bCanWriteToEMN;
}

//TES 4/15/2010 - PLID 24692 - Get the entry in our linked list that corresponds to this ID (NULL if there isn't any).
TopicPositionEntry* CEMN::GetTopicPositionEntryByID(long nTopicID)
{
	//TES 4/15/2010 - PLID 24692 - Just ask our linked list.
	if(m_pTopicPositionHead) {
		return m_pTopicPositionHead->GetEntryByID(nTopicID);
	}
	else {
		return NULL;
	}
}

// (c.haag 2010-07-01 11:52) - PLID 36061 - This function creates and returns a new CEMNDetail corresponding to a lab
CEMNDetail* CEMN::CreateNewLabDetail(CEMRTopic *pTopic, EMNLab *pNewLab, BOOL bIsInitialLoad)
{
	SourceActionInfo sai = pNewLab->sai;
	// (z.manning 2008-10-07 17:03) - PLID 31561 - Add a detail to the current topic
	// with relevant details from the newly created lab.
	// (a.walling 2009-10-23 09:23) - PLID 36046 - Track construction in initial reference count
	CEMNDetail *pLabDetail = CEMNDetail::CreateDetail(pTopic, "Lab text macro");
	// (z.manning 2008-10-07 17:19) - PLID 31561 - Let's just create a dummy text detail
	// with the text macro ID with the relevant text.
	// (a.walling 2012-06-22 14:01) - PLID 51150 - No parent window param
	pLabDetail->LoadFromInfoID(EMR_BUILT_IN_INFO__TEXT_MACRO, m_bIsTemplate, FALSE, sai);
	pLabDetail->SetState(_bstr_t(pNewLab->GetText()));
	pLabDetail->SetLabelText(pNewLab->GetTitle());
	pLabDetail->SetLabID(pNewLab->nID);
	pTopic->AddDetail(pLabDetail, bIsInitialLoad, FALSE);
	CEmrTopicWndPtr pTopicWnd = pTopic->GetTopicWnd();
	if(pTopicWnd) {
		pTopicWnd->RepositionDetailsInTopicByInfoID(EMR_BUILT_IN_INFO__TEXT_MACRO, FALSE);
	}
	CEmrTreeWnd* pTreeWnd = GetInterface();
	if(pTreeWnd != NULL) {
		pTreeWnd->SendMessage(NXM_EMN_DETAIL_UPDATE_PREVIEW_POSITION, WPARAM(pLabDetail), LPARAM(this));
	}
	return pLabDetail;
}

//TES 8/10/2010 - PLID 24692 - Gets the order index of the given topic within our list of topics (non-recursive).
long CEMN::GetChildOrderIndex(CEMRTopic *pChild)
{
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i] == pChild) {
			return i;
		}
	}
	return -1;
}

// (z.manning 2011-03-04 14:13) - PLID 42682
void CEMN::UpdateSourceDetailStampIDs(const long nOldDetailStampID, const long nNewDetailStampID)
{
	//first for the EMN
	if(m_sai.GetDetailStampID() == nOldDetailStampID) {
		m_sai.SetDetailStampID(nNewDetailStampID);
	}

	//Topics
	for(int nTopicIndex = 0; nTopicIndex < m_arypEMRTopics.GetSize(); nTopicIndex++)
	{
		CEMRTopic *pTopic = m_arypEMRTopics.GetAt(nTopicIndex);
		pTopic->UpdateSourceDetailStampIDs(nOldDetailStampID, nNewDetailStampID);
	}

	int i = 0;

	//Charges
	for(i = 0; i < m_aryCharges.GetSize(); i++)
	{
		EMNCharge *pCharge = m_aryCharges.GetAt(i);
		if(pCharge->sai.GetDetailStampID() == nOldDetailStampID) {
			pCharge->sai.SetDetailStampID(nNewDetailStampID);
		}
	}

	//Diag Codes
	for(i = 0; i < m_aryDiagCodes.GetSize(); i++)
	{
		EMNDiagCode *pDiag = m_aryDiagCodes.GetAt(i);
		if(pDiag->sai.GetDetailStampID() == nOldDetailStampID) {
			pDiag->sai.SetDetailStampID(nNewDetailStampID);
		}
	}

	//Procedures
	for(i = 0; i < m_aryProcedures.GetSize(); i++)
	{
		EMNProcedure *pProc = m_aryProcedures.GetAt(i);
		if(pProc->sai.GetDetailStampID() == nOldDetailStampID) {
			pProc->sai.SetDetailStampID(nNewDetailStampID);
		}
	}

	//Medications
	for(i = 0; i < m_aryMedications.GetSize(); i++)
	{
		EMNMedication *pPresc = m_aryMedications.GetAt(i);
		if(pPresc->sai.GetDetailStampID() == nOldDetailStampID) {
			pPresc->sai.SetDetailStampID(nNewDetailStampID);
		}
	}

	// (z.manning 2011-03-04 14:46) - PLID 42682 - We also need to update the source detail stamp ID of any pending actions.
	if(GetParentEMR() != NULL) {
		GetParentEMR()->UpdatePendingActionSourceDetailStampID(nOldDetailStampID, nNewDetailStampID, this);
	}
}

BOOL CEMN::GetGlassesOrderData(OUT GlassesOrder &goOrder, OUT CString &strIgnoredData)
{
	//TES 3/18/2011 - PLID 42762 - If this is a template, we can't make a Glasses Order out of it
	if(m_bIsTemplate) {
		return FALSE;
	}

	//TES 3/18/2011 - PLID 42762 - We'll fill the patient ID
	//TES 4/5/2011 - PLID 42762 - Actually, this is unnecessary, at least for now the struct always comes with a CEMN, so we can just
	// pull the Patient ID from there.
	//goOrder.nPatientID = GetParentEMR()->GetPatientID();

	//TES 3/18/2011 - PLID 42762 - The rest is up to our topics.
	BOOL bAnyDataFound = FALSE;
	for(int i = 0; i < this->m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->GetGlassesOrderData(goOrder, strIgnoredData)) {
			bAnyDataFound = TRUE;
		}
	}
	return bAnyDataFound;
}

//TES 4/11/2012 - PLID 49621 - Added, gathers any information on that could be loaded into a Contact Lens Order.  Same as GetGlassesOrderData
BOOL CEMN::GetContactLensOrderData(OUT ContactLensOrder &cloOrder, OUT CString &strIgnoredData)
{
	//TES 4/11/2012 - PLID 49621 - If this is a template, we can't make a Contact Lens Order out of it
	if(m_bIsTemplate) {
		return FALSE;
	}

	//TES 4/11/2012 - PLID 49621 - The rest is up to our topics.
	BOOL bAnyDataFound = FALSE;
	for(int i = 0; i < this->m_arypEMRTopics.GetSize(); i++) {
		if(m_arypEMRTopics[i]->GetContactLensOrderData(cloOrder, strIgnoredData)) {
			bAnyDataFound = TRUE;
		}
	}
	return bAnyDataFound;
}

// (j.jones 2011-04-28 14:39) - PLID 43122 - returns the primary provider ID on the EMN
// that has FloatEMRData set to true
long CEMN::GetProviderIDForFloatingData()
{
	//if multiple primary providers exist, return
	//the first one that has FloatEMRData set to true

	//find the first provider that has FloatEMRData enabled
	for(int i=0; i<m_aryProviders.GetSize(); i++) {
		EMNProvider *pProvider = (EMNProvider*)m_aryProviders.GetAt(i);
		if(pProvider->bFloatEMRData) {
			//found one
			return pProvider->nID;
		}
	}

	//we could not find one
	return -1;
}

// (j.jones 2011-07-07 15:59) - PLID 38366 - TryUpdateCodingGroupByServiceID
// will see if an EmrCodingGroup applies for the given ServiceID, then call
// TryUpdateCodingGroup on the correct group. If the ServiceID is processed,
// it will return TRUE, but if this function returns FALSE, the code was not
// processed and still needs to be added normally.
BOOL CEMN::TryUpdateCodingGroupByServiceID(long nServiceID, BOOL bPopup, long nQuantityToIncrement /*= 1*/)
{
	try {

		//this feature is not used on templates
		if(m_bIsTemplate) {
			return FALSE;
		}

		CEmrCodingGroupArray *pMasterArray = GetMainFrame()->GetEmrCodingGroupManager();
		for(int i=0; i<pMasterArray->GetCount(); i++) {
			CEmrCodingGroup *pCodingGroup = pMasterArray->GetAt(i);

			if(!pCodingGroup->HasCptCodeID(nServiceID)) {
				//this group does not apply to this code
				continue;
			}

			if(m_nID != -1) {
				//if this is not a new EMN, and a code in the group is already on the EMN,
				//but the group does not exist in memory, then the code must have been created
				//before this group existed, and thus we cannot apply the rules to this EMN

				//is the group in use on this EMN?
				BOOL bFoundGroup = FALSE;
				for(int j=0; j<m_arypCodingGroups.GetSize() && !bFoundGroup; j++) {
					CEmnCodingGroupInfo *pEMNGroupInfo = (CEmnCodingGroupInfo*)m_arypCodingGroups.GetAt(j);
					if(pEMNGroupInfo->m_nEmrCodingGroupID == pCodingGroup->GetID()) {
						//found our group
						bFoundGroup = TRUE;
					}
				}

				//if this group is not in use, see if one of its charges are in use
				if(!bFoundGroup) {
					CArray<long,long> arynCptCodeIDs;
					pCodingGroup->GetAllCptCodeIDs(&arynCptCodeIDs);
					BOOL bFoundCode = FALSE;
					for(int j=0; j<arynCptCodeIDs.GetSize() && !bFoundCode; j++) {
						long nCPTID = (long)arynCptCodeIDs.GetAt(j);
						if(m_aryCharges.FindByServiceID(nCPTID)) {
							//a code in this group is used on this EMN
							bFoundCode = TRUE;
						}
					}

					if(bFoundCode) {
						//at least one code is in use on this EMN,
						//the rules will not be applied to this change
						Log("EMR Coding Group '%s' will not be applied to EMN ID %li.", pCodingGroup->GetName(), m_nID);
						continue;
					}
				}
			}

			//we're definitely going to process this code, so update this group
			UpdateCodingGroup(pCodingGroup, bPopup, nQuantityToIncrement);

			//returning TRUE will tell the caller that we handled this service,
			//and that it does not need to be manually added
			return TRUE;
		}

	}NxCatchAll(__FUNCTION__);

	return FALSE;
}

// (z.manning 2011-07-12 16:29) - PLID 44469
BOOL CEMN::IsCptCodeInCodingGroup(const long nServiceID)
{
	CEmrCodingGroup *pCodingGroup = GetMainFrame()->GetEmrCodingGroupManager()->GetCodingGroupByCptID(nServiceID);
	if(pCodingGroup == NULL) {
		// (z.manning 2011-07-12 16:35) - PLID 44469 - This CPT code is not in any coding group at all.
		return FALSE;
	}

	CEmnCodingGroupInfo *pEmnCodingInfo = m_arypCodingGroups.FindByCodingGroupID(pCodingGroup->GetID());
	if(pEmnCodingInfo != NULL) {
		// (z.manning 2011-07-12 16:38) - PLID 44469 - We having coding info for this group
		return TRUE;
	}

	return FALSE;
}

// (j.jones 2011-07-07 15:59) - PLID 38366 - TryUpdateCodingGroup will update the tracked
// quantity (usually by 1, but it can be negative), then process the group's rules for that
// quantity, adding/removing the proper service code(s) as needed.
void CEMN::UpdateCodingGroup(CEmrCodingGroup *pCodingGroup, BOOL bPopup, long nQuantityToIncrement /*= 1*/)
{
	try {

		//do we have this group in memory for this EMN?
		BOOL bFound = FALSE;
		CEmnCodingGroupInfo *pEMNGroupToUse = NULL;
		for(int j=0; j<m_arypCodingGroups.GetSize() && !bFound; j++) {
			CEmnCodingGroupInfo *pEMNGroupInfo = (CEmnCodingGroupInfo*)m_arypCodingGroups.GetAt(j);
			if(pEMNGroupInfo->m_nEmrCodingGroupID == pCodingGroup->GetID()) {
				//found our group
				bFound = TRUE;
				pEMNGroupToUse = pEMNGroupInfo;
			}
		}

		//don't bother adding a group if we're only trying to decrement the quantity,
		//because if we don't already have a group then this decrementing will do nothing
		if(!bFound && nQuantityToIncrement >= 0) {
			pEMNGroupToUse = new CEmnCodingGroupInfo;

			pEMNGroupToUse->m_nEmrCodingGroupID = pCodingGroup->GetID();
			pEMNGroupToUse->m_nGroupQuantity = 0;

			// (j.jones 2011-07-11 14:25) - PLID 44509 - added booleans to track if this group is new or modified,
			// as well as m_nOldQuantity, used for auditing purposes
			pEMNGroupToUse->m_bIsNew = TRUE;
			pEMNGroupToUse->m_bIsModified = TRUE;
			pEMNGroupToUse->m_nOldQuantity = 0;

			m_arypCodingGroups.Add(pEMNGroupToUse);
		}

		//pEMNGroupToUse would only be null if we tried to decrement the quantity
		//of a group that did not exist, in which case we will still return TRUE
		//claiming we handled the service, but we won't actually do anything

		if(pEMNGroupToUse) {
			//increase the quantity by nQuantityToIncrement (usually 1, but it can be negative)
			pEMNGroupToUse->m_nGroupQuantity += nQuantityToIncrement;
			pEMNGroupToUse->m_bIsModified = TRUE;

			// (j.jones 2011-07-11 14:47) - PLID 44509 - even if we don't change any of the codes,
			// set the MoreInfo as unsaved because we will be saving changes to the group's quantity
			// (z.manning 2011-07-14 11:10) - PLID 44469 - We may not be changing this at all and are instead
			// calling this just to popup the charge prompt dialog.
			if(nQuantityToIncrement != 0) {
				// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
				//TES 2/21/2014 - PLID 60972 - Charges are on the Codes topic now
				SetCodesUnsaved();
			}

			//now apply the rules of the coding group, which will update our charge list properly
			ReflectCodingRangeCharges(pCodingGroup, pEMNGroupToUse, bPopup);
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2011-07-07 16:25) - PLID 38366 - ReflectCodingGroupCharges will take in a
// given CEmrCodingGroup, CEmrCodingRange, and the current quantity in use for the group,
// and update the charge list in the more info tab to display the correct charges for the
// current range for the group at that quantity level
// (z.manning 2011-07-11 14:29) - PLID 44469 - Changed quantity param to be a coding group info object
void CEMN::ReflectCodingRangeCharges(CEmrCodingGroup *pCodingGroup, CEmnCodingGroupInfo *pEmnCodingInfo, BOOL bPopup)
{
	try
	{
		if(pCodingGroup == NULL) {
			//this should not have been called without a coding group
			ASSERT(FALSE);
			return;
		}

		//now find the range to use
		CEmrCodingRange *pCodingRange = pCodingGroup->FindByCurQuantity(pEmnCodingInfo->m_nGroupQuantity);

		//we do not permit setting up groups without a range that starts at quantity 1,
		//therefore if you have a positive quantity, it should not be possible to have a
		//group, but no applicable range
		if(pCodingRange == NULL && pEmnCodingInfo->m_nGroupQuantity > 0) {
			//this should not have been called without a coding range
			ASSERT(FALSE);
			return;
		}

		CEMNChargeArray arypAllLoadedCharges, arypNewCodingGroupCharges;
		arypAllLoadedCharges.Append(m_aryCharges);
		if(pCodingRange != NULL) {
			GetChargesByCodingGroupQuantity(pCodingRange, pEmnCodingInfo->m_nGroupQuantity, &arypAllLoadedCharges, &arypNewCodingGroupCharges);
		}

		// (z.manning 2011-07-11 15:10) - PLID 44469 - We need to prompt before we process the new charges because
		// they may change the quantity in the charge prompt dialog.
		if(bPopup && arypNewCodingGroupCharges.GetCount() > 0)
		{
			// (j.jones 2012-03-27 15:10) - PLID 44763 - warn if we're under a global period
			if(GetParentEMR() && GetParentEMR()->GetInterface()) {
				GetParentEMR()->GetInterface()->CheckWarnGlobalPeriod_EMR(m_dtEMNDate);
			}

			CWnd *pParent = NULL;
			CEMRItemAdvMultiPopupDlg *pDlg = GetOpenMultiPopupDlg();
			if(pDlg) {
				pParent = pDlg;
			}
			else {
				pParent = GetParentEMR() ? GetParentEMR()->GetInterface() : NULL;
			}
			// (j.jones 2012-01-26 11:19) - PLID 47700 - added patient ID, and an optional EMNID,
			// both are -1 if this is a template, EMNID is -1 if unsaved
			CEMRChargePromptDlg dlg(pParent, m_bIsTemplate ? -1 : m_pParentEMR->GetPatientID(), &arypNewCodingGroupCharges, m_bIsTemplate ? -1 : GetID(), pCodingGroup, pEmnCodingInfo);
			dlg.DoModal();
			// (z.manning 2011-07-12 14:12) - PLID 44469 - The EMN coding info quantity may have changed so
			// we need to update the coding range.
			pCodingRange = pCodingGroup->FindByCurQuantity(pEmnCodingInfo->m_nGroupQuantity);
		}

		// (z.manning 2011-07-11 16:58) - PLID 44469 - Now look through all the loaded charges for anything that
		// isn't a current charge needs cleaned up.
		for(int nAllChargeIndex = arypAllLoadedCharges.GetCount() - 1; nAllChargeIndex >= 0; nAllChargeIndex--)
		{
			EMNCharge *pTempCharge = arypAllLoadedCharges.GetAt(nAllChargeIndex);
			if(!m_aryCharges.HasCharge(pTempCharge) && !arypNewCodingGroupCharges.HasCharge(pTempCharge)) {
				delete pTempCharge;
				arypAllLoadedCharges.RemoveAt(nAllChargeIndex);
			}
		}

		//we have a group and a range, now we need to
		//change the charge list to reflect the necessary
		//charges & quantity for this current range

		CEMNChargeArray arypChangedCharges;
		CEMNChargeArray arypNewCharges;

		{
			//first find charges we need to remove - these are charges
			//in our group that do not exist at our current level

			CArray<long,long> arynCptCodeIDs;
			pCodingGroup->GetAllCptCodeIDs(&arynCptCodeIDs);
			//remove charges that are not in our range
			for(int i=0; i<arynCptCodeIDs.GetSize(); i++)
			{
				long nCPTID = arynCptCodeIDs.GetAt(i);
				//the coding range might be NULL if we are decrementing the group quantity to zero,
				//in which case we remove all codes in the group
				if(pCodingRange == NULL || pCodingRange->FindByCptID(nCPTID) == NULL) {
					//this CPT is in our group, but not in our current range,
					//so remove it from the EMN if it exists					

					for(int j = m_aryCharges.GetSize()-1; j >= 0; j--) {
						EMNCharge *pCharge = (EMNCharge*)m_aryCharges.GetAt(j);
						if(pCharge->nServiceID == nCPTID) {

							if(GetInterface()) {
								GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_CHARGE, (WPARAM)pCharge, (LPARAM)this);
							}

							// (j.jones 2011-07-14 08:37) - PLID 44509 - if not a new charge, track in our map
							// that this charge was removed by this coding group (later used for auditing)
							if(pCharge->nID != -1) {
								m_mapChargeIDsTo_RemovedByCodingGroupID.SetAt(pCharge->nID, pCodingGroup->GetID());
							}

							RemoveCharge(pCharge);

							// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
							//TES 2/21/2014 - PLID 60972 - Diagnosis Codes are on the Codes topic now
							SetCodesUnsaved();
						}
					}
				}
			}
		}

		CMap<long, long, BOOL, BOOL> mapFoundCharges;

		if(pCodingRange)
		{
			//next find charges that already exist, that are in our current
			//level, and update them to their proper quantities

			for(int i = m_aryCharges.GetSize() - 1; i >=0 ; i--)
			{
				EMNCharge* pCharge = (EMNCharge*)m_aryCharges.GetAt(i);

				CEmrCodingGroupDetail *pRangeDetail = pCodingRange->FindByCptID(pCharge->nServiceID);
				if(pRangeDetail)
				{
					//this code is in our range, and will be updated

					BOOL bFound = FALSE;
					if(mapFoundCharges.Lookup(pCharge->nServiceID, bFound) && bFound) {
						//this would only happen if the service existed multiple times in the list,
						//if it did, we need to remove the duplicate
						
						if(GetInterface()) {
							GetInterface()->SendMessage(NXM_PRE_DELETE_EMN_CHARGE, (WPARAM)pCharge, (LPARAM)this);
						}

						// (j.jones 2011-07-14 08:37) - PLID 44509 - if not a new charge, track in our map
						// that this charge was removed by this coding group (later used for auditing)
						if(pCharge->nID != -1) {
							m_mapChargeIDsTo_RemovedByCodingGroupID.SetAt(pCharge->nID, pCodingGroup->GetID());
						}

						// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
						RemoveCharge(pCharge);
					}
					else {
						//track that we found this service
						mapFoundCharges.SetAt(pCharge->nServiceID, TRUE);

						// (j.jones 2011-07-14 08:37) - PLID 44509 - if not a new charge, track in our map
						// that this charge was modified by this coding group (later used for auditing)
						if(pCharge->nID != -1) {
							m_mapChargeIDsTo_ModifiedByCodingGroupID.SetAt(pCharge->nID, pCodingGroup->GetID());
						}

						//don't notify MoreInfo yet, just track that we changed this charge
						arypChangedCharges.Add(pCharge);
					}
				}
			}
		}

		//finally add any new charges that are in our current level,
		//but do not exist in our charge list
		for(int i = 0; i < arypNewCodingGroupCharges.GetCount(); i++)
		{
			EMNCharge *pCharge = arypNewCodingGroupCharges.GetAt(i);
			//does this code exist in our charge list?
			BOOL bFound = FALSE;
			if(!mapFoundCharges.Lookup(pCharge->nServiceID, bFound) || !bFound) {

				// (j.jones 2012-03-27 15:10) - PLID 44763 - warn if we're under a global period
				if(GetParentEMR() && GetParentEMR()->GetInterface()) {
					GetParentEMR()->GetInterface()->CheckWarnGlobalPeriod_EMR(m_dtEMNDate);
				}

				// (j.jones 2012-08-22 09:23) - PLID 50486 - set the default insured party ID
				pCharge->nInsuredPartyID = GetParentEMR()->GetDefaultChargeInsuredPartyID();

				// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
				AddCharge(pCharge);

				// (j.jones 2011-07-14 08:37) - PLID 44509 - track in our map
				// that this charge was created by this coding group (later used for auditing)
				m_mapChargesTo_CreatedByCodingGroupID.SetAt(pCharge, pCodingGroup->GetID());

				//don't notify MoreInfo yet, just track that we added this charge
				arypNewCharges.Add(pCharge);
			}
		}

		//notify MoreInfo on what we changed/added
		if(arypChangedCharges.GetSize() > 0 || arypNewCharges.GetSize() > 0)
		{
			// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
			//TES 2/21/2014 - PLID 60972 - Diagnosis Codes are on the Codes topic now
			SetCodesUnsaved();

			if(GetInterface()) {

				for(int i=0; i<arypChangedCharges.GetSize(); i++) {
					EMNCharge *pCharge = (EMNCharge*)arypChangedCharges.GetAt(i);
					GetInterface()->SendMessage(NXM_EMN_CHARGE_CHANGED, (WPARAM)pCharge, (LPARAM)this);
				}

				for(int i=0; i<arypNewCharges.GetSize(); i++) {
					EMNCharge *pCharge = (EMNCharge*)arypNewCharges.GetAt(i);
					GetInterface()->SendMessage(NXM_EMN_CHARGE_ADDED, (WPARAM)pCharge, (LPARAM)this);
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (z.manning 2011-07-14 10:08) - PLID 44469
CEmnCodingGroupInfoArray* CEMN::GetCodingGroupInfoArray()
{
	return &m_arypCodingGroups;
}

// (a.walling 2009-10-28 14:05) - PLID 35989 - Find the best topic for a new signature (either a *signature* topic, or the very last topic on an EMN)
// (z.manning 2011-10-28 17:52) - PLID 44594 - Moved this to CEMN from CEMRPreviewCtrlDlg
CEMRTopic* CEMN::FindAppropriateSignatureTopic(bool* pbIsSignatureTopic)
{
	CArray<CEMRTopic*, CEMRTopic*> arTopics;
	GetAllTopics(arTopics);

	if (arTopics.GetSize() == 0) {
		return NULL;
	}

	CArray<CEMRTopic*, CEMRTopic*> arExact;
	CArray<CEMRTopic*, CEMRTopic*> arBegin;		
	CArray<CEMRTopic*, CEMRTopic*> arSomewhere;

	CEMRTopic* pTopic = NULL;
	for (int i = arTopics.GetSize() - 1; i >= 0 && pTopic == NULL; i--) {
		CEMRTopic* pCandidateTopic = arTopics[i];

		if (pCandidateTopic->HideOnEMN()) {
			// for safety's sake
			continue;
		}

		CString strName = pCandidateTopic->GetName();

		strName.TrimLeft();
		strName.TrimRight();

		strName.MakeLower();

		int nSignatureTextIndex = strName.Find("signature");
		
		if (nSignatureTextIndex != -1) {
			pTopic = pCandidateTopic;
			if (pbIsSignatureTopic) {
				*pbIsSignatureTopic = true;
			}
		}
	}

	if (pTopic == NULL) {
		for (int i = arTopics.GetSize() - 1; i >= 0 && pTopic == NULL; i--) {
			CEMRTopic* pCandidateTopic = arTopics[i];

			// (a.walling 2009-11-24 16:57) - PLID 35989 - This was considering blank subtopics as data, which was not intended.
			if (!pCandidateTopic->IsEmpty(NULL, TRUE) || pCandidateTopic->ShowIfEmpty()) {
				pTopic = pCandidateTopic;

				if (pbIsSignatureTopic) {
					*pbIsSignatureTopic = false;
				}
			}
		}

		if (pTopic == NULL) {
			pTopic = arTopics[arTopics.GetSize() - 1];

			if (pbIsSignatureTopic) {
				*pbIsSignatureTopic = false;
			}
		}
	}

	return pTopic;
}

// (z.manning 2011-11-03 16:11) - PLID 42765 - Function to return an array of spawned details based on the 
// give source action information.
// (a.walling 2012-03-14 22:51) - PLID 48896 - returns true if any spawned details are added to the array
// (a.walling 2012-08-16 08:18) - PLID 52163 - No longer returning a bool, simply adds to the array when a detail matching pSpawningInfo is found
void CEMN::GetSpawnedDetails(IN CSpawningSourceInfo *pSpawningInfo, OUT CEMNDetailArray *parypSpawnedDetails, CEMNDetail* pStopAt)
{
	long nCountPre = parypSpawnedDetails->GetCount();

	CArray<CEMNDetail*,CEMNDetail*> arypAllDetails;
	GenerateTotalEMNDetailArray(&arypAllDetails);
	for(int nDetailIndex = 0; nDetailIndex < arypAllDetails.GetCount(); nDetailIndex++)
	{
		CEMNDetail *pDetail = arypAllDetails.GetAt(nDetailIndex);
		if(pSpawningInfo->SpawnedDetail(pDetail)) {
			parypSpawnedDetails->Add(pDetail);
			if (pStopAt == pDetail) {
				break;
			}
		}
	}
}

// (z.manning 2011-11-03 16:11) - PLID 42765
// (z.manning 2011-11-07 17:12) - PLID 46309 - Added param for the separator
CString CEMN::GetSpawnedDetailsSentenceFormats(IN CSpawningSourceInfo *pSpawningInfo, LPCTSTR strSeparator, const bool bHtml)
{
	CString strSpawnedDetailsSentenceFormats;
	CEMNDetailArray arypSpawnedDetails;
	GetSpawnedDetails(pSpawningInfo, &arypSpawnedDetails);
	for(int nSpawnedDetailIndex = 0; nSpawnedDetailIndex < arypSpawnedDetails.GetCount(); nSpawnedDetailIndex++)
	{
		CEMNDetail *pDetail = arypSpawnedDetails.GetAt(nSpawnedDetailIndex);
		// (z.manning 2011-11-04 09:56) - PLID 42765 - Only do this for the types that are "linkable" and able
		// to be inserted on a narrative.
		if(IsDetailLinkable(pDetail))
		{
			CString strDetailSentence = GetSentence(pDetail, NULL, bHtml, bHtml);
			if(!strDetailSentence.IsEmpty()) {
				if(!strSpawnedDetailsSentenceFormats.IsEmpty()) {
					strSpawnedDetailsSentenceFormats += GetActualSpawnedItemsSepator(strSeparator);
				}
				strSpawnedDetailsSentenceFormats += strDetailSentence;
			}
		}
	}
	
	return strSpawnedDetailsSentenceFormats;
}

// (j.jones 2012-01-31 15:13) - PLID 47878 - HasChangesMadeThisSession will return the
// value of m_bChangesMadeThisSession for this EMN.
BOOL CEMN::HasChangesMadeThisSession()
{
	return m_bChangesMadeThisSession;
}

// (j.jones 2012-02-20 09:32) - PLID 47886 - exposed the CEMNChargeArray find function
EMNCharge* CEMN::FindByServiceID(const long nServiceID)
{
	return m_aryCharges.FindByServiceID(nServiceID);
}

// (b.spivey, March 07, 2012) - PLID 48581 - Find and remove conflicting codes that could cause problems. 
//	Most of this logic was existing, I just cut it out and put it in an exposed function of the EMN. 
bool CEMN::FindAndRemoveEMChargeConflicts(long nServiceID, CString strServiceCode)
{

		// (j.jones 2007-08-30 12:57) - PLID 27222 - before adding the service, first check
		// whether the service exists already, and also check if any services in the same series
		// exist (992xx codes only)
		CString strExistingCodes;
		CDWordArray aryExistingCodeIDs;

		for(int nChargesIterator = 0; nChargesIterator < m_aryCharges.GetSize(); nChargesIterator++) {

			long nServiceIDToCheck = m_aryCharges.GetAt(nChargesIterator)->nServiceID;  
			CString strCodeToCheck = m_aryCharges.GetAt(nChargesIterator)->strCode; 

			//see if this code already exists
			if(nServiceIDToCheck == nServiceID) {
				CString strMessage;
				strMessage.Format("The service code '%s' already exists in the charge list of this EMN.\n"
					"If you try to use this code again, it will only increment the quantity by one.\n\n"
					"Are you sure you still wish to use this code?", strServiceCode);
				if(IDNO == MessageBox(NULL, strMessage, "Practice", MB_ICONEXCLAMATION|MB_YESNO)) {
					return false;
				}
			}
			else if(strServiceCode.GetLength() > 3 && strServiceCode.Left(3) == "992") {
				//see if any code in the series exists (992xx codes only)

				//this will look for any code with the same first 4 numbers, such as
				//99201 and 99202, or 99211 and 99212, etc.
				if(strCodeToCheck.GetLength() > 3 && strCodeToCheck.Left(4) == strServiceCode.Left(4)) {
					//it is a code in the same series, so add it to the list
					aryExistingCodeIDs.Add((DWORD)nServiceIDToCheck);
					if(!strExistingCodes.IsEmpty())
						strExistingCodes += "\n";
					strExistingCodes += strCodeToCheck;
				}
			}
		}

		//now, do we have any codes in this series?
		long nCount = aryExistingCodeIDs.GetSize();
		if(nCount > 0) {

			CString strMessage;
			strMessage.Format("The following code(s) potentially conflict with the %s service code you are adding:\n\n"
				"%s\n\n"
				"Do you wish to remove the conflicting code(s) from the EMN?\n\n"
				"Clicking 'Yes' will remove these codes and add the new E/M Checklist code.\n"
				"Clicking 'No' will leave these codes in the list and add the new E/M Checklist code.\n"
				"Clicking 'Cancel' will leave these codes in the list and will NOT add the new E/M Checklist code.",
				strServiceCode, strExistingCodes);
			int nRet = MessageBox(NULL, strMessage, "Practice", MB_ICONEXCLAMATION|MB_YESNOCANCEL);
			if(nRet == IDCANCEL) {
				return false;
			}
			else if(nRet == IDYES) {
				//we need to delete the other codes

				for(int nCodeIterator = 0; nCodeIterator < aryExistingCodeIDs.GetSize(); nCodeIterator++) {
					// (j.jones 2012-02-20 09:25) - PLID 47886 - need to search our memory objects, not the datalist
					EMNCharge* pFoundCharge = FindByServiceID((long)(aryExistingCodeIDs.GetAt(nCodeIterator)));
					if(pFoundCharge) {
						
						//remove from the CEMN object
						// (a.walling 2012-03-22 16:50) - PLID 49141 - Notifies the interface
						this->RemoveCharge(pFoundCharge);
						//Tell our parent, so it can update its interface.
					}
				}
			}
			//if they clicked 'No", do nothing here, continue adding the new code normally
		}

	return true; 
}

// (r.gonet 08/03/2012) - PLID 51027 - Perform Wound Care Auto Coding, which will take a table that
//  can be used with Wound Care Coding (EMRInfoT.UseWithWoundCareCoding = 1) and perform some computation
//  on columns associated with Wound Care Coding (EmrDataT.WoundCareDataType). Then if specific conditions are
//  met, performs condition specific actions.
void CEMN::PerformWoundCareAutoCoding()
{
	// See if we have a table that can be used for Wound Care CPT Coding
	// There may be mulitple in fact, so store them and choose from them later.

	// Go through all the topics on the EMN
	CArray<CEMNDetail *, CEMNDetail *> arypWoundCareCPTCodingTables;
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		CEMRTopic *pTopic = m_arypEMRTopics[i];
		if(pTopic) {
			// Now go through all the details on the topic
			for(int j = 0; j < pTopic->GetEMNDetailCount(); j++) {
				CEMNDetail *pDetail = pTopic->GetDetailByIndex(j);
				if(pDetail) {
					// Is this detail a table? Secondly, can the table be used in Wound Care Auto Coding?
					if(pDetail->m_EMRInfoType == eitTable && pDetail->m_bUseWithWoundCareCoding) {
						// It is and it can, so add this to our found list
						arypWoundCareCPTCodingTables.Add(pDetail);
					} else {
						// This isn't a table, so it can't be used with Wound Care Coding.
					}
				} else {
					// Shouldn't be valid, but skip if so
				}
			}
		} else {
			// This shouldn't happen, but ignore the topic if it does
		}
	}

	// If we found no detail capable of auto coding, then alert the user
	if(arypWoundCareCPTCodingTables.GetSize() == 0) {
		MsgBox(MB_ICONERROR|MB_OK, 
			"Practice was unable to find any tables on the EMN that can be used with Wound Care Coding. "
			"You can setup a table to be used in Wound Care Coding by Creating or Editing a table item and "
			"then enabling Use with Wound Care Coding Calculation. ");
		return;
	} else if(arypWoundCareCPTCodingTables.GetSize() > 1) {
		// Which should we use? It is likely we could use both, but by executive decision, we'll only use one.
		MsgBox(MB_ICONINFORMATION|MB_OK,
			"Practice detected that there are %li tables on the EMN that could be used with Wound Care Coding. "
			"Only one will be used though. Practice will use the first one encountered, which is '%s'.",
			arypWoundCareCPTCodingTables.GetSize(), arypWoundCareCPTCodingTables[0]->GetMergeFieldName(FALSE));
	} else {
		// Perfect, just one table found. Exactly what we need.
	}

	// Perform the auto coding on the found table
	CEMNDetail *pDetail = arypWoundCareCPTCodingTables[0];
	if(pDetail) {
		// Create the coding calculator for this table to determine which conditions are met and then perform the conditional actions.
		CWoundCareCalculator calc(pDetail);
		calc.Calculate();
	} else {
		// This doesn't make sense. We found it above and it wasn't null.
		ThrowNxException("%s : EMR table detail already found was null.", __FUNCTION__);
	}
}


// (a.walling 2012-07-09 12:35) - PLID 51441 - Get next EMN
CEMN* CEMN::GetNextEMN()
{
	if (!this) return NULL;
	using namespace boost;

	CEMNArray& emns = GetParentEMR()->GetAllEMNs();

	range_iterator<CEMNArray>::type it = find(emns, this);
	if (it == end(emns) || ++it == end(emns)) {
		return NULL;
	}

	return *it;
}

// (a.walling 2012-07-09 12:35) - PLID 51441 - Get prev EMN
CEMN* CEMN::GetPrevEMN()
{
	if (!this) return NULL;
	using namespace boost;

	CEMNArray& emns = GetParentEMR()->GetAllEMNs();

	range_iterator<CEMNArray>::type it = find(emns, this);
	if (it == end(emns) || it == begin(emns)) {
		return NULL;
	}

	return *--it;
}

// (a.walling 2012-10-01 08:56) - PLID 52931 - Complex where clause used for datalists or other queries to get the default merge template
CSqlFragment CEMN::GetDefaultTemplateWhereClause()
{
	CSqlFragment sqlWhere;
	if(GetCollectionID() == -1) {
		sqlWhere.Create("EmrDefaultTemplatesT.EmrCollectionID Is Null AND ");
	}
	else {
		sqlWhere.Create("EmrDefaultTemplatesT.EmrCollectionID = {INT} AND ", GetCollectionID());
	}

	//We're on an EMR, could be multiple procedures.
	if(GetProcedureCount() == 0) {
		sqlWhere += "EmrDefaultTemplatesT.ID NOT IN (SELECT TemplateID FROM EmrDefaultTemplateProceduresT)";
	}
	else {
		CString strProcIDs;
		for(int i = 0; i < GetProcedureCount(); i++) {
			sqlWhere += CSqlFragment("EmrDefaultTemplatesT.ID IN (SELECT TemplateID FROM EmrDefaultTemplateProceduresT WHERE ProcedureID = {INT}) AND ", VarLong(GetProcedure(i)->nID));
			CString strProcID;
			strProcID.Format("%li, ", VarLong(GetProcedure(i)->nID));
			strProcIDs += strProcID;
		}
		sqlWhere += CSqlFragment("ID NOT IN (SELECT TemplateID FROM EmrDefaultTemplateProceduresT WHERE ProcedureID NOT IN ({INTSTRING}))", strProcIDs.Left(strProcIDs.GetLength()-2));
	}
	return sqlWhere;
}

// (a.walling 2012-10-01 08:56) - PLID 52931 - Queries or returns cached default merge template
const CEMN::DefaultMergeTemplate& CEMN::GetDefaultMergeTemplate()
{
	if (!m_defaultMergeTemplate) {

		CEMN::DefaultMergeTemplate def;

		//DRT 7/13/2007 - PLID 26680 - We don't need to query the data, GetProcedure() returns a struct that has the name!
		{
			for(int i = 0; i < GetProcedureCount(); i++) {
				def.procedureNames += GetProcedure(i)->strName + ", ";
			}
			def.procedureNames.TrimRight(", ");
		}

		//DRT 7/13/2007 - PLID 26680 - Run all these as a single trip to the server instead of separate.  I'm not sure why, but when you
		//	do this, the records come back using the same field alias
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		CSqlFragment sqlSql;
		sqlSql += CSqlFragment("SELECT Template FROM EmrDefaultTemplatesT WHERE {SQL};\r\n", GetDefaultTemplateWhereClause());

		long nCollectionID = GetCollectionID();
		if(nCollectionID != -1) {
			sqlSql += CSqlFragment("SELECT Name FROM EmrCollectionT WHERE ID = {INT};\r\n", GetCollectionID());
		}

		_RecordsetPtr prsLoad = CreateParamRecordset("{SQL}", sqlSql);

		//1)  Get the current default template
		if(!prsLoad->eof) {
			def.templateName = AdoFldString(prsLoad, "Template");
		}

		if(nCollectionID != -1) {
			//2)  Move to the next recordset and get the collection name, if we have a collection
			prsLoad = prsLoad->NextRecordset(NULL);
			def.collectionName = AdoFldString(prsLoad, "Name");
		}

		m_defaultMergeTemplate = def;
	}

	return *m_defaultMergeTemplate;
}

// (a.walling 2012-10-01 08:56) - PLID 52931 - Manually set default merge template for this group
void CEMN::SetDefaultMergeTemplate(const CString& strTemplate)
{
	GetDefaultMergeTemplate(); // ensure we have one

	if (!m_defaultMergeTemplate) {
		ASSERT(FALSE);
		return;
	}

	// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
	_RecordsetPtr rsDefault = CreateParamRecordset("SELECT ID FROM EmrDefaultTemplatesT WHERE {SQL}", GetDefaultTemplateWhereClause());
	if(rsDefault->eof) {
		_variant_t varCollectionID = GetCollectionID() == -1 ? g_cvarNull : (long)GetCollectionID();
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		// (z.manning, 2011-03-14) - PLID 42801 - Combined all queries in this block to one batch
		CParamSqlBatch sqlBatch;
		sqlBatch.Declare("DECLARE @nNewDefaultTemplateID int");
		sqlBatch.Add("INSERT INTO EmrDefaultTemplatesT (EmrCollectionID, Template) VALUES ({VT_I4}, {STRING})", varCollectionID, strTemplate);
		sqlBatch.Add("SET @nNewDefaultTemplateID = Convert(int, SCOPE_IDENTITY())");
		for(int i = 0; i < GetProcedureCount(); i++) {
			sqlBatch.Add("INSERT INTO EmrDefaultTemplateProceduresT (TemplateID, ProcedureID) VALUES (@nNewDefaultTemplateID, {INT})"
				, VarLong(GetProcedure(i)->nID));
		}

		sqlBatch.Execute(GetRemoteData());

		//auditing
		//Does this need to be audited? 
		//if(nAuditID == -1) nAuditID = BeginNewAuditEvent();
		//AuditEvent(-1, "", nAuditID, aeiEMNTemplate, m_nEMRTemplateID, "Old", "New", aepMedium, aetChanged);
	
	}
	else {
		// (a.walling 2010-11-08 12:12) - PLID 40965 - Parameterized
		ExecuteParamSql("UPDATE EmrDefaultTemplatesT SET Template = {STRING} WHERE ID = {INT}", strTemplate, AdoFldLong(rsDefault, "ID"));
		//auditing
		//Does this need to be audited? 
		//if(nAuditID == -1) nAuditID = BeginNewAuditEvent();
		//AuditEvent(-1, "", nAuditID, aeiEMNTemplate, m_nEMRTemplateID, "Old", "New", aepMedium, aetChanged);
		
	}

	m_defaultMergeTemplate->templateName = strTemplate;
}

// (a.walling 2013-03-14 08:51) - PLID 55640 - Already a cdo thread in progress? wait for it to complete
void CEMN::WaitForCDOThread()
{
	try {
		if (m_cdoThread && m_cdoThread->Joinable()) {
			m_cdoThread->Interrupt();
			m_cdoThread->Join();
		}
	} NxCatchAll(__FUNCTION__);
}

// (z.manning 2013-09-17 13:38) - PLID 58450
void CEMN::CheckSaveEMNForDrugInteractions(BOOL bAlreadySavedAnInteractionChange)
{
	if(m_nDetailChangeLocks > 0)
	{
		// (z.manning 2013-09-17 14:45) - PLID 58450 - We have detail change locks which means we're in
		// the middle of something (probably spawning or unspawning) and should not do something that attempts
		// a save. Instead, flag that we need to call this when detail changes are unlocked.
		m_bNeedToHandleCheckSaveEMNForDrugInteractionsOnDetailUnlock = TRUE;
		
		// (z.manning 2013-09-17 14:46) - PLID 58450 - This already saved flag resets to true every time.
		// Since we could this function could be called multiple times during spawning we only need to set
		// if it's false.
		if(!bAlreadySavedAnInteractionChange) {
			m_bAlreadySavedAnInteractionChange_WhenUnlockingDetail = FALSE;
		}
	}
	else
	{
		CEmrTreeWnd *pTree = GetInterface();
		if(pTree != NULL) {
			pTree->PostMessage(NXM_EMR_CHECK_SAVE_SHOW_DRUG_INTERACTIONS, (WPARAM)this, (LPARAM)bAlreadySavedAnInteractionChange);
		}
	}
}

// (j.jones 2012-11-21 14:04) - PLID 53818 - added ReloadMedicationsFromData, which is allowed to be called 
// on either and EMN or a template, and will call the correct function accordingly
// (j.jones 2013-02-07 09:25) - PLID 55045 - now takes in an optional parameter to disable
// showing drug interactions when the requery finishes
void CEMN::ReloadMedicationsFromData(BOOL bForceReload, BOOL bShowDrugInteractions /*= TRUE*/)
{
	if(m_bIsTemplate) {
		ReloadTemplateMedicationsFromData(bForceReload);
	}
	else {
		ReloadPatientMedicationsFromData(bForceReload, bShowDrugInteractions);
	}
}

// (j.jones 2012-11-21 14:04) - PLID 53818 - added ReloadTemplateMedicationsFromData
// if bForceReload is FALSE, we will only perform this reload if we have any medication objects already loaded
void CEMN::ReloadTemplateMedicationsFromData(BOOL bForceReload)
{
	//throw exceptions to the caller

	if(!m_bIsTemplate) {
		//this is supported on templates only
		ASSERT(FALSE);
		return;
	}

	//if we have no medications and aren't forcing a reload, return now
	if(m_aryMedications.GetSize() == 0 && !bForceReload) {
		return;
	}

	long nEMNID = GetID();

	if(IsUnsaved() || nEMNID == -1) {
		//this should have never be called on an unsaved template, but if so, force a save
		CEmrTreeWnd *pTreeWnd = GetInterface();
		//TES 2/12/2014 - PLID 60740 - No need to check IsMoreInfoUnsaved() if we've already checked IsUnsaved()
		if(!IsLoading() && pTreeWnd && (IsUnsaved() || GetID() == -1)) {
			BOOL bFailed = FALSE;
			if(!IsWritable() || FAILED(pTreeWnd->SaveEMR(esotEMN, (long)this, FALSE))) {
				bFailed = TRUE;
			}
			if(bFailed) {
				//if the EMN is new, we cannot possibly continue, so tell them that
				if(nEMNID == -1) {
					pTreeWnd->MessageBox("The EMN must be saved before medications can be added or modified.", "Practice", MB_ICONEXCLAMATION|MB_OK);
					return;
				}
			}
		}
	}

	//clear all our loaded meds
	for(int i=0; i<m_aryMedications.GetSize(); i++) {
		delete (EMNMedication*)m_aryMedications.GetAt(i);
	}
	m_aryMedications.RemoveAll();

	//reload from data, reusing the parameterized sql from when originally loading the template
	CString strSql;
	AppendTemplateLoadSubQuery_rsMedications(strSql);
	_CommandPtr pCmd = OpenParamQuery(strSql);
	AddParameterLong(pCmd, "TemplateID", m_nID);
	_RecordsetPtr rsMedications = CreateRecordset(pCmd);

	BOOL bAddedAMedication = FALSE;

	while(!rsMedications->eof) {

		AddTemplateMedicationFromRecordset(TRUE, rsMedications);

		rsMedications->MoveNext();
	}

	//almost done - we need to update the more info screen if it exists
	if(GetInterface()) {
		GetInterface()->SendMessage(NXM_EMN_REFRESH_PRESCRIPTIONS, (WPARAM)this);
	}
}

// (c.haag 2014-07-16) - PLID 54905 - Reloads only the charges section of this EMN
void CEMN::ReloadChargesFromData()
{
	if (m_bUnsaved)
	{
		ThrowNxException("CEMN::ReloadCharges should not be called if the EMN has been modified.");
	}
	else if (m_nID <= 0)
	{
		// Not in data; nothing to load
		m_aryCharges.Clear();
		m_aryOriginalCharges.Clear();
		return;
	}
	else
	{
		CSqlFragment sqlLoadIDs = CSqlFragment("(SELECT {INT} AS ID)", m_nID);
		CSqlFragment sqlLoadSql = CSqlFragment(m_pParentEMR->AppendLoadSubQuery_rsChargesWhichCodes(), sqlLoadIDs, sqlLoadIDs);
		_RecordsetPtr prsCharges = CreateParamRecordset("{SQL}", sqlLoadSql);
		_RecordsetPtr prsWhichCodes = prsCharges->NextRecordset(NULL);
		LoadChargesFromEmnRecordsets(m_nID, prsCharges, prsWhichCodes);
	}
}

// (j.jones 2013-06-18 13:23) - PLID 47217 - added ability to remove all signature details from new EMNs
void CEMN::RemoveNewSignatureDetails()
{
	//this should never be called on a saved EMN
	if(m_nID != -1) {
		//silently return, but this is a coding error, as this function
		//is only meant to be called on new EMNs
		ASSERT(FALSE);
		return;
	}

	//run through every topic
	for(int i = 0; i < m_arypEMRTopics.GetSize(); i++) {
		m_arypEMRTopics[i]->RemoveNewSignatureDetails();
	}
}

// (b.savon 2014-03-07 10:13) - PLID 60826 - SPAWN - Check if any unmatched diagcodes
BOOL CEMN::HasUnmatchedDiagnosisCodes(long nWarnIfUnmatchedPreference)
{
	// Only do the check if they are in crosswalk mode and have the preference set; otherwise just return that they don't have any unmatched
	if( DiagSearchUtils::GetPreferenceSearchStyle() != eICD9_10_Crosswalk || nWarnIfUnmatchedPreference == 0 ){
		return FALSE;
	}

	for (int iDiag = 0; iDiag < m_aryDiagCodes.GetCount(); iDiag++){
		EMNDiagCode* pDiag = m_aryDiagCodes.GetAt(iDiag);
		// Check ICD-10 unmatched
		if( nWarnIfUnmatchedPreference == 2 /*Warn if ICD-10 unmatched*/ || nWarnIfUnmatchedPreference == 3 /*Warn when either code is unmatched*/ ){
			if( pDiag->nDiagCodeID_ICD10 == -1 && pDiag->MatchType != nexgemtDone ){
				return TRUE;
			}
		}

		// Check ICD-9 unmatched
		if( nWarnIfUnmatchedPreference == 1 /*Warn if ICD-10 unmatched*/ || nWarnIfUnmatchedPreference == 3 /*Warn when either code is unmatched*/ ){
			if( pDiag->nDiagCodeID == -1 && pDiag->MatchType == nexgemtDone ){
				return TRUE;
			}
		}
	}
	return FALSE;
}

// (b.savon 2014-09-10 09:39) - PLID 62712 - Handle the ToDo creation preference when spawning diagnosis tuples in a different search mode
void CEMN::ProcessSpawnedDiagnosisForTodoCreationInMisalignedModes(const EmrAction &ea)
{
	DiagCodeSearchStyle ICDPreference = DiagSearchUtils::GetPreferenceSearchStyle();
	bool bIn9AndMissing9 = (ICDPreference == DiagCodeSearchStyle::eManagedICD9_Search && ea.diaDiagnosis.nDiagCodeID_ICD9 == -1);
	bool bIn10AndMissing10 = (ICDPreference == DiagCodeSearchStyle::eManagedICD10_Search && ea.diaDiagnosis.nDiagCodeID_ICD10 == -1);
	bool bCreateToDo = false;
	if (bIn9AndMissing9 || bIn10AndMissing10){
		int nTodoPref = GetRemotePropertyInt("CreateTodoWhenDiagCodeSpawnedInDiffDiagMode", 0, 0, "<None>");
		if (nTodoPref == 0){
			CString strMessage;
			if (ICDPreference == DiagCodeSearchStyle::eManagedICD9_Search){
				strMessage = "An action was found to spawn an ICD-10 code, but you are currently in ICD-9 mode.  Would you like to create a ToDo to fix the following action?";
			}
			else if (ICDPreference == DiagCodeSearchStyle::eManagedICD10_Search){
				strMessage = "An action was found to spawn an ICD-9 code, but you are currently in ICD-10 mode. Would you like to create a ToDo to fix the following action?";
			}

			if (IDYES == MsgBox(MB_YESNO | MB_ICONQUESTION, _T(strMessage)))
			{
				bCreateToDo = true;
			}
		}
		else if (nTodoPref == 1){
			bCreateToDo = true;
		}
	}

	if (bCreateToDo){
		NexTech_Accessor::DiagDisplayType mode;
		if (ICDPreference == DiagCodeSearchStyle::eManagedICD9_Search){
			mode = NexTech_Accessor::DiagDisplayType_ICD9;
		}
		else if (ICDPreference == DiagCodeSearchStyle::eManagedICD10_Search){
			mode = NexTech_Accessor::DiagDisplayType_ICD10;
		}

		CString strEmrActionID;
		CString strEMNID;
		strEmrActionID.Format("%li", ea.nID);
		strEMNID.Format("%li", m_nID);
		GetAPI()->CheckForSpawnedDiagMismatchWithModeAndCreateTodo(GetAPISubkey(), GetAPILoginToken(), mode, AsBstr(strEmrActionID), AsBstr(strEMNID));
	}
}

// (c.haag 2016-06-09 14:54) - PLID-66502 - Returns TRUE if a charge was modified
BOOL CEMN::WasChargeChanged(EMNCharge* pCharge)
{
	// (c.haag 2016-06-09 14:54) - PLID-66502 - Moved from GenerateSaveString

	// (z.manning, 09/11/2006) - PLID 22278 - Yes, the EMNCharge struct has a bChanged member,
	// but it wasn't being set reliably, so rather than relying on it and since we're already
	// comparing the old data to the new for auding, let's just use that to see if we even
	// need to bother saving this charge.
	BOOL bChargeChanged = FALSE;

	//TES 6/15/2012 - PLID 50983 - To determine whether a charge changed, we're going to compare against m_aryOriginalCharges,
	// rather than the data.  If some other user changed a charge value, we don't want to save our data over that change
	// unless we also modified the charge.
	EMNCharge *pOriginalCharge = NULL;
	for (int nOriginalCharge = 0; nOriginalCharge < m_aryOriginalCharges.GetSize() && pOriginalCharge == NULL; nOriginalCharge++) {
		if (m_aryOriginalCharges[nOriginalCharge]->nID == pCharge->nID) {
			pOriginalCharge = m_aryOriginalCharges[nOriginalCharge];
		}
	}
	if (!pOriginalCharge) {
		bChargeChanged = TRUE;
	}
	else {
		// (s.dhole 2014-02-27 12:48) - PLID 60996 look like this has been boroken
		// HasChangedProblemLinks always retun false if problem is not assined to charges
		bChargeChanged = (!(*pOriginalCharge == *pCharge) || pCharge->HasChangedProblemLinks());
	}
	return bChargeChanged;
}