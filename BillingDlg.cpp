// BillingDlg.cpp : implementation file
//

/************************************************************************
	This source contains code for the billing tab of the billing
	module invoked from the Financial tab. Charges that appear in the
	list come from the BillingTabInfoT table. No charge information is
	actually saved until ::SaveChanges().

	There are two NxDataLists in this dialog. One lists charges if a
	bill is opened (m_List), and the other lists charges if a quote is
	opened (m_QuoteList).
	*************************************************************************/

#include "stdafx.h"
#include "Practice.h"
#include "PracProps.h"
#include "BillingDlg.h"
#include "GlobalUtils.h"
#include "EditComboBox.h"
#include "GlobalFinancialUtils.h"
#include "PaymentDlg.h"
#include "BillingModuleDlg.h"
#include "MultiFeeAdjustmentDlg.h"
#include "CPTCodes.h"
#include "InvEditDlg.h"
#include "NxStandard.h"
#include "MsgBox.h"
#include "NxModalParentDlg.h"
#include "GlobalDataUtils.h"
#include "AuditTrail.h"
#include "InvUtils.h"
#include "Barcode.h"
#include "PhaseTracking.h"
#include "ApplyListDlg.h"
#include "ProductItemsDlg.h"
#include "BillingRc.h"
#include "InternationalUtils.h"
#include "DateTimeUtils.h"
#include "CPTCodeInsNotesDlg.h"
#include "PlaceCodeDlg.h"
#include "DontShowDlg.h"
#include "GCEntryDlg.h"
#include "GCRechargeDlg.h"
#include "AnesthesiaTimePromptDlg.h"
#include "PackageUseSelectionDlg.h"
#include "GlobalSchedUtils.h"
#include "ppclink.h"
#include "CareCreditUtils.h"
#include "MultiSelectDlg.h"
#include "EMNQuoteSelectionDlg.h"
#include "DiscountCategorySelectDlg.h"
#include "SuggestedSalesDlg.h"
#include "DiscountBillDlg.h"
#include "Rewards.h"
#include "TodoUtils.h"
#include "SingleSelectDlg.h"
#include "SelectLinkedProductsDlg.h"
#include "OHIPUtils.h"
#include "HL7Utils.h"
#include "BillSelectChargeDigsCodeDlg.h"
#include "BillChangeServiceCodeDlg.h" // (s.dhole 2011-05-25 15:20) - PLID 44953
#include "AlbertaHLINKUtils.h"
#include "NotesDlg.h"
#include "BillingExtraChargeInfoDlg.h"	// (j.dinatale 2012-06-25 09:47) - PLID 51138
#include "InsuranceBilling.h"
#include "Billing2Dlg.h"
#include "DiagSearchUtils.h" // (d.singleton 2014-02-24 11:40) - PLID 60974
#include "DiagQuickListDlg.h"
#include "NxAPI.h"
#include "DiagQuickListUtils.h"
#include "BillingSuggestedSalesDlg.h"
#include "InvAllocationUsageDlg.h"	// (j.jones 2007-11-13 17:21) - PLID 27988
#include "DiagCodeInfo.h"
#include "NexCodeDlg.h"
#include "SelectDlg.h" // (j.gruber 2014-03-31 11:22) - PLID 61602
#include "BillStatusSetupDlg.h"
#include "BillingDiagSearchDlg.h"	// (j.armen 2014-08-06 10:06) - PLID 63161
#include "EditBillTestCodesDlg.h" // (r.gonet 08/05/2014) - PLID 63098

// (a.walling 2010-01-21 16:43) - PLID 37021 - Modified all auditing to take in a patient's internal ID when applicable, -1 if not.

// (a.walling 2014-02-24 11:27) - PLID 61003 - CPtrArray g_aryBillingTabInfoT in CBillingDlg et al should instead be a typed collection: vector<BillingItemPtr> m_billingItems. Also use smart pointers for BillingItem -- shared_ptr, since we don't have VS2010 or later yet to use unique_ptr.

// (a.walling 2014-02-25 13:34) - PLID 61024 - Removed ancient Access error 3048 handling and nonexistent datalist Exception event

extern CPracticeApp theApp;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// (a.walling 2014-04-24 12:00) - VS2013 - no using std in global headers
using namespace std;

// (a.walling 2010-01-14 16:29) - PLID 36889 - Almost all SW_SHOW calls here have been changed to SW_SHOWNOACTIVATE to stop messing with the focus.
// Exceptions include showing the list when initializing, and the 'Bill A' combo boxes

// (a.walling 2007-11-06 10:28) - PLID 28000 - Need to specify namespace
using namespace ADODB;
//cpt code datalist
#define CPT_COLUMN_TOS					0
#define CPT_COLUMN_CODE					1
#define CPT_COLUMN_SUBCODE				2
#define CPT_COLUMN_NAME					3
#define CPT_COLUMN_PRICE				4
#define CPT_COLUMN_CATEGORY				5
#define CPT_COLUMN_SERVICE_ID			6
#define CPT_COLUMN_TAXABLE1				7
#define CPT_COLUMN_TAXABLE2				8
#define CPT_COLUMN_BARCODE				9
#define CPT_COLUMN_IS_AMA				10
#define CPT_COLUMN_ANESTHESIA			11
#define CPT_COLUMN_USE_ANESTH_BILLING	12
#define CPT_COLUMN_FACILITY_FEE			13
#define CPT_COLUMN_USE_FACILITY_BILLING	14
#define CPT_COLUMN_POINTCOST			15
#define CPT_COLUMN_DISCOUNTPERCENT		16
#define CPT_COLUMN_DISCOUNTDOLLARS		17
// (j.jones 2009-03-31 10:59) - PLID 33747 - added OHIP Premium Code information
#define CPT_COLUMN_OHIP_PREMIUM_CODE	18
#define CPT_COLUMN_OHIP_PC_USE_PERCENT	19
#define CPT_COLUMN_OHIP_PC_PERCENTAGE	20
#define CPT_COLUMN_OHIP_PC_ADD_MULTIPLE	21
// (j.jones 2010-11-23 08:51) - PLID 39602 - added column for AssistingCode
#define CPT_COLUMN_ASSISTING_CODE		22
// (j.jones 2012-04-12 10:06) - PLID 49609 - added column for ClaimNote
#define CPT_COLUMN_CLAIM_NOTE			23
// (j.dinatale 2012-06-13 13:42) - PLID 50959 - Added columns for the default NDC values
#define CPT_COLUMN_NDCDEFCODE		24
#define CPT_COLUMN_NDCDEFQTY		25
#define CPT_COLUMN_NDCDEFUNITPRICE	26
#define CPT_COLUMN_NDCDEFUNITTYPE	27
// (j.dinatale 2012-06-22 15:54) - PLID 51138 - Cache if a service code is an NOC code
#define CPT_COLUMN_ISNOC			28
// (j.jones 2012-07-23 13:55) - PLID 51698 - added default pay group ID and pay group category
#define CPT_COLUMN_PAY_GROUP_ID		29
#define CPT_COLUMN_PAY_GROUP_CATEGORY		30
// (r.gonet 07/07/2014) - PLID 62572 - Added a column to store the CPTCodeT.DefaultAsOnHold bit field
#define CPT_COLUMN_DEFAULTASONHOLD	31
#define CPT_COLUMN_CATEGORY_COUNT   32 // (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later

//product datalist
#define PRODUCTS_COLUMN_ID				0
#define PRODUCTS_COLUMN_CATEGORY		1
#define PRODUCTS_COLUMN_SUPPLIER		2
#define PRODUCTS_COLUMN_TAXABLE_1		3
#define PRODUCTS_COLUMN_TAXABLE_2		4
#define PRODUCTS_COLUMN_NAME			5
#define PRODUCTS_COLUMN_BARCODE			6
#define PRODUCTS_COLUMN_SALES_PRICE		7
#define PRODUCTS_COLUMN_CATEGORYID		8
#define PRODUCTS_COLUMN_INS_CODE		9
#define PRODUCTS_COLUMN_POINTCOST		10
#define PRODUCTS_COLUMN_DISCOUNTPERCENT	11
#define PRODUCTS_COLUMN_DISCOUNTDOLLARS	12
// (j.dinatale 2012-06-13 13:42) - PLID 50959 - Added columns for the default NDC values
#define PRODUCTS_COLUMN_NDCDEFCODE		13
#define PRODUCTS_COLUMN_NDCDEFQTY		14
#define PRODUCTS_COLUMN_NDCDEFUNITPRICE	15
#define PRODUCTS_COLUMN_NDCDEFUNITTYPE	16
// (j.dinatale 2012-06-15 10:51) - PLID 51000 - Added claim notes to inventory items
#define PRODUCTS_COLUMN_CLAIM_NOTE		17
#define PRODUCTS_COLUMN_CATEGORY_COUNT	18 // (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
// (j.jones 2016-04-07 13:16) - NX-100077 - added RememberChargeProvider setting
#define PRODUCTS_COLUMN_REMEMBER_CHARGE_PROVIDER 19

//case history datalist
#define CASE_HISTORY_COLUMN_ID		0
#define CASE_HISTORY_COLUMN_DATE	1
#define CASE_HISTORY_COLUMN_NAME	2
#define CASE_HISTORY_COLUMN_AMOUNT	3

//gift certificate datalist
#define GIFT_COLUMN_ID					0
#define	GIFT_COLUMN_NAME				1
#define GIFT_COLUMN_PRICE				2
#define GIFT_COLUMN_CATEGORY			3
#define GIFT_COLUMN_REDEEMABLE			4
#define GIFT_COLUMN_POINTS				5
#define GIFT_COLUMN_DISCOUNTCATEGORYID	6
// (r.gonet 2015-03-27 18:30) - PLID 65277 - Added the Value column to the Gift Certificate dropdown
#define GIFT_COLUMN_VALUE				7

//TES 4/13/2011 - PLID 43249 - Glasses Order datalist
#define	GLASSES_ORDERS_COLUMN_ID		0
#define GLASSES_ORDERS_COLUMN_DATE		1
#define GLASSES_ORDERS_COLUMN_DESCRIPTION	2

// (j.dinatale 2012-06-25 09:21) - PLID 51138 - 
#define WM_SHOW_ADD_CHARGES	(WM_USER + 1000)

// (r.gonet 07/07/2014) - PLID 62569 - On hold charges have a background color of orange
#define CHARGE_ON_HOLD_BACK_COLOR		RGB(255,225,10)
#define CHARGE_ON_HOLD_BACK_COLOR_SEL	RGB(226,198,0)

// (j.jones 2008-09-11 17:26) - PLID 4423 - converted to an enum, and added the Order and Inactive Date columns
// (j.jones 2010-08-17 10:43) - PLID 40135 - added CategoryType
// (j.gruber 2012-01-04 11:39) - PLID 46291 - added BillDescription
enum BillToComboColumns {

	btcID = 0,			//the RespTypeT.ID
	btcRespName,		//the RespTypeT.TypeName
	btcPriority,		//the RespTypeT.Priority
	btcInternalOrder,	//a calculated column for sorting purposes, patient is 0, active resp. is 1, inactive resp. is 2
	btcInsuredPartyID,	//InsuredPartyT.PersonID
	btcInsuranceCoID,	//InsuranceCoT.InsuranceCoID
	btcInsuranceCoName,	//InsuranceCoT.Name	
	btcCategoryTypeID,	//RespTypeT.CategoryType
	btcCategoryTypeName,//the name associated with RespTypeT.CategoryType
	btcInactiveDate,	//InsuredPartyT.ExpireDate (NULL if RespTypeT.ID is not -1)
	btcBillDescription  //RespTypeT.BillDescription
};

// (a.walling 2010-04-06 13:51) - PLID 23643 - inappropriate command ID range (0x8000 -> 0xDFFF / 32768 -> 57343)
#define ID_DELCHARGE		51248
#define ID_EDITPRODITEMS	51249
#define ID_EDIT_CPT_CODES	51250
#define ID_EDIT_INV_ITEMS	51251
#define ID_EDIT_CPT_INS_NOTES 51252
#define	ID_LAUNCH_CODELINK	51253
#define ID_CHANGE_ANESTH_TIME	51254
#define ID_CHANGE_FACILITY_TIME	51255
// (s.dhole 2011-05-24 16:28) - PLID 44953 
#define ID_CHANGE_SERVICE_CODE	51256
// (j.jones 2011-11-01 12:44) - PLID 41558 - added ability to change assisting time
#define ID_CHANGE_ASSISTING_TIME	51257
// (r.gonet 07/07/2014) - PLID 62569 - Context menu option on charge rows to mark a charge on hold
#define ID_MARK_CHARGE_ON_HOLD	51260
// (r.gonet 07/07/2014) - PLID 62569 - Context menu option on on-hold charge rows to remove the hold status
#define ID_REMOVE_CHARGE_HOLD	51261
// (r.gonet 08/05/2014) - PLID 63098 - Context menu option on lab charge rows to edit the test codes
#define ID_EDIT_TEST_CODES	51262


//for AddNewExternalCPT and Product
#define EXT_CASE_HISTORY	1
#define EXT_EMR				2
#define EXT_ALLOCATION		3	// (j.jones 2007-12-14 13:26) - PLID 27988
#define EXT_APPOINTMENT		4	// (j.jones 2008-06-20 11:35) - PLID 26153
#define EXT_GLASSES_ORDER	5	//TES 4/13/2011 - PLID 43249

//m_WhatToAddCombo ("Bill A") rows
#define ROW_BILL_A_CPT_CODE		0
#define ROW_BILL_A_SURGERY		1
#define ROW_BILL_A_PRODUCT		2
#define ROW_BILL_A_QUOTE		3
#define ROW_BILL_AN_APPT		4	// (j.jones 2008-06-20 09:17) - PLID 26153
#define ROW_BILL_A_CASE			5
#define ROW_BILL_A_EMR			6
#define ROW_BILL_A_GIFT			7
#define ROW_BILL_A_GLASSES_ORDER	8	//TES 4/13/2011 - PLID 43249

//m_WhatToAddCombo ("Quote A") rows
#define ROW_QUOTE_A_SURGERY		0
#define ROW_QUOTE_A_PACKAGE		5	// (j.jones 2010-01-06 14:55) - PLID 36757
#define ROW_QUOTE_A_CPT_CODE	1
#define ROW_QUOTE_A_PRODUCT		2
#define ROW_QUOTE_AN_APPT		3	// (j.jones 2008-06-20 09:17) - PLID 26153
#define ROW_QUOTE_A_EMR			4

//Charge item types - Previously known as "ProcCode" (boolean)
#define	ITEM_TYPE_CPT			1	//CPTCodeT
#define ITEM_TYPE_PRODUCT		2	//ProductT
#define	ITEM_TYPE_GIFT			3	//GCTypesT
#define ITEM_TYPE_ADMIN_FEE		4	//AdministrativeFeesT

// (j.jones 2009-09-28 16:15) - PLID 35686 - added POS designation enum
enum POSDesignationColumns {

	posdcID = 0,
	posdcCode,
	posdcDesc,
};

// (r.gonet 2016-04-07) - NX-100072 - Constructs a new ClaimDates structure.
ClaimDates::ClaimDates()
{
	eConditionDateType = ConditionDateType::cdtFirstVisitOrConsultation444;
}

// (r.gonet 2016-04-07) - NX-100072 - Gets the first condition date.
COleDateTime ClaimDates::GetFirstConditionDate() const
{
	switch (eConditionDateType) {
	case ConditionDateType::cdtFirstVisitOrConsultation444:
		return dtFirstVisitOrConsultationDate;
	case ConditionDateType::cdtInitialTreatmentDate454:
		return dtInitialTreatmentDate;
	case ConditionDateType::cdtLastSeenDate304:
		return dtLastSeenDate;
	case ConditionDateType::cdtAcuteManifestation453:
		return dtAcuteManifestationDate;
	case ConditionDateType::cdtLastXray455:
		return dtLastXRayDate;
	case ConditionDateType::cdtHearingAndPrescription471:
		return dtHearingAndPrescriptionDate;
	case ConditionDateType::cdtAssumedCare090:
		return dtAssumedCareDate;
	case ConditionDateType::cdtRelinquishedCare91:
		return dtRelinquishedCareDate;
	case ConditionDateType::cdtAccident439:
		return dtAccidentDate;
	default:
		ThrowNxException("%s : eConditionDateType is invalid (%li)", __FUNCTION__, eConditionDateType);
	}
}

// (r.gonet 2016-04-07) - NX-100072 - Sets the first condition date.
void ClaimDates::SetFirstConditionDate(COleDateTime dtFirstConditionDate)
{
	switch (eConditionDateType) {
	case ConditionDateType::cdtFirstVisitOrConsultation444:
		dtFirstVisitOrConsultationDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtInitialTreatmentDate454:
		dtInitialTreatmentDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtLastSeenDate304:
		dtLastSeenDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtAcuteManifestation453:
		dtAcuteManifestationDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtLastXray455:
		dtLastXRayDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtHearingAndPrescription471:
		dtHearingAndPrescriptionDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtAssumedCare090:
		dtAssumedCareDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtRelinquishedCare91:
		dtRelinquishedCareDate = dtFirstConditionDate;
		break;
	case ConditionDateType::cdtAccident439:
		dtAccidentDate = dtFirstConditionDate;
		break;
	default:
		ThrowNxException("%s : eConditionDateType is invalid (%li)", __FUNCTION__, eConditionDateType);
	}
}

// (r.gonet 2016-04-07) - NX-100072 - Clears all claim dates.
void ClaimDates::Clear()
{
	dtFirstVisitOrConsultationDate = g_cdtNull;
	dtInitialTreatmentDate = g_cdtNull;
	dtLastSeenDate = g_cdtNull;
	dtAcuteManifestationDate = g_cdtNull;
	dtLastXRayDate = g_cdtNull;
	dtHearingAndPrescriptionDate = g_cdtNull;
	dtAssumedCareDate = g_cdtNull;
	dtRelinquishedCareDate = g_cdtNull;
	dtAccidentDate = g_cdtNull;
}

// (r.gonet 2016-04-07) - NX-100072 - Returns true if any claim dates are filled and are valid.
bool ClaimDates::AnyFilledAndValid() const
{
	return dtFirstVisitOrConsultationDate.GetStatus() == COleDateTime::valid
		|| dtInitialTreatmentDate.GetStatus() == COleDateTime::valid
		|| dtLastSeenDate.GetStatus() == COleDateTime::valid
		|| dtAcuteManifestationDate.GetStatus() == COleDateTime::valid
		|| dtLastXRayDate.GetStatus() == COleDateTime::valid
		|| dtHearingAndPrescriptionDate.GetStatus() == COleDateTime::valid
		|| dtAssumedCareDate.GetStatus() == COleDateTime::valid
		|| dtRelinquishedCareDate.GetStatus() == COleDateTime::valid
		|| dtAccidentDate.GetStatus() == COleDateTime::valid;
}

// (r.gonet 2016-04-07) - NX-100072 - Validates the dates according to business logic and
// and returns a warning message to display.
CString ClaimDates::GetValidationWarning() const
{
	//build a warning if any times are invalid, in the future, or before 1800(which is going to count as invalid
	CString strWarningLater, strWarningInvalid, strWarning;
	long nWarningInvalid = 0, nWarningLater = 0;

	//check first visit
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtFirstVisitOrConsultationDate, ConditionDateType::cdtFirstVisitOrConsultation444);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtInitialTreatmentDate, ConditionDateType::cdtInitialTreatmentDate454);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtLastSeenDate, ConditionDateType::cdtLastSeenDate304);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtAcuteManifestationDate, ConditionDateType::cdtAcuteManifestation453);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtLastXRayDate, ConditionDateType::cdtLastXray455);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtHearingAndPrescriptionDate, ConditionDateType::cdtHearingAndPrescription471);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtAssumedCareDate, ConditionDateType::cdtAssumedCare090);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtRelinquishedCareDate, ConditionDateType::cdtRelinquishedCare91);
	GetValidationWarning(strWarningInvalid, nWarningInvalid, strWarningLater, nWarningLater, dtAccidentDate, ConditionDateType::cdtAccident439);

	//build warning
	if (nWarningInvalid != 0 || nWarningLater != 0) {
		strWarningInvalid.TrimRight(", "); //get rid of the ', ' at the end
		strWarningLater.TrimRight(", "); //get rid of the ', ' at the end
										 //both have one
		if (nWarningInvalid == 1 && nWarningLater == 1) {
			strWarning.Format("The %s is invalid. \n"
				"The %s is after today. \n"
				"Please correct these dates before saving.", strWarningInvalid, strWarningLater);
		}
		//invalid has 1 and later greater than 1 
		else if (nWarningInvalid == 1 && nWarningLater > 1) {
			strWarning.Format("The %s is invalid. \n"
				"The following dates are after today: %s. \n"
				"Please correct these dates before saving.", strWarningInvalid, strWarningLater);
		}
		//later has 1 and warning greater than 1
		else if (nWarningInvalid > 1 && nWarningLater == 1) {
			strWarning.Format("The following dates are invalid: %s. \n"
				"The %s is after today. \n"
				"Please correct these dates before saving.", strWarningInvalid, strWarningLater);
		}
		//invalid is 1 and later is 0
		else if (nWarningInvalid == 0 && nWarningLater == 1) {
			strWarning.Format("The %s is after today. \n"
				"Please correct this date before saving.", strWarningLater);
		}
		//later is 1 and invalid is 0
		else if (nWarningInvalid == 1 && nWarningLater == 0) {
			strWarning.Format("The %s is invalid. \n"
				"Please correct this date before saving.", strWarningInvalid);
		}
		//invalid greater than 1 and later is 0
		else if (nWarningInvalid > 1 && nWarningLater == 0) {
			strWarning.Format("The following dates are invalid: %s. \n"
				"Please correct these dates before saving.", strWarningInvalid);
		}
		//later greater than 1 and invalid is 0
		else if (nWarningInvalid == 0 && nWarningLater > 1) {
			strWarning.Format("The following dates are after today: %s. \n"
				"Please correct these dates before saving.", strWarningLater);
		}
		//both greater than 1
		else {
			strWarning.Format("The following dates are invalid: %s. \n"
				"The following dates are after today: %s. \n"
				"Please correct these dates before saving.", strWarningInvalid, strWarningLater);
		}
	}
	return strWarning;
}

// (r.gonet 2016-04-07) - NX-100072 - Gets a description of a ConditionDateType enum value.
CString GetConditionDateTypeDescription(ConditionDateType eConditionDateType)
{
	switch (eConditionDateType) {
	case ConditionDateType::cdtFirstVisitOrConsultation444:
		return "First Visit or Consultation";
	case ConditionDateType::cdtInitialTreatmentDate454:
		return "Initial Treatment Date";
	case ConditionDateType::cdtLastSeenDate304:
		return "Last Seen Date / Latest Visit";
	case ConditionDateType::cdtAcuteManifestation453:
		return "Acute Manifestation of a Chronic Condition";
	case ConditionDateType::cdtLastXray455:
		return "Last X-Ray Date";
	case ConditionDateType::cdtHearingAndPrescription471:
		return "Hearing And Prescription Date";
	case ConditionDateType::cdtAssumedCare090:
		return "Assumed Care Date";
	case ConditionDateType::cdtRelinquishedCare91:
		return "Relinquished Care Date";
	case ConditionDateType::cdtAccident439:
		return "Accident Date";
	default:
		ASSERT(FALSE);
		return "<Unknown Date Type>";
	}
}

// (r.gonet 2016-04-07) - NX-100072 - Gets warnings for a particular date and condition date type.
void ClaimDates::GetValidationWarning(CString& strWarningInvalid, long& nWarningInvalid, CString& strWarningLater, long& nWarningLater, 
	COleDateTime dt, ConditionDateType eConditionDateType) const
{
	COleDateTime dtOldDate;
	dtOldDate.SetDateTime(1800, 1, 1, 1, 1, 1);

	if (dt.GetStatus() == COleDateTime::valid) {

		if (dt < dtOldDate) {
			strWarningInvalid += FormatString("%s, ", GetConditionDateTypeDescription(eConditionDateType));
			nWarningInvalid++;
		}

		if (dt > COleDateTime::GetCurrentTime()) {
			strWarningLater += FormatString("%s, ", GetConditionDateTypeDescription(eConditionDateType));
			nWarningLater++;
		}
	} else if (dt.GetStatus() == COleDateTime::invalid) {
		strWarningInvalid += FormatString("%s, ", GetConditionDateTypeDescription(eConditionDateType));
		nWarningInvalid++;
	}
}

// (j.jones 2011-10-04 09:08) - PLID 45799 - the charge list(s) are now DL2 controls,
// so I changed all DL1 references to use NXDATALISTLib, and changed the namespace to be DL2
using namespace NXDATALIST2Lib;
/////////////////////////////////////////////////////////////////////////////
// CBillingDlg dialog

// (z.manning, 04/16/2008) - PLID 29680 - Removed all references to obsolete 640x480 dialogs

// (a.walling 2008-05-05 12:53) - PLID 29897 - All references to GetActivePatientName have been replaced with GetBillPatientName
// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
// (a.walling 2011-08-26 09:56) - PLID 45199 - CMaintainFocus moved to NexTechDialog header

// (j.jones 2014-05-13 09:08) - PLID 61837 - added tablechecker for the charge claim provider setup;
// (r.gonet 07/01/2014) - PLID 62531 - Added a tablechecker for the BillStatusT table
// (r.gonet 07/01/2014) - PLID 62523 - Added a tablechecker for the BillStatusNoteT table
CBillingDlg::CBillingDlg(CWnd* pParent, UINT nIDTemplate)
	: CNxDialog(nIDTemplate, pParent),
	m_DiagCodeChecker(NetUtils::DiagCodes), m_CPTCodeChecker(NetUtils::CPTCodeT),
	m_POSChecker(NetUtils::LocationsT), m_POSDesigChecker(NetUtils::PlaceOfServiceDesignation), m_ProviderChecker(NetUtils::Providers),
	m_ModiferChecker(NetUtils::CPTModifierT), m_ProductChecker(NetUtils::Products), m_SurgeryChecker(NetUtils::SurgeriesT),
	m_PatCoordChecker(NetUtils::Coordinators), m_ClaimProviderChecker(NetUtils::ChargeLevelProviderConfigT),
	m_BillStatusChecker(NetUtils::BillStatusT), m_BillStatusNoteChecker(NetUtils::BillStatusNoteT)
{
	m_EntryType = BillEntryType::Bill;
	// (j.jones 2011-01-21 10:10) - PLID 42156 - this is now an enum
	m_eHasAccess = batNoAccess;
	m_nIDTemplate = nIDTemplate;

	// (d.singleton 2012-03-07 09:33) - PLID 49100 load images to mem variables
	// (d.singleton 2012-03-22 15:43) - PLID 49136 add notes column
	m_hIconCheck = (HICON)LoadImage(AfxGetApp()->m_hInstance,
		MAKEINTRESOURCE(IDI_GREEN_CHECK), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
	m_hIconRedX = (HICON)LoadImage(AfxGetApp()->m_hInstance,
		MAKEINTRESOURCE(IDI_X), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
	m_hIconWarning = (HICON)LoadImage(AfxGetApp()->m_hInstance,
		MAKEINTRESOURCE(IDI_BLUE_QUESTION), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
	m_hIconNotes = (HICON)LoadImage(AfxGetApp()->m_hInstance,
		MAKEINTRESOURCE(IDI_TOPIC_OPEN), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
	m_hIconHasNotes = (HICON)LoadImage(AfxGetApp()->m_hInstance,
		MAKEINTRESOURCE(IDI_BILL_NOTES), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
}

CBillingDlg::~CBillingDlg() {

	// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
	int i = 0;

	// (j.jones 2009-08-12 15:32) - PLID 35179 - clear our case history arrays
	ClearCaseHistoryArray();
	ClearOldCaseHistoryArray();

	m_billingItems.clear();

	for (i = m_arypBilledQuotes.GetSize() - 1; i >= 0; i--) {
		delete m_arypBilledQuotes.GetAt(i);
	}
	m_arypBilledQuotes.RemoveAll();

	for (i = m_pServiceModifierLinks.GetSize() - 1; i >= 0; i--) {
		ServiceModifierLink *pLink = (ServiceModifierLink*)(m_pServiceModifierLinks.GetAt(i));
		delete pLink;
	}
	m_pServiceModifierLinks.RemoveAll();

	// (d.singleton 2012-03-07 09:37) - PLID 49100
	// (d.singleton 2012-03-22 15:43) - PLID 49136 add notes column
	DestroyIcon((HICON)m_hIconCheck);
	DestroyIcon((HICON)m_hIconRedX);
	DestroyIcon((HICON)m_hIconWarning);
	DestroyIcon((HICON)m_hIconNotes);
	DestroyIcon((HICON)m_hIconHasNotes);
}


void CBillingDlg::DoDataExchange(CDataExchange* pDX)
{
	CNxDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBillingDlg)
	DDX_Control(pDX, IDC_BTN_EDIT_POS_CODES, m_nxibEditPOSCodes);
	DDX_Control(pDX, IDC_BTN_EDIT_CODES, m_nxibEditCodes);
	DDX_Control(pDX, IDC_BTN_APPLY_DISCOUNT_TO_ALL, m_nxibApplyDiscountToAll);
	DDX_Control(pDX, IDC_BTN_TOGGLE_INDIV_BATCH, m_nxibToggleIndivBatch);
	DDX_Control(pDX, IDC_BTN_SHOW_SUGGESTED_SALES, m_nxibShowSuggestedSales);
	DDX_Control(pDX, IDC_QUOTE_USE_EXP_CHECK, m_quoteExpCheck);
	DDX_Control(pDX, IDC_PACKAGE_CHECK, m_packageCheck);
	DDX_Control(pDX, IDC_RADIO_REPEAT_PACKAGE, m_radioRepeatPackage);
	DDX_Control(pDX, IDC_RADIO_MULTIUSE_PACKAGE, m_radioMultiUsePackage);
	DDX_Control(pDX, IDC_FILTER_CODES, m_filterCodesButton);
	DDX_Control(pDX, IDC_QUOTE_EXP_DAYS, m_nxeditQuoteExpDays);
	DDX_Control(pDX, IDC_QUOTE_EXPIRE_DATE, m_nxeditQuoteExpireDate);
	DDX_Control(pDX, IDC_PACKAGE_TOTAL_COUNT, m_nxeditPackageTotalCount);
	DDX_Control(pDX, IDC_PACKAGE_COUNT, m_nxeditPackageCount);
	DDX_Control(pDX, IDC_PACKAGE_TOTAL_COST, m_nxeditPackageTotalCost);
	DDX_Control(pDX, IDC_PACKAGE_CURRENT_BALANCE, m_nxeditPackageCurrentBalance);
	DDX_Control(pDX, IDC_LABEL_RESP, m_nxstaticLabelResp);
	DDX_Control(pDX, IDC_QUOTE_EXP_DAY_LABEL, m_nxstaticQuoteExpDayLabel);
	DDX_Control(pDX, IDC_QUOTE_EXPIRE_DATE_LABEL, m_nxstaticQuoteExpireDateLabel);
	DDX_Control(pDX, IDC_LABEL_BILLA, m_nxstaticLabelBilla);
	DDX_Control(pDX, IDC_PACKAGE_TOTAL_COUNT_LABEL, m_nxstaticPackageTotalCountLabel);
	DDX_Control(pDX, IDC_PACKAGE_COUNT_LABEL, m_nxstaticPackageCountLabel);
	DDX_Control(pDX, IDC_PACKAGE_TOTAL_COST_LABEL, m_nxstaticPackageTotalCostLabel);
	DDX_Control(pDX, IDC_PACKAGE_CURRENT_BALANCE_LABEL, m_nxstaticPackageCurrentBalanceLabel);
	DDX_Control(pDX, IDC_LABEL_POS, m_nxstaticLabelPos);
	DDX_Control(pDX, IDC_LABEL_DESIG, m_nxstaticLabelDesig);
	DDX_Control(pDX, IDC_PAID_OUTSIDE_LABEL, m_nxstaticPaidOutsideLabel);
	DDX_Control(pDX, IDC_LABEL_TOTAL_OUTSIDE, m_nxstaticLabelTotalOutside);
	DDX_Control(pDX, IDC_PATIENT_TOTAL_LABEL, m_nxstaticPatientTotalLabel);
	DDX_Control(pDX, IDC_LABEL_TOTAL, m_nxstaticLabelTotal);
	DDX_Control(pDX, IDC_DISCOUNT_TOTAL_LABEL, m_nxstaticDiscountTotalLabel);
	DDX_Control(pDX, IDC_LABEL_DISCOUNTS, m_nxstaticLabelDiscounts);
	DDX_Control(pDX, IDC_BTN_ADVANCED_DISCOUNTING, m_nxibAdvancedDiscounting);
	DDX_Control(pDX, IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL, m_nxstaticPackageOriginalCurrentAmountLabel);
	DDX_Control(pDX, IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, m_editPackageOriginalCurrentAmount);
	DDX_Control(pDX, IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL, m_nxstaticPackageOriginalCurrentCountLabel);
	DDX_Control(pDX, IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, m_editPackageOriginalCurrentCount);
	DDX_Control(pDX, IDC_PACKAGE_SHOW_INITIAL_VALUES, m_checkPackageShowInitialValues);
	DDX_Control(pDX, IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL, m_nxstaticOutsideDiscountTotalLabel);
	DDX_Control(pDX, IDC_LABEL_OUTSIDE_DISCOUNTS, m_nxstaticOutsideLabelDiscounts);
	DDX_Control(pDX, IDC_BILL_STATUS_STATIC, m_nxstaticBillStatus);
	DDX_Control(pDX, IDC_BILL_STATUS_CONFIG_BTN, m_btnBillStatusConfig);
	DDX_Control(pDX, IDC_BILL_STATUS_NOTE_STATIC, m_nxstaticBillStatusNote);
	DDX_Control(pDX, IDC_BILL_STATUS_NOTE_CONFIG_BTN, m_btnBillStatusNoteConfig);
	DDX_Control(pDX, IDC_BILL_STATUS_NOTE_EDIT, m_nxeditBillStatusNote);
	//}}AFX_DATA_MAP
}


// (j.gruber 2009-03-23 17:02) - PLID 33355 - added menu items for new preference
BEGIN_MESSAGE_MAP(CBillingDlg, CNxDialog)
	ON_WM_SHOWWINDOW()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BTN_EDIT_CODES, OnBtnEditCodes)
	ON_COMMAND(ID_EDIT_CPT_CODES, OnEditCPT)
	ON_COMMAND(ID_EDIT_INV_ITEMS, OnEditInventory)
	ON_BN_CLICKED(IDC_PACKAGE_CHECK, OnPackageCheck)
	ON_BN_CLICKED(IDC_RADIO_REPEAT_PACKAGE, OnPackageTypeChanged)
	ON_EN_KILLFOCUS(IDC_PACKAGE_COUNT, OnKillfocusPackageCount)
	ON_EN_KILLFOCUS(IDC_PACKAGE_CURRENT_BALANCE, OnKillfocusPackageCurrentBalance)
	ON_EN_KILLFOCUS(IDC_PACKAGE_TOTAL_COST, OnKillfocusPackageTotalCost)
	ON_EN_KILLFOCUS(IDC_PACKAGE_TOTAL_COUNT, OnKillfocusPackageTotalCount)
	ON_EN_CHANGE(IDC_PACKAGE_TOTAL_COUNT, OnChangePackageTotalCount)
	ON_EN_CHANGE(IDC_PACKAGE_COUNT, OnChangePackageCount)
	ON_BN_CLICKED(IDC_QUOTE_USE_EXP_CHECK, OnQuoteUseExpCheck)
	ON_EN_KILLFOCUS(IDC_QUOTE_EXP_DAYS, OnKillfocusQuoteExpDays)
	ON_COMMAND(ID_EDIT_CPT_INS_NOTES, OnEditCPTInsNotes)
	ON_BN_CLICKED(IDC_BTN_EDIT_POS_CODES, OnBtnEditPosCodes)
	ON_COMMAND(ID_LAUNCH_CODELINK, OnLaunchCodeLink)
	ON_BN_CLICKED(IDC_BTN_TOGGLE_INDIV_BATCH, OnBtnToggleIndivBatch)
	ON_BN_CLICKED(IDC_FILTER_CODES, OnFilterCodes)
	ON_BN_CLICKED(IDC_BTN_SHOW_SUGGESTED_SALES, OnBtnShowSuggestedSales)
	ON_BN_CLICKED(IDC_RADIO_MULTIUSE_PACKAGE, OnPackageTypeChanged)
	ON_MESSAGE(WM_BARCODE_SCAN, OnBarcodeScan)
	ON_BN_CLICKED(IDC_BTN_APPLY_DISCOUNT_TO_ALL, OnBtnApplyDiscountToAll)
	ON_BN_CLICKED(IDC_BTN_ADVANCED_DISCOUNTING, OnBnClickedBtnAdvancedDiscounting)
	ON_COMMAND(ID_PRACTICEFEES, OnApplyDiscountToPracticeFeeLinesOnly)
	ON_COMMAND(ID_BOTHPRACTICEANDOTHERFEES, OnApplyDiscountToAllLines)
	ON_BN_CLICKED(IDC_PACKAGE_SHOW_INITIAL_VALUES, OnPackageShowInitialValues)
	ON_EN_KILLFOCUS(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, OnKillfocusPackageOriginalCurrentAmount)
	ON_EN_KILLFOCUS(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, OnKillfocusPackageOriginalCurrentCount)
	ON_EN_CHANGE(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, OnChangePackageOriginalCurrentAmount)
	ON_EN_CHANGE(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, OnChangePackageOriginalCurrentCount)
	ON_BN_CLICKED(IDC_VERIFY_BILL, &CBillingDlg::OnBnClickedVerifyBill)	// (d.singleton 2012-03-07 17:21) - PLID 25098
	ON_MESSAGE(WM_SHOW_ADD_CHARGES, OnShowEditAdditionalChargeInfo)
	ON_BN_CLICKED(IDC_BILL_STATUS_CONFIG_BTN, &CBillingDlg::OnBnClickedBillStatusConfigBtn)
	ON_BN_CLICKED(IDC_BILL_STATUS_NOTE_CONFIG_BTN, &CBillingDlg::OnBnClickedBillStatusNoteConfigBtn)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBillingDlg message handlers

void CBillingDlg::UpdateView(bool bForceRefresh) // (a.walling 2010-10-12 15:27) - PLID 40906 - UpdateView with option to force a refresh
{
	if (m_EntryType == 1)
		FillBillList();
	else
		FillQuoteList();
}

void CBillingDlg::OnShowWindow(BOOL bShow, UINT nStatus)
{
	CNxDialog::OnShowWindow(bShow, nStatus);

	if (bShow == FALSE || m_boInitialized) {
		if (bShow == FALSE) {
			if (m_pSuggestedSalesDlg) {
				// (a.walling 2007-05-04 11:30) - PLID 14717 - Destroy the suggested sales window
				if (m_pSuggestedSalesDlg->GetSafeHwnd())
					m_pSuggestedSalesDlg->DestroyWindow();

				SetSuggestedSalesHidden();
			}

			//TES 7/1/2008 - PLID 26143 - Clear out any payment IDs we were asked to apply.
			m_dwaPaymentIDsToApply.RemoveAll();
		}
		return;
	}

	CWaitCursor pWait;

	// (a.wetta 2007-05-17 10:41) - PLID 25960 - Suggested sales should not be shown if they don't have the NexSpa license
	bool bHaveNexSpaLicense = g_pLicense && g_pLicense->CheckForLicense(CLicense::lcNexSpa, CLicense::cflrSilent);

	m_nxibShowSuggestedSales.ShowWindow(bHaveNexSpaLicense);

	if (bHaveNexSpaLicense && m_pSuggestedSalesDlg == NULL) { // (a.walling 2007-05-04 11:31) - PLID 14717 - Construct if NULL
		m_pSuggestedSalesDlg.reset(new CBillingSuggestedSalesDlg(this));
		m_pSuggestedSalesDlg->SetBillingDlg(this);
	}

	// (a.walling 2007-05-04 11:57) - PLID 14717 - Seems like this should be GetSysColor(COLOR_BTNTEXT)
	// but this is how it's done in NxIconButton, so I'll be consistent
	m_nxibShowSuggestedSales.SetTextColor(0);

	// (s.dhole 2011-06-13 09:51) - PLID 33666 This code will refresh changes user assigned to  DiagS code preference.
	if (m_EntryType == 1) {
		if (ShouldShowDiagExt())
		{
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->PutStoredWidth(0);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->PutColumnStyle(csFixedWidth | csEditable);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->PutStoredWidth(7);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->PutColumnStyle(csVisible | csWidthPercent);
		}
		else
		{
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->PutStoredWidth(7);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->PutColumnStyle(csVisible | csWidthPercent | csEditable);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->PutStoredWidth(0);
			m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->PutColumnStyle(csFixedWidth | csWidthPercent);
		}
		// (s.dhole 2011-06-13 09:51) - PLID 33666 Since we are changing column style on show, i need to set style array
		m_aBillColumnStyles[BILL_COLUMN_WHICH_CODES] = m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->GetColumnStyle();
		m_aBillColumnStyles[BILL_COLUMN_WHICH_CODES_EXT] = m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->GetColumnStyle();

	}

	
	// (j.gruber 2007-05-02 16:17) - PLID 14202 - adding bill discount button
	if (m_EntryType == 1) {
		// (j.gruber 2008-02-07 17:09) - PLID 28803 - change the name of the button
		// (j.gruber 2009-04-22 10:21) - PLID 34042 - change the name again
		SetDlgItemText(IDC_BTN_APPLY_DISCOUNT_TO_ALL, "Apply Discount to All Charges");
	}
	else {
		// (j.gruber 2008-02-07 17:09) - PLID 28803 - change the name of the button
		SetDlgItemText(IDC_BTN_APPLY_DISCOUNT_TO_ALL, "Apply Discount to All Charges");
	}

	// (j.gruber 2007-09-05 16:05) - PLID 27254 - see if this quote has been billed
	if (m_EntryType != 1) {
		if (GetBillID() != -1) {
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			m_bQuoteHasBeenBilled = ReturnsRecordsParam("SELECT BilledQuotesT.ID FROM BilledQuotesT LEFT JOIN BillsT ON BilledQuotesT.BillID = BillsT.ID WHERE BillsT.Deleted = 0 AND BilledQuotesT.QuoteID = {INT}", GetBillID());
		}
		else {
			m_bQuoteHasBeenBilled = FALSE;
		}

	}

	m_nPatientID = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nPatientID;

	// (a.walling 2007-05-04 11:31) - PLID 14717 - Set up the suggested sales dialog and refresh
	if (bHaveNexSpaLicense) {
		m_pSuggestedSalesDlg->SetBillInfo(m_nPatientID, GetBillID());
		m_pSuggestedSalesDlg->RefreshIfNeeded();
	}

	_variant_t var;

	m_DisableRefCount = 0;

	m_bIsScreenEnabled = TRUE;

	m_bIsABilledPackage = FALSE;
	m_bPaymentPlan = FALSE;
	m_RepeatPackageUses = 0;
	m_nPackageID = -1;
	m_nPackageType = -1;

	// (j.jones 2007-11-27 12:32) - PLID 28198 - cache the package information
	m_cyOldPackageTotalAmount = COleCurrency(0, 0);
	m_nOldPackageTotalCount = 0;
	m_cyOldPackageCurrentAmount = COleCurrency(0, 0);
	m_nOldPackageCurrentCount = 0;
	m_cyOldPackageOriginalCurrentAmount = COleCurrency(0, 0);
	m_nOldPackageOriginalCurrentCount = 0;
	// (j.jones 2009-12-23 16:53) - PLID 36699 - added old package type, to finish up this caching
	m_nOldPackageType = -1; //init. to -1 specifying it is not an existing package

	m_bPromptedChargeDate = false;	//this is for charge date prompting.  if we're just opening, they have not been prompted.
	m_bPromptedChargeServiceDateTo = false;
	m_bPromptedChargeInputDate = false;

	//requery the bill to combo to reflect the patient's insured parties
	CString strResp;
	// (j.jones 2008-09-11 17:33) - PLID 4423 - supported showing inactive resps.
	strResp.Format("InsuredPartyT.PatientID = %li", m_nPatientID);
	m_listBillTo->WhereClause = _bstr_t(strResp);
	m_listBillTo->Requery();

	// (j.dinatale 2012-04-25 11:27) - PLID 49690 - need to see if we have any primary vision, cache this info
	// (j.dinatale 2012-06-05 11:11) - PLID 49713 - no longer need to worry about primary vision ID, we use whats on the optical order
	/*_RecordsetPtr rsPrimVision = CreateParamRecordset(
		"SELECT TOP 1 InsuredPartyT.PersonID AS InsuredPartyID, RespTypeT.TypeName AS RespName, InsuranceCoT.Name AS InsName "
		"FROM InsuredPartyT "
		"LEFT JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
		"LEFT JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
		"WHERE CategoryPlacement = 1 AND CategoryType = 2 AND InsuredPartyT.RespTypeID > 0 AND PatientID = {INT} "
		"ORDER BY RespTypeT.Priority ASC;", m_nPatientID);

		if(!rsPrimVision->eof){
		m_nPrimaryVisionID = AdoFldLong(rsPrimVision, "InsuredPartyID", -1);
		m_strPrimaryVisionName = AdoFldString(rsPrimVision, "InsName", "");
		m_strPrimaryVisTypeName = AdoFldString(rsPrimVision, "RespName", "");
		}else{
		m_nPrimaryVisionID = -1;
		m_strPrimaryVisionName = "";
		m_strPrimaryVisTypeName = "";
		}*/

	if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->Clear();
		// (r.gonet 2016-04-07) - NX-100072
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.ClearAdditionalClaimDates();
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pHospFrom->Clear();
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pHospTo->Clear();
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pWorkFrom->Clear();
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pWorkTo->Clear();
		// (j.jones 2013-06-07 15:29) - PLID 41479 - added admission & discharge times
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAdmissionTime->Clear();
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pDischargeTime->Clear();
	}

	//don't bother requerying if it hasn't been loaded the first time yet
	if (m_CPTCodeChecker.Changed() && m_bCPTCombo) {
		//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
		m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
		m_CPTCombo->Requery();
	}

	if (m_POSChecker.Changed()) {
		m_PlaceOfServiceCombo->Requery();
		m_LocationCombo->Requery();
	}

	if (m_POSDesigChecker.Changed()) {
		m_DesignationCombo->Requery();

		NXDATALISTLib::IRowSettingsPtr pRow = m_DesignationCombo->GetRow(-1);
		pRow->PutValue(posdcID, (long)-1);
		pRow->PutValue(posdcCode, _bstr_t(""));
		pRow->PutValue(posdcDesc, _bstr_t("<No Code Selected>"));
		m_DesignationCombo->InsertRow(pRow, 0);
	}

	if (m_EntryType == 1) {
		// (r.gonet 06/30/2014) - PLID 62531 - If the available bill statuses have changed, then update the bill status combo.
		if (m_BillStatusChecker.Changed()) {

			RefreshBillStatusList();
		}

		// (r.gonet 06/30/2014) - PLID 62523 - If the available bill status notes have changed, then update the bill status combo.
		if (m_BillStatusNoteChecker.Changed()) {
			m_pBillStatusNoteCombo->Requery();
		}
	} else {
		// (r.gonet 07/01/2014) - PLID 62531 - The quotes dialog doesn't show bill status controls.
	}

	//DRT 10/1/03 - PLID 9465 - There is no guarantee that either of these lists is created yet (well, 1 of them has to be, but no idea which one).
	//		This was throwing errors!  If it hasn't been created yet, then don't bother resetting the source, it will be set when we create it.
	// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
	// (j.jones 2014-04-22 16:41) - PLID 61836 - added referring, ordering, supervising providers

	IColumnSettingsPtr pProvCol = NULL, pClaimProvCol = NULL, pReferringProvCol = NULL, pOrderingProvCol = NULL, pSupervisingProvCol = NULL;
	if (m_EntryType == 1) {
		//this is a bill
		pProvCol = m_List->GetColumn(BILL_COLUMN_PROVIDER);
		pClaimProvCol = m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER);
		pReferringProvCol = m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER);
		pOrderingProvCol = m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER);
		pSupervisingProvCol = m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER);
	}
	else {
		//this is a quote
		pProvCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER);
		pClaimProvCol = NULL;
		pReferringProvCol = NULL;
		pOrderingProvCol = NULL;
		pSupervisingProvCol = NULL;
	}

	CString strProvCombo, strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo;

	// (j.jones 2014-04-22 16:49) - PLID 61836 - This is now loaded in a modular function.
	GetProviderComboSql(strProvCombo, strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo);


	

	if (pProvCol) {
		pProvCol->ComboSource = _bstr_t(strProvCombo);
	}
	else {
		//this should be impossible
		ASSERT(FALSE);
		ThrowNxException("The Charge Provider column does not exist!");
	}

	if (m_EntryType == 1) {
		//for bills only

		if (pClaimProvCol) {
			pClaimProvCol->ComboSource = _bstr_t(strClaimProvCombo);
		}
		// (j.jones 2014-04-22 16:41) - PLID 61836 - added referring, ordering, supervising providers
		if (pReferringProvCol) {
			pReferringProvCol->ComboSource = _bstr_t(strReferringProvCombo);
		}
		if (pOrderingProvCol) {
			pOrderingProvCol->ComboSource = _bstr_t(strOrderingProvCombo);
		}
		if (pSupervisingProvCol) {
			pSupervisingProvCol->ComboSource = _bstr_t(strSupervisingProvCombo);
		}
	}

	if (m_PatCoordChecker.Changed()) {
		IColumnSettingsPtr pCol;
		pCol = m_List->GetColumn(COLUMN_PATCOORD);
		if (pCol) {
			pCol->ComboSource = "SELECT PersonT.ID, (PersonT.[Last] + ', ' + PersonT.[First] + ' ' + PersonT.Middle) AS Name "
				"FROM PersonT INNER JOIN UsersT ON PersonT.ID = UsersT.PersonID WHERE PersonT.Archived = 0 AND UsersT.PatientCoordinator = 1 ORDER BY (PersonT.[Last] + ', ' + PersonT.[First] + ' ' + PersonT.Middle)";
		}
	}

	// (j.jones 2011-10-06 11:07) - PLID 44941 - always clear the Alberta modifier map
	m_mapAlbertaServiceIDToModifierComboSource.RemoveAll();

	

	if (m_ModiferChecker.Changed())
	{
		// (j.jones 2011-10-06 11:10) - PLID 44941 - if Alberta, we do not need to load anything now,
		// but if not Alberta, we will load our master ComboSource for modifiers
		if (!UseAlbertaHLINK()) {

			// (j.jones 2011-10-06 10:23) - PLID 44941 - recreate the stored m_pfsCPTModifierComboSource
			RefreshCPTModifierComboSource();
		}

		// (j.jones 2007-07-03 16:31) - PLID 26098 - clear out the linked array and rebuild from data
		PopulateServiceModifierLinkArray();
	}

	//don't bother requerying if it hasn't been loaded the first time yet
	if (m_ProductChecker.Changed() && m_bProductsCombo) {

		// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
		RequeryProductCombo();
	}

	if (m_SurgeryChecker.Changed() && m_bSurgeryCombo)
		m_SrgyCombo->Requery();

	//add a patient row to the bill to combo
	{
		NXDATALISTLib::IRowSettingsPtr pRow;
		pRow = m_listBillTo->GetRow(-1);
		// (j.jones 2008-09-11 17:26) - PLID 4423 - converted indices to an enum,
		// and added the Order and Inactive Date columns
		pRow->PutValue(btcID, long(0));
		pRow->PutValue(btcRespName, _bstr_t("Patient"));
		pRow->PutValue(btcPriority, long(0));
		pRow->PutValue(btcInternalOrder, long(0));
		pRow->PutValue(btcInsuredPartyID, long(-1));
		pRow->PutValue(btcInsuranceCoID, long(-1));
		// (j.jones 2008-05-01 11:18) - PLID 29291 - ensured the insco name field was populated with an empty string
		pRow->PutValue(btcInsuranceCoName, _bstr_t(""));
		// (j.jones 2010-08-17 10:43) - PLID 40135 - added CategoryType
		pRow->PutValue(btcCategoryTypeID, (long)rctInvalidRespCategory);
		pRow->PutValue(btcCategoryTypeName, _bstr_t(""));
		pRow->PutValue(btcInactiveDate, g_cvarNull);
		// (j.gruber 2012-01-04 11:40) - PLID 46291 - description
		pRow->PutValue(btcBillDescription, _variant_t(GetRemotePropertyText("PatientRespBillDesc", "", 0, "<None>")));
		m_listBillTo->AddRow(pRow);
	}

	m_cyBillTotal = COleCurrency(0, 0);

	for (int i = m_arypBilledQuotes.GetSize() - 1; i >= 0; i--) {
		delete m_arypBilledQuotes.GetAt(i);
	}
	m_arypBilledQuotes.RemoveAll();

	// (j.jones 2009-08-06 10:26) - PLID 35120 - clear our list of case history IDs
	// (j.jones 2009-08-12 15:32) - PLID 35179 - this is now an array of pointers
	ClearCaseHistoryArray();

	// (j.jones 2009-08-11 16:32) - PLID 35142 - clear the list of "old" case history IDs
	// (j.jones 2009-08-12 15:32) - PLID 35179 - this is now an array of pointers
	ClearOldCaseHistoryArray();

	m_aryBilledEMNInfo.RemoveAll();

	// (j.dinatale 2012-03-20 11:27) - PLID 48893 - need to clear out the set of glasses orders everytime this dialog is shown again
	m_setBilledOpticalOrderIDs.clear();

	// (j.jones 2007-11-14 12:46) - PLID 27988 - safely free any tracked allocations
	FreeTrackedAllocations();

	// (j.jones 2007-11-13 17:45) - PLID 27988 - reload the cached lists of allocations
	PopulateProductToAllocationArray();

	m_cyDefaultChargeDate.SetStatus(COleDateTime::invalid);
	m_DefaultProvider = -1;
	m_DefaultClaimProvider = -1;
	//(e.lally 2009-09-10) PLID 23163 - Load both Ref Phy ID and PCP ID so we can use either one to set the Referring Phys dropdown.
	long nDefaultReferringPhyID = -1;
	long nPatientPcpID = -1;
	long nAffiliatePhysID = -1; // (j.gruber 2011-10-24 13:28) - PLID 45356
	AffiliatePhysType nAffiliatePhysType = afptNone; // (j.gruber 2012-10-17 13:11) - PLID 53227
	CString str;

	GetDlgItem(IDC_LABEL_TOTAL)->SetWindowText(FormatCurrencyForInterface(COleCurrency(0, 0)));

	if (m_EntryType != 1) {
		GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->SetWindowText(FormatCurrencyForInterface(COleCurrency(0, 0)));
		GetDlgItem(IDC_LABEL_DISCOUNTS)->SetWindowText(FormatCurrencyForInterface(COleCurrency(0, 0)));
		//(e.lally 2010-10-22) PLID 30253 - Reset the outside discounts
		GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->SetWindowText(FormatCurrencyForInterface(COleCurrency(0, 0)));
		m_bHasOutsideDiscount = FALSE;
	}

	// (d.singleton 2012-04-24 15:54) - PLID 49086 hide verify button if you dont have the license
	if (!g_pLicense->CheckForLicense(CLicense::lcCodeCorrect, CLicense::cflrSilent)) {
		GetDlgItem(IDC_VERIFY_BILL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_VERIFY_BILL)->EnableWindow(FALSE);
	}

	//(b.spivey - February 26, 2014) PLID 60994 - Flag telling us to load. 
	bool bLoadG2DiagCodes = false;

	try {
		ResizeColumns();

		m_PlaceOfServiceCombo->CurSel = -1;
		m_LocationCombo->CurSel = -1;
		m_DesignationCombo->CurSel = -1;
		m_CPTCombo->CurSel = -1;
		m_ProductsCombo->CurSel = -1;
		m_SrgyCombo->CurSel = -1;
		m_QuotesCombo->CurSel = -1;
		if (m_CaseHistoryCombo != NULL)
			m_CaseHistoryCombo->CurSel = -1;
		// (r.gonet 06/30/2014) - PLID 62531 - Set the bill status combo current selection to no selection
		m_pBillStatusCombo->CurSel = NULL;
		// (r.gonet 06/30/2014) - PLID 62523 - Set the bill status note combo current selection to no selection
		m_pBillStatusNoteCombo->CurSel = NULL;
		// (r.gonet 07/01/2014) - PLID 62523 - Default the status note edit box to no text.
		m_nxeditBillStatusNote.SetWindowText("");

		/////////////////////////////////////////////////////////////////
		// Set the default billing responsibility to the patient if this
		// is a bill...otherwise, hide the combo		
		if (m_EntryType == 1) {
			m_listBillTo->PutCurSel(long(0));	//Patient should always be the first row

			// (j.jones 2009-03-20 09:43) - PLID 9729 - clear the extra diag codes
			ClearDiagCodesList();

			// (j.jones 2009-03-25 10:02) - PLID 33653 - also clear the "old" array
			ClearOldDiagCodesList();

			// (j.gruber 2014-02-24 13:25) - PLID 60942 - Clear the whichCodes
			ClearWhichCodesList();

			// (r.gonet 07/01/2014) - PLID 62531
			m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, (long)-1);
		}
		else
			((CWnd*)GetDlgItem(IDC_COMBO_BILL_TO))->ShowWindow(SW_HIDE);

		/////////////////////////////////////////////////////////////////
		// Set NxDataList pointer according to which list we're looking at
		// (quotes or bills)
		if (m_EntryType == 1) {
			m_pList = m_List;
			GetDlgItem(IDC_QUOTE_LIST)->ShowWindow(SW_HIDE);

			GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->SetWindowText("");
			GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->SetWindowText("");
			GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->SetWindowText("");
			GetDlgItem(IDC_LABEL_DISCOUNTS)->SetWindowText("");
			//(e.lally 2010-10-22) PLID 30253
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->SetWindowText("");
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->SetWindowText("");
		}
		else {
			/////////////////////////////////////////////////////////////////
			// Change the background color to match a quote
			((CNxColor*)GetDlgItem(IDC_NXCOLORCTRL3))->SetColor(GetNxColor());
			((CNxColor*)GetDlgItem(IDC_NXCOLORCTRL7))->SetColor(GetNxColor());
			
			m_pList = m_QuoteList;
			GetDlgItem(IDC_LIST)->ShowWindow(SW_HIDE);

			GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->SetWindowText("Practice Total:");
			GetDlgItem(IDC_LABEL_RESP)->SetWindowText("");

			// (r.gonet 07/01/2014) - PLID 62531 - Hide the status nxcolor, label, and combo
			((CNxColor*)GetDlgItem(IDC_BILL_STATUS_NXCOLOR))->ShowWindow(SW_HIDE);
			m_nxstaticBillStatus.ShowWindow(SW_HIDE);
			GetDlgItem(IDC_BILL_STATUS_COMBO)->ShowWindow(SW_HIDE);
			// (r.gonet 07/01/2014) - PLID 62533 - Hide the status config button
			m_btnBillStatusConfig.ShowWindow(SW_HIDE);
			// (r.gonet 07/01/2014) - PLID 62523 - Hide the status note label and combo
			m_nxstaticBillStatusNote.ShowWindow(SW_HIDE);
			GetDlgItem(IDC_BILL_STATUS_NOTE_COMBO)->ShowWindow(SW_HIDE);
			// (r.gonet 07/01/2014) - PLID 62520 - Hide the status note config button
			m_btnBillStatusNoteConfig.ShowWindow(SW_HIDE);
			// (r.gonet 07/01/2014) - PLID 62524 - Hide the status note edit box
			m_nxeditBillStatusNote.ShowWindow(SW_HIDE);
		}

		/////////////////////////////////////////////////////////////////
		// Empty the charge list
		m_billingItems.clear();

		if (m_EntryType == 1)
			GetDlgItem(IDC_LIST)->ShowWindow(SW_SHOW);
		else
			GetDlgItem(IDC_QUOTE_LIST)->ShowWindow(SW_SHOW);

		m_pList->Clear();

		m_bOrderChanged = FALSE;

		/////////////////////////////////////////////////////////////////
		// Set up Referring physicians combo
		if (!m_bRefCombo && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->Requery();

			NXDATALISTLib::IRowSettingsPtr pRow;
			pRow = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->GetRow(-1);
			_variant_t var;
			var.vt = VT_NULL;
			pRow->PutValue(0, var);
			pRow->PutValue(1, "<No Physician Selected>");
			pRow->PutValue(2, var);
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->InsertRow(pRow, 0);

			m_bRefCombo = TRUE;
		}

		/////////////////////////////////////////////////////////////////
		// Set some member variables to their proper values based on
		// patient information. This is the only time these member
		// variables are set.
		// m.carlson 4/29/2005 PL 16367 - don't retrieve the default physician if they're inactive
		//(e.lally 2009-09-10) PLID 23163 - Added PCP
		// (j.gruber 2011-10-24 13:28) - PLID 45356 - added affiliate physician
		// (j.gruber 2012-10-17 12:57) - PLID 53227 - added AffiliatePhysType
		_RecordsetPtr tmpRS = CreateParamRecordset("SELECT GuarantorID1, GuarantorID2, DefaultReferringPhyID, PCP, (SELECT id FROM persont WHERE PersonT.ID=MainPhysician AND PersonT.Archived = 0) AS MainPhysician, "
			"DefaultDiagID1, DefaultDiagID2, DefaultDiagID3, DefaultDiagID4, AffiliatePhysID, AffiliatePhysType "
			"FROM PatientsT LEFT JOIN (SELECT InsuredPartyT.PersonID AS GuarantorID1, PatientID FROM InsuredPartyT WHERE InsuredPartyT.RespTypeID = 1) AS InsParty1 "	//1 is always primary
			"ON PatientsT.PersonID = InsParty1.PatientID LEFT JOIN (SELECT InsuredPartyT.PersonID AS GuarantorID2, PatientID FROM InsuredPartyT WHERE InsuredPartyT.RespTypeID = 2) AS InsParty2 ON PatientsT.PersonID = InsParty2.PatientID "	//2 is always secondary
			"WHERE PatientsT.PersonID = {INT}", m_nPatientID);
		if (!tmpRS->eof) {
			nDefaultReferringPhyID = AdoFldLong(tmpRS, "DefaultReferringPhyID", -1);
			//(e.lally 2009-09-10) PLID 23163 - Added PCP
			nPatientPcpID = AdoFldLong(tmpRS, "PCP", -1);
			// (j.gruber 2011-10-24 13:29) - PLID 45356 - affiliate physician
			nAffiliatePhysID = AdoFldLong(tmpRS, "AffiliatePhysID", -1);
			// (j.gruber 2012-10-17 12:58) - PLID 53227
			nAffiliatePhysType = (AffiliatePhysType)AdoFldLong(tmpRS, "AffiliatePhysType", afptNone);
			m_Main_Physician = AdoFldLong(tmpRS, "MainPhysician", -1);
			m_GuarantorID1 = AdoFldLong(tmpRS, "GuarantorID1", -1);
			m_GuarantorID2 = AdoFldLong(tmpRS, "GuarantorID2", -1);

			// (j.jones 2011-06-29 17:00) - PLID 43770 - added ability to control when we load these defaults, 
			// (d.thompson 2012-06-27) - PLID 51220 - Changed default to Never (1)
			long nBillLoadG2Codes = GetRemotePropertyInt("BillLoadG2Codes", 1, 0, "<None>", true);
			//0 - load G2 always, 1 - never load, 2 - only load when not billing an EMN upon creation
			// (j.gruber 2016-03-22 10:12) - PLID 68006 - Change m_bCreatedFromEMR to an Enum
			if (nBillLoadG2Codes == 0 ||
				(nBillLoadG2Codes == 2 && ((((CBillingModuleDlg*)m_pBillingModuleWnd)->m_eCreatedFrom != BillFromType::EMR)))) {

				//(b.spivey - February 26, 2014) PLID 60994 - If we are supposed to load, set the flag to true. 
				bLoadG2DiagCodes = true;
			}
		}
		else {
			m_Main_Physician = -1;
			m_GuarantorID1 = -1;
			m_GuarantorID2 = -1;
			nDefaultReferringPhyID = -1;
			//(e.lally 2009-09-10) PLID 23163 - Added PCP
			nPatientPcpID = -1;
			nAffiliatePhysID = -1; // (j.gruber 2011-10-24 13:29) - PLID 45356
			nAffiliatePhysType = afptNone; // (j.gruber 2012-10-17 12:58) - PLID 53227
		}
		tmpRS->Close();

		//TES 1/11/2010 - PLID 33125 - Changed preference to be per-user rather than global.
		// (j.jones 2010-08-31 09:07) - PLID 39218 - this preference now has three options
		// (d.singleton 2014-02-27 17:35) - PLID 61072 - added 4th option to manually choose when creating bill
		// -1 = No Default
		// 0 = Patient Resp
		// 1 = Primary Resp (else Patient if no Primary exists)
		// 2 = they get to choose before creating the bill
		long nDefaultRespType = GetRemotePropertyInt("BillPrimaryIns", GetRemotePropertyInt("BillPrimaryIns", 0, 0, "<None>", false), 0, GetCurrentUserName(), TRUE);

		// (j.gruber 2016-03-22 10:12) - PLID 68006 - override this if we came from HL7, to just use what we chose
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_eCreatedFrom == BillFromType::VisitsToBeBilled)
		{
			nDefaultRespType = 2;
		}

		if (GetBillID() == -1 && m_EntryType == 1) {
			//if a primary insurance exists, and they want it to auto-select primary, then do so
			if (nDefaultRespType == 1 && m_GuarantorID1 != -1) {

				long nRow = m_listBillTo->FindByColumn(btcID, long(1), 0, FALSE);

				if (nRow != -1) {

					//do they only want to do this when the ins.co. is accepted?
					//TES 1/11/2010 - PLID 33125 - Changed preference to be per-user rather than global.
					if (GetRemotePropertyInt("BillPrimaryInsWhenAccepted", GetRemotePropertyInt("BillPrimaryInsWhenAccepted", 0, 0, "<None>", false), 0, GetCurrentUserName(), TRUE) == 1) {
						//yep, so find out if the G1 provider accepts it
						long nInsCoID = VarLong(m_listBillTo->GetValue(nRow, btcInsuranceCoID), -1);

						if (m_Main_Physician != -1) {
							//check the G1 Provider
							// (j.jones 2010-07-23 15:02) - PLID 39783 - accept assignment is calculated in GetAcceptAssignment_ByInsCo now
							BOOL bAccepted = GetAcceptAssignment_ByInsCo(nInsCoID, m_Main_Physician);
							if (bAccepted) {
								//it IS accepted, so we can set the selection
								m_listBillTo->CurSel = nRow;
							}
						}
						else {
							//if no G1 provider, still do this if ALL active providers accept the company

							// (j.jones 2010-07-23 15:03) - PLID 39783 - we now assume accepted if no
							// record exists in InsuranceAcceptedT, so now we just need to see if any
							// active provider does not accept this insurance company
							_RecordsetPtr rsAcc = CreateParamRecordset("SELECT TOP 1 PersonID "
								"FROM ProvidersT "
								"INNER JOIN PersonT ON ProvidersT.PersonID = PersonT.ID "
								"INNER JOIN InsuranceAcceptedT ON ProvidersT.PersonID = InsuranceAcceptedT.ProviderID "
								"WHERE PersonT.Archived = 0 AND InsuranceAcceptedT.InsuranceCoID = {INT} "
								"AND InsuranceAcceptedT.Accepted = 0", nInsCoID);
							if (rsAcc->eof) {
								//if empty, this means that the company is accepted by all
								//active providers, so set the selection
								m_listBillTo->CurSel = nRow;
							}
							rsAcc->Close();
						}
					}
					else {
						//they always want to do this
						m_listBillTo->CurSel = nRow;
					}
				}
			}
			// (j.jones 2010-08-31 09:09) - PLID 39218 - supported ability to default to no
			// responsibility selected
			else if (nDefaultRespType == -1) {
				m_listBillTo->PutCurSel(-1);
			}
			// (d.singleton 2014-02-28 11:08) - PLID 61072 - support ability to manually choose the resp
			else if (nDefaultRespType == 2) {
				long nRow = m_listBillTo->FindByColumn(btcInsuredPartyID, m_nBillToInsPartyID, 0, FALSE);
				if (nRow != -1) {
					m_listBillTo->CurSel = nRow;
				}
			}
			else {
				//default to patient resp
				m_listBillTo->SetSelByColumn(btcPriority, (long)0);
			}
		}

	} NxCatchAll("Error in BillingDlg::OnShowWindow");

	if (GetBillID() == -1) {
		//New Bill

		try {
			//location info
			//TES 11/2/2006 - PLID 23314 - If we were already given a location ID, use it
			//TES 12/4/2006 - PLID 23732 - New plan: if we were given both overrides, just use them.  Otherwise, go through the
			// normal calculations, and then override just the one we were given (if any).
			long nLocationID = -1;
			long nPOSLocationID = -1;

			if (m_nOverrideLocationID == -1 || m_nOverridePOSID == -1) {
				if (nLocationID == -1) {
					// a.walling 4/19/2006
					// if linked to superbill and preference set, pull info from there
					// (j.jones 2011-04-27 15:32) - PLID 43405 - this is now a variant
					if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_varSuperbillID.vt == VT_I4
						&& GetRemotePropertyInt("ApplySuperbillLocation", 0, 0, "<None>", true) == 1)
					{
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rsLoc = CreateParamRecordset("SELECT TOP 1 LocationID, Managed, Active FROM AppointmentsT INNER JOIN "
							"PrintedSuperBillsT ON AppointmentsT.ID = PrintedSuperBillsT.ReservationID "
							"LEFT JOIN LocationsT ON AppointmentsT.LocationID = LocationsT.ID "
							"WHERE PrintedSuperBillsT.SavedID = {INT}", VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_varSuperbillID));
						if (!rsLoc->eof) {
							nPOSLocationID = AdoFldLong(rsLoc, "LocationID", GetCurrentLocationID());
							if (AdoFldBool(rsLoc, "Managed", FALSE)) {
								nLocationID = nPOSLocationID;
							}
							else {
								nLocationID = -1;
							}
						}
						else {
							nLocationID = -1;
						}
					}
				}

				if (nLocationID == -1) {
					//1 - set the location to the currently logged in location
					//2 - set the location to the patient's location
					long nBillLoc = GetRemotePropertyInt("BillLocationPref", 1, 0, "<None>", true);
					if (nBillLoc == 3) {
						// Set the location to the patient's provider's default location
						//TES 9/8/2008 - PLID 27727 - This is now stored in PersonT.Location.
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						// (s.tullis 2016-05-25 15:41) - NX-100760 - Allow null locations
						_RecordsetPtr rs = CreateParamRecordset("SELECT PersonT.Location FROM PatientsT LEFT JOIN (ProvidersT INNER JOIN PersonT ON ProvidersT.PersonID = PersonT.ID) ON PatientsT.MainPhysician = ProvidersT.PersonID LEFT JOIN LocationsT ON PersonT.Location = LocationsT.ID WHERE PatientsT.PersonID = {INT} AND LocationsT.Active = 1 AND MainPhysician IN (SELECT PersonID FROM ProvidersT)", m_nPatientID);
						if (!rs->eof) {
							nLocationID = AdoFldLong(rs, "Location", -1);
							if (nLocationID == -1) {
								nLocationID = GetCurrentLocationID();
							}
						}
						else
						{
							//TES 9/8/2008 - PLID 27727 - It's technically possible for the provider to not have a default location now.
							MsgBox("This patient has no main physician, or the patient's main physician does not have an active default location. The bill location will default to the current location.");
							// Set the location to the currently logged in location
							nLocationID = GetCurrentLocationID();
						}
					}
					else if (nBillLoc == 2) {
						// Set the location to the patient's location
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rs = CreateParamRecordset("SELECT Location FROM PersonT INNER JOIN LocationsT ON PersonT.Location = LocationsT.ID WHERE LocationsT.Active = 1 AND PersonT.ID = {INT}", m_nPatientID);
						if (!rs->eof) {
							nLocationID = AdoFldLong(rs, "Location", GetCurrentLocationID());
						}
						else {
							// (j.jones 2011-06-17 13:09) - PLID 27843 - this message is wrong, the patient more likely than not
							// just does not have a default location
							MsgBox("The patient does not have a valid location selected in General 2 (it may be inactive). The bill location will default to the current location.");
							// Set the location to the currently logged in location
							nLocationID = GetCurrentLocationID();
						}
						rs->Close();
					}
					else {
						// Set the location to the currently logged in location
						nLocationID = GetCurrentLocationID();
					}
				}

				if (nLocationID == -1) nLocationID = GetCurrentLocationID();
				if (nPOSLocationID == -1) nPOSLocationID = nLocationID;
			}

			//Now, apply the overrides
			//TES 12/19/2006 - PLID 23930 - But only if they have them!
			if (m_nOverrideLocationID != -1) nLocationID = m_nOverrideLocationID;
			if (m_nOverridePOSID != -1) nPOSLocationID = m_nOverridePOSID;

			// (j.politis 2015-07-06 11:36) - PLID 65949 - Getting error when try to open edit a bill has  active location but not managed !
			// if you edit any bill for that loaction ( Dr.John Vine )  will give you the error .
			ChangeLocationComboSelection(nLocationID, TRUE);
			// (s.dhole 2010-09-13 16:40) - PLID 38434 This option will overwrite PID 23930 if there is default location selected in preference, 
			long nTempPOSLocationID = GetRemotePropertyInt("DefaultQuotePlaceOfService", -1, 0, "<None>", true);
			if (m_EntryType == 2 && nTempPOSLocationID != -1)
				nPOSLocationID = nTempPOSLocationID;
			m_PlaceOfServiceCombo->SetSelByColumn(0, (long)nPOSLocationID);
			if (m_PlaceOfServiceCombo->CurSel == -1)
				m_PlaceOfServiceCombo->CurSel = 0;
			PostPlaceOfServiceChanged();

		} NxCatchAll("Error determining POS Code status");
	}

	try {
		/////////////////////////////////////////////////////////////////
		// Set default referring ID and designation
		if (GetBillID() == -1 && m_EntryType == 1) {
			//(e.lally 2009-09-10) PLID 23163 - new preference for which provider to use to set the Referring Physican dropdown.
			long nReferringPhysPref = GetRemotePropertyInt("BillSetDefaultRefPhys", 1, 0, "<None>");
			long nSelectedPhysicianID = -1;
			switch (nReferringPhysPref){
				case 1:
				case 3:
					//(e.lally 2009-09-10) PLID 23163 - First, try to set it to the patient's ref phys
					nSelectedPhysicianID = nDefaultReferringPhyID;
					//If there is not one, and the preference calls for the PCP, try that provider
					if (nSelectedPhysicianID < 0 && nReferringPhysPref == 3){
						nSelectedPhysicianID = nPatientPcpID;
					}
					break;
				case 2:
				case 4:
					//(e.lally 2009-09-10) PLID 23163 - First, try to set it to the patient's PCP
					nSelectedPhysicianID = nPatientPcpID;
					//If there is not one, and the preference calls for the ref phys, try that provider
					if (nSelectedPhysicianID < 0 && nReferringPhysPref == 4){
						nSelectedPhysicianID = nDefaultReferringPhyID;
					}
					break;
				case 5:
				default:
					//(e.lally 2009-09-10) PLID 23163 - Do not set the Referring Phys
					break;
			}

			//(e.lally 2009-09-10) PLID 23163 - Do we have a valid physician ID for the referring phys?
			if (nSelectedPhysicianID != -1) {
				COleVariant var = nSelectedPhysicianID;
				// (z.manning 2008-12-08 13:24) - PLID 32320 - Now have an enum for m_pRefList
				//(e.lally 2009-09-10) PLID 23163 - Use TrySetSel so inactive records are detected.
				if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->TrySetSelByColumn(CInsuranceBilling::rpcID, var) == -1){
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->CurSel = sriNoRow;
				}
			}
			else {
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->CurSel = sriNoRow;
			}

			// (j.gruber 2011-10-24 13:30) - PLID 45356
			if (nAffiliatePhysID != -1)
			{
				COleVariant var = nAffiliatePhysID;
				if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_pAffiliatePhysList->TrySetSelByColumn_Deprecated(CBilling2Dlg::aflcID, var) == -1){
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_pAffiliatePhysList->CurSel = NULL;
				}
				else {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_nOldAffiliatePhysID = nAffiliatePhysID;
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_nCurrentAffiliatePhysID = nAffiliatePhysID;
				}

			}

			// (j.gruber 2012-10-17 12:59) - PLID 53227 - fill in the note if there is a type
			if (nAffiliatePhysType != afptNone) {
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_nxeditAffiliatePhysNote.SetWindowTextA(GetAffiliateTypeDescription((AffiliatePhysType)nAffiliatePhysType));
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_strOldAffiliateNote = GetAffiliateTypeDescription((AffiliatePhysType)nAffiliatePhysType);
			}

		}

		//for use when warning later
		BOOL bUpdatedConditionDate = FALSE;
		BOOL bUpdatedFirstConditionDate = FALSE;

		/////////////////////////////////////////////////////////////////
		// Set default injury date
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			long nAccType = GetRemotePropertyInt("DefaultAccidentType", 0, 0, "<None>", true);
			_variant_t varDate;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rs = CreateParamRecordset("SELECT DefaultInjuryDate FROM PatientsT WHERE PersonID = {INT}", m_nPatientID);
			if (!rs->eof) {
				varDate = rs->Fields->Item["DefaultInjuryDate"]->Value;
			}
			rs->Close();

			//this could be an existing bill and we haven't loaded the date yet,
			//so don't forget to check and see if there is one			

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if ((nAccType == 0 || nAccType == 2) && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetStatus() == 3 /*empty*/) {
				if (GetBillID() == -1 || ReturnsRecordsParam("SELECT ConditionDate FROM BillsT WHERE ID = {INT} AND ConditionDate Is Null", GetBillID())) {
					if (varDate.vt == VT_DATE) {
						COleDateTime dt;
						dt = varDate.date;
						((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->SetDateTime(dt);
						//for use when warning later
						bUpdatedConditionDate = TRUE;
					}
					else {
						((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->Clear();
					}
				}
			}
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if ((nAccType == 1 || nAccType == 2) && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pIllness->GetStatus() == 3 /*empty*/) {
				// (r.gonet 2016-04-07) - NX-100072
				if (GetBillID() == -1 
					|| ReturnsRecordsParam(R"(
SELECT TOP 1 NULL
FROM BillsT
WHERE
	BillsT.ID = {INT}
	AND 
	(
		CASE BillsT.ConditionDateType 
			WHEN {CONST_INT} THEN BillsT.FirstVisitOrConsultationDate 
			WHEN {CONST_INT} THEN BillsT.InitialTreatmentDate 
			WHEN {CONST_INT} THEN BillsT.LastSeenDate 
			WHEN {CONST_INT} THEN BillsT.AcuteManifestationDate 
			WHEN {CONST_INT} THEN BillsT.LastXRayDate 
			WHEN {CONST_INT} THEN BillsT.HearingAndPrescriptionDate 
			WHEN {CONST_INT} THEN BillsT.AssumedCareDate 
			WHEN {CONST_INT} THEN BillsT.RelinquishedCareDate 
			WHEN {CONST_INT} THEN BillsT.AccidentDate 
			ELSE NULL 
		END
	) IS NULL 
)",
					GetBillID(),
					ConditionDateType::cdtFirstVisitOrConsultation444,
					ConditionDateType::cdtInitialTreatmentDate454,
					ConditionDateType::cdtLastSeenDate304,
					ConditionDateType::cdtAcuteManifestation453,
					ConditionDateType::cdtLastXray455,
					ConditionDateType::cdtHearingAndPrescription471,
					ConditionDateType::cdtAssumedCare090,
					ConditionDateType::cdtRelinquishedCare91,
					ConditionDateType::cdtAccident439)
				) {
					if (varDate.vt == VT_DATE) {
						COleDateTime dt;
						dt = varDate.date;
						// (r.gonet 2016-04-07) - NX-100072
						((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.SetFirstConditionDate(dt);
						//for use when warning later
						bUpdatedFirstConditionDate = TRUE;
					}
					else {
						// (r.gonet 2016-04-07) - NX-100072
						((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.ClearFirstConditionDate();
					}
				}
			}
		}

		/////////////////////////////////////////////////////////////////
		// Enable or disable resources depending on access

		if (GetBillID() == -1) {
			// (j.jones 2011-01-21 10:10) - PLID 42156 - this is now an enum
			m_eHasAccess = batFullAccess;
		}

		ChangeAccess();

		//if this is an existing bill and we updated a date, warn the user so they will save their changes
		if (m_EntryType == 1 && GetBillID() != -1 && (bUpdatedConditionDate || bUpdatedFirstConditionDate)) {
			CString strWarn;
			strWarn = "Practice has pulled the \"Date Of Current Illness / Accident\" from\n"
				"General 2 and placed it in the ";

			// (r.gonet 2016-04-07) - NX-100072 - Fixed the string to match the label's text.
			if (bUpdatedConditionDate)
				strWarn += "\"Date of Current Illness / Injury\" ";

			if (bUpdatedConditionDate && bUpdatedFirstConditionDate)
				strWarn += "and\n";

			if (bUpdatedFirstConditionDate) {
				// (r.gonet 2016-04-07) - NX-100072
				strWarn += FormatString("\"%s\" ",
					GetConditionDateTypeDescription(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates.eConditionDateType));
			}

			strWarn += "in the Insurance tab of this bill.\n"
				"When you are done viewing this bill, please click OK to save this change.";

			AfxMessageBox(strWarn);
		}


		// (b.eyers 2015-07-14) - PLID 47739 - moved checking the preferences for insurance dates to own function in insurancebilling
		if (m_EntryType == 1) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.UpdateInsuranceDates();
		}

	} NxCatchAll("Error in BillingDlg::OnShowWindow");

	try {
		m_adwDeletedCharges.RemoveAll();
		m_adwEditedCharges.RemoveAll();

		// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
		// (j.jones 2015-02-03 16:50) - PLID 64501 - moved this to apply to both bills and quotes
		m_dtOldDate = (m_peditBillDate->GetValue());
		m_bUpdateDate = FALSE;

		// Diagnosis combo boxes.
		if (m_EntryType == 1) { // Is a bill

			if (m_nIDTemplate == IDD_BILLING_DLG)
			{
				m_packageCheck.ShowWindow(SW_HIDE);
				m_radioRepeatPackage.ShowWindow(SW_HIDE);
				m_radioMultiUsePackage.ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_COUNT_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_COUNT)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_TOTAL_COUNT_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_TOTAL_COUNT)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_QUOTE_EXP_DAY_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_QUOTE_EXP_DAYS)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_QUOTE_USE_EXP_CHECK)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_QUOTE_EXPIRE_DATE_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_QUOTE_EXPIRE_DATE)->ShowWindow(SW_HIDE);
				// (j.jones 2009-12-22 14:32) - PLID 32587 - hide the original amount fields
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_HIDE);
				//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts
				GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);

				// (j.jones 2009-12-31 09:58) - PLID 18765 - ensure the total labels are shown
				GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_SHOWNOACTIVATE);
			}

			if (GetBillID() == -1) {
				//(b.spivey - February 26, 2014) PLID 60994 - load default diag. 
				if (bLoadG2DiagCodes) {
					LoadDefaultDiagnosisCodes();
				}
			}

			if (m_bCptCodesFilter)
			{
				//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
				RemoveCodeFilter(m_CPTCombo, &m_filterCodesButton, m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere); //Remove filter
				m_bCptCodesFilter = false;
			}
			if (m_bProductsFilter == true)
			{
				RemoveCodeFilter(m_ProductsCombo, &m_filterCodesButton, m_strProductsWhere); //Remove filter
				m_bProductsFilter = false;
			}
		}
		else
		{
			// Is a quote
			GetDlgItem(IDC_LABEL_BILLA)->SetWindowText("Quote A");
			m_packageCheck.ShowWindow(SW_SHOWNOACTIVATE);
			m_radioRepeatPackage.ShowWindow(SW_HIDE);
			m_radioMultiUsePackage.ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_HIDE);
			// (j.jones 2009-12-22 14:32) - PLID 32587 - hide the original amount fields
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_HIDE);
			m_checkPackageShowInitialValues.SetCheck(FALSE);

			// (j.jones 2009-12-31 09:58) - PLID 18765 - ensure the total labels are shown
			GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_SHOWNOACTIVATE);
			//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts until it is in use
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);

			GetDlgItem(IDC_QUOTE_EXP_DAY_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXP_DAYS)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_USE_EXP_CHECK)->ShowWindow(SW_SHOWNOACTIVATE);

			// (d.singleton 2012-03-14 16:46) - PLID 25098 - hide verify button if this is a quote
			GetDlgItem(IDC_VERIFY_BILL)->ShowWindow(SW_HIDE);

			SetDlgItemInt(IDC_PACKAGE_COUNT, 1);
			SetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT, 1);
			SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, 1);
			SetDlgItemText(IDC_PACKAGE_TOTAL_COST, FormatCurrencyForInterface(COleCurrency(0, 0)));
			SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, FormatCurrencyForInterface(COleCurrency(0, 0)));
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(COleCurrency(0, 0)));

			// (j.jones 2015-02-24 08:56) - PLID 57494 - cache the current totals
			m_nLastPackageTotalCount = 1;
			m_nLastPackageCount = 1;

			// (d.singleton 2014-03-21 11:43) - PLID 61501 - need to expand the charge list for quotes only so that it goes up to the bottom of the Edit Initial Value box
			CRect rcInitialValues, rcQuoteList;
			GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->GetWindowRect(&rcInitialValues);
			GetDlgItem(IDC_QUOTE_LIST)->GetWindowRect(&rcQuoteList);
			ScreenToClient(&rcInitialValues);
			ScreenToClient(&rcQuoteList);
			//modify the heigth property of the list rect
			long nBorderSpace = 5;
			long nHeight = rcQuoteList.bottom - rcInitialValues.bottom - nBorderSpace;
			//now reflect the change to the list,  move up to initial values checkbox and increase height to fill space
			GetDlgItem(IDC_QUOTE_LIST)->MoveWindow(rcQuoteList.left, rcInitialValues.bottom + nBorderSpace, rcQuoteList.Width(), nHeight);

			m_quoteExpCheck.SetCheck(GetRemotePropertyInt("QuoteDefaultExpires", 0, 0, "<None>", TRUE));
			OnQuoteUseExpCheck();

			if (GetBillID() > 0) {

				_variant_t var;

				_RecordsetPtr tmpRS = CreateParamRecordset("SELECT UseExp, ExpDays FROM BillsT WHERE ID = {INT}", GetBillID());
				if (!tmpRS->eof) {
					_variant_t v;
					v = tmpRS->Fields->Item["UseExp"]->Value;
					if (v.vt == VT_BOOL) {
						if (v.boolVal) {

							m_quoteExpCheck.SetCheck(TRUE);
							OnQuoteUseExpCheck();

							v = tmpRS->Fields->Item["ExpDays"]->Value;
							if (v.vt == VT_I4) {
								SetDlgItemInt(IDC_QUOTE_EXP_DAYS, v.lVal);
								CalcExpireDate();
							}
						}
						else {
							m_quoteExpCheck.SetCheck(FALSE);
							OnQuoteUseExpCheck();
						}
					}
				}
				tmpRS->Close();

				// (j.jones 2009-12-23 10:54) - PLID 32587 - parameterized and added
				// calculation for whether any charge quantities mismatch the initial quantity
				tmpRS = CreateParamRecordset("SELECT PackagesT.*, "
					"Convert(bit, CASE WHEN EditedInitialChargeQtyQ.BillID Is Null THEN 0 ELSE 1 END) AS HasEditedInitialChargeQty "
					"FROM PackagesT "
					"LEFT JOIN (SELECT BillID FROM ChargesT "
					"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"WHERE Deleted = 0 AND Quantity <> OriginalPackageQtyRemaining "
					"GROUP BY BillID) AS EditedInitialChargeQtyQ ON PackagesT.QuoteID = EditedInitialChargeQtyQ.BillID "
					"WHERE PackagesT.QuoteID = {INT}", GetBillID());
				if (!tmpRS->eof) {
					//if not eof, it IS a package
					m_packageCheck.SetCheck(TRUE);

					// (j.jones 2010-08-19 09:48) - PLID 40150 - ensure we select the package report
					((CBillingModuleDlg*)m_pBillingModuleWnd)->SetQuoteReportDropDown(TRUE);

					m_radioRepeatPackage.ShowWindow(SW_SHOWNOACTIVATE);
					m_radioMultiUsePackage.ShowWindow(SW_SHOWNOACTIVATE);

					//1 is the repeat package, 2 is the multi-use package
					// (j.jones 2009-12-23 17:07) - PLID 36699 - cache this
					m_nOldPackageType = AdoFldLong(tmpRS, "Type", 1);
					if (m_nOldPackageType == 1) {
						//repeat package
						m_radioRepeatPackage.SetCheck(TRUE);
						m_radioMultiUsePackage.SetCheck(FALSE);
					}
					else {
						//multi-use package
						m_radioRepeatPackage.SetCheck(FALSE);
						m_radioMultiUsePackage.SetCheck(TRUE);
					}

					OnPackageTypeChanged();

					GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_SHOWNOACTIVATE);
					// (j.jones 2009-12-22 14:32) - PLID 32587 - show the initial value checkbox
					GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_SHOWNOACTIVATE);

					// (j.jones 2009-12-31 09:58) - PLID 18765 - ensure the total labels are hidden
					GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_HIDE);
					//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts
					GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);

					var = tmpRS->Fields->Item["TotalCount"]->Value;
					if (var.vt == VT_I4) {
						SetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT, VarLong(var));

						// (j.jones 2007-11-27 12:37) - PLID 28198 - cache this value
						m_nOldPackageTotalCount = VarLong(var);

						// (j.jones 2015-02-24 08:56) - PLID 57494 - cache here as well
						m_nLastPackageTotalCount = m_nOldPackageTotalCount;
					}
					var = tmpRS->Fields->Item["CurrentCount"]->Value;
					if (var.vt == VT_I4) {
						SetDlgItemInt(IDC_PACKAGE_COUNT, VarLong(var));

						// (j.jones 2007-11-27 12:37) - PLID 28198 - cache this value
						m_nOldPackageCurrentCount = VarLong(var);

						// (j.jones 2015-02-24 08:56) - PLID 57494 - cache here as well
						m_nLastPackageCount = m_nOldPackageTotalCount;
					}
					var = tmpRS->Fields->Item["TotalAmount"]->Value;
					if (var.vt == VT_CY) {
						str = FormatCurrencyForInterface(VarCurrency(var));
						SetDlgItemText(IDC_PACKAGE_TOTAL_COST, str);

						// (j.jones 2007-11-27 12:37) - PLID 28198 - cache this value
						m_cyOldPackageTotalAmount = VarCurrency(var);
					}
					var = tmpRS->Fields->Item["CurrentAmount"]->Value;
					if (var.vt == VT_CY) {
						str = FormatCurrencyForInterface(VarCurrency(var));
						SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, str);

						// (j.jones 2007-11-27 12:37) - PLID 28198 - cache this value
						m_cyOldPackageCurrentAmount = VarCurrency(var);
					}

					// (j.jones 2007-11-27 12:37) - PLID 28198 - cache the original amounts
					// (j.jones 2009-12-23 10:16) - PLID 32587 - these are now displayed on the screen
					var = tmpRS->Fields->Item["OriginalCurrentCount"]->Value;
					if (var.vt == VT_I4) {
						SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, VarLong(var));

						m_nOldPackageOriginalCurrentCount = VarLong(var);
					}
					var = tmpRS->Fields->Item["OriginalCurrentAmount"]->Value;
					if (var.vt == VT_CY) {
						str = FormatCurrencyForInterface(VarCurrency(var));
						SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, str);

						m_cyOldPackageOriginalCurrentAmount = VarCurrency(var);
					}

					// (j.jones 2009-12-23 10:51) - PLID 32587 - if any "original" value
					// doesn't match the total, show the initial values
					if (m_cyOldPackageOriginalCurrentAmount != m_cyOldPackageTotalAmount
						|| m_nOldPackageOriginalCurrentCount != m_nOldPackageTotalCount
						|| (m_nOldPackageType == 2 && AdoFldBool(tmpRS, "HasEditedInitialChargeQty", FALSE))) {

						//something mismatches, so show the initial values
						m_checkPackageShowInitialValues.SetCheck(TRUE);
					}
					else {
						m_checkPackageShowInitialValues.SetCheck(FALSE);
					}

					OnPackageShowInitialValues();
				}
				tmpRS->Close();
			}
		}

		//////////////////////////////////////////////
		// Quotes combo box

		//JMJ - 3/22/2004 - fixed so if a quote is all outside fees, it will not be selectable in the list
		//we define a charge as all outside fees if the practice fee is $0.00 and the outside fee is > $0.00
		// (j.gruber 2009-03-09 15:12) - PLID 33351 - take out percentoff and discount fields
		// (d.thompson 2009-08-18) - PLID 16758 - Added Expired flag, which displays as a color field
		CString strQuoteFromClause;
		strQuoteFromClause.Format("(SELECT [PatientBillsQ].ID AS LineID, [PatientBillsQ].Description AS FirstOfNotes, [PatientBillsQ].Date, CASE WHEN HasBeenBilled Is Null THEN 0 ELSE 1 END AS HasBeenBilled, "
			"(CASE WHEN PackagesT.QuoteID Is Not Null THEN PackagesT.CurrentAmount ELSE "
			"Sum(Round(Convert(money,((([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))) + "
			"(([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))*(TaxRate-1)) + "
			"(([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))*(TaxRate2-1)) "
			")),2)) END) AS Total, "
			"convert(bit, CASE WHEN PatientBillsQ.UseExp = 1 THEN CASE WHEN DATEADD(d, PatientBillsQ.ExpDays, PatientBillsQ.Date) < getdate() then 1 else 0 end ELSE 0 END) AS Expired "
			"FROM ((SELECT BillsT.*, (SELECT TOP 1 ID FROM BilledQuotesT WHERE BilledQuotesT.QuoteID = BillsT.ID AND BilledQuotesT.BillID IN (SELECT ID FROM BillsT WHERE Deleted = 0 AND EntryType = 1)) AS HasBeenBilled FROM BillsT "
			"WHERE BillsT.PatientID=%li AND BillsT.Deleted=0 AND BillsT.Active = 1) AS PatientBillsQ "
			"INNER JOIN (SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders FROM LineItemT INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
			"WHERE LineItemT.PatientID=%li AND LineItemT.Deleted=0 AND LineItemT.Type >= 10 AND (ChargesT.OthrBillFee = 0 OR LineItemT.Amount > 0)) AS PatientChargesQ ON [PatientBillsQ].ID = [PatientChargesQ].BillID) "
			"INNER JOIN ChargesT ON [PatientChargesQ].ID = ChargesT.ID "
			"LEFT JOIN (SELECT ChargeID, Sum(PercentOff) as TotalPercentOff, Sum(Discount) AS TotalDiscount FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) ChargeTotalDiscountsT ON ChargesT.ID = ChargeTotalDiscountsT.ChargeID "
			"LEFT JOIN PackagesT ON PatientBillsQ.ID = PackagesT.QuoteID "
			"WHERE (([PatientBillsQ].EntryType)=2) "
			"GROUP BY [PatientBillsQ].ID, [PatientBillsQ].Date, [PatientBillsQ].Description, PatientBillsQ.HasBeenBilled, PackagesT.QuoteID, PackagesT.CurrentAmount, "
			"convert(bit, CASE WHEN PatientBillsQ.UseExp = 1 THEN CASE WHEN DATEADD(d, PatientBillsQ.ExpDays, PatientBillsQ.Date) < getdate() then 1 else 0 end ELSE 0 END)) AS Q", m_nPatientID, m_nPatientID);
		m_QuotesCombo->FromClause = _bstr_t(strQuoteFromClause);

		// (j.jones 2009-08-19 15:30) - PLID 35124 - removed PayToPractice
		CString strCaseHistoryFromClause;
		strCaseHistoryFromClause.Format("(SELECT CaseHistoryT.ID, PersonID, Name, SurgeryDate, CompletedDate, Sum(Round(Convert(money,Amount*Quantity),2)) AS Amount FROM CaseHistoryT INNER JOIN CaseHistoryDetailsT ON CaseHistoryT.ID = CaseHistoryDetailsT.CaseHistoryID "
			"WHERE (ItemType = -1 OR ItemType = -2) AND CaseHistoryDetailsT.Billable = 1 AND PersonID = %li AND CompletedDate Is Not Null "
			"GROUP BY CaseHistoryT.ID, PersonID, Name, SurgeryDate, CompletedDate) AS CaseHistoryQ", m_nPatientID);
		if (m_CaseHistoryCombo != NULL)
		{
			m_CaseHistoryCombo->FromClause = _bstr_t(strCaseHistoryFromClause);
		}

		CString strEMRWhereClause;
		strEMRWhereClause.Format("PatientID = %li", m_nPatientID);
		m_EMRCombo->WhereClause = _bstr_t(strEMRWhereClause);

		// (j.jones 2008-06-20 10:33) - PLID 26153 - filter the appointment combo, and potentially requery
		CString strAppointmentWhereClause;
		strAppointmentWhereClause.Format("PatientID = %li", m_nPatientID);
		m_AppointmentCombo->WhereClause = _bstr_t(strAppointmentWhereClause);
		if (m_bAppointmentCombo) {
			m_AppointmentCombo->Requery();
			m_bAppointmentCombo = TRUE;
		}

		//TES 4/13/2011 - PLID 43249 - Filter the Glasses order combo, and potentially requery
		// (j.dinatale 2012-03-20 09:38) - PLID 48893 - filter out billed glasses orders
		CString strGlassesOrderWhereClause;
		strGlassesOrderWhereClause.Format(
			"GlassesOrderT.IsDelete = 0 AND PersonID = %li AND "
			"GlassesOrderT.ID NOT IN ( "
			"	SELECT DISTINCT GlassesOrderT.ID AS BilledGlassesOrderID FROM GlassesOrderT "
			"	LEFT JOIN BillsT ON GlassesOrderT.BillID = BillsT.ID "
			"	LEFT JOIN BillCorrectionsT ON BillsT.ID = BillCorrectionsT.OriginalBillID "
			"	INNER JOIN ( "
			"		SELECT DISTINCT BillID "
			"		FROM "
			"		LineItemT "
			"		INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
			"		WHERE LineItemT.Deleted = 0 "
			"	) ChargesSubQ ON BillsT.ID = ChargesSubQ.BillID "
			"	WHERE BillsT.Deleted = 0 AND BillCorrectionsT.ID IS NULL "
			") "
			, m_nPatientID);
		m_GlassesOrderCombo->WhereClause = _bstr_t(strGlassesOrderWhereClause);
		if (m_bGlassesOrderCombo) {
			m_GlassesOrderCombo->Requery();
			m_bGlassesOrderCombo = TRUE;
		}

		//////////////////////////////////////////////
		int index = 0;
		//"Bill A" or "Quote A"
		m_WhatToAddCombo->Clear();
		if (m_EntryType == 1) {
			NXDATALISTLib::IRowSettingsPtr pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_BILL_A_CPT_CODE);
			pRow->PutValue(1, _bstr_t("Service Code"));
			m_WhatToAddCombo->AddRow(pRow);

			pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_BILL_A_SURGERY);
			pRow->PutValue(1, _bstr_t("Surgery"));
			m_WhatToAddCombo->AddRow(pRow);

			if (g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_A_PRODUCT);
				pRow->PutValue(1, _bstr_t("Inventory Item"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			// (j.jones 2008-06-20 09:15) - PLID 26153 - added ability to bill an appointment
			//TES 12/10/2008 - PLID 32145 - New function for checking scheduler licensing.
			if (g_pLicense->CheckSchedulerAccess_Any(CLicense::cflrSilent)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_AN_APPT);
				pRow->PutValue(1, _bstr_t("Appointment"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			if (IsSurgeryCenter(false)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_A_CASE);
				pRow->PutValue(1, _bstr_t("Previous Case History"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_BILL_A_QUOTE);
			pRow->PutValue(1, _bstr_t("Previous Quote"));
			m_WhatToAddCombo->AddRow(pRow);

			CString strEMR = "";

			//check the license to see if it is a custom record or an emn
			long nHasEMR = g_pLicense->HasEMR(CLicense::cflrSilent);
			if (nHasEMR == 2) {
				strEMR = "Previous EMN";
			}
			else if (nHasEMR == 1) {
				strEMR = "Previous Custom Record";
			}

			if (strEMR != "") {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_A_EMR);
				pRow->PutValue(1, _bstr_t(strEMR));
				m_WhatToAddCombo->AddRow(pRow);
			}

			if (IsSpa(FALSE)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_A_GIFT);
				pRow->PutValue(1, _bstr_t("Gift Certificate"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			//TES 4/13/2011 - PLID 43249 - Added ability to bill a Glasses Order
			// (j.dinatale 2012-04-17 17:17) - PLID 49078 - now called optical orders
			if (g_pLicense->CheckForLicense(CLicense::lcGlassesOrders, CLicense::cflrSilent)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_BILL_A_GLASSES_ORDER);
				pRow->PutValue(1, _bstr_t("Optical Order"));
				m_WhatToAddCombo->AddRow(pRow);
			}


			//TES 7/3/2008 - PLID 26143 - Our caller may have set a specific "Bill A" option for this particular bill.
			int set = -1;
			if (m_nDefaultBillAOverride != -1) {
				set = m_nDefaultBillAOverride;
				//TES 7/3/2008 - PLID 26143 - Make sure we don't use this override on any future bills, it's a one-time thing.
				m_nDefaultBillAOverride = -1;
			}
			else {
				set = GetRemotePropertyInt("DefaultBillAChoice", 0, 0, "<None>", TRUE);
			}
			if (!(set == ROW_BILL_A_PRODUCT && !g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)) && !(set == ROW_BILL_A_CASE && !IsSurgeryCenter(false)))
				m_WhatToAddCombo->SetSelByColumn(0, (long)set);
		}
		else {
			NXDATALISTLib::IRowSettingsPtr pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_QUOTE_A_SURGERY);
			pRow->PutValue(1, _bstr_t("Surgery"));
			m_WhatToAddCombo->AddRow(pRow);

			// (j.jones 2010-01-06 14:55) - PLID 36757 - we now have a separate quote option for packages
			pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_QUOTE_A_PACKAGE);
			pRow->PutValue(1, _bstr_t("Package"));
			m_WhatToAddCombo->AddRow(pRow);

			pRow = m_WhatToAddCombo->GetRow(-1);
			pRow->PutValue(0, (long)ROW_QUOTE_A_CPT_CODE);
			pRow->PutValue(1, _bstr_t("Service Code"));
			m_WhatToAddCombo->AddRow(pRow);

			if (g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_QUOTE_A_PRODUCT);
				pRow->PutValue(1, _bstr_t("Inventory Item"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			// (j.jones 2008-06-20 09:15) - PLID 26153 - added ability to quote an appointment
			//TES 12/10/2008 - PLID 32145 - New function for checking scheduler licensing.
			if (g_pLicense->CheckSchedulerAccess_Any(CLicense::cflrSilent)) {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_QUOTE_AN_APPT);
				pRow->PutValue(1, _bstr_t("Appointment"));
				m_WhatToAddCombo->AddRow(pRow);
			}

			CString strEMR = "";

			//quoting is only allowed in EMR L2

			//check the license to see if it is a custom record or an emn
			long nHasEMR = g_pLicense->HasEMR(CLicense::cflrSilent);
			if (nHasEMR == 2) {
				strEMR = "Previous EMN";
			}

			if (strEMR != "") {
				pRow = m_WhatToAddCombo->GetRow(-1);
				pRow->PutValue(0, (long)ROW_QUOTE_A_EMR);
				pRow->PutValue(1, _bstr_t(strEMR));
				m_WhatToAddCombo->AddRow(pRow);
			}

			int set = GetRemotePropertyInt("DefaultQuoteAChoice", 0, 0, "<None>", TRUE);
			if (!(set == ROW_QUOTE_A_PRODUCT && !g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)))
				m_WhatToAddCombo->SetSelByColumn(0, (long)set);
		}

		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->CurSel);

		//put default ICD9s in
		if (m_EntryType == 1) {

			if (GetBillID() > 0) {
				// (j.jones 2009-03-24 16:44) - PLID 9729 - now fill in the extra diag codes
				LoadDiagnosisCodes();
			}

			ReflectDiagCodeArrayToInterface();
			// (j.gruber 2014-03-31 09:53) - PLID 31033 - moved UpdateDiagnosisControlColumnSize() to ReflectDiagCodeArrayToInterface
			// (d.singleton 2014-02-27 11:00) - PLID 60974 - need to display 12 diag code datalists that apply the global diagnosis search			

			BuildWhichCodesCombo(TRUE);
		}

		//if there is Primary Insurance responsibility, default to primary, else secondary if
		//there is secondary resp., else default to patient
		if (m_EntryType == 1 && GetBillID() != -1) {
			_RecordsetPtr tmpRS = CreateParamRecordset("SELECT Amount AS InsResp, ChargeID AS ID, "
				"(CASE WHEN RespTypeID IS NULL THEN 0 ELSE RespTypeID END) AS RespTypeID, "
				"InsuredPartyT.PersonID "
				"FROM ChargeRespT "
				"INNER JOIN ChargesT ON ChargeRespT.ChargeID = ChargesT.ID "
				"LEFT JOIN InsuredPartyT ON ChargeRespT.InsuredPartyID = InsuredPartyT.PersonID "
				"WHERE ChargesT.BillID = {INT} "
				"ORDER BY Amount DESC", GetBillID());

			//set the selection to patient to begin with.  If there are insurance records, it will change
			//to the appropriate resp
			m_listBillTo->SetSelByColumn(btcID, long(0));

			BOOL bIsSet = FALSE;
			while (!tmpRS->eof && !bIsSet) {

				COleCurrency cyAmt = AdoFldCurrency(tmpRS, "InsResp", COleCurrency(0, 0));
				long nRespTypeID = AdoFldLong(tmpRS, "RespTypeID", 0);
				long nInsuredPartyID = AdoFldLong(tmpRS, "PersonID", -1);

				if (cyAmt != COleCurrency(0, 0)) {

					// (j.jones 2008-09-12 12:03) - PLID 4423 - we support inactive insurance now,
					// so always set the resp type selection, but for inactive set by insured party ID

					long nRow = -1;
					if (nRespTypeID == -1) {
						nRow = m_listBillTo->SetSelByColumn(btcInsuredPartyID, nInsuredPartyID);
					}
					else {
						nRow = m_listBillTo->SetSelByColumn(btcID, nRespTypeID);
					}

					if (nRow == -1) {
						//not found? ASSERT!
						ASSERT(FALSE);
						//re-set to patient instead
						m_listBillTo->SetSelByColumn(btcID, long(0));

						//don't set bIsSet here, try the next resp.
					}
					else {
						//we set a selection, so we're done
						bIsSet = TRUE;
					}
				}

				tmpRS->MoveNext();
			}
		}

		/////////////////////////////////////////////////////////////////
		// Fill the listbox with charges
		FillTabInfo();

		/////////////////////////////////////////////////////////////////
		// Calculate the totals at the bottom of the dialog
		CalculateTotal();

		//DRT 5/5/2004 - PLID 12207 - If we are barcode scanning from the quotes tab, 
		//	we don't have a modeless dialog to post a message to.  So we setup a member
		//	variable (m_strBarcode) that is used to hold the code.  When we load this
		//	dialog, we need to check that variable, and if anything exists, process
		//	a barcode message out of it.
		if (!((CBillingModuleDlg*)m_pBillingModuleWnd)->m_strBarcode.IsEmpty()) {
			CString str = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_strBarcode;
			//TODO:  This code makes me slightly wary... doing str.AllocSysString() was
			//	generating a bstr, that when converted back on the other side only 
			//	resulted in 1 character.  Doing this code works perfectly fine.

			// (a.walling 2007-11-08 16:34) - PLID 27476 - For anyone else reading this, the code that worked 'perfectly
			// fine', was not correctly converting to a bstr. It was being converted on the other side wrong, so the 
			// allocation was deliberately broken to match that behaviour. A BSTR is much different than a char array.

			// (a.walling 2007-11-06 17:49) - PLID 27476 - VS2008 - Need a portable solution for allocating the BSTR
			//BSTR bstr = SysAllocString((unsigned short*)(LPCTSTR)str);
			BSTR bstr = str.AllocSysString();

			SendMessage(WM_BARCODE_SCAN, 0, (LPARAM)bstr);

			//free memory used by the bstr
			SysFreeString(bstr);
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_strBarcode.Empty();
		}

		//DRT 5/11/2004 - PLID 12204 - Because we've done some renaming of the "Bill A"
		//	types, we need to give them some sort of description on what each one is.  Also,
		//	it's not a bad idea for new users who might be confused.
		// (j.jones 2008-06-23 15:53) - PLID 26153 - added appts.
		//TES 4/13/2011 - PLID 43249 - Added Glasses Orders
		// (j.dinatale 2012-04-17 17:19) - PLID 49078 - glasses orders are referred to as optical orders now since we can do contacts too
		{
			CString strMsg;
			strMsg.Format("This billing dialog allows you to bill several types of items to a customer.  You can choose the types "
				"by looking under the \"Bill A\" list:\r\n"
				" - Service Code:  This allows you to bill a code that is created in the billing tab of the Administrator module.\r\n"
				" - Surgery:  This allows you to bill a collection of items in one quick choice.  Surgeries can be setup in the surgery tab of the Administrator module.\r\n"
				" - Inventory Item:  This allows you to bill items which are created in the Inventory module.\r\n"
				"\t(You must have purchased the inventory module to use this option.)\r\n"
				" - Appointments:  This allows you to bill services and products linked to procedures on existing appointments for the patient.\r\n"
				" - Previous Quote:  This allows you to create a bill from a quote which has already been saved.\r\n"
				"\t(You must have purchased the ability to use quotes to use this option.)\r\n"
				" - Previous Case History:  This allows you to create a bill from a saved Case History.\r\n"
				"\t(You must have purchased the ASC module to use this feature.)\r\n"
				" - Previous EMN:  This allows you to create a bill from a saved EMN.  This is the same functionality as pressing 'Create Bill' on the EMN itself.\r\n"
				" - Gift Certificate:  This allows you to create a gift certificate for the customer.\r\n"
				"\t(You must have purchased NexSpa to use this feature.)\r\n"
				" - Optical Order: This allows you to create a bill for a Optical Order entered in Inventory.\r\n"
				"\t(You must have purchased the Optical Orders module to use this feature.)\r\n");

			//this will allow them to stop seeing this message
			DontShowMeAgain(this, strMsg, "BillingDlgInformational", "Practice", FALSE, FALSE);
		}

		// (d.singleton 2011-12-21 14:18) - PLID 40036 if they DONT HAVE permission to change ANY charge amount
		//BUT HAVE permission to change charge amounts for codes with std fee of zero, create a map of those codes so we can look them up later.
		// (j.jones 2012-05-10 10:47) - PLID 49213 - corrected these permission checks so that we skip the bioEditZeroChargeAmounts permission
		// check if you have full bioChargePrice permission, but not if you have bioChargePrice w/pass permission
		if (!(GetCurrentUserPermissions(bioChargePrice) & sptWrite)
			&& (GetCurrentUserPermissions(bioEditZeroChargeAmounts) & (sptWrite | sptWriteWithPass)))
		{
			_RecordsetPtr pCon = CreateRecordset("SELECT ID FROM ServiceT "
				"WHERE ServiceT.Price = CONVERT(MONEY, 0) AND ServiceT.Active = 1");

			//add the codes to a map
			while (!pCon->eof)
			{
				long nCodeID = AdoFldLong(pCon, "ID");

				m_lstZeroAmountCodes.AddHead(nCodeID);
				pCon->MoveNext();
			}
			pCon->Close();
		}

	}NxCatchAll("Error in BillingDlg::OnShowWindow");

	if (m_EntryType == 1) {
		// (j.jones 2008-09-12 13:06) - PLID 4423 - changed to PostSelChosenComboBillTo
		PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
	}

	m_boInitialized = TRUE;
}

BEGIN_EVENTSINK_MAP(CBillingDlg, CNxDialog)
	ON_EVENT(CBillingDlg, IDC_LIST, 4 /* LButtonDown */, OnLButtonDownList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_LIST, 6 /* RButtonDown */, OnRButtonDownList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_LIST, 8 /* EditingStarting */, OnEditingStartingList, VTS_DISPATCH VTS_I2 VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_LIST, 10 /* EditingFinished */, OnEditingFinishedList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_VARIANT VTS_BOOL)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 4 /* LButtonDown */, OnLButtonDownQuoteList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 6 /* RButtonDown */, OnRButtonDownQuoteList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 10 /* EditingFinished */, OnEditingFinishedQuoteList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_VARIANT VTS_BOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_DESIGNATION, 2 /* SelChanged */, OnSelChangedComboDesignation, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_PLACEOFSERVICE, 16 /* SelChosen */, OnSelChosenComboPlaceofservice, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_PRODUCTS, 16 /* SelChosen */, OnSelChosenComboProducts, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_QUOTE, 16 /* SelChosen */, OnSelChosenComboQuote, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_SRGY, 16 /* SelChosen */, OnSelChosenComboSrgy, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_CPT, 16 /* SelChosen */, OnSelChosenComboCpt, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_EMR, 16 /* SelChosen */, OnSelChosenComboEMR, VTS_DISPATCH)
	ON_EVENT(CBillingDlg, IDC_LIST, 9 /* EditingFinishing */, OnEditingFinishingList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_BSTR VTS_PVARIANT VTS_PBOOL VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 9 /* EditingFinishing */, OnEditingFinishingQuoteList, VTS_DISPATCH VTS_I2 VTS_VARIANT VTS_BSTR VTS_PVARIANT VTS_PBOOL VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_CPT, 17 /* ColumnClicking */, OnColumnClickingComboCpt, VTS_I2 VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_PRODUCTS, 17 /* ColumnClicking */, OnColumnClickingComboProducts, VTS_I2 VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_QUOTE, 17 /* ColumnClicking */, OnColumnClickingComboQuote, VTS_I2 VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_SRGY, 17 /* ColumnClicking */, OnColumnClickingComboSrgy, VTS_I2 VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_LIST, 12 /* DragBegin */, OnDragBeginList, VTS_PBOOL VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_LIST, 13 /* DragOverCell */, OnDragOverCellList, VTS_PBOOL VTS_DISPATCH VTS_I2 VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_LIST, 14 /* DragEnd */, OnDragEndList, VTS_DISPATCH VTS_I2 VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 12 /* DragBegin */, OnDragBeginQuoteList, VTS_PBOOL VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 13 /* DragOverCell */, OnDragOverCellQuoteList, VTS_PBOOL VTS_DISPATCH VTS_I2 VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 14 /* DragEnd */, OnDragEndQuoteList, VTS_DISPATCH VTS_I2 VTS_DISPATCH VTS_I2 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_LOCATION, 16 /* SelChosen */, OnSelChosenComboLocation, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_CASE_HISTORY, 16 /* SelChosen */, OnSelChosenComboCaseHistory, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_SRGY, 18 /* RequeryFinished */, OnRequeryFinishedComboSrgy, VTS_I2)
	ON_EVENT(CBillingDlg, IDC_COMBO_BILL_TO, 16 /* SelChosen */, OnSelChosenComboBillTo, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_PLACEOFSERVICE, 20 /* TrySetSelFinished */, OnTrySetSelFinishedComboPlaceofservice, VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_LOCATION, 20 /* TrySetSelFinished */, OnTrySetSelFinishedComboLocation, VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_WHAT_TO_ADD_COMBO, 16 /* SelChosen */, OnSelChosenWhatToAddCombo, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_GIFT, 16 /* SelChosen */, OnSelChosenComboGift, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_LIST, 19 /* LeftClick */, OnLeftClickBillList, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 19 /* LeftClick */, OnLeftClickListQuote, VTS_DISPATCH VTS_I2 VTS_I4 VTS_I4 VTS_I4)
	ON_EVENT(CBillingDlg, IDC_QUOTE_LIST, 8 /* EditingStarting */, OnEditingStartingQuoteList, VTS_DISPATCH VTS_I2 VTS_PVARIANT VTS_PBOOL)
	ON_EVENT(CBillingDlg, IDC_COMBO_LOCATION, 2 /* SelChanged */, OnSelChangedComboLocation, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_COMBO_APPOINTMENTS, 16 /* SelChosen */, OnSelChosenComboAppointments, VTS_DISPATCH)
	ON_EVENT(CBillingDlg, IDC_COMBO_QUOTE, 18, RequeryFinishedComboQuote, VTS_I2)
	ON_EVENT(CBillingDlg, IDC_COMBO_GLASSES_ORDERS, 16, OnSelChosenComboGlassesOrders, VTS_DISPATCH)
	ON_EVENT(CBillingDlg, IDC_COMBO_PLACEOFSERVICE, 2, OnSelChangedComboPlaceofservice, VTS_I4)
	ON_EVENT(CBillingDlg, IDC_BILL_STATUS_COMBO, 16, CBillingDlg::SelChosenBillStatusCombo, VTS_DISPATCH)
	ON_EVENT(CBillingDlg, IDC_BILL_STATUS_COMBO, 1, CNxDialog::RequireDataListSel, VTS_DISPATCH VTS_PDISPATCH)
	ON_EVENT(CBillingDlg, IDC_BILL_STATUS_NOTE_COMBO, 16, CBillingDlg::SelChosenBillStatusNoteCombo, VTS_DISPATCH)
	ON_EVENT(CBillingDlg, IDC_BILL_STATUS_NOTE_COMBO, 1, CNxDialog::RequireDataListSel, VTS_DISPATCH VTS_PDISPATCH)
	ON_EVENT(CBillingDlg, IDC_BILL_STATUS_COMBO, 28, CBillingDlg::CurSelWasSetBillStatusCombo, VTS_NONE)
END_EVENTSINK_MAP()

//this function is an override of the OnLButtonDown on the datalist,
//OnLeftClickBill list is the LeftClick event from the datalist
// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLeftClickList(LPDISPATCH lpRow, long iColumn)
{
	try {
	}NxCatchAll("Error in CBillingDlg::OnLeftClickList - Bill");
}

//this function is an override of the OnLButtonDown on the datalist,
//OnLeftClickBill list is the LeftClick event from the datalist
// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLeftClickQuoteList(LPDISPATCH lpRow, long iColumn)
{
	try {


	}NxCatchAll("Error in CBillingDlg::OnLeftClickQuoteList");
}

////////////////////////////////////////////////
// This would only be called for a bill
void CBillingDlg::BuildWhichCodesCombo(BOOL AutoBuild)
{
	// (j.jones 2008-05-01 13:47) - PLID 29868 - this function is not
	// needed on a quote, and should not be called on a quote, so
	// assert if it is called
	if (m_EntryType == 2) {
		ASSERT(FALSE);
		return;
	}

	// (j.jones 2009-03-25 11:23) - PLID 9729 - converted this list to support
	// all possible diagnosis code combinations
	CArray<long, long> aryIndexes;

	COleVariant var;
	CString text;//, diag1, diag2, diag3, diag4;	// (s.dhole 2011-06-08 15:10) - PLID 33666 We do not need actule code

	// (j.jones 2007-03-29 14:46) - PLID 25404 - track a list aside from
	// the combo source so we can compare any changes that this rebuild may cause
	CStringArray aryList;

	if (AutoBuild) {
		// (a.walling 2007-07-09 12:41) - PLID 26088 - Don't query when the billid is -1
		// the only time this is called with AutoBuild set to TRUE, is in OnShowWindow, which is
		// followed almost immediatey by FillTabInfo, which sets m_rsBill to a new recordset.
		// So we are safe setting m_rsBill to NULL since no where else should be referencing it.
		if (GetBillID() != -1) {
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			//m_rsBill = CreateRecordset(adOpenStatic,adLockReadOnly,((CBillingModuleDlg*)m_pBillingModuleWnd)->GetChargeSql());			
			m_rsBill = ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetChargeRecordset();
		} else {
			m_rsBill = NULL;
		}

		/////////////////////////////////////////////////////////////
		// Empty the listbox
		m_billingItems.clear();
	}

	// (j.jones 2009-03-25 12:04) - PLID 9729 - now add our extra diags to the list
	// (b.spivey March 10th, 2014) - PLID 60980 - Load all indexes from this array. 
	for each(const DiagCodeInfoPtr& pDiag in m_arypDiagCodes)
		aryIndexes.Add(pDiag->nOrderIndex);

	// Fill in dropdown

	// (j.jones 2007-03-29 14:46) - PLID 25404 - track a list aside from
	// the combo source so we can compare any changes that this rebuild may cause
	text = ";(none)";

	// (j.jones 2009-03-25 11:27) - PLID 9729 - now we use BuildDiagCsContent to build this list
	BuildDiagCsContent(aryIndexes, text, aryList, -1, "");

	//now add diag codes
	// (j.jones 2009-03-25 12:22) - PLID 9729 - we are only allowing adding the first four
	// diag codes to this list, because you can only submit claims this way on paper,
	// which is limited to 4 diag codes
	// (s.dhole 2011-06-08 15:10) - PLID 33666 We do not need actule code
	/*
	if(diag1!="") {
	text += ";" + diag1 + ";" + diag1;
	aryList.Add(diag1);
	}
	if(diag2!="") {
	text += ";" + diag2 + ";" + diag2;
	aryList.Add(diag2);
	}
	if(diag3!="") {
	text += ";" + diag3 + ";" + diag3;
	aryList.Add(diag3);
	}
	if(diag4!="") {
	text += ";" + diag4 + ";" + diag4;
	aryList.Add(diag4);
	}
	*/
	m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->ComboSource = _bstr_t(text);

	// (j.jones 2007-03-29 13:45) - PLID 25404 - now see if any rows are blank,
	// if so, update their charge accordingly because may have removed the row!
	// (j.jones 2011-10-04 09:16) - PLID 45799 - changed to be a DL2
	IRowSettingsPtr pRow = m_List->GetFirstRow();
	while (pRow) {

		_variant_t varLineID = pRow->GetValue(COLUMN_LINE_ID);

		_variant_t varWhichCodes = pRow->GetValue(BILL_COLUMN_WHICH_CODES);

		if (varWhichCodes.vt == VT_BSTR && VarString(varWhichCodes, "") != "" && VarString(varWhichCodes, "") != "(none)") {
			//ensure that the datalist and BillingTabInfo array are using a value that exists in the combo

			BOOL bFound = FALSE;
			for (int j = 0; j < aryList.GetSize() && !bFound; j++) {
				CString strListItem = aryList.GetAt(j);
				if (strListItem == VarString(varWhichCodes, "")) {
					//the currently selected WhichCodes are valid, so cease searchhng
					bFound = TRUE;
				}
			}

			if (!bFound) {
				//the currently selected WhichCodes are NOT valid, so clear them out
				_variant_t varNull;
				varNull.vt = VT_NULL;

				//update the Datalist
				varWhichCodes = varNull;
				pRow->PutValue(BILL_COLUMN_WHICH_CODES, varNull);
				// (s.dhole 2011-05-20 11:05) - PLID 33666 set WhichCodeExt value to be null
				if (ShouldShowDiagExt())
					pRow->PutValue(BILL_COLUMN_WHICH_CODES_EXT, varNull);
				//update the BillingTabInfo array
				for (int j = 0; j < (int)m_billingItems.size(); j++) {
					if (m_billingItems[j]->LineID.lVal == VarLong(varLineID)) {
						// (j.gruber 2014-02-19 10:10) - PLID 60878 - create a new map						
						m_billingItems[j]->whichCodes = boost::make_shared<CChargeWhichCodesMap>();
					}
				}

				//ensure this charge gets saved
				_variant_t varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
				long nChargeID = VarLong(varChargeID, -2);
				if (nChargeID != -2) {
					// (j.jones 2011-08-24 08:41) - PLID 44868 - this is permitted on original/void charges
					AddToModifiedList(nChargeID, TRUE);
				}
			}
		}

		pRow = pRow->GetNextRow();
	}

	GetDlgItem(IDC_LIST)->Invalidate();
}

// (j.jones 2009-03-25 11:33) - PLID 9729 - added a recursive function to build this list
void CBillingDlg::BuildDiagCsContent(CArray<long, long> &aryDiagIndexes, CString &strComboBoxText, CStringArray &aryList, int iLastIndex, CString strLastText)
{
	//this is a recursive function - throw exceptions to the caller

	//for each index in aryDiagIndices, we need a combo box text entry for it
	//combined with every other permutation, plus a straight CStringArray
	//of the displayed content

	if (strComboBoxText.IsEmpty()) {
		strComboBoxText = ";(none)";
	}

	int i = 0, j = 0;
	for (i = iLastIndex + 1; i < aryDiagIndexes.GetSize(); i++) {

		long nIndex = (long)aryDiagIndexes.GetAt(i);

		if (nIndex > MAX_DIAG_Cs_INDEX) {
			//disallow adding a number higher than our MAX_DIAG_Cs_INDEX
			//(defined in BillExtraDiagCodesDlg.h)
			continue;
		}

		CString strText;

		//if strLastText is empty, we're starting with a new number
		// (j.armen 2014-08-07 12:01) - PLID 63229 - Use letters instead of numbers
		if (strLastText.IsEmpty()) {
			strText = static_cast<char>('A' + nIndex - 1);
		}
		else {
			//otherwise, we're appending to strLastText

			//turns out that the ANSI format doesn't even allow linking
			//more than 4 codes to a charge - you can have an index up to
			//12, but you can't have more than 4 indexes per charge
			int nCountCommas = 0;
			int nComma = strLastText.Find(",");
			while (nComma != -1) {
				nCountCommas++;
				nComma = strLastText.Find(",", nComma + 1);
			}
			if (nCountCommas == 3) {
				//3 commas means 4 indices, which means we cannot build this list further
				return;
			}

			// (j.armen 2014-08-07 12:01) - PLID 63229 - Use letters instead of numbers
			strText = strLastText + ',' + static_cast<char>('A' + nIndex - 1);
		}

		CString strComboTextToAdd;
		CString strListTextToAdd;

		//add this index to our combo source
		strComboTextToAdd.Format(";%s;%s", strText, strText);
		strComboBoxText += strComboTextToAdd;

		//add this index to our tracked list
		aryList.Add(strText);

		//now add every other combo
		BuildDiagCsContent(aryDiagIndexes, strComboBoxText, aryList, i, strText);
	}
}

BOOL CBillingDlg::SetNewRecordDefaults(BillingItemPtr pNew, int& iLineID)
{
	_variant_t var;

	try {

		// (d.singleton 2012-05-08 14:49) - PLID 48152 added column for skill code,  alberta only,  requires default skill code stored in ProiversT.TaxonomyCode
		_RecordsetPtr rs = CreateParamRecordset("SELECT PersonT.[Last], PersonT.[First], PersonT.[Middle], ProvidersT.PersonID, ProvidersT.TaxonomyCode FROM PersonT INNER JOIN ProvidersT ON (PersonT.ID = ProvidersT.PersonID) AND (PersonT.ID = ProvidersT.PersonID) "
			"WHERE ProvidersT.PersonID = {INT} AND PersonT.Archived = 0", m_Main_Physician);

		// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
		// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
		if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 1) {
			m_DefaultProvider = -1;
		}
		else if (m_DefaultProvider == -1) {
			m_DefaultProvider = GetDefaultBillProviderID();
		}

		var = (long)m_DefaultProvider;
		pNew->Provider = var;

		// (j.jones 2010-11-09 10:03) - PLID 31392 - added claim provider
		pNew->ClaimProvider = m_DefaultClaimProvider;

		// (j.jones 2014-04-23 08:40) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
		pNew->ReferringProviderID = (long)-1;
		pNew->ReferringProviderIDRequired = g_cvarFalse;
		pNew->OrderingProviderID = (long)-1;
		pNew->OrderingProviderIDRequired = g_cvarFalse;
		pNew->SupervisingProviderID = (long)-1;
		pNew->SupervisingProviderIDRequired = g_cvarFalse;

		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel() != -1) {
			var = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetValue(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel(), 0);
			if (VarLong(var, -1) != -1)
				pNew->PatCoordinator = var;
		}

		// Line ID
		if ((int)m_billingItems.size() > 0) {
			int MaxLineID = 0;
			for (int z = 0; z<(int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal > MaxLineID)
					MaxLineID = m_billingItems[z]->LineID.lVal;
			}
			iLineID = MaxLineID + 1;
		}
		else
			iLineID = 1;
		pNew->LineID = (long)iLineID;

		// Retrieve the date straight from the edit box in
		// the CBillingModuleDlg.
		if (m_cyDefaultChargeDate.GetStatus() == COleDateTime::invalid) {
			m_cyDefaultChargeDate = (COleDateTime)m_peditBillDate->GetValue();
			m_cyDefaultChargeDate.SetDateTime(m_cyDefaultChargeDate.GetYear(), m_cyDefaultChargeDate.GetMonth(), m_cyDefaultChargeDate.GetDay(), 0, 0, 0);
		}

		// (j.jones 2010-11-29 11:29) - PLID 31392 - ensure this is cast as a date
		pNew->Date = COleVariant(m_cyDefaultChargeDate);
		pNew->ServiceDateTo = COleVariant(m_cyDefaultChargeDate);
		pNew->InputDate = COleVariant(COleDateTime::GetCurrentTime());

		pNew->Modifier1 = g_cvarNull;
		pNew->Modifier2 = g_cvarNull;
		pNew->Modifier3 = g_cvarNull;
		pNew->Modifier4 = g_cvarNull;

		// Diagnosis codes
		// (j.gruber 2014-02-19 10:16) - PLID 60878 - load the defaultWhichCodes		
		//this is always a new BillingItem, so its fine to do this here
		pNew->whichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		LoadDefaultWhichCodes(pNew->whichCodes);
		// (j.gruber 2014-02-19 10:16) - PLID 60878 - we don't need the rest of this anymore


		//DRT 4/7/2006 - PLID 11734 - Removed ProcCode, replaced with ItemType
		pNew->ItemType = (long)ITEM_TYPE_CPT;

		//only used for Gift certificate type items
		pNew->GiftID.vt = VT_NULL;
		// (r.gonet 2015-03-27 18:32) - PLID 65279 - Line items start off with a null Gift Certificate Value.
		pNew->Value.vt = VT_NULL;

		// Batched status
		pNew->Batched.vt = VT_BOOL;
		pNew->Batched.boolVal = TRUE;

		// (a.walling 2007-05-24 09:32) - PLID 26114
		pNew->PointsUsed = COleCurrency(0, 0);

		m_boChangesMade = TRUE;

		pNew->ChargedProductItemListID = (long)-1;

		// (j.jones 2007-02-28 09:05) - PLID 24988 - ensured PackageChargeRefID is always filled
		pNew->PackageChargeRefID = (long)-1;

		// (j.jones 2007-12-10 14:24) - PLID 27988 - we now track when we bill allocation details
		pNew->ChargedAllocationDetailListID = (long)-1;

		// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
		pNew->Calls = (double)0.0;

		// (d.singleton 2012-05-08 14:46) - PLID 48512 - added skill column, alberta only
		if (!rs->eof) {
			CString strTaxCode = AdoFldString(rs, "TaxonomyCode", "");
			if (strTaxCode.GetLength() < 5) {
				pNew->Skill = _bstr_t(strTaxCode);
			}
			else {
				//need to set to blank if they have codes > 5 char
				pNew->Skill = _bstr_t("");
			}
		}
		else {
			pNew->Skill = _bstr_t("");
		}

		// (j.jones 2009-06-04 10:28) - PLID 34435 - ensure we default the NDCCode to NULL
		pNew->NDCCode = g_cvarNull;

		// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
		pNew->DrugUnitPrice = COleCurrency(0, 0);
		pNew->DrugUnitType = (LPCTSTR)"";
		pNew->DrugUnitQuantity = (double)0.0;
		pNew->PrescriptionNumber = (LPCTSTR)"";

		// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
		pNew->IsEmergency = (long)cietUseDefault;

		// (d.singleton 2012-03-07 17:22) - PLID 49100 new column
		pNew->ValidationStatus = g_cvarNull;

		// (d.singleton 2012-03-22 15:43) - PLID 49136 add notes column
		pNew->Notes = _variant_t((long)m_hIconNotes);

		return FALSE;
	}
	NxCatchAll("BillingDlg::SetNewRecordDefaults");
	return FALSE;
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnRightClick(LPDISPATCH lpRow, long iColumn)
{
	if (m_eHasAccess == batNoAccess) {
		return;
	}

	IRowSettingsPtr pRow(lpRow);

	if (pRow) {
		m_pList->PutCurSel(pRow);

		// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
		// Original or Void charges once a correction has been made, which means that no right-click
		// options are valid for these charges
		if (m_EntryType == 1) {
			long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

			if (IsOriginalOrVoidCharge(nChargeID)) {
				return;
			}
		}



		// Build a menu popup with the ability to delete the current row
		CMenu pMenu;
		pMenu.CreatePopupMenu();
		int nMenuIndex = 0;
		pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION, ID_DELCHARGE, "Delete Charge");

		// (r.gonet 07/07/2014) - PLID 62569 - Add an option to mark a charge on hold
		if (m_EntryType == 1) {
			bool bBillOnHold = (GetBillStatusType() == EBillStatusType::OnHold);
			// The On Hold column should never be null since it is filled from a NOT NULL field in BillsT.
			BOOL bChargeIsOnHold = VarBool(pRow->GetValue(BILL_COLUMN_ON_HOLD));
			// If a  bill is on hold, then the charge cannot be made to be on hold.
			if (!bChargeIsOnHold) {
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | (!bBillOnHold ? MF_ENABLED : MF_DISABLED|MF_GRAYED), ID_MARK_CHARGE_ON_HOLD, "Mark Charge On Hold");
			} else {
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | (!bBillOnHold ? MF_ENABLED : MF_DISABLED|MF_GRAYED), ID_REMOVE_CHARGE_HOLD, "Remove Charge Hold");
			}
		}

		//find if there is an attached product item list
		BOOL bIsProductItem = FALSE;
		long LineID = pRow->GetValue(0).lVal;
		int i = -1;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == LineID) {
				//DRT 4/24/03 - ChargedProductItemListID comes up as VT_EMPTY sometimes (new bills, cpt codes)
				//		so this was pulling a random value (usually not -1), and allowing you to see "Edit Product
				//		Info" on things you couldn't open the dialog for.
				long nCPILID = -1;
				_variant_t var = m_billingItems[i]->ChargedProductItemListID;
				if (var.vt == VT_I4)
					nCPILID = long(var.lVal);
				if (nCPILID != -1) {
					bIsProductItem = TRUE;
				}
				break;
			}
		}

		if (!bIsProductItem)
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_EDITPRODITEMS, "Edit Product Info");
		else
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_EDITPRODITEMS, "Edit Product Info");

		long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);
		if (m_PlaceOfServiceCombo->CurSel == -1)
			m_PlaceOfServiceCombo->CurSel = 0;
		long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;
		long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

		// (r.gonet 08/01/2014) - PLID 63098 - If this is a bill and the charge's service code is designated as a lab charge, then let them associate test codes with the charge.
		if (m_EntryType == 1 && VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) == (long)ITEM_TYPE_CPT) {
			// If a  bill is on hold, then the charge cannot be made to be on hold.
			if (ReturnsRecordsParam("SELECT NULL FROM ServiceT WHERE ID = {INT} AND LabCharge = 1", nServiceID)
				|| (nChargeID > 0 && ReturnsRecordsParam("SELECT NULL FROM ChargeLabTestCodesT WHERE ChargeID = {INT}", nChargeID))
				|| m_billingItems[i]->TestCodeList.size() > 0)
			{
				CString strMenuOptionText = FormatString("Edit Test Codes (%li Selected)", m_billingItems[i]->TestCodeList.size());
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_EDIT_TEST_CODES, strMenuOptionText);
			} else {
				// (r.gonet 08/05/2014) - PLID 63098 - Don't show the menu option if it is not a lab charge
			}
		} else {
			// (r.gonet 08/05/2014) - PLID 63098 - Quotes don't have the option of editing test codes associated with
			// the charge.
		}

		// (j.jones 2007-10-15 14:57) - PLID 27757 - converted to use the new structure
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		if (ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND Anesthesia = 1 AND UseAnesthesiaBilling = 1", nServiceID)
			&& ReturnsRecordsParam("SELECT ID FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND AnesthesiaFeeBillType <> 1", nServiceID, nPlaceOfServiceID)) {

			//it's an anesthesia charge and anesthesia billing is enabled and the type is not a flat fee
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_CHANGE_ANESTH_TIME, "Change Anesthesia Time");
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_FACILITY_TIME, "Change Facility Time");
		}
		// (j.jones 2007-10-15 14:57) - PLID 27757 - converted to use the new structure
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		else if (ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND FacilityFee = 1 AND UseFacilityBilling = 1", nServiceID)
			&& ReturnsRecordsParam("SELECT ID FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND FacilityFeeBillType <> 1", nServiceID, nPlaceOfServiceID)) {

			//it's a facility charge and facility fee billing is enabled and the type is not a flat fee
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_ANESTH_TIME, "Change Anesthesia Time");
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_CHANGE_FACILITY_TIME, "Change Facility Time");
		}
		else {
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_ANESTH_TIME, "Change Anesthesia Time");
			pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_FACILITY_TIME, "Change Facility Time");
		}

		// (j.jones 2011-11-01 12:42) - PLID 41558 - if OHIP, see if this is an Assisting charge
		if (UseOHIP()) {
			if (ReturnsRecordsParam("SELECT ID FROM CPTCodeT WHERE ID = {INT} AND AssistingCode = 1", nServiceID)) {
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_CHANGE_ASSISTING_TIME, "Change Assisting Time");
			}
			else {
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_ASSISTING_TIME, "Change Assisting Time");
			}
		}

		// (j.dinatale 2012-02-01 15:24) - PLID 45511 - line item corrections is no longer in beta, so dont check our flag
		//// (s.dhole 2011-05-31 12:28) - PLID 44951 -added change service code permissions
		if (m_EntryType == 1 && (GetCurrentUserPermissions(bioBillChangeServiceCode) & (sptWrite | sptWriteWithPass)))
		{
			// (s.dhole 2011-05-24 16:25) - PLID 44953 show menu item to edit CPT code if line item is CPT/sevice code
			if (VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) == (long)ITEM_TYPE_CPT)
			{
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_ENABLED, ID_CHANGE_SERVICE_CODE, "Edit Service Code");

			}
			else
				pMenu.InsertMenu(nMenuIndex++, MF_BYPOSITION | MF_GRAYED, ID_CHANGE_SERVICE_CODE, "Edit Service Code");
		}

		CPoint pt;
		GetCursorPos(&pt);
		pMenu.TrackPopupMenu(TPM_LEFTALIGN, pt.x, pt.y, this);
	}
}

/* The latter two parameters, iPercentOff and cyDiscount, apply only to quotes

			dblTax is a 'Visible' rate, not the actual in-the-data rate.

			m_varBoundItem must be valid for this function to work properly.
			*/

// (j.gruber 2009-03-05 11:10) - PLID 33351 Change discount and percentoff to total discount
// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
void CBillingDlg::CalculateLineTotal(COleCurrency cyUnitCost, COleCurrency cyOthrCost, double dblQuantity, double dblPackageQtyRemaining, double dblOriginalPackageQtyRemaining, double dblMultiplier1, double dblMultiplier2, double dblMultiplier3, double dblMultiplier4, double dblTax1, double dblTax2, COleCurrency cyTotalDiscount)
{
	try {
		// Calculate the new line total given the unit cost, quantity
		// and modifier
		COleVariant var;
		COleCurrency cy, cyOldLineTotal, cyIns1Resp, cyIns2Resp;
		BOOL Ins1Resp = FALSE, Ins2Resp = FALSE;
		CString str;

		// (j.jones 2009-02-05 14:22) - PLID 32965 - added an assertion and handling if we don't have a bound item
		if (m_varBoundItem.vt != VT_I4 || VarLong(m_varBoundItem) == -1) {
			//this shouldn't be possible, it means whatever function called us did so improperly,
			//and didn't ensure m_varBoundItem was set first
			ASSERT(FALSE);
			return;
		}

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == m_varBoundItem.lVal) {
				break;
			}
		}

		cyOldLineTotal = m_billingItems[i]->LineTotal.cyVal;


		if (cyUnitCost.GetStatus() == COleCurrency::invalid) {
			var = m_billingItems[i]->UnitCost;
			cyUnitCost = var.cyVal;
		}
		else {	// This needs to be done for CalculateTotal()
			var = cyUnitCost;
			m_billingItems[i]->UnitCost = var;
		}

		if (cyOthrCost.GetStatus() == COleCurrency::invalid) {
			var = m_billingItems[i]->OthrUnitCost;
			if (var.vt != VT_NULL && var.vt != VT_EMPTY)
				cyOthrCost = var.cyVal;
			else
				cyOthrCost = COleCurrency(0, 0);
		}
		else {	// This needs to be done for CalculateTotal()
			var = cyOthrCost;
			m_billingItems[i]->OthrUnitCost = var;
		}

		if (dblQuantity == -1.0) {
			var = m_billingItems[i]->Quantity;
			dblQuantity = var.dblVal;
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblQuantity;
			m_billingItems[i]->Quantity = var;
		}

		if (dblPackageQtyRemaining == -1.0) {
			var = m_billingItems[i]->PackageQtyRemaining;
			dblPackageQtyRemaining = var.dblVal;
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblPackageQtyRemaining;
			m_billingItems[i]->PackageQtyRemaining = var;
		}

		// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
		if (dblOriginalPackageQtyRemaining == -1.0) {
			var = m_billingItems[i]->OriginalPackageQtyRemaining;
			dblOriginalPackageQtyRemaining = var.dblVal;
		}
		else {
			var.vt = VT_R8;
			var.dblVal = dblOriginalPackageQtyRemaining;
			m_billingItems[i]->OriginalPackageQtyRemaining = var;
		}

		if (dblMultiplier1 == -1) {
			var = m_billingItems[i]->Multiplier1;
			dblMultiplier1 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblMultiplier1;
			m_billingItems[i]->Multiplier1 = var;
		}

		if (dblMultiplier2 == -1) {
			var = m_billingItems[i]->Multiplier2;
			dblMultiplier2 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblMultiplier2;
			m_billingItems[i]->Multiplier2 = var;
		}

		if (dblMultiplier3 == -1) {
			var = m_billingItems[i]->Multiplier3;
			dblMultiplier3 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblMultiplier3;
			m_billingItems[i]->Multiplier3 = var;
		}

		if (dblMultiplier4 == -1) {
			var = m_billingItems[i]->Multiplier4;
			dblMultiplier4 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);
		}
		else {	// This needs to be done for CalculateTotal()
			var.vt = VT_R8;
			var.dblVal = dblMultiplier4;
			m_billingItems[i]->Multiplier4 = var;
		}

		if (dblTax1 == -1.0) {
			var = m_billingItems[i]->TaxRate1;
			if (var.vt == VT_R8)
				dblTax1 = var.dblVal;
			else
				dblTax1 = 0.0;
		}
		else {	// This needs to be done for CalculateTotal()
			var = dblTax1;
			m_billingItems[i]->TaxRate1 = var;
		}

		/* Convert the rate from 'Visible rate' to 'Scott rate' */
		dblTax1 /= 100.0;
		dblTax1 += 1.0;

		if (dblTax2 == -1.0) {
			var = m_billingItems[i]->TaxRate2;
			if (var.vt == VT_R8)
				dblTax2 = var.dblVal;
			else
				dblTax2 = 0.0;
		}
		else {	// This needs to be done for CalculateTotal()
			var = dblTax2;
			m_billingItems[i]->TaxRate2 = var;
		}

		/* Convert the rate from 'Visible rate' to 'Scott rate' */
		dblTax2 /= 100.0;
		dblTax2 += 1.0;

		//if a bill:
		//cost * quantity, then apply modifiers, then percent off, then discount, then tax that total
		// Charge Total = ((((UnitCost * Quantity) * (1+(Modifier / 100)) * (1-(PercentOff / 100)) - Discount) * (Tax / 100)

		//if a quote:
		//cost + other cost, times quantity, then percent off, then discount, then tax that total
		// Charge total = (((UnitCost + OtherCost) * Quantity) * (1-(PercentOff / 100)) - Discount) * (Tax / 100)

		if (m_EntryType == 2)
			//JJ - 11-8-2002 now we use the OutsideFee too
			cy = cyUnitCost + cyOthrCost;
		else
			cy = cyUnitCost;

		cy = CalculateAmtQuantity(cy, dblQuantity);

		//highly unlikely anyone would use modifiers and discounts together,
		//but if so, modify first
		cy = CalculateAmtQuantity(cy, dblMultiplier1);
		cy = CalculateAmtQuantity(cy, dblMultiplier2);
		cy = CalculateAmtQuantity(cy, dblMultiplier3);
		cy = CalculateAmtQuantity(cy, dblMultiplier4);

		// (j.gruber 2009-03-05 11:11) - PLID 33351 - take out percentOff and discount for TotalDiscount

		//we need to recalculate the discounts here based on the changes
		COleCurrency cyTotalDollarDiscount(0, 0), cyTotalLineDiscount(0, 0);
		long nTotalPercentOff = 0;
		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);
		CalculateTotalDiscount(m_billingItems[i]->DiscountList, cy, cyInvalid, nTotalPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);
		m_billingItems[i]->TotalDiscount = cyTotalLineDiscount;

		cy = (cy * (100000 - nTotalPercentOff * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cy = cy / long(100000);
		cy -= cyTotalDollarDiscount;


		COleCurrency cyPreTaxTotal = cy;
		// (j.jones 2007-03-01 13:04) - PLID 25027 - this total needs rounded!
		RoundCurrency(cyPreTaxTotal);

		//Equivalent to cy = cy + (cy * (double)(dblTax / 100.0));
		COleCurrency taxResult1, taxResult2;

		taxResult1 = CalculateTax(cy, dblTax1);
		taxResult2 = CalculateTax(cy, dblTax2);

		cy += taxResult1;
		cy += taxResult2;

		RoundCurrency(cy);

		//warn if they have an amount less than zero (warn, do not stop them, saving will do that)
		if (cy < COleCurrency(0, 0)) {
			if (cyUnitCost < COleCurrency(0, 0) || dblQuantity < 0 || cy.m_cur.Hi == -1) {
				AfxMessageBox("You cannot have a negative charge. Please make sure none of your charges are less than zero.");
			}
			else {
				AfxMessageBox("You have generated an invalid charge amount that is unsupported by Practice.\n"
					"(It will appear as a negative charge until it is repaired.)\n"
					"You must fix this charge before saving.");
			}
		}

		var = cy;
		//if(m_List->GetValue(m_varBoundItem.lVal,COLUMN_LINE_TOTAL).cyVal != cy)
		//	m_List->SetSelByColumn(COLUMN_LINE_TOTAL,var);

		m_billingItems[i]->LineTotal = var;

		// (j.jones 2010-09-02 10:13) - PLID 40330 - need to calculate the total allowable
		if (m_billingItems[i]->HasAllowable.vt == VT_BOOL
			&& VarBool(m_billingItems[i]->HasAllowable)) {

			COleCurrency cyAllowableTotal = VarCurrency(m_billingItems[i]->UnitAllowable, COleCurrency(0, 0));
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

			RoundCurrency(cyAllowableTotal);

			m_billingItems[i]->TotalAllowable = _variant_t(cyAllowableTotal);
		}
		else {
			m_billingItems[i]->TotalAllowable = g_cvarNull;
		}

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			if (pRow->GetValue(COLUMN_LINE_ID).lVal == m_varBoundItem.lVal) {
				if (m_EntryType == 1) {
					// (j.gruber 2009-03-09 10:54) - PLID 33351 - add the total discount here too because that could've changed
					pRow->PutValue(COLUMN_TOTAL_DISCOUNT, _variant_t(cyTotalLineDiscount));
					pRow->PutValue(BILL_COLUMN_LINE_TOTAL, var);
				}
				else {
					pRow->PutValue(QUOTE_COLUMN_TOTAL_DISCOUNT, _variant_t(cyTotalLineDiscount));

					pRow->PutValue(QUOTE_COLUMN_LINE_TOTAL, var);
				}
				break;
			}

			pRow = pRow->GetNextRow();
		}

		/////////////////////////////////////////////////////////////////
		// Update the insurance amount given the new line total
		MatchCostAndInsurance(m_varBoundItem.lVal, cyOldLineTotal, var.cyVal, cyPreTaxTotal);

		m_pList->SetRedraw(TRUE);

		if (m_EntryType == 1)
			FillBillList();
		else
			FillQuoteList();

		// (j.gruber 2007-11-20 10:51) - PLID 28141 - Calculate Total needs to be called after FillQuoteList because Calculate total uses the datatlist to calculate its values
		CalculateTotal();

		if (m_EntryType == 1) {
			// Check for bad insurance data
			COleCurrency InsResp, LineTotal;
			LineTotal = m_billingItems[i]->LineTotal.cyVal;

			//Instead of this getting ins1, then getting 2, then checking each, 
			//		we need to loop through ALL available resps, and compare + warn as we
			//		go.
			RPCList* list = m_billingItems[i]->RPCList;
			BOOL bShowError = FALSE;

			for (int j = 0; j < list->aryRPC.GetSize(); j++) {
				RespPerCharge rpc = list->aryRPC.GetAt(j);

				if (rpc.InsAmount.vt == VT_CY)
					InsResp = rpc.InsAmount.cyVal;
				else
					InsResp = COleCurrency(0, 0);

				if (InsResp > LineTotal) {
					str.Format("The total for charge '%s' is %s, but the %s insurance \n"
						"responsibility is %s. Please recheck your insurance totals.",
						CString(m_billingItems[i]->Description.bstrVal),
						FormatCurrencyForInterface(LineTotal), VarString(m_listBillTo->GetValue(m_listBillTo->FindByColumn(btcID, (long)GetInsuranceTypeFromID(VarLong(rpc.InsuredPartyID, -1)), 0, VARIANT_FALSE), btcRespName), ""),
						FormatCurrencyForInterface(InsResp));
					MsgBox(str);
				}

				// Check to see if the charge amt is less than the applied value
				long ChargeID = m_billingItems[i]->ChargeID.lVal;
				if (ChargeID != -2) {

					if (!bShowError) {
						//Since we're looping over all the resps, if we find the error, we really only want to
						//show it once.  Once we've done so, we still need to keep looping for the above error
						//checking, but we don't want to keep warning them.

						//first check patient balance
						COleCurrency cyCharges, cyPayments, cyAdjustments, cyRefunds, cyInsResp;
						GetChargeTotals(ChargeID, m_nPatientID, &cyCharges, &cyPayments, &cyAdjustments, &cyRefunds, &cyInsResp);
						if (LineTotal < (cyPayments + cyAdjustments + cyRefunds)) {
							bShowError = TRUE;
						}

						//We're already looping through our resps for the above check, so we can do this here.
						GetChargeInsuranceTotals(ChargeID, m_nPatientID, VarLong(list->aryRPC.GetAt(j).InsuredPartyID), &cyCharges, &cyPayments, &cyAdjustments, &cyRefunds);
						if (InsResp < (cyPayments + cyAdjustments + cyRefunds)) {
							bShowError = TRUE;
						}

						if (bShowError)
							AfxMessageBox("You have decreased the value of a charge that has payments applied to it.\n"
							"If you are certain that this is correct, please cancel out of this bill and unapply all payments that are currently applied.");
					}

				}
			}
		}

		// (j.jones 2007-06-27 11:16) - PLID 26471 - we cleared the list in this function,
		//so we should re-select the m_varBoundItem, if one exists
		if (m_varBoundItem.vt == VT_I4)
			m_pList->SetSelByColumn(COLUMN_LINE_ID, VarLong(m_varBoundItem, -1));
	}
	NxCatchAll("BillingDlg::CalculateLineTotal");
}

// (j.jones 2015-02-24 08:57) - PLID 57494 - bRecalculatePackageTotal is now a parameter for this function
void CBillingDlg::CalculateTotal(bool bRecalculatePackageTotal /*= false*/)
{
	// (j.jones 2010-10-29 17:18) - PLID 40922 - cache the current total
	COleCurrency cyOldBillTotal = m_cyBillTotal;

	COleCurrency cyTotal = COleCurrency(0, 0);
	COleCurrency cyQuoteTotalWithoutDiscounts = COleCurrency(0, 0);
	COleCurrency cyQuoteTotalWithoutTax = COleCurrency(0, 0);
	COleCurrency cyOutsideTotal = COleCurrency(0, 0);
	//(e.lally 2010-10-22) PLID 30253 - Calculate all the same totals for outside fees as practice fees so we can determines discounts
	COleCurrency cyOutsideTotalWithoutDiscounts = COleCurrency(0, 0);
	COleCurrency cyOutsideTotalWithoutTax = COleCurrency(0, 0);
	COleCurrency cyUnitCost = COleCurrency(0, 0);
	COleCurrency cyOutsideUnitCost = COleCurrency(0, 0);
	double dblMultiplier1 = 1.0, dblMultiplier2 = 1.0, dblMultiplier3 = 1.0, dblMultiplier4 = 1.0;
	COleVariant var;

	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {
		// If a bill, just get the line total and add it to the practice
		// total
		if (m_EntryType == 1) {
			var = pRow->GetValue(BILL_COLUMN_LINE_TOTAL);
			cyTotal += COleCurrency(var.cyVal);
			RoundCurrency(cyTotal);
		}
		// For a quote...
		else {
			// Get the unit cost paid to the practice
			var = pRow->GetValue(QUOTE_COLUMN_UNIT_COST);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY)
				cyUnitCost = var.cyVal;
			else
				cyUnitCost = COleCurrency(0, 0);

			////////////////////////////////////////////////////////////
			// Get the outside practice unit cost
			var = pRow->GetValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY)
				cyOutsideUnitCost = var.cyVal;
			else
				cyOutsideUnitCost = COleCurrency(0, 0);

			////////////////////////////////////////////////////////////
			// Get the multipliers

			var = pRow->GetValue(QUOTE_COLUMN_MODIFIER1);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {

				CString Mod1;
				if (var.vt == VT_BSTR)
					Mod1 = CString(var.bstrVal);
				else if (var.vt == VT_I4)
					Mod1.Format("%li", var.lVal);
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod1);
				if (!rs->eof) {
					_variant_t var = rs->Fields->Item["Multiplier"]->Value;
					if (var.vt == VT_R8) {
						dblMultiplier1 = VarDouble(var, 1.0);
					}
				}
				rs->Close();
			}
			else
				dblMultiplier1 = 1.0;

			var = pRow->GetValue(QUOTE_COLUMN_MODIFIER2);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {

				CString Mod2;
				if (var.vt == VT_BSTR)
					Mod2 = CString(var.bstrVal);
				else if (var.vt == VT_I4)
					Mod2.Format("%li", var.lVal);
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod2);
				if (!rs->eof) {
					_variant_t var = rs->Fields->Item["Multiplier"]->Value;
					if (var.vt == VT_R8) {
						dblMultiplier2 = VarDouble(var, 1.0);
					}
				}
				rs->Close();
			}
			else
				dblMultiplier2 = 1.0;

			var = pRow->GetValue(QUOTE_COLUMN_MODIFIER3);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {

				CString Mod3;
				if (var.vt == VT_BSTR)
					Mod3 = CString(var.bstrVal);
				else if (var.vt == VT_I4)
					Mod3.Format("%li", var.lVal);
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod3);
				if (!rs->eof) {
					_variant_t var = rs->Fields->Item["Multiplier"]->Value;
					if (var.vt == VT_R8) {
						dblMultiplier3 = VarDouble(var, 1.0);
					}
				}
				rs->Close();
			}
			else
				dblMultiplier3 = 1.0;

			var = pRow->GetValue(QUOTE_COLUMN_MODIFIER4);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {

				CString Mod4;
				if (var.vt == VT_BSTR)
					Mod4 = CString(var.bstrVal);
				else if (var.vt == VT_I4)
					Mod4.Format("%li", var.lVal);
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod4);
				if (!rs->eof) {
					_variant_t var = rs->Fields->Item["Multiplier"]->Value;
					if (var.vt == VT_R8) {
						dblMultiplier4 = VarDouble(var, 1.0);
					}
				}
				rs->Close();
			}
			else
				dblMultiplier4 = 1.0;

			cyUnitCost = CalculateAmtQuantity(cyUnitCost, dblMultiplier1);
			cyUnitCost = CalculateAmtQuantity(cyUnitCost, dblMultiplier2);
			cyUnitCost = CalculateAmtQuantity(cyUnitCost, dblMultiplier3);
			cyUnitCost = CalculateAmtQuantity(cyUnitCost, dblMultiplier4);

			cyOutsideUnitCost = CalculateAmtQuantity(cyOutsideUnitCost, dblMultiplier1);
			cyOutsideUnitCost = CalculateAmtQuantity(cyOutsideUnitCost, dblMultiplier2);
			cyOutsideUnitCost = CalculateAmtQuantity(cyOutsideUnitCost, dblMultiplier3);
			cyOutsideUnitCost = CalculateAmtQuantity(cyOutsideUnitCost, dblMultiplier4);

			////////////////////////////////////////////////////////////
			// Now get the quantity
			var = pRow->GetValue(QUOTE_COLUMN_QUANTITY);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				cyUnitCost = CalculateAmtQuantity(cyUnitCost, var.dblVal);
				cyOutsideUnitCost = CalculateAmtQuantity(cyOutsideUnitCost, var.dblVal);
			}

			// (j.jones 2005-06-27 14:14) - PLID 15485 - for quotes, calculate the
			// amount of the quote without discounts, to get the total amount saved
			COleCurrency cyUnitCostPreDiscount = cyUnitCost;
			//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
			COleCurrency cyOutsideUnitCostPreDiscount = cyOutsideUnitCost;

			///////////////////////////////////////////////////////////
			//Total Discount 
			var = pRow->GetValue(QUOTE_COLUMN_TOTAL_DISCOUNT);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {

				//JJ - 3/7/2003 - subtracting from a cost to make it less than zero IS LEGAL (currently)
				//so we have the following rule:
				//if the practice fee is zero and the outside fee is greater than zero, then deduct from outside fee
				//if the practice fee is greater than zero or both fees are zero, then deduct from the practice fee

				if (cyUnitCost == COleCurrency(0, 0) && cyOutsideUnitCost > COleCurrency(0, 0))
					cyOutsideUnitCost -= var.cyVal;
				else
					cyUnitCost -= var.cyVal;
			}

			// (j.jones 2005-06-10 10:15) - PLID 14992 - for packages,
			// calculate the total without tax
			COleCurrency cyUnitCostPreTax = cyUnitCost;
			RoundCurrency(cyUnitCostPreTax);
			cyQuoteTotalWithoutTax += cyUnitCostPreTax;

			//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
			COleCurrency cyOutsideUnitCostPreTax = cyOutsideUnitCost;
			RoundCurrency(cyOutsideUnitCostPreTax);
			cyOutsideTotalWithoutTax += cyOutsideUnitCostPreTax;

			////////////////////////////////////////////////////////////
			// Now get the tax and totals for the practice fee
			//(e.lally 2010-10-22) PLID 30253 - Ensure everything is initialized
			COleCurrency taxResult1 = COleCurrency(0, 0), taxResult2 = COleCurrency(0, 0);
			COleCurrency PreDiscountTaxResult1 = COleCurrency(0, 0), PreDiscountTaxResult2 = COleCurrency(0, 0);
			//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
			COleCurrency OutsidePreDiscountTaxResult1 = COleCurrency(0, 0), OutsidePreDiscountTaxResult2 = COleCurrency(0, 0);

			var = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_1);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				////////////////////////////////////////////////////////////
				// Convert the rate from 'Visible rate' to 'Scott rate'
				if (var.vt == VT_R8) {
					if (var.dblVal != 0.0)
						var.dblVal /= 100.0;
					var.dblVal += 1.0;

					taxResult1 = CalculateTax(cyUnitCost, var.dblVal);
					PreDiscountTaxResult1 = CalculateTax(cyUnitCostPreDiscount, var.dblVal);
				}
			}
			var = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_2);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				////////////////////////////////////////////////////////////
				// Convert the rate from 'Visible rate' to 'Scott rate'
				if (var.vt == VT_R8) {
					if (var.dblVal != 0.0)
						var.dblVal /= 100.0;
					var.dblVal += 1.0;

					taxResult2 = CalculateTax(cyUnitCost, var.dblVal);
					PreDiscountTaxResult2 = CalculateTax(cyUnitCostPreDiscount, var.dblVal);
				}
			}
			////////////////////////////////////////////////////////////
			// Now add this value to the total pay-to-practice
			// fees

			cyUnitCost += taxResult1;
			cyUnitCost += taxResult2;
			RoundCurrency(cyUnitCost);
			cyTotal += cyUnitCost;

			cyUnitCostPreDiscount += PreDiscountTaxResult1;
			cyUnitCostPreDiscount += PreDiscountTaxResult2;
			RoundCurrency(cyUnitCostPreDiscount);
			cyQuoteTotalWithoutDiscounts += cyUnitCostPreDiscount;

			////////////////////////////////////////////////////////////
			// Now get the tax and totals for the outside fee
			var = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_1);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				////////////////////////////////////////////////////////////
				// Convert the rate from 'Visible rate' to 'Scott rate'
				var.dblVal /= 100.0;
				var.dblVal += 1.0;

				taxResult1 = CalculateTax(cyOutsideUnitCost, var.dblVal);
				//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
				OutsidePreDiscountTaxResult1 = CalculateTax(cyOutsideUnitCostPreDiscount, var.dblVal);
			}
			var = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_2);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				////////////////////////////////////////////////////////////
				// Convert the rate from 'Visible rate' to 'Scott rate'
				var.dblVal /= 100.0;
				var.dblVal += 1.0;

				taxResult2 = CalculateTax(cyOutsideUnitCost, var.dblVal);
				//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
				OutsidePreDiscountTaxResult2 = CalculateTax(cyOutsideUnitCostPreDiscount, var.dblVal);
			}

			cyOutsideUnitCost += taxResult1;
			cyOutsideUnitCost += taxResult2;
			RoundCurrency(cyOutsideUnitCost);
			cyOutsideTotal += cyOutsideUnitCost;

			//(e.lally 2010-10-22) PLID 30253 - Calculate the same for Outside fees to determines discounts
			cyOutsideUnitCostPreDiscount += OutsidePreDiscountTaxResult1;
			cyOutsideUnitCostPreDiscount += OutsidePreDiscountTaxResult2;
			RoundCurrency(cyOutsideUnitCostPreDiscount);
			cyOutsideTotalWithoutDiscounts += cyOutsideUnitCostPreDiscount;
		}

		pRow = pRow->GetNextRow();
	}

	m_cyBillTotal = cyTotal;

	GetDlgItem(IDC_LABEL_TOTAL)->SetWindowText(FormatCurrencyForInterface(cyTotal));

	if (m_EntryType != 1) {
		//if a quote
		GetDlgItem(IDC_LABEL_DISCOUNTS)->SetWindowText(FormatCurrencyForInterface(cyQuoteTotalWithoutDiscounts - cyTotal));

		if ((cyOutsideTotalWithoutDiscounts - cyOutsideTotal) > COleCurrency(0, 0)){
			//(e.lally 2010-10-22) PLID 30253 - we have an outside discount
			m_bHasOutsideDiscount = TRUE;
		}
		if (m_bHasOutsideDiscount && m_packageCheck.GetCheck() == FALSE){
			//(e.lally 2010-10-22) PLID 30253 - The outside discounts is in use, we can finally show it
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->SetWindowText(FormatCurrencyForInterface(cyOutsideTotalWithoutDiscounts - cyOutsideTotal));
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_SHOWNOACTIVATE);
		}
		else{
			//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts until it is in use
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);
		}


		//first set package info
		// (j.gruber 2007-09-05 16:05) - PLID 27254 - see if this quote has been billed
		// (j.jones 2010-10-29 17:18) - PLID 40922 - don't change the package total if the
		// bill total did not change during this process
		// (b.eyers 2013-02-22) - PLID 55280 - total package cost wasn't updating when total uses was changed		
		// (j.jones 2015-02-24 08:57) - PLID 57494 - bRecalculatePackageTotal is now a parameter for this function
		if (!m_bQuoteHasBeenBilled && m_boInitialized && (cyOldBillTotal != m_cyBillTotal || bRecalculatePackageTotal)) {
			//only update if new
			long nCount = 1;
			// (j.jones 2008-04-30 10:22) - PLID 27506 - don't multiply by total count unless
			// it is a repeatable package
			if (GetIsRepeatPackage()) {
				nCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
			}
			COleCurrency cyAmt = cyQuoteTotalWithoutTax * nCount;
			SetDlgItemText(IDC_PACKAGE_TOTAL_COST, FormatCurrencyForInterface(cyAmt));
			SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, FormatCurrencyForInterface(cyAmt));
			// (j.jones 2009-12-23 11:45) - PLID 32587- also set the original amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cyAmt));
		}

		//then check outside cost
		GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->SetWindowText(FormatCurrencyForInterface(cyOutsideTotal));
	}

}


/********************************************************
*  AddChargeToList()
*
* Callers:	FillTabInfo
*			OnSelectionChangeComboQuotes
********************************************************/

// (j.jones 2007-03-26 14:39) - PLID 25287 - supported cyOffsetAmount for the purposes of altering package values
// (j.jones 2007-12-11 12:01) - PLID 27988 - added nChargedAllocationDetailListID
// also added a number of fields that the allocation can change, so we aren't dependent on m_rsBill for them
// (j.jones 2008-06-24 15:02) - PLID 30458 - added nAppointmentID
// (r.gonet 08/01/2014) - PLID 62834 - Added varOnHoldOverride to be able to specify an overriding value for the charge's on hold status.
//  Otherwise it will just try to draw from either CPTCodeT.DefaultAsOnHold or become false if the charge is existing.
//  Pass g_cvarNull if the OnHold override should not be used. Pass g_cvarFalse to override the OnHold value with false. Pass g_cvarTrue to override the OnHold value with true.
// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
CString CBillingDlg::AddChargeToList(BOOL IsNew, long nServiceID, double dblQuantity, CString strDescription, CString strItemCode, long nCategoryID, long nSubCategoryID, BOOL bIsPackage, long nCategoryCount,long ChargedProductItemListID /*= -1*/, long nChargedAllocationDetailListID /*= -1*/, long nPackageChargeRefID /*= -1*/, COleCurrency cyOffsetAmount /*= COleCurrency(0,0)*/, long nAppointmentID /*= -1*/, _variant_t varOnHoldOverride /*= g_cvarNull*/)
{
	// (s.dhole 2011-06-13 11:29) - PLID 33666 This code will be outside try-- catch so it can return value 
	CString strChangeDiagSCodes = "";
	try {
		COleVariant var;
		CString str;

		double taxrate1, taxrate2;
		double dblPackageQtyRemaining = 0.0;
		double dblOriginalPackageQtyRemaining = 0.0;

		//TES 7/15/2008 - PLID 27983 - First, check whether we should pull in linked products for this charge.
		if (m_EntryType == 1 && IsNew) {
			//TES 7/17/2008 - PLID 27983 - Pass in true for bMassAdding, we only get here if we're billing a quote, 
			// (j.jones 2010-11-23 16:27) - PLID 41549 - supported nPackageChargeRefID, the quote price, and discounts
			var = m_rsBill->Fields->Item["PracBillFee"]->Value;		// Unit cost
			COleCurrency cyUnitPrice = VarCurrency(var);
			long nQuoteChargeID = AdoFldLong(m_rsBill, "ID", -1);

			if (CheckLinkProducts(nServiceID, dblQuantity, true,
				&cyUnitPrice, bIsPackage ? nPackageChargeRefID : -1,
				nQuoteChargeID, FALSE)) {
				//TES 7/15/2008 - PLID 27983 - If CheckLinkProducts() returns TRUE, that means it already added linked products
				// to the bill in lieu of this item.
				return "";
			}
		}

		BillingItemPtr pNew = BillingItem::Create();
		pNew->ChargedProductItemListID = (long)-1;
		pNew->ChargedAllocationDetailListID = (long)-1;
		pNew->PackageChargeRefID = nPackageChargeRefID;
		// (j.gruber 2014-02-19 16:19) - PLID 60878 - set map to null
		pNew->whichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);

		// (j.jones 2006-12-20 10:25) - PLID 23936 - ensured this is only called when loading
		// an existing bill, and is not referenced when we are adding new charges to an existing bill
		if (!IsNew && m_EntryType == 1 && GetBillID() != -1 && nPackageChargeRefID == -1) {
			//we're loading an existing bill
			pNew->PackageChargeRefID = m_rsBill->Fields->Item["PackageChargeRefID"]->Value;
		}

		//////////
		//LineID
		if (IsNew) {
			if ((int)m_billingItems.size() > 0) {
				//become the last LineID
				var = (long)m_billingItems.back()->LineID.lVal + 1;
			}
			else  {
				//start at the top
				var = (long)1;
			}
		}
		else {
			//pull from the data field
			var = m_rsBill->Fields->Item["LineID"]->Value;
		}
		m_varBoundItem = var;
		pNew->LineID = var;	// Line ID

		//////////
		//ChargeID
		if (!IsNew) {
			var = m_rsBill->Fields->Item["ID"]->Value;	// Charge ID
		}
		else {
			var.vt = VT_I4;
			var = (long)-2;
		}
		pNew->ChargeID = var;

		// (r.gonet 07/08/2014) - PLID 62569 - Load the related voiding and original line item IDs
		if (!IsNew) {
			pNew->VoidingLineItemID = m_rsBill->Fields->Item["VoidingLineItemID"]->Value;
			pNew->OriginalLineItemID = m_rsBill->Fields->Item["OriginalLineItemID"]->Value;
		}

		// (j.jones 2011-08-24 09:51) - PLID 44873 - added IsVoidingCharge, a boolean
		// that is true only if the ChargeID is in LineItemCorrectionsT.VoidingLineItemID
		// (this defaults to g_cvarFalse)
		if (!IsNew) {
			pNew->IsVoidingCharge = m_rsBill->Fields->Item["IsVoidingCharge"]->Value;
		}

		// (j.jones 2011-08-24 08:41) - PLID 44868 - added IsOriginalCharge, a boolean
		// that is true only if the ChargeID is in LineItemCorrectionsT.OriginalLineItemID
		if (!IsNew) {
			pNew->IsOriginalCharge = m_rsBill->Fields->Item["IsOriginalCharge"]->Value;
		}

		// (r.gonet 07/08/2014) - PLID 62569 - Load whether this charge is a new charge from a correction
		if (!IsNew) {
			pNew->IsNewChargeFromCorrection = m_rsBill->Fields->Item["IsNewChargeFromCorrection"]->Value;
		}

		//////////
		//DRT 9/15/2004 - PLID 14005 - We forgot to load the GiftID field!
		if (!IsNew) {
			var = m_rsBill->Fields->Item["GiftID"]->Value;
			pNew->GiftID = var;
		}

		if (!IsNew) {
			// (r.gonet 2015-03-27 18:58) - PLID 65279 - Load the Value if the bill is existing.
			var = m_rsBill->Fields->Item["GCValue"]->Value;
			pNew->Value = var;
		}

		//////////
		//LocationID
		var = m_rsBill->Fields->Item["LocationID"]->Value;
		long nNewLocationID = VarLong(var, -1);
		if (nNewLocationID == -1) {
			nNewLocationID = GetCurrentLocationID();
		}
		if (nNewLocationID != m_nCurLocationID) {

			// (j.jones 2011-08-24 08:41) - PLID 44868 - if IsNew,
			// call TryChangeBillLocation, as we might not be allowed to change
			// the existing location
			if (IsNew) {
				// (j.jones 2011-08-24 08:41) - PLID 44868 - call TryChangeBillLocation,
				// as we might not be allowed to change the location
				TryChangeBillLocation(nNewLocationID);
			}
			else {
				// (j.jones 2007-12-14 11:47) - PLID 27988 - disallow changing locations
				// if we have any allocations currently in use on this bill
				// (do so silently in this function)
				if (m_paryAllocationInfo.GetSize() == 0 && !HasChargesLinkedToAllocations()) {
					// (j.politis 2015-07-06 11:36) - PLID 65949 - Getting error when try to open edit a bill has  active location but not managed !
					// if you edit any bill for that loaction ( Dr.John Vine )  will give you the error .
					ChangeLocationComboSelection(nNewLocationID, TRUE);
				}
			}
		}

		//////////
		//Item Desc
		pNew->Description = _bstr_t(strDescription);

		// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary logs
		/*
		if (strDescription.IsEmpty())
		LogDetail("Adding charge (no description) to list");
		else
		LogDetail("Adding charge %s to list", strDescription);
		*/

		//////////
		//Provider
		var = m_rsBill->Fields->Item["DoctorsProviders"]->Value;	// Doctor ID
		pNew->Provider = var;
		if (IsNew) {

			// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
			// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
			if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 1) {
				pNew->Provider = (long)-1;
			}
			//see if the DoctorID is invalid or empty, if so then try to use default provider
			else if (var.vt != VT_I4 || var.lVal < 0) {
				if (m_DefaultProvider == -1) {
					m_DefaultProvider = GetDefaultBillProviderID();
				}
				else {
					var.lVal = m_DefaultProvider;
					var.vt = VT_I4;
					pNew->Provider = var;
				}
			}
		}

		// (j.jones 2010-11-09 10:03) - PLID 31392 - added claim provider
		var = m_rsBill->Fields->Item["ClaimProviderID"]->Value;
		pNew->ClaimProvider = VarLong(var, -1);
		if (IsNew) {
			//if new, always use the default claim provider, which is usually -1
			pNew->ClaimProvider = m_DefaultClaimProvider;
		}

		// (j.jones 2014-04-23 08:40) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
		var = m_rsBill->Fields->Item["ReferringProviderID"]->Value;
		pNew->ReferringProviderID = VarLong(var, -1);
		pNew->ReferringProviderIDRequired = g_cvarFalse;
		if (IsNew) {
			//if new, always use the default value
			pNew->ReferringProviderID = (long)-1;
		}
		var = m_rsBill->Fields->Item["OrderingProviderID"]->Value;
		pNew->OrderingProviderID = VarLong(var, -1);
		pNew->OrderingProviderIDRequired = g_cvarFalse;
		if (IsNew) {
			//if new, always use the default value
			pNew->OrderingProviderID = (long)-1;
		}
		var = m_rsBill->Fields->Item["SupervisingProviderID"]->Value;
		pNew->SupervisingProviderID = VarLong(var, -1);
		pNew->SupervisingProviderIDRequired = g_cvarFalse;
		if (IsNew) {
			//if new, always use the default value
			pNew->SupervisingProviderID = (long)-1;
		}

		//if the PC charge column is shown, set these charges to the quote's PC, otherwise
		//they will default to the PC on the bill, as updated above

		var = m_rsBill->Fields->Item["PatCoordID"]->Value;	// Patient Coordinator ID
		pNew->PatCoordinator = var;
		if (IsNew) {
			//see if the PatCoordID is invalid, empty, or we are not showing the PC column, try to use default patient coordinator
			if (var.vt != VT_I4 || var.lVal < 0 || m_bBillPatCoord) {
				if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel() != -1) {
					var = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetValue(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel(), 0);
					if (VarLong(var, -1) != -1)
						pNew->PatCoordinator = var;
				}
			}
		}

		//////////
		//Date
		if (IsNew == FALSE) {
			var = m_rsBill->Fields->Item["TDate"]->Value;				// Date			
		}
		else {
			//try to use default date
			if (m_cyDefaultChargeDate.GetStatus() == COleDateTime::invalid) {
				COleDateTime dt = (COleDateTime)m_peditBillDate->GetValue();
				dt.SetDateTime(dt.GetYear(), dt.GetMonth(), dt.GetDay(), 0, 0, 0);
				var = dt;
			}
			else {
				COleDateTime dt = m_cyDefaultChargeDate;
				dt.SetDateTime(dt.GetYear(), dt.GetMonth(), dt.GetDay(), 0, 0, 0);
				var = dt;
			}
		}
		pNew->Date = var;

		//////////
		//Service Date To
		if (IsNew == FALSE) {
			var = m_rsBill->Fields->Item["ServiceDateTo"]->Value;				// Date			
		}
		else {
			//try to use default date
			if (m_cyDefaultChargeDate.GetStatus() == COleDateTime::invalid) {
				COleDateTime dt = (COleDateTime)m_peditBillDate->GetValue();
				dt.SetDateTime(dt.GetYear(), dt.GetMonth(), dt.GetDay(), 0, 0, 0);
				var = dt;
			}
			else {
				COleDateTime dt = m_cyDefaultChargeDate;
				dt.SetDateTime(dt.GetYear(), dt.GetMonth(), dt.GetDay(), 0, 0, 0);
				var = dt;
			}
		}
		pNew->ServiceDateTo = var;

		//////////
		//Input Date
		if (IsNew == FALSE) {
			var = m_rsBill->Fields->Item["IDate"]->Value;				// Input Date			
		}
		else {
			var = COleVariant(COleDateTime::GetCurrentTime());
		}
		pNew->InputDate = var;

		//////////
		//ServiceID
		pNew->ServiceID = nServiceID;
		//////////
		//CPT Code
		pNew->CPTCode = _bstr_t(strItemCode);
		//////////
		//TOS
		var = m_rsBill->Fields->Item["Service Type"]->Value;		// CPT Type of Service
		pNew->TypeOfService = var;
		//////////
		//SubCode
		var = m_rsBill->Fields->Item["ItemSubCode"]->Value;		// CPT Sub Code
		pNew->CPTSubCode = var;
		//////////
		//Category
		// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
		pNew->CPTCategoryID = (nCategoryID > 0 ? (_variant_t)(long)nCategoryID : g_cvarNull);
		//////////
		//SubCat
		// (j.jones 2015-03-18 14:24) - PLID 64974 - SubCategory is now nullable
		pNew->CPTSubCategoryID = (nSubCategoryID > 0 ? (_variant_t)(long)nSubCategoryID : g_cvarNull);

		// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
		pNew->CPTCategoryCount = nCategoryCount;
		//////////
		//ItemType
		//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
		var = m_rsBill->Fields->Item["ItemType"]->Value;			// Item Type Flag
		pNew->ItemType = var;

		//////////
		//Batched
		var = m_rsBill->Fields->Item["Batched"]->Value;			// Batched Status
		pNew->Batched = var;

		//////////
		//Qty
		var = dblQuantity;
		pNew->Quantity = var;
		pNew->PackageQtyRemaining = var;
		// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
		pNew->OriginalPackageQtyRemaining = var;

		dblQuantity = var.dblVal;
		dblPackageQtyRemaining = var.dblVal;
		dblOriginalPackageQtyRemaining = var.dblVal;

		//////////
		//PackageQtyRemaining
		if (m_EntryType == 2) {
			var = m_rsBill->Fields->Item["PackageQtyRemaining"]->Value;	// Quantity
			pNew->PackageQtyRemaining = var;
			dblPackageQtyRemaining = var.dblVal;

			// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
			var = m_rsBill->Fields->Item["OriginalPackageQtyRemaining"]->Value;	// Quantity
			pNew->OriginalPackageQtyRemaining = var;
			dblOriginalPackageQtyRemaining = var.dblVal;
		}

		//////////
		//load the charge product items
		if (ChargedProductItemListID != -1) {
			pNew->ChargedProductItemListID = ChargedProductItemListID;
			pNew->Quantity = dblQuantity;
			pNew->PackageQtyRemaining = dblQuantity;
			// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
			pNew->OriginalPackageQtyRemaining = dblQuantity;
		}
		else {
			if (pNew->ChargeID.lVal != -2) {
				pNew->ChargedProductItemListID = LoadIntoChargedProductItemsArray(pNew->ChargeID.lVal);
			}
		}

		// (j.jones 2007-12-11 11:57) - PLID 27988 - load the allocation details
		if (m_EntryType == 1) {
			if (nChargedAllocationDetailListID != -1) {
				pNew->ChargedAllocationDetailListID = nChargedAllocationDetailListID;
			}
			else {
				if (VarLong(pNew->ChargeID) != -2) {
					pNew->ChargedAllocationDetailListID = LoadIntoChargedAllocationDetailsArray(VarLong(pNew->ChargeID));
				}
			}
		}
		else {
			pNew->ChargedAllocationDetailListID = (long)-1;
		}

		if (nPackageChargeRefID != -1) {
			//we passed in the quantity for this
			pNew->Quantity = dblQuantity;
			pNew->PackageQtyRemaining = dblQuantity;
			// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
			pNew->OriginalPackageQtyRemaining = dblQuantity;
		}

		//////////
		//get taxable status
		long TaxType = 2;

		long nInsPartyID = GetCurrentBillToInsuredPartyID();

		if (IsNew && nInsPartyID != -1)
			TaxType = GetInsuranceCoTaxType(nInsPartyID);

		//////////
		//Tax1
		var = m_rsBill->Fields->Item["TaxRate"]->Value;		// Tax (double)
		if (var.vt == VT_R8 && TaxType != 3)
			taxrate1 = var.dblVal;
		else
			taxrate1 = 1.0;

		/* Convert the rate from 'Scott rate' to 'Visible rate' */
		taxrate1 -= 1.0;
		taxrate1 *= 100.0;
		var = taxrate1;

		pNew->TaxRate1 = var;

		/* Convert the rate from 'Visible rate' to 'Scott rate' */
		taxrate1 /= 100.0;
		taxrate1 += 1.0;

		//////////
		//Tax2
		var = m_rsBill->Fields->Item["TaxRate2"]->Value;		// Tax (double)
		if (var.vt == VT_R8 && TaxType != 3)
			taxrate2 = var.dblVal;
		else
			taxrate2 = 1.0;

		/* Convert the rate from 'Scott rate' to 'Visible rate' */
		taxrate2 -= 1.0;
		taxrate2 *= 100.0;
		var = taxrate2;

		pNew->TaxRate2 = var;

		/* Convert the rate from 'Visible rate' to 'Scott rate' */
		taxrate2 /= 100.0;
		taxrate2 += 1.0;

		COleVariant varExt;

		// (j.gruber 2014-02-21 10:19) - PLID 60787 - moved to here
		long nChargeID = VarLong(pNew->ChargeID, -1);
		//////////
		//WhichCodes
		if (IsNew) {
			//needs the WhichCodes filled
			// Diagnosis codes
			// (j.gruber 2014-02-19 10:18) - PLID 60878 - load the default
			if (!pNew->whichCodes) {
				pNew->whichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
			}
			LoadDefaultWhichCodes(pNew->whichCodes);
		}
		else
		{
			// (j.gruber 2014-02-19 10:18) - PLID 60878 - existing bill
			if (!pNew->whichCodes) {
				pNew->whichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
			}
			LoadExistingWhichCodes(pNew->whichCodes, nChargeID);
		}

		// (j.gruber 2014-02-19 10:19) - PLID 60878 - not needed anymore		



		//////////
		//PercentOff + Discount
		// (j.gruber 2009-03-05 11:40) - PLID 33351 - take out existing discount fields for Total Discount
		if (pNew->DiscountList == NULL) {
			pNew->DiscountList = new DiscountList;
		}
		//fills the discount list
		// (j.gruber 2014-02-21 10:10) - PLID 60787 - moved higher		
		if (IsNew) {
			//if its new, it is coming from the quote, so we need the chargeID from the quote
			nChargeID = AdoFldLong(m_rsBill, "ID", -1);
		}
		COleCurrency cyPointsUsed(0, 0);
		BOOL bUsingPoints = FALSE;

		COleCurrency cyPointCost, cyRewardDiscountDollars;
		long nRewardDiscountPercent = -1;
		if (IsNew && !m_bPaymentPlan) {
			cyPointCost = AdoFldCurrency(m_rsBill, "PointCost", COleCurrency(0, 0));
			cyRewardDiscountDollars = AdoFldCurrency(m_rsBill, "DiscountDollars", COleCurrency(0, 0));
			nRewardDiscountPercent = AdoFldLong(m_rsBill, "DiscountPercent", 0);
		}

		if (!bIsPackage) {
			LoadDiscountList(IsNew, nChargeID, nServiceID, pNew->DiscountList,
				cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent,
				bUsingPoints, cyPointsUsed, IsNew ? TRUE : FALSE, FALSE);
		}
		pNew->PointsUsed = cyPointsUsed;


		// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes
		pNew->NDCCode = m_rsBill->Fields->Item["NDCCode"]->Value;

		// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
		pNew->DrugUnitPrice = m_rsBill->Fields->Item["DrugUnitPrice"]->Value;
		pNew->DrugUnitType = m_rsBill->Fields->Item["DrugUnitTypeQual"]->Value;
		pNew->DrugUnitQuantity = m_rsBill->Fields->Item["DrugUnitQuantity"]->Value;
		pNew->PrescriptionNumber = m_rsBill->Fields->Item["PrescriptionNumber"]->Value;

		// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
		pNew->IsEmergency = m_rsBill->Fields->Item["IsEmergency"]->Value;

		// (j.jones 2008-06-04 15:00) - PLID 30256 - added EMRChargeID
		pNew->EMRChargeID = m_rsBill->Fields->Item["EMRChargeID"]->Value;

		// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
		// (j.jones 2008-06-24 15:19) - PLID 30458 - use the nAppointmentID override if it is given to us
		if (nAppointmentID != -1) {
			pNew->AppointmentID = nAppointmentID;
		}
		else {
			pNew->AppointmentID = m_rsBill->Fields->Item["AppointmentID"]->Value;
		}

		//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
		pNew->GlassesOrderServiceID = m_rsBill->Fields->Item["GlassesOrderServiceID"]->Value;

		//////////
		//CPTModifier1
		var = m_rsBill->Fields->Item["CPTModifier"]->Value;		// Modifier1
		pNew->Modifier1 = var;
		//////////
		//CPTModifier2
		var = m_rsBill->Fields->Item["CPTModifier2"]->Value;	// Modifier2
		pNew->Modifier2 = var;
		//////////
		//CPTModifier3
		var = m_rsBill->Fields->Item["CPTModifier3"]->Value;	// Modifier3
		pNew->Modifier3 = var;
		//////////
		//CPTModifier4
		var = m_rsBill->Fields->Item["CPTModifier4"]->Value;	// Modifier4
		pNew->Modifier4 = var;

		//////////
		//Multiplier1
		var = m_rsBill->Fields->Item["CPTMultiplier1"]->Value;	// Multiplier

		double dblMultiplier1;
		if (var.vt == VT_NULL)
			dblMultiplier1 = 1.0;
		else
			dblMultiplier1 = var.dblVal;

		pNew->Multiplier1 = var;

		//////////
		//Multiplier2
		var = m_rsBill->Fields->Item["CPTMultiplier2"]->Value;		//Multiplier2

		double dblMultiplier2;
		if (var.vt == VT_NULL)
			dblMultiplier2 = 1.0;
		else
			dblMultiplier2 = var.dblVal;

		pNew->Multiplier2 = var;

		//////////
		//Multiplier3
		var = m_rsBill->Fields->Item["CPTMultiplier3"]->Value;		// Multiplier

		double dblMultiplier3;
		if (var.vt == VT_NULL)
			dblMultiplier3 = 1.0;
		else
			dblMultiplier3 = var.dblVal;

		pNew->Multiplier3 = var;

		//////////
		//Multiplier4
		var = m_rsBill->Fields->Item["CPTMultiplier4"]->Value;		// Multiplier

		double dblMultiplier4;
		if (var.vt == VT_NULL)
			dblMultiplier4 = 1.0;
		else
			dblMultiplier4 = var.dblVal;

		pNew->Multiplier4 = var;

		// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
		pNew->Calls = m_rsBill->Fields->Item["Calls"]->Value;

		// (d.singleton 2012-05-09 09:57) - PLID 
		pNew->Skill = m_rsBill->Fields->Item["SkillCode"]->Value;

		// (d.singleton 2012-03-07 17:23) - PLID 49100 new button
		pNew->ValidationStatus = g_cvarNull;

		// (d.singleton 2012-03-22 15:57) - PLID 49136 notes column
		if (ReturnsRecordsParam("SELECT * FROM NoteInfoT WHERE LineItemID = {INT}", nChargeID)) {
			pNew->Notes = _variant_t((long)m_hIconHasNotes);
		}
		else {
			pNew->Notes = _variant_t((long)m_hIconNotes);
		}


		//////////
		//OnHold
		// (r.gonet 07/07/2014) - PLID 62572 - For bills, certain CPT codes default the charge to be on hold,
		// but only if they are being added for the first time.
		if (m_EntryType == 1) {
			// (r.gonet 08/01/2014) - PLID 62834 - If there is an override, use that. Otherwise get the OnHold value from
			// our normal sources.
			if (varOnHoldOverride.vt != VT_BOOL) {
				if (IsNew && GetBillStatusType() != EBillStatusType::OnHold) {
					pNew->OnHold = AdoFldBool(m_rsBill->Fields, "DefaultAsOnHold", FALSE) ? g_cvarTrue : g_cvarFalse;
				} else {
					// Charge on hold state is not persisted between loading and saving. And bills already on hold can't have on hold charges.
					pNew->OnHold = g_cvarFalse;
				}
			} else {
				pNew->OnHold = varOnHoldOverride;
			}
		} else {
			// (r.gonet 07/07/2014) - PLID 62569 - Quotes don't allow on hold charges
			pNew->OnHold = g_cvarFalse;
		}

		var = _bstr_t(strDescription);
		/////////////////////////////////////////////////////////////
		// Fill in the bill description if there is none
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(CString(var.bstrVal));
			}
		}

		/////////////////////////////////////////////////////////////
		//Unit Cost
		COleCurrency cyPatient, cyInsurance;
		cyPatient = COleCurrency(0, 0);
		cyInsurance = COleCurrency(0, 0);

		var = m_rsBill->Fields->Item["PracBillFee"]->Value;		// Unit cost
		cyPatient = var.cyVal;
		if (IsNew == FALSE) {
			pNew->UnitCost = var;
		}

		if (IsNew){
			if (VarLong(pNew->ItemType) == ITEM_TYPE_CPT && m_EntryType == 1) {

				int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);

				if (iCPTRow >= 0) {
					// (j.jones 2012-04-12 10:00) - PLID 49609 - add the default claim note, if it exists
					CString strClaimNote = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_CLAIM_NOTE), "");
					strClaimNote.TrimLeft(); strClaimNote.TrimRight();
					if (strClaimNote.GetLength() > 0) {
						AddNewUnsavedChargeNote(pNew, strClaimNote, TRUE);
					}

					// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
					CString strNDCCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFCODE), "");
					double dblNDCQty = VarDouble(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFQTY), 0.0);
					COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
					CString strNDCUnitType = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITTYPE), "");

					pNew->NDCCode = strNDCCode;
					pNew->DrugUnitPrice = cyNDCUnitPrice;
					pNew->DrugUnitType = strNDCUnitType;
					pNew->DrugUnitQuantity = dblNDCQty;
				}

				// (j.jones 2010-11-23 09:26) - PLID 32431 - assisting codes need to prompt for times
				// if we are adding to a bill
				if (UseOHIP()) {

					BOOL bCPTCodeCachedInfoLoaded = FALSE;
					BOOL bIsAssistingCode = FALSE;

					if (iCPTRow >= 0) {
						bIsAssistingCode = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ASSISTING_CODE), FALSE);
						bCPTCodeCachedInfoLoaded = TRUE;
					}

					if (!bCPTCodeCachedInfoLoaded || bIsAssistingCode) {

						BOOL bAssistingCode = FALSE;
						COleCurrency cyAssistingCodeUnitCost = COleCurrency(0, 0);

						// (j.jones 2011-10-31 17:15) - PLID 41558 - we now store this per bill
						long nAssistingMinutes = GetAssistingMinutes();
						CString strAssistingStartTime = GetAssistingStartTime();
						CString strAssistingEndTime = GetAssistingEndTime();

						if (!CheckAssistingCode(nServiceID, bAssistingCode, cyAssistingCodeUnitCost, nAssistingMinutes, strAssistingStartTime, strAssistingEndTime)) {
							return strChangeDiagSCodes; // (s.dhole 2011-06-13 11:48) - PLID 33666 added return value
						}

						if (bAssistingCode) {
							pNew->UnitCost = cyAssistingCodeUnitCost;
							cyPatient = cyAssistingCodeUnitCost;

							SetAssistingMinutes(nAssistingMinutes);
							SetAssistingStartTime(strAssistingStartTime);
							SetAssistingEndTime(strAssistingEndTime);
						}
					}
				}
			}
			else {
				// (j.dinatale 2012-06-15 14:11) - PLID 50959 - add NDC defaults to inventory items
				if(VarLong(pNew->ItemType) == ITEM_TYPE_PRODUCT) {

					// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
					long iNewRow = FindProductRowInComboByServiceID(nServiceID, TRUE);
					if (iNewRow < 0) {
						MessageBox("This product was not able to be added. Ensure the product is billable for this location.", "Practice", MB_ICONINFORMATION | MB_OK);
					}
					else if (iNewRow >= 0) {

						//bills only
						if (m_EntryType == 1) {
							// (j.dinatale 2012-06-15 10:51) - PLID 51000 - Added claim notes to inventory items
							CString strClaimNote = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CLAIM_NOTE), "");
							strClaimNote.TrimLeft(); strClaimNote.TrimRight();
							if (strClaimNote.GetLength() > 0) {
								AddNewUnsavedChargeNote(pNew, strClaimNote, TRUE);
							}

							CString strNDCCode = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFCODE), "");
							double dblNDCQty = VarDouble(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFQTY), 0.0);
							COleCurrency cyNDCUnitPrice = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
							CString strNDCUnitType = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITTYPE), "");

							pNew->NDCCode = strNDCCode;
							pNew->DrugUnitPrice = cyNDCUnitPrice;
							pNew->DrugUnitType = strNDCUnitType;
							pNew->DrugUnitQuantity = dblNDCQty;
						}

						//the remaining features are for bills and quotes

						// (j.jones 2016-04-07 13:16) - NX-100077 - added RememberChargeProvider setting
						bool bRememberChargeProvider = VarBool(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_REMEMBER_CHARGE_PROVIDER), FALSE) ? true : false;
						if (bRememberChargeProvider) {
							//this function will auto-update the provider to the last one who sold
							//the patient this product, if a prior sale exists
							UpdateChargeToMostRecentProviderSold(pNew);
						}
					}
				}
			}
		}

		/////////////////////////////////////////////////////////////////
		// For quotes: outside practice fees. We still need to set this
		// to -1 for bills to keep the old and new data consistent.
		//		if (m_EntryType != 1) {
		// (j.jones 2008-05-30 11:52) - PLID 28898 - billing packages should never fill in the other fee
		if (m_EntryType == 1 && nPackageChargeRefID != -1) {
			pNew->OthrUnitCost = COleCurrency(0, 0);
		}
		else {
			var = m_rsBill->Fields->Item["OthrBillFee"]->Value;
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				pNew->OthrUnitCost = var;

				//JJ - 11/8/2002 - We now calculate the outside fee into the total
				if (m_EntryType == 2)
					cyPatient += var.cyVal;
			}
			else {
				pNew->OthrUnitCost = COleCurrency(0, 0);
			}
		}

		// (d.lange 2015-11-17 15:58) - PLID 67128 - Load the Insurance Co ID for calculating the allowable
		pNew->AllowableInsuranceCoID = m_rsBill->Fields->Item["AllowableInsuranceCoID"]->Value;

		// (j.gruber 2009-10-19 16:44) - PLID 35947 - Add Allowable, quotes only
		if (m_EntryType == 2) {
			var = m_rsBill->Fields->Item["Allowable"]->Value;
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				pNew->UnitAllowable = var;
			}
			else {
				pNew->UnitAllowable = COleCurrency(0, 0);
			}

			// (j.jones 2010-09-02 09:38) - PLID 40330 - TotalAllowable is not used on quotes
			pNew->TotalAllowable = g_cvarNull;
		}
		else {
			// (j.jones 2010-09-01 12:26) - PLID 40330 - on bills we always call LoadAllowableColumn()
			LoadAllowableColumn(pNew, FALSE);

			// (j.jones 2014-05-01 08:36) - PLID 61837 - The charge may
			// potentially show additional provider columns.
			// Don't update providers though if we are loading an existing bill.
			TryShowChargeProviderColumns(pNew, IsNew ? true : false, IsNew ? true : false);
		}

		//if a bill:
		//cost * quantity, then apply modifiers, then percent off, then discount, then tax that total
		// Charge Total = ((((UnitCost * Quantity) * (1+(Modifier / 100)) * (1-(PercentOff / 100)) - Discount) * (Tax / 100)

		//if a quote:
		//cost + other cost, times quantity, then percent off, then discount, then tax that total
		// Charge total = (((UnitCost + OtherCost) * Quantity) * (1-(PercentOff / 100)) - Discount) * (Tax / 100)

		//cyPatient *= dblQuantity;

		/////////////////////////////////////////////////////////////
		// If applying a quote, remove the discount
		if (IsNew == TRUE) {

			// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
			// the unit cost based on the modifier we just chose
			// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
			// price unless there are modifiers
			if (UseAlbertaHLINK()) {
				pNew->UnitCost = cyPatient;
				UpdateChargePriceWithAlbertaModifiers(pNew, FALSE);
				//get the new price, as it could have changed
				cyPatient = VarCurrency(pNew->UnitCost);
			}

			//only remove it if they do not have the preference set to retain it
			BOOL bKeepDiscounts = (GetRemotePropertyInt("KeepQuoteDiscounts", 1, 0, "<None>", TRUE) == 1);
			if (!bKeepDiscounts) {

				// (j.gruber 2009-03-05 16:05) - PLID 33351 - take out existing structure

				//ok, what this does, is instead of bringing over the discounts in the discounts fields,
				//this preference puts the discounts as 0 and subtracts the discounts total from the 
				//unit cost.

				//So, we need to divide the totalDiscount by the quantity and the subtract from the unit cost
				//and remove everything from the discounts array
				COleCurrency cyTotalDollarDiscount(0, 0);
				long nPercentOff = 0;
				COleCurrency cyTotalLineDiscount;

				COleCurrency cyInvalid;
				cyInvalid.SetStatus(COleCurrency::invalid);

				CalculateTotalDiscount(pNew->DiscountList, cyPatient, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIncludeDiscountInTotal);

				//now that we calculated it, we need to clear our list
				//pNew->DiscountList->aryDiscounts.RemoveAll();
				// (z.manning 2011-03-28 17:20) - PLID 41423 - Wrong, we only want to clear the discounts that came from the
				// quote. We may have other discounts (from sales, reward points, etc.) that we still need to handle.
				for (int nDiscountIndex = pNew->DiscountList->aryDiscounts.GetSize() - 1; nDiscountIndex >= 0; nDiscountIndex--) {
					stDiscount discount = pNew->DiscountList->aryDiscounts.GetAt(nDiscountIndex);
					if (discount.DiscountPreference == dpIncludeDiscountInTotal) {
						pNew->DiscountList->aryDiscounts.RemoveAt(nDiscountIndex);
					}
				}

				/*var = m_rsBill->Fields->Item["PercentOff"]->Value;
				if (var.vt != VT_NULL)
				iQuotePercentOff = var.lVal;

				var = m_rsBill->Fields->Item["Discount"]->Value;
				if (var.vt != VT_NULL)
				cyQuoteDiscount = var.cyVal;
				*/
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator * is ambiguous
				cyPatient = (cyPatient * long(100000 - nPercentOff * 1000));
				cyPatient /= 100000;

				if (!m_bPaymentPlan) {
					cyPatient -= cyTotalDollarDiscount / dblQuantity;
					//cyPatient /= dblQuantity;
				}
			}

			// (j.jones 2007-03-26 14:39) - PLID 25287 - if we have an offset, use it!
			if (cyPatient + cyOffsetAmount < COleCurrency(0, 0)) {
				//if the offset is negative and using it would cause a negative
				//charge, set the charge to zero, but also assert because we should
				//not be allowing this setup to occur
				ASSERT(FALSE);
				cyPatient = COleCurrency(0, 0);
			}
			else {
				//normal use, append cyOffsetAmount to cyPatient
				cyPatient += cyOffsetAmount;
			}

			RoundCurrency(cyPatient);
			var = cyPatient;
			pNew->UnitCost = var;
		}

		cyPatient = CalculateAmtQuantity(cyPatient, dblQuantity);

		cyPatient = CalculateAmtQuantity(cyPatient, dblMultiplier1);
		cyPatient = CalculateAmtQuantity(cyPatient, dblMultiplier2);
		cyPatient = CalculateAmtQuantity(cyPatient, dblMultiplier3);
		cyPatient = CalculateAmtQuantity(cyPatient, dblMultiplier4);

		// (j.gruber 2009-03-09 10:12) - PLID 33351 - new discount structure
		long nPercentOff = 0;
		COleCurrency cyTotalDollarDiscount(0, 0);
		COleCurrency cyTotalLineDiscount(0, 0);

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		CalculateTotalDiscount(pNew->DiscountList, cyPatient, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, IsNew ? dpKeepDiscountSeparate : dpIgnorePreference);
		pNew->TotalDiscount = cyTotalLineDiscount;

		cyPatient = (cyPatient * (100000 - nPercentOff * 1000));
		cyPatient /= 100000;
		cyPatient -= cyTotalDollarDiscount;

		//calculate tax		

		COleCurrency taxResult1, taxResult2;

		var = cyPatient;

		taxResult1 = CalculateTax(cyPatient, taxrate1);
		taxResult2 = CalculateTax(cyPatient, taxrate2);

		cyPatient += taxResult1;
		cyPatient += taxResult2;

		RoundCurrency(cyPatient);
		_variant_t varTotal = cyPatient;
		pNew->LineTotal = varTotal;		// Line total		

		///////////////////////////////////////////
		//Insurance setup
		if (!IsNew) {
			//we are pulling from the database
			// (j.jones 2007-02-27 17:49) - PLID 24844 - pull the InsCo and Resp name, later used in auditing
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsResp = CreateParamRecordset("SELECT Sum(Amount) AS InsResp, ChargeID, InsuredPartyID, "
				"InsuranceCoT.Name AS InsCoName, RespTypeT.TypeName AS RespTypeName "
				"FROM ChargeRespT "
				"INNER JOIN InsuredPartyT ON ChargeRespT.InsuredPartyID = InsuredPartyT.PersonID "
				"INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
				"INNER JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
				"WHERE ChargeID = {INT} "
				"GROUP BY ChargeID, InsuredPartyID, InsuranceCoT.Name, RespTypeT.TypeName", VarLong(pNew->ChargeID));

			RPCList *list = new RPCList;
			RespPerCharge rpc;// = new RespPerCharge;

			while (!rsResp->eof) {
				//loop through all the available responsibilities for this charge and load
				//them into our RPCList struct
				rpc.InsAmount = rsResp->Fields->Item["InsResp"]->Value;
				rpc.InsuredPartyID = rsResp->Fields->Item["InsuredPartyID"]->Value;
				rpc.InsuranceCoName = rsResp->Fields->Item["InsCoName"]->Value;
				rpc.RespTypeName = rsResp->Fields->Item["RespTypeName"]->Value;

				//now add that struct into our array
				list->aryRPC.Add(rpc);

				rsResp->MoveNext();
			}

			//now that we're done adding all the structs, add the list into our BillingItem
			pNew->RPCList = list;
		}
		else {

			//this is indeed a new charge.
			RPCList *list = new RPCList;

			//add to our BillingItem
			pNew->RPCList = list;

			//DRT 6/16/03 - This code does NOT need to be executed if we are under patient resp - that is all
			//		handled at the end of a save to figure out the patient resp from what the insurance has
			long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
			if (nInsuredPartyID > 0) {

				bool bFoundResp = false;
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int j = 0;
				for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
					if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
						bFoundResp = true;
				}

				if (bFoundResp) {
					//at this point, varLineTotal is the amount before tax, and var is the amount with tax
					//use the insurance TaxType to determine which responsibility gets which amount
					if (TaxType == 1)
						UpdateListInsAmount(list, j, varTotal);
					else
						//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
						UpdateListInsAmount(list, j, var);
				}
				else {
					//we're looking at insurance, but there's nothing in our list!  we
					//need to add it
					RespPerCharge rpc;
					rpc.InsuredPartyID = nInsuredPartyID;

					if (TaxType == 1)
						rpc.InsAmount = varTotal;
					else
						//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
						rpc.InsAmount = var;

					// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
					rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
					rpc.RespTypeName = GetCurrentBillToRespTypeName();

					list->aryRPC.Add(rpc);
				}

			}
		}

		// (r.gonet 08/05/2014) - PLID 63098 - Retrieve the lab test codes associated with this charge.
		// Only lab charges can have lab test codes. New charges obviously cannot have saved test codes.
		if (!IsNew && (ReturnsRecordsParam("SELECT NULL FROM ServiceT WHERE ID = {INT} AND LabCharge = 1", nServiceID)
			|| ReturnsRecordsParam("SELECT NULL FROM ChargeLabTestCodesT WHERE ChargeID = {INT}", nChargeID))) {

			_RecordsetPtr prsTestCodes = CreateParamRecordset(GetRemoteDataSnapshot(), R"(
SELECT ChargeLabTestCodesT.BillLabTestCodeID 
FROM ChargeLabTestCodesT
WHERE ChargeID = {INT}
)"
, VarLong(pNew->ChargeID));

			while (!prsTestCodes->eof) {
				long nTestCodeID = AdoFldLong(prsTestCodes->Fields, "BillLabTestCodeID");
				pNew->TestCodeList.push_back(nTestCodeID);
				prsTestCodes->MoveNext();
			}
			prsTestCodes->Close();
		}

		//and we're done!  add it into our structure
		m_billingItems.push_back(pNew);

	}
	NxCatchAll("BillingDlg::AddChargeToList");
	// now we need return value 	
	return strChangeDiagSCodes;
}

// (r.gonet 07/09/2014) - PLID 62834 - Reloads the current bill
void CBillingDlg::ReloadCurrentBill()
{
	m_List->Clear();
	FillTabInfo(true);
}


/********************************************************
*	FillTabInfo() fills the listbox with charges from
*	a bill. This is only called on OnShowWindow().
*
* Callers:	OnShowWindow()
********************************************************/
// (r.gonet 08/01/2014) - PLID 62834 - Added bReloadingCurrentBill, which should be
// true if, and only if, the current, open bill is being reloaded while the billing dialog is open.
void CBillingDlg::FillTabInfo(bool bReloadingCurrentBill/*=false*/)
{
	try {
		COleVariant var;
		CString str;

		try {
			// First fill in the place of service

			// (j.jones 2005-01-26 10:43) - we have to do this PRIOR to setting the saved POS code in
			//the DesignationCombo, because OnSelChangedComboPlaceofservice will revert it to
			//the default POS code
			COleVariant var;

			// (a.walling 2007-05-21 14:46) - PLID 26088 - Don't query if we already know it won't return anything.
			if (GetBillID() == -1)
				return;

			// Queries the bill
			// (r.gonet 07/01/2014) - PLID 62531 - Combined multiple trips to the database regarding non-charge related fields of the bill into one.
			// (r.gonet 07/02/2014) - PLID 62524 - Load the BillStatusNote
			// (r.gonet 07/02/2014) - PLID 62525 - Load the username of the user who input the Bill Status Note
			CParamSqlBatch sqlBatch;
			sqlBatch.Add(
				"SELECT BillsT.Location AS LocationID, LocationsT.Name AS LocationName, "
				"	BillStatusT.ID AS BillStatusID, BillStatusT.Name AS BillStatusName, BillStatusT.Type AS BillStatusType, BillStatusT.Inactive AS BillStatusIsInactive, BillStatusT.Custom AS BillStatusIsCustom, "
				"	StatusNoteDataT.Note AS BillStatusNote, StatusNoteInputUserT.Username AS BillStatusNoteUsername "
				"FROM BillsT "
				"LEFT JOIN LocationsT ON BillsT.Location = LocationsT.ID "
				"LEFT JOIN BillStatusT ON BillsT.StatusID = BillStatusT.ID "
				"LEFT JOIN NoteDataT StatusNoteDataT ON BillsT.StatusNoteID = StatusNoteDataT.ID "
				"LEFT JOIN UsersT StatusNoteInputUserT ON StatusNoteDataT.UserID = StatusNoteInputUserT.PersonID "
				"WHERE BillsT.ID = {INT}; "
				, GetBillID());
			if (m_EntryType == 1) {
				// (r.gonet 07/01/2014) - PLID 62531 - Moved from a separate batch.
				// If this has a billed package, then load some package relevant data.
				sqlBatch.Add(
					"SELECT BilledQuotesT.QuoteID, CONVERT(BIT, CASE WHEN PackagesT.QuoteID IS NULL THEN 0 ELSE 1 END) AS IsBilledPackage, PackagesT.Type "
					"FROM BilledQuotesT "
					"LEFT JOIN PackagesT ON BilledQuotesT.QuoteID = PackagesT.QuoteID "
					"WHERE BillID = {INT} "
					"AND BillID IN (SELECT ID FROM BillsT WHERE Deleted = 0 AND EntryType = 1); "
					, GetBillID());
				if (IsSurgeryCenter(true)) {
					// (j.jones 2009-08-12 15:44) - PLID 35179 - need to load up more info for auditing purposes,
					// added order by name so existing bills will display the names of multiple cases in alphabetical order
					// (though this is nor maintained if you add more cases)
					// (r.gonet 07/01/2014) - PLID 62531 - Moved from a separate batch.
					sqlBatch.Add(
						"SELECT CaseHistoryID, CaseHistoryT.Name, CaseHistoryT.SurgeryDate "
						"FROM BilledCaseHistoriesT "
						"INNER JOIN CaseHistoryT ON BilledCaseHistoriesT.CaseHistoryID = CaseHistoryT.ID "
						"WHERE BilledCaseHistoriesT.BillID = {INT} "
						"ORDER BY CaseHistoryT.Name"
						, GetBillID());
				}
			}
			_RecordsetPtr rs = sqlBatch.CreateRecordset(GetRemoteData());


			if (rs->eof) {
				// (r.gonet 07/01/2014) - PLID 62531 - No bill with this ID. Hm.
				return;
			}

			// Bill Place of Service
			var = rs->Fields->Item["LocationID"]->Value;
			if (m_PlaceOfServiceCombo->TrySetSelByColumn(0, var) == -1) {
				//Must be inactive.
				// (r.gonet 07/01/2014) - PLID 62531 - We used to query again here just for the location name.
				// We now get the Bill location and the Location Name in one recordset.
				_variant_t varLocationName = AdoFldVar(rs->Fields, "LocationName");
				if (varLocationName.vt == VT_BSTR) {
					m_PlaceOfServiceCombo->PutComboBoxText(_bstr_t(varLocationName.bstrVal));
				}
			}
			else {
				//DRT 1/4/2005 - PLID 15184 - If the selection is set, we must call OnSelChosen... to appropriately
				//	set the m_fltPracticeTax1 or 2 values!
				PostPlaceOfServiceChanged();
			}

			if (m_EntryType == 1) {
				// Loads for bills

				// (r.gonet 07/01/2014) - PLID 62531 - Bill Status
				long nBillStatusID = AdoFldLong(rs->Fields, "BillStatusID", -1);
				if (m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, nBillStatusID) == NULL) {
					// (r.gonet 07/01/2014) - PLID 62531 - Must be inactive. We filter out the inactive statuses from the status dropdown.
					NXDATALIST2Lib::IRowSettingsPtr pRow = m_pBillStatusCombo->GetNewRow();
					pRow->PutValue((short)EBillStatusComboColumns::ID, nBillStatusID);
					pRow->PutValue((short)EBillStatusComboColumns::Name, AdoFldVar(rs->Fields, "BillStatusName"));
					EBillStatusType eBillStatusType = (EBillStatusType)AdoFldLong(rs->Fields, "BillStatusType", (long)EBillStatusType::None);
					pRow->PutValue((short)EBillStatusComboColumns::Type, (long)eBillStatusType);
					pRow->PutValue((short)EBillStatusComboColumns::Inactive, AdoFldVar(rs->Fields, "BillStatusIsInactive"));
					pRow->PutValue((short)EBillStatusComboColumns::Custom, AdoFldVar(rs->Fields, "BillStatusIsCustom"));
					// (r.gonet 07/01/2014) - PLID 62531 - A couple other places just set the combo text,
					// however, we need to know what type the status is later. Setting it to invisible 
					// works fine too.
					pRow->PutVisible(VARIANT_FALSE);
					m_pBillStatusCombo->AddRowAtEnd(pRow, NULL);
					m_pBillStatusCombo->CurSel = pRow;
				}

				// (r.gonet 07/01/2014) - PLID 62524 - Bill Status Note
				// (r.gonet 07/01/2014) - PLID 62525 - Remove the username from the note. We don't want to show it in the bill dialog.
				CString strBillStatusNote = RemoveUsernameFromStatusNote(AdoFldString(rs->Fields, "BillStatusNote", ""), AdoFldString(rs->Fields, "BillStatusNoteUsername", ""));
				m_nxeditBillStatusNote.SetWindowText(strBillStatusNote);

				// (j.jones 2005-04-08 15:06) - PLID 16183 - also load the status of this being a billed package
				// (r.gonet 07/01/2014) - PLID 62531 - Moved a separate query for the package related fields to one batch
				rs = rs->NextRecordset(NULL);
				while (!rs->eof) {
					long nBilledQuote = AdoFldLong(rs, "QuoteID", -1);
					if (nBilledQuote != -1) {
						// (r.gonet 07/01/2014) - PLID 62531 - Moved a separate query for the associated quote to one batch
						if (AdoFldBool(rs->Fields, "IsBilledPackage")) {
							//it's a billed package, so...
							m_bPaymentPlan = TRUE;
							m_nPackageType = AdoFldLong(rs, "Type", 1);
							m_nPackageID = nBilledQuote;

							//do not set m_bIsABilledPackage, that is only used to decrement the package use count
						}
					}

					rs->MoveNext();
				}

				// (j.jones 2009-08-12 15:32) - PLID 35179 - these are now arrays of pointers
				ClearCaseHistoryArray();
				ClearOldCaseHistoryArray();

				// (j.jones 2009-08-10 18:01) - PLID 35142 - load up our billed case histories, we will also store these in an "old" list
				if (IsSurgeryCenter(true) && m_EntryType == 1) {
					// (j.jones 2009-08-12 15:44) - PLID 35179 - need to load up more info for auditing purposes,
					// added order by name so existing bills will display the names of multiple cases in alphabetical order
					// (though this is nor maintained if you add more cases)
					// (r.gonet 07/01/2014) - PLID 62531 - Moved a separate query to one batch
					rs = rs->NextRecordset(NULL);
					while (!rs->eof) {
						long nCaseHistoryID = AdoFldLong(rs, "CaseHistoryID");
						CString strCaseHistoryName = AdoFldString(rs, "Name");
						COleDateTime dtSurgeryDate = AdoFldDateTime(rs, "SurgeryDate");

						// (j.jones 2009-08-12 15:32) - PLID 35179 - these are now arrays of pointers
						CaseHistoryInfo *pNewCase1 = new CaseHistoryInfo;
						pNewCase1->nCaseHistoryID = nCaseHistoryID;
						pNewCase1->strCaseHistoryName = strCaseHistoryName;
						pNewCase1->dtSurgeryDate = dtSurgeryDate;
						m_arypBilledCaseHistories.Add(pNewCase1);

						CaseHistoryInfo *pNewCase2 = new CaseHistoryInfo;
						pNewCase2->nCaseHistoryID = nCaseHistoryID;
						pNewCase2->strCaseHistoryName = strCaseHistoryName;
						pNewCase2->dtSurgeryDate = dtSurgeryDate;
						m_arypOldBilledCaseHistories.Add(pNewCase2);

						rs->MoveNext();
					}
				}
			}

			rs->Close();
		}
		NxCatchAll("Billing::FillTabInfo");

		// (a.walling 2007-07-09 12:40) - PLID 26088 - Do not query when billid is -1
		if (GetBillID() != -1) {
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			//m_rsBill = CreateRecordset(adOpenStatic,adLockReadOnly,((CBillingModuleDlg*)m_pBillingModuleWnd)->GetChargeSql());
			m_rsBill = ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetChargeRecordset();
			// (j.gruber 2014-02-20 11:01) - PLID 60942 - load the new whichcodes structure
			LoadBillWhichCodes(GetBillID());
		} else {
			m_rsBill = NULL;
		}

		// (r.gonet 08/01/2014) - PLID 62834 - If we are reloading a bill, preserve the on hold statuses. They don't get saved to the database.
		std::vector<BillingItemPtr> vecOnHoldCharges;
		std::map<long, BillingItemPtr> mapLineIDToOldOnHoldBillingItem;
		if (bReloadingCurrentBill) {
			GetOnHoldCharges(vecOnHoldCharges);
			for each(BillingItemPtr pItem in vecOnHoldCharges)
			{
				long nLineID = VarLong(pItem->LineID);
				mapLineIDToOldOnHoldBillingItem[nLineID] = pItem;
			}
		}


		/////////////////////////////////////////////////////////////
		// Empty the listbox
		m_billingItems.clear();


		/////////////////////////////////////////////////////////////
		// Fill in diagnosis codes (ICD-9)'s with the codes
		// from the first charge. Saving ICD-9's in charges is
		// redundant (because they're all the same for a bill) but
		// that is the way the architecture is right now.

		//DRT 9/29/03 - PLID 9347 - Handle inactive diag codes on existing bills

		// (a.walling 2007-07-09 12:40) - PLID 26088
		if (m_rsBill != NULL && !m_rsBill->eof) {

			/////////////////////////////////////////////////////////////
			// Fill in POS Designation
			var = m_rsBill->Fields->Item["Service Location"]->Value;
			m_DesignationCombo->SetSelByColumn(posdcID, var);
		}

		// (j.jones 2005-04-04 15:06) - PLID 11966 - auto-show the "batched" column
		// if any charges are not marked as being batched
		BOOL bAllBatched = TRUE;
		// (s.dhole 2011-06-13 11:44) - PLID 33666  Constucting Diag Code changes string
		CString strChangeDiagSCodes = "";
		// (a.walling 2007-07-09 12:40) - PLID 26088
		while (m_rsBill != NULL && !m_rsBill->eof) {
			/////////////////////////////////////////////////////////////
			// Fill with only old existing charges since this
			// is only called on OnShowWindow. Thats why we
			// pass in FALSE

			// (j.jones 2007-12-14 09:14) - PLID 27988 - removed these field calls from AddChargeToList,
			// need to pull them ahead of time - allocations may change them
			CString strDescription = AdoFldString(m_rsBill, "ItemDesc", "");
			long nServiceID = AdoFldLong(m_rsBill, "ServiceID", -1);
			CString strItemCode = AdoFldString(m_rsBill, "ItemCode", "");
			long nCategoryID = AdoFldLong(m_rsBill, "Category", -1);
			long nSubCategoryID = AdoFldLong(m_rsBill, "SubCategory", -1);
			// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
			long nCategoryCount = AdoFldLong(m_rsBill, "CategoryCount", 0);
			double dblQuantity = AdoFldDouble(m_rsBill, "Quantity", 1.0);
			// (r.gonet 08/01/2014) - PLID 62834 - Get the line ID.
			long nLineID = AdoFldLong(m_rsBill, "LineID", -1);

			// (r.gonet 08/01/2014) - PLID 62834 - We may need to preserve the OnHold status of the charges if we are just reloading the billing dialog
			// while it is open (such as during saving) since charge OnHold status is not persisted.
			_variant_t varOnHold = g_cvarFalse;
			if (bReloadingCurrentBill && mapLineIDToOldOnHoldBillingItem.find(nLineID) != mapLineIDToOldOnHoldBillingItem.end()) {
				varOnHold = g_cvarTrue;
			}
			
			// (j.gruber 2009-03-17 09:43) - PLID 33351 - added bIsPackage bool, just set to false here, since its not a new charge
			// (s.dhole 2011-06-13 11:31) - PLID 33666 build Diag code changes string 
			// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
			CString strTemp = AddChargeToList(FALSE, nServiceID, dblQuantity, strDescription, strItemCode, nCategoryID, nSubCategoryID, FALSE,  nCategoryCount, -1L, -1L, -1L, COleCurrency(0, 0), -1L, varOnHold);
			if (!strTemp.IsEmpty() && strChangeDiagSCodes.Find(strTemp, 0) == -1)
				strChangeDiagSCodes = FormatString("%s%s", strChangeDiagSCodes, strTemp);

			//check the batched status
			if (!AdoFldBool(m_rsBill, "Batched", TRUE)) {
				bAllBatched = FALSE;
			}

			m_rsBill->MoveNext();
		}

		// (r.gonet 08/01/2014) - PLID 62834 - Clear the old onhold charges containers.
		mapLineIDToOldOnHoldBillingItem.clear();
		vecOnHoldCharges.clear();

		// (s.dhole 2011-06-13 11:45) - PLID 33666  if ther is any value in DiagCode change string than propt to user
		if (!strChangeDiagSCodes.IsEmpty()){
			MessageBox(FormatString("The charges were configured to show the diagnosis code instead of pointers on the claim, which is no longer supported.\r\n"
				"The following diagnosis code pointers have changed:\r\n "
				"%s\r\n"
				"When you click OK on the bill, these changes will be saved.", strChangeDiagSCodes), "Practice", MB_ICONINFORMATION | MB_OK);
		}



		if (!bAllBatched) {
			//if not all batched, show the batched column
			ToggleChargeBatchColumn(TRUE);
		}
		else {
			//otherwise hide it
			ToggleChargeBatchColumn(FALSE);
		}
	}
	NxCatchAll("Billing::FillTabInfo");


	/////////////////////////////////////////////////////////////////
	// Determine if it is in the correct sorted order or not.
	// This works well because this function is ONLY called once, from OnShowWindow, so we
	// don't have to worry about this being reset (though really it should be OK even if
	// it was, because it would calculate OK)
	if (GetBillID() != -1) {
		//if it's not a new bill, determine if it's in the default sorted order.  If so,
		//it will effect the way things are sorted later on
		if (IsListInDefaultSortedOrder()) {
			m_bIsInDefaultSortedOrder = true;
		}
		else  {
			m_bIsInDefaultSortedOrder = false;
		}
	}
	else {
		//new bill, so it is in the default order
		m_bIsInDefaultSortedOrder = true;
	}

	// (a.walling 2007-07-09 12:41) - PLID 26088 - Close the recordset if it is not null
	if (m_rsBill != NULL)
		m_rsBill->Close();

	Requery();
}


/********************************************************
*	ApplyChargeToBill() adds or modifies a charge that
*	exists in the LineItemsT/ChargesT tables.
*	This is only called on SaveChanges()
*
* Callers:	SaveChanges()
********************************************************/
// (j.gruber 2014-02-24 11:52) - PLID 60893 - WhichCodes Saving
BOOL CBillingDlg::ApplyChargeToBill(long LineID, long ChargeID, BOOL bIsNewBill, CSqlFragment &sqlTotalWhichCodes)
{
	_RecordsetPtr  rsList, rsParam, rs;
	COleVariant var;
	CString str;
	int NewChargeID;
	bool bNewCharge = FALSE;
	bool bServiceCodeChanged = false;

	CString strItemDescription, strTaxRate1, strTaxRate2, strDate, strServiceDateTo;
	COleDateTime dtDateNoTime, date;
	long nDesignation;
	// (j.jones 2008-05-02 15:25) - PLID 27245 - track whether the date changed
	BOOL bDateChanged = FALSE;

	// (j.jones 2007-11-27 13:01) - PLID 28198 - track if the quantities changed, for package purposes later on
	BOOL bQuantityChanged = FALSE;
	BOOL bPackageQuantityRemChanged = FALSE;
	BOOL bOriginalPackageQuantityRemChanged = FALSE;

	try {

		CString strPatientName = GetBillPatientName();
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			var = m_billingItems[i]->LineID;
			if (var.lVal == LineID)
				break;
		}

		////////////////////////////////////////////////////////
		//This function is broken up into parts: Initializing and
		//auditing variables, changing inventory, getting the new
		//ID, inserting/updating the data, and updating the
		//ChargeRespT table.
		////////////////////////////////////////////////////////
		if (ChargeID == -2) {
			bNewCharge = TRUE;
		}

		// (j.jones 2013-08-20 10:57) - PLID 57959 - if the service code changed,
		// track that locally, and reset the HasServiceCodeChanged field to false
		// so that it doesn't remain set the next time the bill is saved
		if (VarBool(m_billingItems[i]->HasServiceCodeChanged, FALSE)) {
			bServiceCodeChanged = true;
		}
		m_billingItems[i]->HasServiceCodeChanged = g_cvarFalse;

		COleCurrency cyPointsUsed, cyTotalCharge;
		// (j.gruber 2014-03-10 11:03) - PLID 60893 - take out old WhichCodes
		CString CPTCode, TOS, CPTSubCode, OthCost, strDiscount, oldVal, newVal, strSkill;
		double dblTax;
		long LineID, ServiceID, /*PercentOff,*/ AuditID = -1, LocationID = GetCurrentLocationID();
		long nDocID, nPackageChargeRefID = -1;
		double dblQty = 0.0, PackageQtyRemaining = 0.0, OriginalPackageQtyRemaining = 0.0, dblCalls = 0.0;
		COleDateTime dtNewInputDate;
		BOOL bBatched = TRUE;
		// (r.gonet 07/07/2014) - PLID 62569 - Initialize the new on hold status for the charge to be not on hold.
		BOOL bOnHold = FALSE;
		// (j.jones 2011-04-27 14:44) - PLID 43405 - converted various fields to variants
		_variant_t varGiftID = g_cvarNull;
		_variant_t varOldGCValue = g_cvarNull;
		_variant_t varNewGCValue = g_cvarNull;
		_variant_t varMod1 = g_cvarNull;
		_variant_t varMod2 = g_cvarNull;
		_variant_t varMod3 = g_cvarNull;
		_variant_t varMod4 = g_cvarNull;
		_variant_t varMultiplier1 = g_cvarNull;
		_variant_t varMultiplier2 = g_cvarNull;
		_variant_t varMultiplier3 = g_cvarNull;
		_variant_t varMultiplier4 = g_cvarNull;
		_variant_t varClaimProviderID = g_cvarNull;
		_variant_t varReferringProviderID = g_cvarNull;
		_variant_t varOrderingProviderID = g_cvarNull;
		_variant_t varSupervisingProviderID = g_cvarNull;
		_variant_t varPatCoordID = g_cvarNull;
		_variant_t varPOSToSave = g_cvarNull;
		_variant_t varPackageChargeRefID = g_cvarNull;
		_variant_t varAppointmentID = g_cvarNull;
		_variant_t varGlassesOrderServiceID = g_cvarNull;
		// (j.jones 2015-03-18 14:24) - PLID 64974 - Category and SubCategory are now nullable
		_variant_t varCategoryID = g_cvarNull;
		_variant_t varSubCategoryID = g_cvarNull;

		CString strProductItemID;

		// (j.gruber 2007-03-23 09:31) - PLID 24870 - adding discount categories
		//CString strDiscountCategoryID, strCustomDiscountDescription;

		// (j.gruber 2007-04-03 17:36) - PLID 9796 - Coupons
		//CString strCouponID;

		// (j.jones 2008-05-28 11:44) - PLID 28782 - added NDCCode
		CString strNDCCode = "";

		// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
		ChargeIsEmergencyType eIsEmergency = cietUseDefault;

		// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
		COleCurrency cyDrugUnitPrice = COleCurrency(0, 0);
		CString strDrugUnitType = "";
		double dblDrugUnitQuantity = 0.0;
		CString strPrescriptionNumber = "";

		// (j.jones 2008-06-04 15:00) - PLID 30256 - added EMRChargeID
		long nEMRChargeID = -1;
		_variant_t varEMRChargeID = g_cvarNull;

		// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
		long nAppointmentID = -1;

		//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
		long nGlassesOrderServiceID = -1;

		// (j.gruber 2009-03-11 13:52) - PLID 33351 - DiscountSaveString
		CString strDiscountSaveString;

		// (j.gruber 2009-10-19 12:44) - PLID 35947 - Allowable
		COleCurrency cyAllowable;

		// (j.gruber 2014-02-24 11:52) - PLID 60893 - WhichCodes Saving
		CSqlFragment sqlWhichCodesSave;

		try {
			if (!bNewCharge) {
				// (s.tullis 2015-03-24 09:28) - PLID 64973 - Added Charge category name
				// (j.gruber 2009-03-11 10:25) - PLID 33351 - take out discount fields
				rs = CreateParamRecordset("SELECT LineItemT.*, ChargesT.*, "
					/*" CASE WHEN ChargesT.DiscountCategoryID IS NULL THEN '<No Category>' ELSE CASE WHEN ChargesT.DiscountCategoryID = -1 THEN '<Custom Discount Description>' ELSE  CASE WHEN ChargesT.DiscountCategoryID = -2 THEN '<Coupon>' ELSE DiscountCategoriesT.Description END END END AS DiscountCategoryName, "
					" CASE WHEN ChargesT.CouponID IS NULL THEN '' ELSE CouponsT.Description END AS CouponName, "*/
					" LocationsT.Name AS LocationName, "
					" CategoriesT.Name AS CategoryName "
					" FROM LineItemT "
					" INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
					" INNER JOIN BillsT ON ChargesT.BillID = BillsT.ID "
					" INNER JOIN LocationsT ON LineItemT.LocationID = LocationsT.ID "
					/*" LEFT JOIN DiscountCategoriesT ON ChargesT.DiscountCategoryID = DiscountCategoriesT.ID "*/
					/*" LEFT JOIN CouponsT ON ChargesT.CouponID = CouponsT.ID "*/
					" LEFT JOIN CategoriesT ON ChargesT.Category =  CategoriesT.ID "
					" WHERE ChargesT.ID = {INT}", ChargeID);
			}

			//TES 4/9/2008 - PLID 29585 - Track the new location name for auditing.
			CString strLocationName;
			if (m_LocationCombo->GetCurSel() == -1) {
				if (CString((LPCTSTR)m_LocationCombo->ComboBoxText) != "") {
					//It's an inactive location, leave it.
					//We don't want to change the location.
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsLocID = CreateParamRecordset(
						"SELECT TOP 1 LocationID, LocationsT.Name FROM LineItemT INNER JOIN LocationsT ON LineItemT.LocationID = LocationsT.ID "
						"WHERE LineItemT.ID IN (SELECT ID FROM ChargesT WHERE BillID = {INT})", GetBillID());
					if (!rsLocID->eof) {
						LocationID = AdoFldLong(rsLocID, "LocationID");
						strLocationName = AdoFldString(rsLocID, "Name");
					}
				}
				else {
					//This should have been caught in the validation section up above.
					// (j.jones 2007-02-21 11:56) - PLID 24835 - we previously returned SCR_NOT_SAVED, which is invalid here
					return FALSE;
				}
			}
			else {
				var = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0);
				if (var.vt == VT_I4) {
					LocationID = var.lVal;
					strLocationName = VarString(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 1));
				}
				else {
					LocationID = GetCurrentLocationID();
					strLocationName = GetCurrentLocationName();
				}
			}

			//TES 4/9/2008 - PLID 29585 - Audit the new location
			if (!bNewCharge) {
				if (!m_bLocationAudited) {
					var = rs->Fields->Item["LocationID"]->Value;
					long nOldLocationID = AdoFldLong(rs, "LocationID"); //Doesn't allow NULL
					if (nOldLocationID != LocationID) {
						CString strOldLocationName = AdoFldString(rs, "LocationName"); //Doesn't allow NULL.

						if (AuditID == -1)
							AuditID = BeginNewAuditEvent();
						AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiBillLocation : aeiQuoteLocation, ChargeID, strOldLocationName, strLocationName, aepMedium);
					}
					m_bLocationAudited = true;
				}
			}

			// Date
			var = m_billingItems[i]->Date;			// Date
			// Remove the time from the date
			COleDateTime datetime;
			datetime = var.date;
			date.SetDate(datetime.GetYear(), datetime.GetMonth(), datetime.GetDay());
			strDate = FormatDateTimeForSql(date, dtoDate);
			dtDateNoTime = AsDateNoTime(date);

			if (!bNewCharge) {
				var = rs->Fields->Item["Date"]->Value;

				if (var.vt != VT_NULL && FormatDateTimeForSql(COleDateTime(var.date), dtoDate) != strDate) {
					//set the values for ChargeRespDetail updating

					// (j.jones 2008-05-02 16:01) - PLID 27275 - track that the date changed
					bDateChanged = TRUE;

					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					//TES 10/4/2010 - PLID 29623 - Need to format for interface, not for SQL.
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeLineDate, ChargeID, FormatDateTimeForInterface(COleDateTime(var.date), NULL, dtoDate), FormatDateTimeForInterface(date, NULL, dtoDate), aepMedium);
				}
			}

			// ServiceDateTo
			var = m_billingItems[i]->ServiceDateTo;		// ServiceDateTo
			// Remove the time from the date
			COleDateTime datetimeto, servicedateto;
			datetimeto = var.date;
			servicedateto.SetDate(datetimeto.GetYear(), datetimeto.GetMonth(), datetimeto.GetDay());
			strServiceDateTo = FormatDateTimeForSql(servicedateto, dtoDate);

			if (!bNewCharge) {
				var = rs->Fields->Item["ServiceDateTo"]->Value;

				if (var.vt != VT_NULL && FormatDateTimeForSql(COleDateTime(var.date), dtoDate) != strServiceDateTo) {
					//set the values for ChargeRespDetail updating

					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					//TES 10/4/2010 - PLID 29623 - Need to format for interface, not for SQL.
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeServiceDateTo, ChargeID, FormatDateTimeForInterface(COleDateTime(var.date), NULL, dtoDate), FormatDateTimeForInterface(datetimeto, NULL, dtoDate), aepMedium);
				}
			}

			// InputDate
			dtNewInputDate = VarDateTime(m_billingItems[i]->InputDate);			// Input Date

			if (!bNewCharge) {
				var = rs->Fields->Item["InputDate"]->Value;

				if (var.vt != VT_NULL && FormatDateTimeForSql(COleDateTime(var.date), dtoDateTime) != FormatDateTimeForSql(dtNewInputDate, dtoDateTime)) {
					//set the values for ChargeRespDetail updating

					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					//TES 10/4/2010 - PLID 29623 - Need to format for interface, not for SQL.
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeInputDate, ChargeID, FormatDateTimeForInterface(COleDateTime(var.date), NULL, dtoDateTime), FormatDateTimeForInterface(dtNewInputDate, NULL, dtoDateTime), aepHigh, aetChanged);
				}
			}

			var = m_billingItems[i]->LineID;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				LineID = -1;
			else
				LineID = var.lVal;

			var = m_billingItems[i]->ServiceID;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				ServiceID = -1;
			else
				ServiceID = var.lVal;

			var = m_billingItems[i]->CPTCode;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				CPTCode = "";
			else
				CPTCode = CString(var.bstrVal);

			// (s.dhole 2011-05-24 16:37) - PLID 46358 Audit Service code changes
			if (!bNewCharge && m_EntryType == 1) {
				long nOldServiceID = AdoFldLong(rs, "ServiceId"); //Doesn't allow NULL
				if (ServiceID != nOldServiceID) {
					CString strOldCPTCode = AdoFldString(rs, "ItemCode"); //Doesn't allow NULL.

					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeServiceCode, ChargeID, strOldCPTCode, CPTCode, aepHigh);
				}
			}

			var = m_billingItems[i]->TypeOfService;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				TOS = "";
			else
				TOS = CString(var.bstrVal);

			var = m_billingItems[i]->CPTSubCode;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				CPTSubCode = "";
			else
				CPTSubCode = CString(var.bstrVal);
			
			var = m_billingItems[i]->CPTCategoryID;
			// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
			if (var.vt == VT_I4 && VarLong(var, 0) > 0) {
				varCategoryID = var;
			}
			// (s.tullis 2015-03-24 09:28) - PLID 64973 -  Audit Changed Charge Category
			if (!bNewCharge) {
				long nNewCatID = VarLong(varCategoryID, -1);
				long nOldCatID = AdoFldLong(rs, "Category", -1);
				CString strNewCat = "";
				CString strOldCat = AdoFldString(rs, "CategoryName", ""); 
				if (nNewCatID != nOldCatID) {
					if (nNewCatID != -1){
						_RecordsetPtr rsCat = CreateParamRecordset("Select Name FROM  CategoriesT Where ID = {INT} ", VarLong(varCategoryID, -1));
						if (!rsCat->eof){
							strNewCat =  AdoFldString(rsCat, "Name", "");
						}
						else{
							ASSERT(FALSE);
						}
					}
					else{
						strNewCat = "";
					}
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeCategory, ChargeID, strOldCat, strNewCat, aepHigh);
				}
			}

			var = m_billingItems[i]->CPTSubCategoryID;
			// (j.jones 2015-03-18 14:24) - PLID 64974 - SubCategory is now nullable
			if (var.vt == VT_I4 && VarLong(var, 0) > 0) {
				varSubCategoryID = var;
			}

			// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes			
			var = m_billingItems[i]->NDCCode;
			if (var.vt == VT_BSTR) {
				strNDCCode = VarString(var, "");
			}

			// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
			var = m_billingItems[i]->IsEmergency;
			if (var.vt == VT_I4) {
				eIsEmergency = (ChargeIsEmergencyType)VarLong(var);
			}

			// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
			var = m_billingItems[i]->DrugUnitPrice;
			if (var.vt == VT_CY) {
				cyDrugUnitPrice = VarCurrency(var);
			}

			var = m_billingItems[i]->DrugUnitType;
			if (var.vt == VT_BSTR) {
				strDrugUnitType = VarString(var);
			}

			var = m_billingItems[i]->DrugUnitQuantity;
			if (var.vt == VT_R8) {
				dblDrugUnitQuantity = VarDouble(var);
			}

			var = m_billingItems[i]->PrescriptionNumber;
			if (var.vt == VT_BSTR) {
				strPrescriptionNumber = VarString(var);
			}

			// (j.jones 2008-06-04 15:00) - PLID 30256 - added EMRChargeID
			var = m_billingItems[i]->EMRChargeID;
			if (var.vt == VT_I4) {
				nEMRChargeID = VarLong(var, -1);
				// (j.jones 2012-01-17 15:12) - PLID 47537 - for Bills only, we save in ChargesT,
				// although we will only save it on new charges, it won't change after that
				if (m_EntryType == 1 && nEMRChargeID != -1) {
					varEMRChargeID = (long)nEMRChargeID;
				}
			}

			// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
			long nAppointmentID = -1;
			var = m_billingItems[i]->AppointmentID;
			if (var.vt == VT_I4) {
				nAppointmentID = VarLong(var, -1);
				if (nAppointmentID != -1) {
					varAppointmentID = (long)nAppointmentID;
				}
			}

			//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
			var = m_billingItems[i]->GlassesOrderServiceID;
			if (var.vt == VT_I4) {
				nGlassesOrderServiceID = VarLong(var, -1);
				if (nGlassesOrderServiceID != -1) {
					varGlassesOrderServiceID = (long)nGlassesOrderServiceID;
				}
			}

			// (j.gruber 2009-10-19 12:46) - PLID 35947 - added allowable
			// (j.jones 2010-09-01 12:25) - PLID 40330 - only save the allowable on quotes,
			// force to zero for bills (previous logic, just now explicitly enforced)
			if (m_EntryType == 2) {
				var = m_billingItems[i]->UnitAllowable;
				if (var.vt == VT_CY) {
					cyAllowable = VarCurrency(var, COleCurrency(0, 0));
				}
			}
			else {
				cyAllowable = COleCurrency(0, 0);
			}

			CString strNewModValue = "";

			var = m_billingItems[i]->Modifier1;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY || CString(var.bstrVal) == "-1") {
				varMod1 = g_cvarNull;
				varMultiplier1 = g_cvarNull;
				strNewModValue = "";
			}
			else {
				varMod1 = (LPCTSTR)VarString(var);

				strNewModValue = CString(var.bstrVal);

				//get the multiplier
				var = m_billingItems[i]->Multiplier1;
				if (var.vt == VT_R8) {
					varMultiplier1 = var;
				}
				else {
					varMultiplier1 = g_cvarNull;
				}
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["CPTModifier"]->Value;
				CString strOldModValue = VarString(var, ""); // (a.walling 2007-05-31 14:23) - PLID 26198
				// The first half of the conditional checked for VT_NULL before trying to create a CString from the
				// bstrVal. However, since it may be ORed with the second half, then we will get into this block of
				// code with a possibly NULL variant. Then when the CString is created from the variant for auditing,
				// it may be NULL and hence the bstrVal is undefined. Then we may end up with an access violation.
				if ((var.vt != VT_NULL && strOldModValue != strNewModValue)
					|| (var.vt == VT_NULL && strNewModValue != "")) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeModifier, ChargeID, strOldModValue, strNewModValue, aepMedium);
				}
			}

			var = m_billingItems[i]->Modifier2;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY || CString(var.bstrVal) == "-1") {
				varMod2 = g_cvarNull;
				varMultiplier2 = g_cvarNull;
				strNewModValue = "";
			}
			else {
				varMod2 = (LPCTSTR)VarString(var);

				strNewModValue = CString(var.bstrVal);

				//get the multiplier
				var = m_billingItems[i]->Multiplier2;
				if (var.vt == VT_R8) {
					varMultiplier2 = var;
				}
				else {
					varMultiplier2 = g_cvarNull;
				}
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["CPTModifier2"]->Value;
				CString strOldModValue = VarString(var, ""); // (a.walling 2007-05-31 14:23) - PLID 26198
				if ((var.vt != VT_NULL && strOldModValue != strNewModValue)
					|| (var.vt == VT_NULL && strNewModValue != "")) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeModifier2, ChargeID, strOldModValue, strNewModValue, aepMedium);
				}
			}

			var = m_billingItems[i]->Modifier3;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY || CString(var.bstrVal) == "-1") {
				varMod3 = g_cvarNull;
				varMultiplier3 = g_cvarNull;
				strNewModValue = "";
			}
			else {
				varMod3 = (LPCTSTR)VarString(var);

				strNewModValue = CString(var.bstrVal);

				//get the multiplier
				var = m_billingItems[i]->Multiplier3;
				if (var.vt == VT_R8) {
					varMultiplier3 = var;
				}
				else {
					varMultiplier3 = g_cvarNull;
				}
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["CPTModifier3"]->Value;
				CString strOldModValue = VarString(var, ""); // (a.walling 2007-05-31 14:23) - PLID 26198
				if ((var.vt != VT_NULL && strOldModValue != strNewModValue)
					|| (var.vt == VT_NULL && strNewModValue != "")) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeModifier3, ChargeID, strOldModValue, strNewModValue, aepMedium);
				}
			}

			var = m_billingItems[i]->Modifier4;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY || CString(var.bstrVal) == "-1") {
				varMod4 = g_cvarNull;
				varMultiplier4 = g_cvarNull;
				strNewModValue = "";
			}
			else {
				varMod4 = (LPCTSTR)VarString(var);

				strNewModValue = CString(var.bstrVal);

				//get the multiplier
				var = m_billingItems[i]->Multiplier4;
				if (var.vt == VT_R8) {
					varMultiplier4 = var;
				}
				else {
					varMultiplier4 = g_cvarNull;
				}
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["CPTModifier4"]->Value;
				CString strOldModValue = VarString(var, ""); // (a.walling 2007-05-31 14:23) - PLID 26198
				if ((var.vt != VT_NULL && strOldModValue != strNewModValue)
					|| (var.vt == VT_NULL && strNewModValue != "")) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeModifier4, ChargeID, strOldModValue, strNewModValue, aepMedium);
				}
			}

			// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
			dblCalls = VarDouble(m_billingItems[i]->Calls, 0.0);

			if (!bNewCharge) {

				double dblOldCalls = VarDouble(rs->Fields->Item["Calls"]->Value, 0.0);

				if (dblOldCalls != dblCalls) {
					CString strOldValue;
					strOldValue.Format("%g", dblOldCalls);
					CString strNewValue;
					strNewValue.Format("%g", dblCalls);
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeCalls : aeiQuoteChargeCalls, ChargeID, strOldValue, strNewValue, aepMedium);
				}
			}

			// (d.singleton 2012-05-21 09:39) - PLID 48152 - added skill column alberta only
			strSkill = VarString(m_billingItems[i]->Skill, "");

			if (!bNewCharge) {
				CString strOldSkill = VarString(rs->Fields->Item["SkillCode"]->Value, "");
				if (strOldSkill.CompareNoCase(strSkill) != 0) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiSkillCode : aeiSkillCodeQuote, ChargeID, strOldSkill, strSkill, aepMedium);
				}
			}

			// (j.gruber 2014-02-19 10:23) - PLID 60893 - not needed here anymore
			AuditAndGenerateSaveStringForWhichCodes(bNewCharge, ChargeID, GetBillID(), m_billingItems[i]->whichCodes, sqlWhichCodesSave);

			var = m_billingItems[i]->Provider;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				nDocID = -1;
			else
				nDocID = var.lVal;

			if (!bNewCharge) {
				var = rs->Fields->Item["DoctorsProviders"]->Value;

				// (c.haag 2016-05-10 13:00) - NX-100403 - I don't think it's possible to change an existing charge provider
				// to NULL, but just in case, I changed the existing logic so that var is never null
				if (var.vt == VT_NULL || var.vt == VT_EMPTY)
					var = -1L;

				if (var.lVal != nDocID) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					oldVal = GetExistingContactName(var.lVal);
					newVal = GetExistingContactName(nDocID);
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeProvider : aeiQuoteChargeProvider, ChargeID, oldVal, newVal, aepHigh);
				}
			}

			//bills only
			if (m_EntryType == 1) {

				// (j.jones 2010-11-09 10:12) - PLID 31392 - audit ClaimProviderID
				_variant_t varSelClaimProv = m_billingItems[i]->ClaimProvider;
				long nClaimProviderID = -1;
				varClaimProviderID = g_cvarNull;

				if (varSelClaimProv.vt == VT_NULL || varSelClaimProv.vt == VT_EMPTY) {
					nClaimProviderID = -1;
				}
				else {
					nClaimProviderID = VarLong(varSelClaimProv, -1);
					if (nClaimProviderID != -1) {
						varClaimProviderID = (long)nClaimProviderID;
					}
				}

				// (j.jones 2014-04-23 08:40) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				_variant_t varSelReferringProv = m_billingItems[i]->ReferringProviderID;
				long nReferringProviderID = -1;
				varReferringProviderID = g_cvarNull;

				if (varSelReferringProv.vt == VT_NULL || varSelReferringProv.vt == VT_EMPTY) {
					nReferringProviderID = -1;
				}
				else {
					nReferringProviderID = VarLong(varSelReferringProv, -1);
					if (nReferringProviderID != -1) {
						varReferringProviderID = (long)nReferringProviderID;
					}
				}

				_variant_t varSelOrderingProv = m_billingItems[i]->OrderingProviderID;
				long nOrderingProviderID = -1;
				varOrderingProviderID = g_cvarNull;

				if (varSelOrderingProv.vt == VT_NULL || varSelOrderingProv.vt == VT_EMPTY) {
					nOrderingProviderID = -1;
				}
				else {
					nOrderingProviderID = VarLong(varSelOrderingProv, -1);
					if (nOrderingProviderID != -1) {
						varOrderingProviderID = (long)nOrderingProviderID;
					}
				}

				_variant_t varSelSupervisingProv = m_billingItems[i]->SupervisingProviderID;
				long nSupervisingProviderID = -1;
				varSupervisingProviderID = g_cvarNull;

				if (varSelSupervisingProv.vt == VT_NULL || varSelSupervisingProv.vt == VT_EMPTY) {
					nSupervisingProviderID = -1;
				}
				else {
					nSupervisingProviderID = VarLong(varSelSupervisingProv, -1);
					if (nSupervisingProviderID != -1) {
						varSupervisingProviderID = (long)nSupervisingProviderID;
					}
				}

				if (!bNewCharge) {

					var = rs->Fields->Item["ClaimProviderID"]->Value;
					long nOldClaimProviderID = VarLong(var, -1);
					if (nOldClaimProviderID != nClaimProviderID) {
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						if (nOldClaimProviderID == -1) {
							oldVal = "<Use Default Claim Provider>";
						}
						else {
							oldVal = GetExistingContactName(nOldClaimProviderID);
						}

						if (nClaimProviderID == -1) {
							newVal = "<Use Default Claim Provider>";
						}
						else {
							newVal = GetExistingContactName(nClaimProviderID);
						}

						CString strOldValue;
						strOldValue.Format("%s (%s charge, %s)", oldVal, FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
						AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeClaimProvider, ChargeID, strOldValue, newVal, aepHigh);
					}

					// (j.jones 2014-04-23 11:11) - PLID 61836 - added auditing for ReferringProviderID, OrderingProviderID, SupervisingProviderID
					var = rs->Fields->Item["ReferringProviderID"]->Value;
					long nOldReferringProviderID = VarLong(var, -1);
					if (nOldReferringProviderID != nReferringProviderID) {
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						if (nOldReferringProviderID == -1) {
							oldVal = "<None>";
						}
						else {
							oldVal = GetExistingContactName(nOldReferringProviderID);
						}

						if (nReferringProviderID == -1) {
							newVal = "<None>";
						}
						else {
							newVal = GetExistingContactName(nReferringProviderID);
						}

						CString strOldValue;
						strOldValue.Format("%s (%s charge, %s)", oldVal, FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
						AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeReferringProvider, ChargeID, strOldValue, newVal, aepMedium);
					}

					var = rs->Fields->Item["OrderingProviderID"]->Value;
					long nOldOrderingProviderID = VarLong(var, -1);
					if (nOldOrderingProviderID != nOrderingProviderID) {
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						if (nOldOrderingProviderID == -1) {
							oldVal = "<None>";
						}
						else {
							oldVal = GetExistingContactName(nOldOrderingProviderID);
						}

						if (nOrderingProviderID == -1) {
							newVal = "<None>";
						}
						else {
							newVal = GetExistingContactName(nOrderingProviderID);
						}

						CString strOldValue;
						strOldValue.Format("%s (%s charge, %s)", oldVal, FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
						AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeOrderingProvider, ChargeID, strOldValue, newVal, aepMedium);
					}

					var = rs->Fields->Item["SupervisingProviderID"]->Value;
					long nOldSupervisingProviderID = VarLong(var, -1);
					if (nOldSupervisingProviderID != nSupervisingProviderID) {
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						if (nOldSupervisingProviderID == -1) {
							oldVal = "<None>";
						}
						else {
							oldVal = GetExistingContactName(nOldSupervisingProviderID);
						}

						if (nSupervisingProviderID == -1) {
							newVal = "<None>";
						}
						else {
							newVal = GetExistingContactName(nSupervisingProviderID);
						}

						CString strOldValue;
						strOldValue.Format("%s (%s charge, %s)", oldVal, FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
						AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeSupervisingProvider, ChargeID, strOldValue, newVal, aepMedium);
					}
				}
			}

			varPatCoordID = g_cvarNull;
			var = m_billingItems[i]->PatCoordinator;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY) {
				varPatCoordID = g_cvarNull;
			}
			else {
				varPatCoordID = VarLong(var);
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["PatCoordID"]->Value;
				// (b.cardillo 2011-08-03 17:07) - PLID 44806 - Audit <no pat coord> as "" instead of throwing an exception
				long nNewPatCoordID = VarLong(varPatCoordID, -1);
				if (var.vt != VT_NULL && var.lVal != nNewPatCoordID) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					oldVal = GetExistingContactName(var.lVal);
					newVal = ((nNewPatCoordID != -1) ? GetExistingContactName(nNewPatCoordID) : "");
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargePatCoord : aeiQuoteChargePatientCoor, ChargeID, oldVal, newVal, aepHigh);
				}
			}

			var = m_billingItems[i]->Quantity;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				dblQty = 0.0;
			else {
				if (var.vt == VT_R8)
					dblQty = var.dblVal;
				else if (var.vt == VT_I4)
					dblQty = (double)var.lVal;
				else if (var.vt == VT_I2 || var.vt == VT_UI1)
					dblQty = (double)VarByte(var);
			}

			// (j.jones 2012-05-09 17:22) - PLID 50269 - fail if this is negative, it should be impossible unless voided
			if (dblQty < 0 && !VarBool(m_billingItems[i]->IsVoidingCharge, FALSE)) {
				ThrowNxException("Negative Quantity found on a charge!");
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["Quantity"]->Value;
				if (var.vt != VT_NULL && var.dblVal != dblQty) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					oldVal.Format("%g", var.dblVal);
					newVal.Format("%g", dblQty);
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeQty : aeiQuoteChargeQuantity, ChargeID, oldVal, newVal, aepHigh);

					// (j.jones 2007-11-27 13:01) - PLID 28198 - track if the quantity changed, for package purposes later on
					bQuantityChanged = TRUE;
				}
			}

			var = m_billingItems[i]->PackageQtyRemaining;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				PackageQtyRemaining = 0.0;
			else {
				if (var.vt == VT_R8)
					PackageQtyRemaining = var.dblVal;
				else if (var.vt == VT_I4)
					PackageQtyRemaining = (double)var.lVal;
				else if (var.vt == VT_I2 || var.vt == VT_UI1)
					PackageQtyRemaining = (double)VarByte(var);
			}

			// (j.jones 2012-05-09 17:22) - PLID 50269 - fail if this is negative, it should be impossible unless voided
			if (PackageQtyRemaining < 0 && !VarBool(m_billingItems[i]->IsVoidingCharge, FALSE)) {
				ThrowNxException("Negative PackageQtyRemaining found on a charge!");
			}

			if (!bNewCharge && m_EntryType == 2) {
				var = rs->Fields->Item["PackageQtyRemaining"]->Value;
				if (var.vt != VT_NULL && var.dblVal != PackageQtyRemaining) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					oldVal.Format("%g", var.dblVal);
					newVal.Format("%g", PackageQtyRemaining);
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiQuoteChargePackageQtyRemaining, ChargeID, oldVal, newVal, aepHigh);

					// (j.jones 2007-11-27 13:01) - PLID 28198 - track if the quantity changed, for package purposes later on
					bPackageQuantityRemChanged = TRUE;
				}
			}

			// (j.jones 2009-12-22 17:04) - PLID 32587 - added original quantity
			var = m_billingItems[i]->OriginalPackageQtyRemaining;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				OriginalPackageQtyRemaining = 0.0;
			else {
				if (var.vt == VT_R8)
					OriginalPackageQtyRemaining = var.dblVal;
				else if (var.vt == VT_I4)
					OriginalPackageQtyRemaining = (double)var.lVal;
				else if (var.vt == VT_I2 || var.vt == VT_UI1)
					OriginalPackageQtyRemaining = (double)VarByte(var);
			}

			// (j.jones 2012-05-09 17:22) - PLID 50269 - fail if this is negative, it should be impossible unless voided
			if (OriginalPackageQtyRemaining < 0 && !VarBool(m_billingItems[i]->IsVoidingCharge, FALSE)) {
				ThrowNxException("Negative OriginalPackageQtyRemaining found on a charge!");
			}

			if (!bNewCharge && m_EntryType == 2) {
				var = rs->Fields->Item["OriginalPackageQtyRemaining"]->Value;
				if (var.vt != VT_NULL && var.dblVal != OriginalPackageQtyRemaining) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					oldVal.Format("%g", var.dblVal);
					newVal.Format("%g", OriginalPackageQtyRemaining);
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiQuoteChargeOriginalPackageQtyRemaining, ChargeID, oldVal, newVal, aepHigh);

					// (j.jones 2007-11-27 13:01) - PLID 28198 - track if the quantity changed, for package purposes later on
					bOriginalPackageQuantityRemChanged = TRUE;
				}
			}

			if (m_billingItems[i]->OthrUnitCost.vt == VT_NULL)
				m_billingItems[i]->OthrUnitCost = COleCurrency(0, 0);

			var = m_billingItems[i]->OthrUnitCost;
			if (var.vt == VT_NULL || var.vt == VT_EMPTY)
				OthCost = FormatCurrencyForSql(COleCurrency(0, 0));
			else
				OthCost = FormatCurrencyForSql(var.cyVal);

			if (!bNewCharge && m_EntryType == 2) {
				var = rs->Fields->Item["OthrBillFee"]->Value;
				if (var.vt != VT_NULL && FormatCurrencyForSql(COleCurrency(var.cyVal)) != OthCost) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeBillFee : aeiQuoteChargeOutsideCharges, ChargeID, FormatCurrencyForInterface(COleCurrency(var.cyVal)), FormatCurrencyForInterface(ParseCurrencyFromSql(OthCost)), aepMedium);
				}
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["Amount"]->Value;
				if (var.vt != VT_NULL && FormatCurrencyForSql(COleCurrency(var.cyVal)) != FormatCurrencyForSql(m_billingItems[i]->UnitCost.cyVal)) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeLineAmount : aeiQuoteChargeAmount, ChargeID, FormatCurrencyForInterface(COleCurrency(var.cyVal)), FormatCurrencyForInterface(m_billingItems[i]->UnitCost.cyVal), aepHigh);
				}
			}

			var = m_billingItems[i]->Description;	// Item description
			strItemDescription = CString(var.bstrVal);
			if (strItemDescription.GetLength() == 0) {
				strItemDescription = "(No description)";
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["Description"]->Value;
				if (var.vt != VT_NULL && CString(var.bstrVal) != strItemDescription) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeLineDescription : aeiQuoteChargeDescription, ChargeID, CString(var.bstrVal), strItemDescription, aepLow);
				}
			}

			// Convert the rate from 'Visible rate' to 'Scott rate'
			var = m_billingItems[i]->TaxRate1;	// Tax (double)		
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				if (var.vt == VT_R8)
					dblTax = var.dblVal;
				else
					dblTax = 0.0;
				if (dblTax != 0.0)
					dblTax /= 100.0;
			}
			else {
				dblTax = 0.0;
			}
			dblTax += 1.0;
			strTaxRate1.Format("%0.09g", dblTax);

			CString testVal;

			if (!bNewCharge) {
				var = rs->Fields->Item["TaxRate"]->Value;
				if (var.vt != VT_NULL) {
					testVal.Format("%0.09g", var.dblVal);
					oldVal.Format("%0.04f%%", ((var.dblVal - 1.0) * 100.0));
				}
			}

			if (!bNewCharge && var.vt != VT_NULL && testVal != strTaxRate1) {
				if (AuditID == -1)
					AuditID = BeginNewAuditEvent();
				newVal.Format("%0.04f%%", ((dblTax - 1.0) * 100.0));
				AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeTax : aeiQuoteChargeTaxRate, ChargeID, oldVal, newVal, aepHigh);
			}

			// Convert the rate from 'Visible rate' to 'Scott rate'
			var = m_billingItems[i]->TaxRate2;	// Tax (double)		
			if (var.vt != VT_NULL && var.vt != VT_EMPTY) {
				if (var.vt == VT_R8)
					dblTax = var.dblVal;
				else
					dblTax = 0.0;
				if (dblTax != 0.0)
					dblTax /= 100.0;
			}
			else {
				dblTax = 0.0;
			}
			dblTax += 1.0;
			strTaxRate2.Format("%0.09g", dblTax);

			testVal = "";

			if (!bNewCharge) {
				var = rs->Fields->Item["TaxRate2"]->Value;
				if (var.vt != VT_NULL) {
					testVal.Format("%0.09g", var.dblVal);
					oldVal.Format("%0.04f%%", ((var.dblVal - 1.0) * 100.0));
				}
			}

			if (!bNewCharge && var.vt != VT_NULL && testVal != strTaxRate2) {
				if (AuditID == -1)
					AuditID = BeginNewAuditEvent();
				newVal.Format("%0.04f%%", ((dblTax - 1.0) * 100.0));
				AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeTax2 : aeiQuoteChargeTaxRate2, ChargeID, oldVal, newVal, aepHigh);
			}

			//Batched status			
			var = m_billingItems[i]->Batched;
			if (var.vt == VT_BOOL && !VarBool(var, TRUE)) {
				bBatched = FALSE;
			}

			// (r.gonet 07/07/2014) - PLID 62569 - On Hold status
			var = m_billingItems[i]->OnHold;
			if (var.vt == VT_BOOL && VarBool(var, FALSE)) {
				bOnHold = TRUE;
			}

			// Place of service DESIGNATION
			if (m_DesignationCombo->GetCurSel() == -1)
				nDesignation = -1;
			else {
				var = m_DesignationCombo->GetValue(m_DesignationCombo->GetCurSel(), posdcID);
				if (var.vt != VT_I4)
					nDesignation = -1;
				else
					nDesignation = var.lVal;
			}

			if (!bNewCharge) {
				var = rs->Fields->Item["ServiceLocationID"]->Value;
				if (var.vt != VT_NULL && var.lVal != nDesignation) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsOldPOS = CreateParamRecordset("SELECT PlaceCodes FROM PlaceOfServiceCodesT WHERE ID = {INT}", var.lVal);
					CString strOldVal = "", strNewVal = "";
					if (!rsOldPOS->eof) {
						strOldVal = AdoFldString(rsOldPOS, "PlaceCodes", "");
					}
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsNewPOS = CreateParamRecordset("SELECT PlaceCodes FROM PlaceOfServiceCodesT WHERE ID = {INT}", nDesignation);
					if (!rsNewPOS->eof) {
						strNewVal = AdoFldString(rsNewPOS, "PlaceCodes", "");
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiChargeServLoc : aeiQuotePOSDesignation, ChargeID, strNewVal, strOldVal, aepMedium);
				}
			}

			if (nDesignation == -1) {
				varPOSToSave = g_cvarNull;
			}
			else {
				varPOSToSave = (long)nDesignation;
			}

			// (j.gruber 2009-10-19 12:43) - PLID 35947 - allowable
			//only audit for a quote
			if (!bNewCharge && m_EntryType == 2) {
				var = rs->Fields->Item["Allowable"]->Value;

				if (var.vt != VT_NULL && VarCurrency(var, COleCurrency(0, 0)) != cyAllowable) {
					//set the values for updating

					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiQuoteChargeAllowable, ChargeID, FormatCurrencyForInterface(VarCurrency(var, COleCurrency(0, 0))), FormatCurrencyForInterface(cyAllowable), aepMedium, aetChanged);
				}
			}

			// (j.gruber 2009-03-06 10:14) - PLID 33351 - take out discount fields		
			AuditAndGenerateSaveStringForDiscounts(bNewCharge, m_billingItems[i], strDiscountSaveString);

			// (a.walling 2007-05-24 11:20) - PLID 26114
			// Reward points used
			var = m_billingItems[i]->PointsUsed;
			if (var.vt == VT_CY) {
				cyPointsUsed = VarCurrency(var);
			} else {
				cyPointsUsed.SetCurrency(0, 0);	
			}

			cyTotalCharge = (m_billingItems[i]->LineTotal.vt == VT_EMPTY) ? COleCurrency(0,0) : VarCurrency(m_billingItems[i]->LineTotal, COleCurrency(0,0));

			// (r.gonet 2015-07-10) - PLID 65279 - Gift certificate number for auditing.
			CString strGiftCertificateNumber;
			CString strGiftCertName;
			long nGiftCertReceivedBy = -1;
			//DRT 4/2/2004 - Gift certificate ID and prompting.  If the GiftID field is null, this is
			//	not a gift certificate.  If it is not null, it is a gift certificate.  If the ID is -1, 
			//We have 2 types of GCs -- Rechargeable and New. 
			int nGiftType = 0;		//0 = new, 1 = rechargeable.
			var = m_billingItems[i]->GiftID;
			if (var.vt == VT_I4) {
				long nGiftID = VarLong(var);
				
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr prsGift = CreateParamRecordset("SELECT IsRecharge FROM GCTypesT WHERE ServiceID = {INT}", ServiceID);
				if (!prsGift->eof) {
					_variant_t var = prsGift->Fields->Item["IsRecharge"]->Value;
					nGiftType = VarByte(var, 0);
				}
				else
					//if we get here then our service ID is invalid, and we're really screwed
					ASSERT(FALSE);
				// (r.gonet 2015-03-27 18:58) - PLID 65279 - Close the recordset.
				prsGift->Close();

				if (nGiftID == -1) { // no cert has been chosen
					if (nGiftType == 0) {
						//new GC
						// (j.jones 2015-05-11 16:57) - PLID 65714 - added GCCreationStyle
						CGCEntryDlg dlg(this, GCCreationStyle::eCreateNewGC_FromBill);
						dlg.SetProvider(nDocID);
						// (a.walling 2008-05-05 13:00) - PLID 29897 - Need to set it to the bill's patient
						// (r.gonet 2015-04-29 10:00) - PLID 65327 - Renamed from SetPatient to SetPurchasedByPatientID
						dlg.SetPurchasedByPatientID(m_nPatientID);
						dlg.SetService(ServiceID);
						// (r.gonet 2015-03-25 09:28) - PLID 65276 - Preset the cert's Value field and the Price field with the unit cost.
						dlg.SetValue(m_billingItems[i]->Value.cyVal);
						dlg.SetPrice(m_billingItems[i]->UnitCost.cyVal);
						dlg.SetPurchaseDate(VarDateTime(m_billingItems[i]->Date));

						if (dlg.DoModal() == IDOK) {
							m_billingItems[i]->GiftID = (long)dlg.m_nID;

							varGiftID = (long)dlg.m_nID;
							// (r.gonet 2015-07-10) - PLID 65279 - Get the certificate number for auditing.
							strGiftCertificateNumber = dlg.m_strCertNumber;

							//DRT TODO:  This report is ugly.  Very ugly.  We're operating on the current
							//	assumption that most people are going to use pre-printed GC's.  We need
							//	a preference to show this automatically, but for now, it's commented out.
							//dlg.ViewReport();
						}
						else {
							//abort the saving
							// (j.jones 2007-02-21 11:56) - PLID 24835 - we previously returned SCR_NOT_SAVED, which is invalid here
							return FALSE;
						}
					}
					else if (nGiftType == 1) {
						//recharging a GC
						CGCRechargeDlg dlg(this);
						// (a.walling 2008-05-05 13:00) - PLID 29897 - Need to set it to the bill's patient
						dlg.SetPatient(m_nPatientID);


						if (dlg.DoModal() == IDOK) {
							m_billingItems[i]->GiftID = (long)dlg.m_nID;

							varGiftID = (long)dlg.m_nID;
							// (r.gonet 2015-07-10) - PLID 65279 - Get the certificate number for auditing.
							strGiftCertificateNumber = dlg.m_strCertNumber;

							if (dlg.m_bIsExpired) { // a.walling 04/13/06 update the expiration date when recharging (if expired)
								try {
									CString strUpdateGiftC;

									long nGiftPeriod;

									// get default expiration period for the category
									// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
									_RecordsetPtr prs = CreateParamRecordset("SELECT DefaultDays FROM GiftCertificatesT INNER JOIN GCTypesT ON DefaultTypeID = GCTypesT.ServiceID WHERE ID = {INT} AND DefaultDays Is Not Null", dlg.m_nID);
									if (!prs->eof) {
										nGiftPeriod = AdoFldLong(prs, "DefaultDays", 365); // in days
									}
									else {
										/* TODO: Custom extension dialog
										nGiftPeriod = dlg.m_nNumDays;


										*/
										nGiftPeriod = 365;
									}

									COleDateTime dtNewExp = m_billingItems[i]->Date;
									COleDateTimeSpan dtsExpPeriod;
									dtsExpPeriod.SetDateTimeSpan(nGiftPeriod, 0, 0, 0);
									dtNewExp += dtsExpPeriod;

									// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
									ExecuteParamSql("UPDATE GiftCertificatesT SET ExpDate = {OLEDATETIME} WHERE ID = {INT}", AsDateNoTime(dtNewExp), dlg.m_nID); // add to query
								} NxCatchAll("BillingDlg::ApplyChargeToBill - RechargeExp");
							}
						}
						else {
							//abort the saving
							// (j.jones 2007-02-21 11:56) - PLID 24835 - we previously returned SCR_NOT_SAVED, which is invalid here
							return FALSE;
						}
					}
				}
				else { // a GC is already chosen
					varGiftID = (long)nGiftID;
				}

				if (!bNewCharge) {
					// (r.gonet 2015-03-27 18:58) - PLID 65279 - Get the old value and other properites of the gift certificate.
					// Note that this works for both a standard gift certificate and a recharge gift certificate. The recharge gift
					// certificate will get the gift certificate number and received by name of the original but its own service name. 
					// This should be a couple of quick index seeks.
					_RecordsetPtr prsGiftCertificateProperties = CreateParamRecordset(R"(
SELECT OriginalGiftCertificatesT.GiftID, ServiceT.Name, OriginalGiftCertificatesT.ReceivedBy
FROM ServiceT
INNER JOIN GCTypesT ON ServiceT.ID = GCTypesT.ServiceID
INNER JOIN GiftCertificatesT OriginalGiftCertificatesT ON OriginalGiftCertificatesT.ID = {INT}
WHERE ServiceT.ID = {INT}
)",
					VarLong(varGiftID, -1), VarLong(m_billingItems[i]->ServiceID, -1));
					if (!prsGiftCertificateProperties->eof) {
						// (r.gonet 2015-07-10) - PLID 65279 - Get the certificate number for auditing.
						strGiftCertificateNumber = AdoFldString(prsGiftCertificateProperties->Fields, "GiftID", "");
						strGiftCertName = AdoFldString(prsGiftCertificateProperties->Fields, "Name");
						nGiftCertReceivedBy = AdoFldLong(prsGiftCertificateProperties->Fields, "ReceivedBy", -1);
					} else {
						// (r.gonet 2015-03-27 18:58) - PLID 65279 - There is no gift certificate but there is a gift ID?
						strGiftCertificateNumber = "";
						strGiftCertName = "";
						nGiftCertReceivedBy = -1;
					}
					prsGiftCertificateProperties->Close();
					// (r.gonet 2015-03-27 18:58) - PLID 65279 - Get the old gift certificate value of the line item.
					varOldGCValue = AdoFldVar(rs, "GCValue");
				} else {
					// (r.gonet 2015-03-27 18:58) - PLID 65279 - New gift certificate line items won't have a past version, so set the old properties to defaults.
					strGiftCertName = "";
					nGiftCertReceivedBy = -1;
					varOldGCValue = g_cvarNull;
				}
				// (r.gonet 2015-03-27 18:58) - PLID 65279 - Grab the line item's current value.
				varNewGCValue = m_billingItems[i]->Value;
			}
			else {
				//NULL type, we aren't using GC's
				varGiftID = g_cvarNull;
			}

			// (j.jones 2008-05-28 14:53) - PLID 30175 - audited ChargesT.NDCCode
			if (!bNewCharge && m_EntryType == 1) {
				CString strOldCode = AdoFldString(rs, "NDCCode", "");
				if (strOldCode != strNDCCode) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeNDCCode, ChargeID, strOldCode.IsEmpty() ? "<None>" : strOldCode, strNDCCode.IsEmpty() ? "<None>" : strNDCCode, aepMedium, aetChanged);
				}

				// (j.jones 2009-08-13 12:05) - PLID 35206 - added more drug fields to audit
				COleCurrency cyOldDrugUnitPrice = AdoFldCurrency(rs, "DrugUnitPrice");
				if (cyOldDrugUnitPrice != cyDrugUnitPrice) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeDrugUnitPrice, ChargeID, FormatCurrencyForInterface(cyOldDrugUnitPrice), FormatCurrencyForInterface(cyDrugUnitPrice), aepMedium, aetChanged);
				}

				CString strOldDrugUnitType = AdoFldString(rs, "DrugUnitTypeQual");
				if (strOldDrugUnitType != strDrugUnitType) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeDrugUnitTypeQual, ChargeID, strOldDrugUnitType.IsEmpty() ? "<None>" : strOldDrugUnitType, strDrugUnitType.IsEmpty() ? "<None>" : strDrugUnitType, aepMedium, aetChanged);
				}

				double dblOldDrugUnitQuantity = AdoFldDouble(rs, "DrugUnitQuantity");
				if (dblOldDrugUnitQuantity != dblDrugUnitQuantity) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeDrugUnitQuantity, ChargeID, AsString(dblOldDrugUnitQuantity), AsString(dblDrugUnitQuantity), aepMedium, aetChanged);
				}

				CString strOldPrescriptionNumber = AdoFldString(rs, "PrescriptionNumber");
				if (strOldPrescriptionNumber != strPrescriptionNumber) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargePrescriptionNumber, ChargeID, strOldPrescriptionNumber.IsEmpty() ? "<None>" : strOldPrescriptionNumber, strPrescriptionNumber.IsEmpty() ? "<None>" : strPrescriptionNumber, aepMedium, aetChanged);
				}

				// (j.jones 2010-04-08 11:55) - PLID 15224 - audit ChargesT.IsEmergency
				ChargeIsEmergencyType eOldIsEmergency = (ChargeIsEmergencyType)AdoFldLong(rs, "IsEmergency");
				if (eOldIsEmergency != eIsEmergency) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld, strNew;
					switch (eOldIsEmergency) {
					case cietBlank:
						strOld = "<Blank>";
						break;
					case cietNo:
						strOld = "No";
						break;
					case cietYes:
						strOld = "Yes";
						break;
					case cietUseDefault:
					default:
						strOld = "<Use Default Value>";
						break;
					}
					switch (eIsEmergency) {
					case cietBlank:
						strNew = "<Blank>";
						break;
					case cietNo:
						strNew = "No";
						break;
					case cietYes:
						strNew = "Yes";
						break;
					case cietUseDefault:
					default:
						strNew = "<Use Default Value>";
						break;
					}

					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeIsEmergency, ChargeID, strOld, strNew, aepMedium, aetChanged);
				}

				// (j.jones 2011-08-25 16:56) - PLID 44796 - audit the batched status
				BOOL bOldBatched = AdoFldBool(rs, "Batched");
				if (bOldBatched != bBatched) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOldValue;
					strOldValue.Format("%s (%s charge, %s)", bOldBatched ? "Batched" : "Unbatched", FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeBatched, ChargeID, strOldValue, bBatched ? "Batched" : "Unbatched", aepMedium, aetChanged);
				}

				// (r.gonet 2015-03-27 18:58) - PLID 65279 - Audit if there were any changes to the gift certificate Value.
				if (m_billingItems[i]->ItemType.vt == VT_I4 && VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_GIFT) {
					// a.walling 4/12/06 audit the new GC
					long nGiftID = VarLong(m_billingItems[i]->GiftID);

					// (r.gonet 2015-03-27 18:58) - PLID 65279 - If the line item' s gift certificate value changed, then we have to audit.
					if (varOldGCValue.vt == VT_CY && varNewGCValue.vt == VT_CY && VarCurrency(varOldGCValue) != VarCurrency(varNewGCValue)) {
						COleCurrency cyOldGCValue = VarCurrency(varOldGCValue);
						COleCurrency cyNewGCValue = VarCurrency(varNewGCValue);
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						CString strWhom;
						if (nGiftCertReceivedBy == -1) {
							strWhom = "Anyone";
						} else {
							strWhom = GetExistingPatientName(nGiftCertReceivedBy);
						}
						CString strOldValue;
						if (nGiftType == 0) {
							strOldValue = FormatString("Gift Certificate ($%s %s for %s, ID %s)", cyOldGCValue.Format(0), strGiftCertName, strWhom, strGiftCertificateNumber);
						} else if (nGiftType == 1) {
							strOldValue = FormatString("Gift Certificate ($%s %s for %s, Recharging GC with ID %s)", cyOldGCValue.Format(0), strGiftCertName, strWhom, strGiftCertificateNumber);
						}
						CString strNewValue = FormatString("Value: %s", FormatCurrencyForInterface(cyNewGCValue));
						AuditEvent(m_nPatientID, strPatientName, AuditID, aeiGiftCModified, nGiftID, strOldValue, strNewValue, aepMedium, aetChanged);
					}
				}
			}

			if (bNewCharge && m_EntryType == 1) {
				if (m_billingItems[i]->ItemType.vt == VT_I4 && VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_GIFT && nGiftType == 1) {
					long nGiftID = VarLong(m_billingItems[i]->GiftID);
					if (varNewGCValue.vt == VT_CY) {
						// (r.gonet 2015-03-27 18:58) - PLID 65279 - We need to audit creation of these new recharge gift certificates somewhere since we now audit changes to them.
						COleCurrency cyNewValue = VarCurrency(varNewGCValue);
						if (AuditID == -1) {
							AuditID = BeginNewAuditEvent();
						}

						_RecordsetPtr prsGCName = CreateParamRecordset("SELECT Name FROM GCTypesT INNER JOIN ServiceT ON ServiceID = ID WHERE ServiceID = {INT}", VarLong(m_billingItems[i]->ServiceID, -1));
						if (!prsGCName->eof) {
							strGiftCertName = AdoFldString(prsGCName, "Name");
						} else {
							strGiftCertName = "Undefined";
						}
						prsGCName->Close();

						CString strNewValue = FormatString("Gift Certificate ($%s %s, Recharging GC with ID %s)", cyNewValue.Format(0), strGiftCertName, strGiftCertificateNumber);
						AuditEvent(m_nPatientID, GetExistingPatientName(m_nPatientID), AuditID, aeiGiftCCreated, -1, "", strNewValue, aepHigh, aetChanged);
					}
				}
			}

			if (!bNewCharge && rs != NULL && rs->State != adStateClosed)
				rs->Close();

			varPackageChargeRefID = g_cvarNull;
			if (m_EntryType == 1) {
				var = m_billingItems[i]->PackageChargeRefID;
				if (var.vt == VT_I4) {
					nPackageChargeRefID = VarLong(var);

					if (nPackageChargeRefID != -1)
						varPackageChargeRefID = (long)nPackageChargeRefID;
				}
			}

			// (a.walling 2010-09-08 14:28) - PLID 40377 - Yet another Rollback with no active transaction!
		}NxCatchAllCall("BillingDlg::ApplyChargeToBill - Initialize", { return FALSE; });

		/////////////////////////////////////////
		//save the charge

		try  {

			// (j.jones 2008-02-12 11:14) - PLID 28848 - if the preference disallows batching patient charges,
			// update the batched status now, even if means undoing a previously saved value

			//require both preferences to be enabled for this to go into effect, but check them
			//prior to the transaction starting
			BOOL bHidePatientChargesOnClaims = (GetRemotePropertyInt("DisallowBatchingPatientClaims", 0, 0, "<None>", TRUE) == 1 &&
				GetRemotePropertyInt("HidePatientChargesOnClaims", 0, 0, "<None>", TRUE) == 1);

			// (j.jones 2008-02-12 11:31) - PLID 28848 - uncheck the "batched" setting if 100% patient resp,
			// and our preferences are enabled
			if (bHidePatientChargesOnClaims && m_EntryType == 1) {
				BOOL bHasInsResp = FALSE;

				RPCList* list = m_billingItems[i]->RPCList;
				for (int j = 0; j < list->aryRPC.GetSize(); j++) {
					RespPerCharge rpc = list->aryRPC.GetAt(j);

					COleCurrency cyInsResp = (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));

					if (cyInsResp > COleCurrency(0, 0)) {
						bHasInsResp = TRUE;
					}
				}

				if (!bHasInsResp) {
					//if we don't have any insurance resp. on this charge,
					//we have to uncheck the batched status

					// (j.jones 2010-09-29 15:32) - PLID 40686 - We now have a setting per service code 
					// to control if the charge batches anyways, it only applies if the total charge is
					// zero, and the option is checked for this service code
					COleCurrency cyLineTotal = (m_billingItems[i]->LineTotal.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(m_billingItems[i]->LineTotal, COleCurrency(0, 0));

					BOOL bUnbatch = TRUE;

					if (cyLineTotal == COleCurrency(0, 0) && VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_CPT) {
						//ok, it's a zero dollar CPT code, so check for this exclusion
						_RecordsetPtr rsCPTZeroOK = CreateParamRecordset("SELECT BatchIfZero FROM CPTCodeT WHERE BatchIfZero = 1 AND ID = {INT}", VarLong(m_billingItems[i]->ServiceID));
						if (!rsCPTZeroOK->eof) {
							//this service code is set to NOT unbatch
							bUnbatch = FALSE;
						}
					}

					if (bUnbatch) {
						bBatched = FALSE;

						//and ensure it changes in the interface
						m_billingItems[i]->Batched = g_cvarFalse;

						// (j.jones 2010-08-10 10:11) - PLID 40056 - make sure we update the correct row
						// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
						IRowSettingsPtr pRow = m_List->GetFirstRow();
						while (pRow) {
							if (LineID == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {
								pRow->PutValue(COLUMN_BATCHED, g_cvarFalse);
								break;
							}

							pRow = pRow->GetNextRow();
						}
					}
				}
			}

			// (a.walling 2010-09-08 13:26) - PLID 40377 - Use CSqlTransaction
			CSqlTransaction trans("Charge");
			trans.Begin();

			CAuditTransaction atAuditTrans;

			if (bNewCharge) {

				CString strAmount = FormatCurrencyForSql(m_billingItems[i]->UnitCost.cyVal);

				if ((m_bPaymentPlan && (m_nPackageType == 1 || m_nPackageType == 2) && nPackageChargeRefID != -1)) {
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("UPDATE PackagesT SET CurrentAmount = CurrentAmount - {OLECURRENCY} WHERE QuoteID = {INT}", GetPreTaxLineTotal(m_billingItems[i]), m_nPackageID);
					ExecuteParamSql("UPDATE PackagesT SET CurrentAmount = Convert(money,'$0.00') WHERE CurrentAmount < Convert(money,'$0.00') AND QuoteID = {INT}", m_nPackageID);

					if (m_bPaymentPlan && m_nPackageType == 2 && nPackageChargeRefID != -1) {
						//if a multi-use package, we need to properly reduce the quantity here
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						ExecuteParamSql("UPDATE ChargesT SET PackageQtyRemaining = PackageQtyRemaining - {DOUBLE} WHERE ID = {INT}", dblQty, nPackageChargeRefID);
						ExecuteParamSql("UPDATE ChargesT SET PackageQtyRemaining = 0 WHERE PackageQtyRemaining < 0 AND ID = {INT}", nPackageChargeRefID);
					}
				}

				// (j.jones 2009-08-20 09:05) - PLID 32652 - converted into a batch so the new ID is gathered in the same execute,
				// and while I was at it just decided to batch these two inserts together once and for all
				// (j.jones 2011-04-27 14:29) - PLID 43405 - converted to a param sql batch
				CString strSqlBatch;
				CNxParamSqlArray aryParams;

				AddDeclarationToSqlBatch(strSqlBatch, "SET NOCOUNT ON");
				// (j.jones 2011-04-28 10:04) - PLID 43405 - this function will add declarations such as
				// @ChargeID, @ChargeRespID, @ChargeRespDetailID, etc.
				DeclareVariablesForChargeSave(strSqlBatch);

				// (j.armen 2013-06-28 12:47) - PLID 57373 - Idenitate LineItemT
				// (r.gonet 2015-03-27 18:58) - PLID 65279 - Insert the GCValue as well.
				//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp****//
				AddParamStatementToSqlBatch(strSqlBatch, aryParams,
					"INSERT INTO LineItemT ("
					"	PatientID, LocationID, Type, [Date],\r\n"
					"	InputDate, InputName, Amount, Description, GiftID, GCValue\r\n"
					") VALUES (\r\n"
					"	{INT}, {INT}, {INT}, {STRING},\r\n"
					"	{STRING}, {STRING}, Convert(money, {STRING}), {STRING}, {VT_I4}, {VT_CY}) ",
					m_nPatientID, LocationID, (m_EntryType == 1) ? 10 : 11, strDate, FormatDateTimeForSql(dtNewInputDate, dtoDateTime),
					GetCurrentUserName(), strAmount, strItemDescription, varGiftID, varNewGCValue);

				AddParamStatementToSqlBatch(strSqlBatch, aryParams,
					"SET @ChargeID = SCOPE_IDENTITY() ");

				// (j.gruber 2007-04-05 14:17) - PLID 9796 - Adding support for Coupons
				// (j.jones 2007-04-23 12:40) - PLID 25735 - supported OriginalPackageQtyRemaining
				// (j.jones 2008-05-28 11:42) - PLID 28782 - added NDCCode
				// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
				// (j.gruber 2009-03-11 10:43) - PLID 33351 - take out discount fields
				// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
				// (j.gruber 2009-10-19 12:59) - PLID 35947 - add allowable
				// (j.jones 2009-12-22 17:24) - PLID 32587 - OriginalPackageQtyRemaining is now editable
				// (j.jones 2010-04-08 11:55) - PLID 15224 - added ChargesT.IsEmergency
				// (j.jones 2010-11-09 10:11) - PLID 31392 - added ChargesT.ClaimProviderID
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				// (j.jones 2011-10-25 16:11) - PLID 46088 - added Calls
				// (j.jones 2012-01-17 15:06) - PLID 47537 - added EMRChargeID
				// (d.singleton 2012-05-21 09:59) - PLID 48152 added skill
				// (j.gruber 2014-03-10 11:01) - PLID 60893 - take out whichCodes
				// (j.jones 2014-04-23 09:51) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category and SubCategory are now nullable, 0 is no longer a valid sentinel value
				// (c.haag 2016-05-02 10:36) - NX-100403 - DoctorsProviders is nullable now

				//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp****//
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "INSERT INTO ChargesT (ID, BillID, LineID, ItemCode, ServiceID, "
					"ServiceType, ItemSubCode, Category, SubCategory, "
					"CPTModifier, CPTModifier2, CPTModifier3, CPTModifier4, "
					"CPTMultiplier1, CPTMultiplier2, CPTMultiplier3, CPTMultiplier4, "
					"DoctorsProviders, ClaimProviderID, Quantity, "
					"PackageQtyRemaining, OriginalPackageQtyRemaining, OthrBillFee, TaxRate, TaxRate2, "
					"ServiceLocationID, ServiceDateFrom, ServiceDateTo, "
					"SuperbillID, PatCoordID, Batched, PackageChargeRefID, "
					"NDCCode, AppointmentID, "
					"DrugUnitPrice, DrugUnitTypeQual, DrugUnitQuantity, PrescriptionNumber, Allowable, "
					"IsEmergency, GlassesOrderServiceID, Calls, EMRChargeID, SkillCode, "
					"ReferringProviderID, OrderingProviderID, SupervisingProviderID) "
					"VALUES (@ChargeID, {INT}, {INT}, {STRING}, {INT}, "
					"{STRING}, {STRING}, {VT_I4}, {VT_I4}, "
					"{VT_BSTR}, {VT_BSTR}, {VT_BSTR}, {VT_BSTR}, "
					"{VT_R8}, {VT_R8}, {VT_R8}, {VT_R8}, "
					"{VT_I4}, {VT_I4}, {DOUBLE},"
					"{DOUBLE}, {DOUBLE}, Convert(money,{STRING}), {STRING}, {STRING}, "
					"{VT_I4}, {STRING}, {STRING}, "
					"{VT_I4}, {VT_I4}, {INT}, {VT_I4},"
					"{STRING}, {VT_I4}, "
					"Convert(money,{STRING}), {STRING}, {DOUBLE}, {STRING}, Convert(money, {STRING}), "
					"{INT}, {VT_I4}, {DOUBLE}, {VT_I4}, {STRING}, "
					"{VT_I4}, {VT_I4}, {VT_I4})",
					GetBillID(), LineID, CPTCode, ServiceID,
					TOS, CPTSubCode, varCategoryID, varSubCategoryID,
					varMod1, varMod2, varMod3, varMod4,
					varMultiplier1, varMultiplier2, varMultiplier3, varMultiplier4,
					(nDocID > 0) ? _variant_t((long)nDocID) : g_cvarNull, varClaimProviderID, dblQty,
					PackageQtyRemaining, OriginalPackageQtyRemaining, OthCost, strTaxRate1, strTaxRate2,
					varPOSToSave, strDate, strServiceDateTo,
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_varSuperbillID, varPatCoordID, bBatched ? 1 : 0, varPackageChargeRefID,
					strNDCCode, varAppointmentID,
					FormatCurrencyForSql(cyDrugUnitPrice), strDrugUnitType, dblDrugUnitQuantity, strPrescriptionNumber, FormatCurrencyForSql(cyAllowable),
					(long)eIsEmergency, varGlassesOrderServiceID, dblCalls, varEMRChargeID, strSkill,
					varReferringProviderID, varOrderingProviderID, varSupervisingProviderID);

				// (j.jones 2011-04-27 17:39) - PLID 43505 - now we update ChargeRespT immediately
				UpdateChargeRespT(strSqlBatch, aryParams, -1, m_billingItems[i], atAuditTrans, dtNewInputDate);
				// (r.gonet 08/05/2014) - PLID 63098 - If this is a lab charge, then save the linked lab test codes.
				if (ReturnsRecordsParam("SELECT NULL FROM ServiceT WHERE ID = {INT} AND LabCharge = 1", ServiceID)
					|| m_billingItems[i]->TestCodeList.size() > 0) {
					UpdateChargeLabTestCodes(strSqlBatch, aryParams, -1, m_billingItems[i], atAuditTrans);
				}

				// (d.lange 2015-11-18 10:32) - PLID 67127 - Calculate and store the insured party ID with lowest placement for the insurance category
				AddParamStatementToSqlBatch(strSqlBatch, aryParams,
					"UPDATE ChargesT SET AllowableInsuredPartyID = dbo.CalcMajorityInsCategoryPrimaryInsuredParty(@chargeID) WHERE ID = @chargeID");
				
				AddDeclarationToSqlBatch(strSqlBatch, "SET NOCOUNT OFF");
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SELECT @ChargeID AS NewID");

				_RecordsetPtr rsResults = CreateParamRecordsetBatch(GetRemoteData(), strSqlBatch, aryParams);
				if (!rsResults->eof) {
					NewChargeID = AdoFldLong(rsResults, "NewID");
				}
				else {
					//should be impossible
					ThrowNxException("Failed to save charge");
				}
				rsResults->Close();

				ChargeID = NewChargeID;

				m_billingItems[i]->ChargeID = (long)NewChargeID;

				// (j.jones 2010-08-10 10:11) - PLID 40056 - make sure we update the correct row
				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				IRowSettingsPtr pRow = m_pList->GetFirstRow();
				while (pRow) {
					if (LineID == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {
						pRow->PutValue(COLUMN_CHARGE_ID, (long)NewChargeID);
						break;
					}

					pRow = pRow->GetNextRow();
				}

				// (j.gruber 2009-03-11 13:48) - PLID 33351 - chargeDiscount
				if (!strDiscountSaveString.IsEmpty()) {
					strDiscountSaveString.Replace("{CHARGEID}", AsString((long)NewChargeID));
					ExecuteSqlStd(strDiscountSaveString);
				}

				// (j.gruber 2014-02-24 12:17) - PLID 60893 - new whichcodes structure
				if (!sqlWhichCodesSave.IsEmpty()) {
					//add the chargeID onto it
					CSqlFragment sqlAppendedWhichCodes = CSqlFragment(" SET @ChargeID = {INT}; \r\n", NewChargeID);
					sqlAppendedWhichCodes += sqlWhichCodesSave;
					//now add this line to our total which codes sql
					sqlTotalWhichCodes += sqlAppendedWhichCodes;
					//we will execute after the bills save
					//ExecuteParamSql(sqlFinalWhichCodes);
				}

				// save ChargedProductItems
				long CPI_ID = m_billingItems[i]->ChargedProductItemListID;
				if (CPI_ID != -1)
					SaveChargedProductItemsArray(NewChargeID, CPI_ID);

				//(c.copits 2010-10-26) PLID 38598 - Warranty tracking system
				UpdateInvWarrantyExpDates(CPI_ID);

				// (j.jones 2007-12-11 11:58) - PLID 27988 - save allocation details
				long nChargedAllocationDetailListID = VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1);
				if (nChargedAllocationDetailListID != -1) {
					SaveChargedAllocationDetailsArray(NewChargeID, nChargedAllocationDetailListID);
				}

				// (a.walling 2007-05-24 11:26) - PLID 26114 - Save any reward redemptions (if a bill)
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator * is ambiguous
				if (m_EntryType == 1 && cyPointsUsed > COleCurrency(0, 0)) {
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("INSERT INTO RewardHistoryT (PatientID, Source, SourceValue, BillID, Points, ChargeID) "
						"VALUES ({INT}, {INT}, {OLECURRENCY}, {INT}, {OLECURRENCY}, {INT})",
						m_nPatientID, Rewards::ersRedeemedByCharge, cyTotalCharge, GetBillID(), (cyPointsUsed * long(-1)), NewChargeID);
				}

				// (j.jones 2008-06-04 15:03) - PLID 30256 - fill in EMRQuotedChargesT accordingly
				if (m_EntryType == 2 && nEMRChargeID != -1) {
					ExecuteParamSql("INSERT INTO EMRQuotedChargesT (EMRChargeID, ChargeID) "
						"VALUES ({INT}, {INT})", nEMRChargeID, NewChargeID);
				}

				// (d.singleton 2012-03-29 13:56) - PLID 49257 Save any notes associated with unsaved charges
				BillingItemPtr bi = m_billingItems[i];
				for (int x = 0; x < bi->m_arUnsavedChargeNotes.GetCount(); x++) {
					CParamSqlBatch batch;
					batch.Declare(
						"SET NOCOUNT ON "
						"DECLARE @nNewID int "
						"DECLARE @dtCurrent datetime ");
					batch.Add("SET @dtCurrent = GetDate() ");

					// (j.armen 2014-01-31 09:31) - PLID 60568 - Idenitate NoteDataT
					batch.Add("INSERT INTO Notes (PersonID, Date, UserID, Category, Note, Priority) "
						"VALUES ({INT}, @dtCurrent, {INT}, {VT_I4}, {STRING}, {INT})",
						m_nPatientID, GetCurrentUserID(), bi->m_arUnsavedChargeNotes.GetAt(x).varCategory,
						VarString(bi->m_arUnsavedChargeNotes.GetAt(x).varNote), bi->m_arUnsavedChargeNotes.GetAt(x).varPriority.lVal);
					batch.Add("SET @nNewID = SCOPE_IDENTITY()");
					batch.Add("INSERT INTO NoteInfoT (NoteID, BillID, LineItemID, MailID, LabResultID, LabID, ShowOnStatement, SendOnClaim, RecallID) "
						"VALUES (@nNewID, NULL, {INT}, {VT_I4}, {VT_I4}, {VT_I4}, {INT}, {INT}, {VT_I4})",
						bi->ChargeID.lVal, g_cvarNull, g_cvarNull, g_cvarNull, bi->m_arUnsavedChargeNotes.GetAt(x).varStatement.intVal,
						bi->m_arUnsavedChargeNotes.GetAt(x).varClaim.intVal, g_cvarNull);

					// (d.singleton 2012-04-02 14:13) - PLID 49257 audit the newly added notes
					batch.Declare(
						"SET NOCOUNT OFF "
						"SELECT @nNewID AS NoteID");

					_RecordsetPtr rsID = batch.CreateRecordset(GetRemoteData());

					long nAuditID = -1;
					nAuditID = BeginNewAuditEvent();
					if (nAuditID != -1) {
						CString strOld, strNew;
						long nNoteID = VarLong(rsID->Fields->GetItem("NoteID")->Value);
						strOld = "";
						strNew = VarString(bi->m_arUnsavedChargeNotes.GetAt(x).varNote);
						AuditEvent(GetActivePatientID(), GetExistingPatientName(GetActivePatientID()), nAuditID, aeiPatientNote, nNoteID, strOld, strNew, aepMedium, aetCreated);
					}
				}

				//if it is a NEW charge on an EXISTING bill, audit the fact that we made it
				if (bNewCharge && !bIsNewBill) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					CString strAuditDesc;
					strAuditDesc.Format("Charge Added: %s", strItemDescription);
					AuditEvent(m_nPatientID, strPatientName, AuditID, m_EntryType == 1 ? aeiBillChargeAdded : aeiQuoteChargeAdded, -1, "", strAuditDesc, aepMedium, aetCreated);
				}

				// (j.jones 2011-08-25 16:56) - PLID 44796 - audit the batched status if the charge is new and unbatched
				if (!bBatched && bNewCharge) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strNewValue;
					strNewValue.Format("Unbatched new charge (%s charge, %s)", FormatCurrencyForInterface(cyTotalCharge), FormatDateTimeForInterface(date, NULL, dtoDate));
					AuditEvent(m_nPatientID, strPatientName, AuditID, aeiChargeBatched, ChargeID, "", strNewValue, aepMedium, aetChanged);
				}
			}
			else {

				CString strAmount = FormatCurrencyForSql(m_billingItems[i]->UnitCost.cyVal);

				if ((m_bPaymentPlan && (m_nPackageType == 1 || m_nPackageType == 2) && nPackageChargeRefID != -1)) {
					//check the existing amount, and change the currentamount to match it
					// (j.jones 2005-06-10 10:37) - PLID 14992 - we in fact need the non tax amount
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsTemp = CreateParamRecordset("SELECT Quantity, "
						"Round(Convert(money,((([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN(CPTMultiplier4 Is Null) THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN((SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE ChargeID = ChargesT.ID AND DELETED = 0) Is Null) THEN 1 ELSE ((100-Convert(float,(SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE ChargeID = ChargesT.ID AND DELETED = 0)))/100) END)-(CASE WHEN (SELECT Sum(Discount) FROM ChargeDiscountsT WHERE ChargeID = ChargesT.ID AND DELETED = 0) Is Null THEN 0 ELSE (SELECT Sum(Discount) FROM ChargeDiscountsT WHERE ChargeID = ChargesT.ID AND DELETED = 0) END))))),2) AS ChargeTotal "
						"FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
						"WHERE LineItemT.Deleted = 0 AND ChargesT.ID = {INT}", ChargeID);
					COleCurrency oldAmt = COleCurrency(0, 0);
					double dblOldQty = 0.0;
					if (!rsTemp->eof) {
						oldAmt = AdoFldCurrency(rsTemp, "ChargeTotal");
						dblOldQty = AdoFldDouble(rsTemp, "Quantity");
					}
					rsTemp->Close();

					//we're changing a package amount, so we need to update the current amount to
					//ignore the previous amount and apply the new amount instead... sneaky!
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("UPDATE PackagesT SET CurrentAmount = (CurrentAmount + {OLECURRENCY}) - {OLECURRENCY} WHERE QuoteID = {INT}", oldAmt, GetPreTaxLineTotal(m_billingItems[i]), m_nPackageID);
					ExecuteParamSql("UPDATE PackagesT SET CurrentAmount = Convert(money,'$0.00') WHERE CurrentAmount < Convert(money,'$0.00') AND QuoteID = {INT}", m_nPackageID);

					if (m_bPaymentPlan && m_nPackageType == 2 && nPackageChargeRefID != -1) {
						//if a multi-use package, we need to properly update the quantity here
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						ExecuteParamSql("UPDATE ChargesT SET PackageQtyRemaining = (PackageQtyRemaining + {DOUBLE}) - {DOUBLE} WHERE ID = {INT}", dblOldQty, dblQty, nPackageChargeRefID);
						ExecuteParamSql("UPDATE ChargesT SET PackageQtyRemaining = 0 WHERE PackageQtyRemaining < 0 AND ID = {INT}", nPackageChargeRefID);
					}
				}

				// (j.jones 2011-04-27 17:21) - PLID 43405 - converted to a param sql batch
				CString strSqlBatch;
				CNxParamSqlArray aryParams;

				// (j.jones 2011-04-28 10:04) - PLID 43405 - this function will add declarations such as
				// @ChargeID, @ChargeRespID, @ChargeRespDetailID, etc.
				DeclareVariablesForChargeSave(strSqlBatch);
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeID = {INT}", ChargeID);

				// (j.jones 2008-05-28 11:42) - PLID 28782 - added NDC Code
				// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
				// (j.gruber 2009-03-11 10:42) - PLID 33351 - take out discount fields
				// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
				// (j.gruber 2009-10-19 13:02) - PLID 35947 - added allowable
				// (j.jones 2009-12-22 17:25) - PLID 32587 - OriginalPackageQtyRemaining is now always editable
				// (j.jones 2010-04-08 11:55) - PLID 15224 - added ChargesT.IsEmergency
				// (j.jones 2010-11-09 10:07) - PLID 31392 - added ChargesT.ClaimProviderID
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				// (j.jones 2011-10-25 16:11) - PLID 46088 - added Calls
				// (d.singleton 2012-05-21 10:00) - PLID 48152 added skill
				// (j.gruber 2014-03-10 11:02) - PLID 60893 - take out old whichCodes
				// (j.jones 2014-04-23 09:51) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category and SubCategory are now nullable, 0 is no longer a valid sentinel value
				// (d.lange 2015-11-20 13:05) - PLID 67127 - Calculate and store the insured party ID of the lowest placement for the selected insurance category
				// (c.haag 2016-05-02 11:00) - NX-100403 - Providers are nullable now

				//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp****//
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "UPDATE ChargesT SET ChargesT.LineID = {INT}, ChargesT.ItemCode = {STRING}, ChargesT.ServiceID = {INT}, "
					"ChargesT.ServiceType = {STRING}, ChargesT.ItemSubCode = {STRING}, ChargesT.Category = {VT_I4}, ChargesT.SubCategory = {VT_I4}, "
					"ChargesT.CPTModifier = {VT_BSTR}, ChargesT.CPTModifier2 = {VT_BSTR}, ChargesT.CPTModifier3 = {VT_BSTR}, ChargesT.CPTModifier4 = {VT_BSTR}, "
					"ChargesT.CPTMultiplier1 = {VT_R8}, ChargesT.CPTMultiplier2 = {VT_R8}, ChargesT.CPTMultiplier3 = {VT_R8}, ChargesT.CPTMultiplier4 = {VT_R8}, "
					"ChargesT.DoctorsProviders = {VT_I4}, ChargesT.ClaimProviderID = {VT_I4}, "
					"ChargesT.Quantity = {DOUBLE}, ChargesT.PackageQtyRemaining = {DOUBLE}, ChargesT.OriginalPackageQtyRemaining = {DOUBLE}, "
					"ChargesT.OthrBillFee = Convert(money,{STRING}), TaxRate = {STRING}, TaxRate2 = {STRING}, [ServiceLocationID] = {VT_I4}, [ServiceDateFrom] = {STRING}, [ServiceDateTo] = {STRING}, "
					"PatCoordID = {VT_I4}, Batched = {INT}, "
					"NDCCode = {STRING}, AppointmentID = {VT_I4}, "
					"DrugUnitPrice = Convert(money, {STRING}), DrugUnitTypeQual = {STRING}, "
					"DrugUnitQuantity = {DOUBLE}, PrescriptionNumber = {STRING}, Allowable = Convert(money, {STRING}), "
					"IsEmergency = {INT}, GlassesOrderServiceID = {VT_I4}, Calls = {DOUBLE}, SkillCode = {STRING}, "
					"ReferringProviderID = {VT_I4}, OrderingProviderID = {VT_I4}, SupervisingProviderID = {VT_I4}, "
					"AllowableInsuredPartyID = dbo.CalcMajorityInsCategoryPrimaryInsuredParty(@ChargeID) "
					"WHERE ChargesT.ID = @ChargeID",
					LineID, CPTCode, ServiceID, TOS, CPTSubCode, varCategoryID, varSubCategoryID,
					varMod1, varMod2, varMod3, varMod4,
					varMultiplier1, varMultiplier2, varMultiplier3, varMultiplier4,
					(nDocID > 0 ? _variant_t((long)nDocID) : g_cvarNull), varClaimProviderID, dblQty, PackageQtyRemaining, OriginalPackageQtyRemaining, OthCost,
					strTaxRate1, strTaxRate2, varPOSToSave, strDate, strServiceDateTo,
					varPatCoordID, bBatched ? 1 : 0,
					strNDCCode, varAppointmentID,
					FormatCurrencyForSql(cyDrugUnitPrice), strDrugUnitType, dblDrugUnitQuantity, strPrescriptionNumber,
					FormatCurrencyForSql(cyAllowable), (long)eIsEmergency, varGlassesOrderServiceID, dblCalls, strSkill,
					varReferringProviderID, varOrderingProviderID, varSupervisingProviderID);

				// (r.gonet 2015-03-27 18:58) - PLID 65279 - Update the GCValue as well.
				//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp****//
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "UPDATE LineItemT SET LocationID = {INT}, Description = {STRING}, [Date] = {STRING}, InputDate = {STRING}, "
					"LineItemT.Amount = Convert(money, {STRING}), GiftID = {VT_I4}, GCValue = {VT_CY} WHERE ID = @ChargeID",
					LocationID, strItemDescription, strDate, FormatDateTimeForSql(dtNewInputDate, dtoDateTime), strAmount, varGiftID, varNewGCValue);

				// (j.jones 2011-04-27 17:39) - PLID 43505 - now we update ChargeRespT immediately
				UpdateChargeRespT(strSqlBatch, aryParams, ChargeID, m_billingItems[i], atAuditTrans, dtNewInputDate);
				// (r.gonet 08/05/2014) - PLID 63098 - If this is a lab charge, then save the linked lab test codes.
				if (ReturnsRecordsParam(
					"SELECT NULL FROM ServiceT WHERE ID = {INT} AND LabCharge = 1 "
					"UNION ALL "
					"SELECT NULL FROM ChargeLabTestCodesT WHERE ChargeID = {INT} "
					, ServiceID, ChargeID)
					|| m_billingItems[i]->TestCodeList.size() > 0) {
					UpdateChargeLabTestCodes(strSqlBatch, aryParams, ChargeID, m_billingItems[i], atAuditTrans);
				}

				ExecuteParamSqlBatch(GetRemoteData(), strSqlBatch, aryParams);

				// (j.gruber 2009-03-11 13:50) - PLID 33351 - ChargeDiscounts
				if (!strDiscountSaveString.IsEmpty()) {
					ExecuteSqlStd(strDiscountSaveString);
				}

				// (j.gruber 2014-02-24 12:17) - PLID 60893 - new whichcodes structure
				if (!sqlWhichCodesSave.IsEmpty()) {
					//add it to the total
					sqlTotalWhichCodes += sqlWhichCodesSave;
					//ExecuteParamSql(sqlWhichCodesSave);
				}

				if (varGiftID.vt != VT_NULL) {
					//DRT 3/11/2005 - PLID 15940 - If this is a gift certificate we're editing, we need to make sure that the ServiceDate stays in sync
					//	with the GiftCertificatesT.PurchaseDate (at this point, I'm not 100% sure why we even have a 
					//	PurchaseDate).
					long nGiftID = VarLong(varGiftID);
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (nGiftID > 0) {
						_RecordsetPtr prs = CreateParamRecordset("SELECT CONVERT(BIT, IsRecharge) AS IsRecharge FROM GCTypesT WHERE ServiceID = {INT}", ServiceID);
						if (!prs->eof) {
							BOOL bIsRecharge = AdoFldBool(prs->Fields, "IsRecharge");

							CSqlFragment sqlUpdate("UPDATE GiftCertificatesT SET ");
							bool bUpdatedSomething = false;
							if (!bIsRecharge) {
								sqlUpdate += CSqlFragment("PurchaseDate = {OLEDATETIME}", dtDateNoTime);
								bUpdatedSomething = true;
							}

							sqlUpdate += CSqlFragment(" WHERE ID = {INT}", nGiftID);
							
							prs->Close();
							if (bUpdatedSomething) {
								// (r.gonet 2015-03-27 18:58) - PLID 65279 - Update the gift certificate with the new values.
								CParamSqlBatch sqlUpdateBatch;
								sqlUpdateBatch.Add(sqlUpdate);
								sqlUpdateBatch.Execute(GetRemoteData());
							}
						}
					}
				}

				// save ChargedProductItems
				long CPI_ID = m_billingItems[i]->ChargedProductItemListID;
				if (CPI_ID != -1)
					SaveChargedProductItemsArray(ChargeID, CPI_ID);

				//(c.copits 2010-10-26) PLID 38598 - Warranty tracking system
				UpdateInvWarrantyExpDates(CPI_ID);
			}

			//generate TODO for global period
			// (j.jones 2007-02-05 10:08) - PLID 24572 - only for bills
			if (m_EntryType == 1 && GetRemotePropertyInt("GlobalPeriodToDos", 0, 0, "<None>", TRUE)) {

				long GlobalPeriod = -1;

				// (j.jones 2012-07-24 17:04) - PLID 51651 - added a preference to only track global periods for
				// surgical codes only, if it is disabled when we would look at all codes
				long nSurgicalCodesOnly = GetRemotePropertyInt("GlobalPeriod_OnlySurgicalCodes", 1, 0, "<None>", true);

				// (j.jones 2012-07-26 09:53) - PLID 50489 - added another preference to NOT track global periods
				// if the charge uses modifier 78
				long nIgnoreModifier78 = GetRemotePropertyInt("GlobalPeriod_IgnoreModifier78", 1, 0, "<None>", true);
				BOOL bSkipTodo = FALSE;
				if (nIgnoreModifier78 == 1
					&& ContainsModifier("78", VarString(varMod1, ""), VarString(varMod2, ""), VarString(varMod3, ""), VarString(varMod4, ""))) {
					bSkipTodo = TRUE;
				}

				if (!bSkipTodo) {
					//see if a global period exists for this item
					// (j.jones 2012-07-24 17:04) - PLID 51651 - optionally filter on surgical codes only
					_RecordsetPtr rs = CreateParamRecordset("SELECT CPTCodeT.GlobalPeriod FROM CPTCodeT "
						"INNER JOIN ServiceT ON CPTCodeT.ID = ServiceT.ID "
						"LEFT JOIN ServicePayGroupsT ON ServiceT.PayGroupID = ServicePayGroupsT.ID "
						"WHERE GlobalPeriod Is Not Null AND CPTCodeT.GlobalPeriod <> 0 "
						"AND ServiceT.ID = {INT} "
						"AND ({INT} <> 1 OR ServicePayGroupsT.Category = {CONST}) ",
						ServiceID, nSurgicalCodesOnly, PayGroupCategory::SurgicalCode);
					if (!rs->eof) {
						GlobalPeriod = AdoFldLong(rs, "GlobalPeriod", -1);
					}
					rs->Close();
				}

				if (GlobalPeriod <= 0) {
					bSkipTodo = TRUE;
				}

				// (j.jones 2008-05-02 15:26) - PLID 27245 - we don't want to delete and recreate a
				// global period TODO unless the charge is new or the charge date changed
				// (j.jones 2013-08-20 11:26) - PLID 57959 - also do this if the service code changed
				if (!bSkipTodo && (bNewCharge || bDateChanged || bServiceCodeChanged)) {

					BOOL bHasTodo = FALSE;
					BOOL bCompleted = FALSE;

					// (j.jones 2008-05-02 16:02) - PLID 27245 - if an existing charge,
					// see if a TODO already exists, and if so, whether it was completed
					if (!bNewCharge) {
						_RecordsetPtr rsTodo = CreateParamRecordset("SELECT Done FROM TodoList "
							"WHERE RegardingID = {INT} AND RegardingType = {INT}", ChargeID, ttGlobalPeriod);
						if (!rsTodo->eof) {
							//there should never be more than one, that would be bad data
							ASSERT(rsTodo->GetRecordCount() == 1);

							bHasTodo = TRUE;

							_variant_t varDone = rsTodo->Fields->Item["Done"]->Value;

							if (varDone.vt == VT_DATE) {
								bCompleted = TRUE;
							}
						}
						rsTodo->Close();
					}

					// (j.jones 2008-05-02 16:02) - PLID 27245 - only create a TODO
					// if there isn't an existing completed one
					if (!bCompleted) {

						//Clear previous TODO items for this charge, if we have any
						if (bHasTodo) {
							// (c.haag 2008-06-11 08:42) - PLID 30328 - Use the new global TODO deletion function
							TodoDelete(FormatString("RegardingID = %d AND RegardingType = %d", ChargeID, ttGlobalPeriod));
						}

						COleDateTime dtExpire = date;
						COleDateTimeSpan dtSpan;
						dtSpan.SetDateTimeSpan(GlobalPeriod, 0, 0, 0);
						dtExpire += dtSpan;

						// (j.jones 2008-05-02 16:06) - PLID 27245 - don't create a new
						// TODO alarm if the expire date isn't in the future
						if (dtExpire > COleDateTime::GetCurrentTime()) {

							long nCatID = -1;
							rs = CreateParamRecordset("SELECT ID FROM NoteCatsF WHERE Description = 'Financial'");
							if (!rs->eof) {
								nCatID = rs->Fields->Item["ID"]->Value.lVal;
							}
							else {
								//TES 8/1/2011 - PLID 44716 - Moved to GlobalUtils function
								//TES 10/13/2011 - PLID 44716 - Tell the function that we're in a transaction, so it doesn't try to
								// start one itself.
								nCatID = CreateNoteCategory("Financial", true);
							}
							rs->Close();

							CString strExpireDate;
							strExpireDate = FormatDateTimeForSql(dtExpire, dtoDate);

							// (c.haag 2008-06-09 09:35) - PLID 30321 - Use a utility function to create the TODO
							TodoCreate(dtExpire, dtExpire, GetCurrentUserID(), CString("Global Period expired for Service Code ") + CPTCode,
								"", ChargeID, ttGlobalPeriod, m_nPatientID, LocationID, ttpLow, nCatID);
						}
					}
				}
			}

			trans.Commit();
			atAuditTrans.Commit();

		//}NxCatchAllCall("BillingDlg::ApplyChargeToBill - SaveCharges",{Rollback(); return FALSE; });
		}catch (CException *e) {			
			HandleException(e, "BillingDlg::ApplyChargeToBill - SaveCharges:1", __LINE__, __FILE__);
			//Rollback();
			return FALSE;
		}catch (_com_error e) {
			HandleException(e, "BillingDlg::ApplyChargeToBill - SaveCharges:2", __LINE__, __FILE__);
			//Rollback();
			return FALSE;
		}catch (...) {
			HandleException(NULL, "BillingDlg::ApplyChargeToBill - SaveCharges:3", __LINE__, __FILE__);
			//Rollback();
			return FALSE;
		}

		return TRUE;
	}
	NxCatchAll("BillingDlg::ApplyChargeToBill");
	return FALSE;
}



// (j.jones 2011-04-28 09:29) - PLID 43405 - this now makes its changes in a batch
void CBillingDlg::UpdateChargeRespDetails(IN OUT CString &strSqlBatch, IN OUT CNxParamSqlArray &aryParams,
	long nChargeRespID, BOOL bUpdateDate, COleDateTime dtOldDate, COleDateTime dtNewDate, COleCurrency cyAmount)
{
	if (nChargeRespID < 0) {
		//this should never be called on any charge resp that doesn't already exist
		ASSERT(FALSE);
		return;
	}

	//first check to see if the amount has changed

	BOOL bAmountChanged = FALSE;

	_RecordsetPtr rsCheck = CreateParamRecordset("SELECT Sum(Amount) AS SumAmount FROM ChargeRespDetailT WHERE ChargeRespID = {INT}", nChargeRespID);
	COleCurrency cyDetailSum = AdoFldCurrency(rsCheck, "SumAmount", COleCurrency(0, 0));
	if (cyDetailSum != cyAmount) {
		bAmountChanged = TRUE;
	}

	if (bAmountChanged)
	{
		//Since the amount changed, we have to delete everything from ChargeRespDetailT that has this ChargeRespID and insert a new value for it.
		//This will rebuild any ApplyDetailsT records that may exist.
		UpdateAllChargeRespDetailsToNewDate(strSqlBatch, aryParams, nChargeRespID, cyAmount, dtNewDate);

		//set the date to not change since we already redid it
		bUpdateDate = FALSE;
	}
	//only update the charge resps if the date actually changed
	else if (bUpdateDate && dtNewDate != dtOldDate)
	{
		//if the new date was advanced, we want to move any resps on or before that NEW date to be on the new date
		//if the new date is further in the past, we want to move any resps on or before the OLD date to be on the new date
		COleDateTime dtPivotDate;
		if (dtNewDate > dtOldDate)
		{
			//they moved the date forward, we will want to move resps <= the new date to be on the new date
			dtPivotDate = dtNewDate;
		}
		else if (dtNewDate < dtOldDate)
		{
			//they moved the date backward, we will want to move resps <= the old date to be on the new date
			dtPivotDate = dtOldDate;
		}

		//now we're going to update only charge resp details before or on this pivot date
		CSqlFragment sqlChargeRespDetailFilter("ChargeRespDetailT.ChargeRespID = {INT} AND ChargeRespDetailT.Date <= {OLEDATETIME}", nChargeRespID, dtPivotDate);
		
		//get the sum of the ChargeRespDetailT records that need changed - there may not be any
		_RecordsetPtr rsOldDateTotal = CreateParamRecordset("SELECT SUM(Amount) AS OldDateTotal FROM ChargeRespDetailT WHERE {SQL}", sqlChargeRespDetailFilter);
		if (!rsOldDateTotal->eof) {
			_variant_t varOldDateTotal = rsOldDateTotal->Fields->Item["OldDateTotal"]->Value;
			if (varOldDateTotal.vt == VT_CY) {

				//we have some ChargeRespDetailT records that need their date changed

				COleCurrency cyOldDateTotal = VarCurrency(varOldDateTotal);

				//This will update all details before or on the pivot date to all use the new date.
				//This will rebuild any ApplyDetailsT records that may exist.
				UpdateFilteredChargeRespDetailsToNewDate(strSqlBatch, aryParams, nChargeRespID, sqlChargeRespDetailFilter, cyOldDateTotal, dtNewDate);
			}
		}
	}
}

/// <summary>
/// Given a ChargeRespT.ID, a date, and the new ChargeRespT total,
/// replace all ChargeRespDetailT entries with just one entry for
/// the new date, with the desired total.
/// Any existing ApplyDetailsT records will point to this new 
/// ChargeRespDetailT record.
/// </summary>
/// <param name="strSqlBatch">The SQL batch that will execute this.</param>
/// <param name="aryParams">Parameters for this SQL batch.</param>
/// <param name="nChargeRespID">The ChargeRespT.ID to clear/rebuild the ChargeRespDetailT content for.</param>	
/// <param name="cyTotalChargeRespAmount">If your </param>
/// <param name="dtNewDate">The new date for the ChargeRespDetailT content.</param>
void CBillingDlg::UpdateAllChargeRespDetailsToNewDate(IN OUT CString &strSqlBatch, IN OUT CNxParamSqlArray &aryParams,
	long nChargeRespID, COleCurrency cyTotalChargeRespAmount, COleDateTime dtNewDate)
{
	//this function is just an overload that happens to not have a filter
	UpdateFilteredChargeRespDetailsToNewDate(strSqlBatch, aryParams, nChargeRespID, CSqlFragment(""), cyTotalChargeRespAmount, dtNewDate);
}

//Only used for the below function
struct ApplyDetail {
	long nApplyID;
	COleCurrency cyAmount;
};

/// <summary>
/// Given a ChargeRespT.ID, a date, a total amount that needs moved to begin aging on that date,
/// replace all ChargeRespDetailT entries in the provided filter with just one entry for the new date,
/// with the desired total.
/// Any existing ApplyDetailsT records will point to this new ChargeRespDetailT record.
/// This is used when only updating details in a specific date range.
/// </summary>
/// <param name="strSqlBatch">The SQL batch that will execute this.</param>
/// <param name="aryParams">Parameters for this SQL batch.</param>
/// <param name="nChargeRespID">The ChargeRespT.ID to clear/rebuild the ChargeRespDetailT content for.</param>
/// <param name="sqlChargeRespDetailDateFilter">A filter on ChargeRespDetailT, such as when filtering on a date range. Must include a ChargeRespID filter.</param>
/// <param name="cyTotalAmountToMove">The total amount that needs moved to the new date.</param>
/// <param name="dtNewDate">The new date for the ChargeRespDetailT content.</param>
void CBillingDlg::UpdateFilteredChargeRespDetailsToNewDate(IN OUT CString &strSqlBatch, IN OUT CNxParamSqlArray &aryParams,
	long nChargeRespID, CSqlFragment sqlChargeRespDetailFilter,
	COleCurrency cyTotalAmountToMove, COleDateTime dtNewDate)
{
	if (nChargeRespID < 0) {
		//this should never be called on any charge resp that doesn't already exist
		ASSERT(FALSE);
		return;
	}

	//add our ChargeRespID to our provided filter
	if (sqlChargeRespDetailFilter == CSqlFragment(""))
	{
		sqlChargeRespDetailFilter = CSqlFragment("ChargeRespDetailT.ChargeRespID = {INT}", nChargeRespID);
	}
	else 
	{
		//make absolutely sure this is filtering on the right ChargeRespID!
		CString strProvidedFilter = sqlChargeRespDetailFilter.Flatten();
		CString strRequiredFilter = FormatString("ChargeRespDetailT.ChargeRespID = %li", nChargeRespID);
		strProvidedFilter.MakeLower(); strRequiredFilter.MakeLower();
		if (strProvidedFilter.Find(strRequiredFilter) == -1) {
			//this is a design-time failure, the caller is not filtering by ChargeRespID!
			ASSERT(FALSE);
			ThrowNxException("UpdateFilteredChargeRespDetailsToNewDate called without a ChargeRespID filter!");
		}
	}

	//DRT 8/19/2005 - PLID 16131 - There is a constraint of 1 Detail per Resp per day.  The purpose of this function is to 
	//	change all details for a resp to be the dtNewDate parameter.  The old way (below) was attempting to update each
	//	detail individually.  But by very definition, we can't have multiple details on the same date.  So we'll sum up everything
	//	for the given ChargeRespID and insert it as 1 record.

	CArray<ApplyDetail*, ApplyDetail*> aryApplies;

	//Now find the sum of all applies to these details, if any
	COleCurrency cyApplySum(0, 0);	
	_RecordsetPtr prsApplies = CreateParamRecordset("SELECT ApplyDetailsT.ApplyID, SUM(ApplyDetailsT.Amount) AS Amount "
		"FROM ApplyDetailsT "
		"INNER JOIN ChargeRespDetailT ON ApplyDetailsT.DetailID = ChargeRespDetailT.ID "
		"WHERE {SQL} "
		"GROUP BY ApplyDetailsT.ApplyID", sqlChargeRespDetailFilter);
	COleCurrency cyTotalApplies = COleCurrency(0, 0);
	while (!prsApplies->eof) {
		ApplyDetail *pad = new ApplyDetail;
		pad->nApplyID = AdoFldLong(prsApplies, "ApplyID");
		pad->cyAmount = AdoFldCurrency(prsApplies, "Amount");

		//track the total applies
		cyTotalApplies += pad->cyAmount;

		aryApplies.Add(pad);

		prsApplies->MoveNext();
	}
	prsApplies->Close();

	//the total applies should never exceed the new desired amount, so fail if it does
	if (cyTotalApplies > cyTotalAmountToMove) {
		
		//this function will get the current call stack, which is translateable using
		//nx-internal\Development\CallStackSymbolizer
		CString strCallStack = GetCallStack();

		//throw a detailed exception
		ThrowNxException("UpdateFilteredChargeRespDetailsToNewDate failed to update ChargeRespT.ID %li to %s for dtNewDate %s due to a total ApplyDetailsT amount of %s.\n\n"
			"sqlChargeRespDetailFilter = \"%s\"\n\n"
			"%s",
			nChargeRespID, FormatCurrencyForInterface(cyTotalAmountToMove), FormatDateTimeForInterface(dtNewDate), FormatCurrencyForInterface(cyTotalApplies),
			sqlChargeRespDetailFilter.Flatten(),
			strCallStack);
	}

	//Delete the records
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "DELETE ApplyDetailsT "
		"FROM ApplyDetailsT "
		"INNER JOIN ChargeRespDetailT ON ApplyDetailsT.DetailID = ChargeRespDetailT.ID "
		"WHERE {SQL}", sqlChargeRespDetailFilter);
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "DELETE FROM ChargeRespDetailT WHERE {SQL}", sqlChargeRespDetailFilter);
	
	//now create our desired new record - handle the case that it may already exist, in the event that
	//we filtered on only some of this charge resp's details

	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespDetailUpdate_ChargeRespID = {INT}", nChargeRespID);
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespDetailUpdate_NewDate = {OLEDATETIME}", AsDateNoTime(dtNewDate));
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespDetailUpdate_AmtToAdd = {OLECURRENCY}", cyTotalAmountToMove);

	//delete the old charge resp records					
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "DELETE FROM ChargeRespDetailT WHERE {SQL}", sqlChargeRespDetailFilter);

	//if a record exists for the new date, update it, otherwise make a new record
	AddParamStatementToSqlBatch(strSqlBatch, aryParams,
		"SET @ChargeRespDetailUpdate_ChargeRespDetailID = (SELECT ChargeRespDetailT.ID FROM ChargeRespDetailT WHERE ChargeRespID = @ChargeRespDetailUpdate_ChargeRespID AND Date = @ChargeRespDetailUpdate_NewDate) \r\n"
		"IF (@ChargeRespDetailUpdate_ChargeRespDetailID Is Not Null) \r\n"
		"BEGIN \r\n"
		"	UPDATE ChargeRespDetailT SET Amount = (Amount + @ChargeRespDetailUpdate_AmtToAdd) WHERE ID = @ChargeRespDetailUpdate_ChargeRespDetailID \r\n"
		"END \r\n"
		"ELSE BEGIN \r\n"
		"	INSERT INTO ChargeRespDetailT (ChargeRespID, Date, Amount) VALUES (@ChargeRespDetailUpdate_ChargeRespID, @ChargeRespDetailUpdate_NewDate, @ChargeRespDetailUpdate_AmtToAdd) \r\n"
		"	SET @ChargeRespDetailUpdate_ChargeRespDetailID = SCOPE_IDENTITY() "
		"END");

	//and now re-insert all applies, if any
	for (int i = 0; i < aryApplies.GetSize(); i++) {
		ApplyDetail *pad = aryApplies.GetAt(i);

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.armen 2013-06-29 14:14) - PLID 57386 - Idenitate ApplyDetailsT
		AddParamStatementToSqlBatch(strSqlBatch, aryParams,
			"INSERT INTO ApplyDetailsT (ApplyID, DetailID, Amount) VALUES ({INT}, @ChargeRespDetailUpdate_ChargeRespDetailID, {OLECURRENCY})",
			pad->nApplyID, pad->cyAmount);

		AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ApplyDetailID = SCOPE_IDENTITY()");

		//clear memory
		delete pad;
	}
	aryApplies.RemoveAll();
}

/* Creates a new bill. Only called on SaveChanges() after the user
defined the bill contents. If -1 is returned, this is considered to have failed. */
long CBillingDlg::CreateNewBill()
{
	COleDateTime dtDateTime = COleDateTime::GetCurrentTime(), dt;
	_variant_t var;
	CString strDesc;

	dt.SetDate(dtDateTime.GetYear(), dtDateTime.GetMonth(), dtDateTime.GetDay());

	long nBillID = -1;

	try {

		// (j.jones 2013-07-10 16:35) - PLID 57148 - if invoice numbers are turned on, auto-generate one now
		bool bCreateInvoiceNumber = false;
		long nInvoiceProviderID = -1;
		CSqlFragment sqlGenerateInvoiceID("");
		if (m_EntryType == 1 && GetRemotePropertyInt("EnableBillInvoiceNumbers", 0, 0, "<None>", true) == 1) {
			nInvoiceProviderID = GetFirstChargeProviderID();
			if (nInvoiceProviderID == -1) {
				//warn if they don't have a provider ID, respecting the preference to allow/disallow continuing
				if (GetRemotePropertyInt("RequireProviderOnCharges", 1, 0, "<None>", true) == 1) {
					MessageBox("An invoice number could not be generated because no charges have a provider selected.\n\n"
						"All new charges must have providers selected. Please correct this before saving.",
						"Practice", MB_ICONEXCLAMATION | MB_OK);
					return -1;
				}
				else if (IDNO == MessageBox("An invoice number could not be generated because no charges have a provider selected.\n\n"
					"Are you sure you wish to continue saving this bill without an invoice number?",
					"Practice", MB_ICONQUESTION | MB_YESNO)) {
					return -1;
				}
			}
			else {
				//we have a provider ID, we can now save an invoice number
				bCreateInvoiceNumber = true;

				sqlGenerateInvoiceID = CSqlFragment("SET @ProviderID = {INT} \r\n"
					""
					"SELECT @NewInvoiceID = COALESCE(MAX(InvoiceID), 0) + 1 FROM BillInvoiceNumbersT WITH (UPDLOCK, HOLDLOCK) WHERE ProviderID = @ProviderID \r\n"
					""
					"INSERT INTO BillInvoiceNumbersT (BillID, ProviderID, InvoiceID) VALUES (@NewBillID, @ProviderID, @NewInvoiceID) \r\n",
					nInvoiceProviderID);
			}

		}
		// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
		strDesc = GetBillDescriptionWithPrefix();

		_variant_t vtRefPhyID = g_cvarNull;

		if (m_EntryType == 1) {
			//DRT 3/2/2004 - PLID 11188 - Fixed datalist exceptions when accessing an invalid row.
			long nRefSel = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->CurSel;
			if (nRefSel != -1) {
				// (z.manning 2008-12-08 13:24) - PLID 32320 - Now have an enum for m_pRefList
				vtRefPhyID = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pRefList->GetValue(nRefSel, CInsuranceBilling::rpcID);
			}
		}

		// (j.armen 2013-06-28 10:37) - PLID 57367 - We should be inserting NULL, not -1. We won't fix the bad data here, but lets stop making it.
		if (vtRefPhyID.vt == VT_I4 && (vtRefPhyID.lVal == 0 || vtRefPhyID.lVal == -1))
			vtRefPhyID = g_cvarNull;

		COleDateTime dtInvalid, dtCurrentCondition, dtFirstCurrentCondition;
		dtInvalid.SetStatus(COleDateTime::invalid);

		_variant_t vtCurrentCondition = g_cvarNull;
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()
			&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetStatus() == 1) {
			vtCurrentCondition = _variant_t(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetDateTime(), VT_DATE);
		}

		// (r.gonet 2016-04-07) - NX-100072
		ClaimDates claimDates;
		if (m_EntryType == 1) {
			claimDates = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates;
		}

		// (s.tullis 2016-03-08 14:42) - PLID 68319 
		long nClaimForm = 1;
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd())
		{
			nClaimForm = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetFormTypeID();
		}

	
		// (j.jones 2009-09-21 11:37) - PLID 35564 - -1 is no longer allowed for insured party IDs, so set to NULL
		_variant_t vtInsuredPartyID = (m_GuarantorID1 == -1) ? g_cvarNull : m_GuarantorID1;
		_variant_t vtOthrInsuredPartyID = (m_GuarantorID2 == -1) ? g_cvarNull : m_GuarantorID2;

		// (j.dinatale 2012-02-07 12:36) - PLID 51181 - batched the bill ID in with the INSERT
		// (d.singleton 2012-07-26 15:18) - PLID 51835 - switch the coalesce and max
		// (j.armen 2013-06-28 10:37) - PLID 57367 - Idenitate BillsT, Parameterize
		// (j.jones 2013-07-11 09:20) - PLID 57148 - This recordset has been changed to optionally
		// include invoice number generation.
		// If disabled (which is usually will be), then the new invoice ID would be -1.
		// (r.gonet 2016-04-07) - NX-100072 - Split FirstConditionDate into mulitple date fields.

		//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp
		//and in SplitChargesIntoNewBill() in GlobalFinancialUtils.****//
		_RecordsetPtr prs = CreateParamRecordset(
			"SET NOCOUNT ON \r\n"
			"BEGIN TRAN \r\n"
			"DECLARE @NewBillID INT \r\n"
			"DECLARE @ProviderID INT \r\n"
			"DECLARE @NewInvoiceID INT \r\n"
			"SET @NewInvoiceID = -1 \r\n"
			""
			"INSERT INTO BillsT (\r\n"
			"	PatientID, [Date], EntryType, InputDate, InputName,\r\n"
			"	RefPhyID, InsuredPartyID, OthrInsuredPartyID, Description, Location,\r\n"
			"	ConditionDate, \r\n"
			"	FirstVisitOrConsultationDate, InitialTreatmentDate, LastSeenDate, AcuteManifestationDate, LastXRayDate, HearingAndPrescriptionDate, AssumedCareDate, RelinquishedCareDate, AccidentDate, \r\n"
			"	FormType\r\n"
			") VALUES (\r\n"
			"	{INT}, GetDate(), {INT}, GetDate(), {INT},\r\n"
			"	{VT_I4}, {VT_I4}, {VT_I4}, {STRING}, {INT},\r\n"
			"	{VT_DATE}, \r\n"
			"	{VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, {VT_DATE}, \r\n"
			"	{INT})\r\n"
			""
			"SET @NewBillID = CAST(SCOPE_IDENTITY() AS INT) \r\n"
			""
			"{SQL} "
			""
			"COMMIT TRAN \r\n"
			"SET NOCOUNT OFF \r\n"
			""
			"SELECT @NewBillID AS BillID, @NewInvoiceID AS InvoiceID",
			m_nPatientID, m_EntryType, GetCurrentUserID(),
			vtRefPhyID, vtInsuredPartyID, vtOthrInsuredPartyID, strDesc, GetCurrentLocationID(),
			vtCurrentCondition, 
			claimDates.dtFirstVisitOrConsultationDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtFirstVisitOrConsultationDate, VT_DATE) : g_cvarNull,
			claimDates.dtInitialTreatmentDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtInitialTreatmentDate, VT_DATE) : g_cvarNull,
			claimDates.dtLastSeenDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtLastSeenDate, VT_DATE) : g_cvarNull,
			claimDates.dtAcuteManifestationDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtAcuteManifestationDate, VT_DATE) : g_cvarNull,
			claimDates.dtLastXRayDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtLastXRayDate, VT_DATE) : g_cvarNull,
			claimDates.dtHearingAndPrescriptionDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtHearingAndPrescriptionDate, VT_DATE) : g_cvarNull,
			claimDates.dtAssumedCareDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtAssumedCareDate, VT_DATE) : g_cvarNull,
			claimDates.dtRelinquishedCareDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtRelinquishedCareDate, VT_DATE) : g_cvarNull,
			claimDates.dtAccidentDate.GetStatus() == COleDateTime::valid ? _variant_t(claimDates.dtAccidentDate, VT_DATE) : g_cvarNull,
			nClaimForm,
			sqlGenerateInvoiceID);

		nBillID = AdoFldLong(prs, "BillID");
		// (j.jones 2013-07-11 09:28) - PLID 57148 - added InvoiceID, will be -1 at all times
		// unless the invoice number feature is turned on
		long nInvoiceID = AdoFldLong(prs, "InvoiceID");

		// (j.jones 2010-08-17 12:03) - PLID 40135 - cache the insured party IDs on the insurance tab
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_nOldInsuranceID1 = m_GuarantorID1;
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_nOldInsuranceID2 = m_GuarantorID2;
		}

		long AuditID = -1;
		AuditID = BeginNewAuditEvent();
		if (m_EntryType == 1) {
			CString strAuditDesc = FormatString("Bill '%s' Created", strDesc);
			AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillCreated, nBillID, "", strAuditDesc, aepHigh);
		}
		else {
			CString strAuditDesc = FormatString("Quote '%s' Created", strDesc);
			AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiQuoteCreated, nBillID, "", strAuditDesc, aepMedium);
		}

		// (j.jones 2013-07-10 16:35) - PLID 57148 - if we did create an invoice number,
		// tell the additional info tab what it is
		if (bCreateInvoiceNumber && nInvoiceID != -1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetSavedInvoiceNumber(nInvoiceID, nInvoiceProviderID);
		}
	}
	NxCatchAll("BillingDlg::CreateNewBill");

	return nBillID;
}

/////////////////////////////////////////////////////////////////
// Save changes here
/////////////////////////////////////////////////////////////////

// (a.walling 2014-02-25 17:59) - PLID 61031 - Refactor BillingDlg::SaveChanges - Break up into major component functions

// order of logic maintained for mostly-clean diff

// maintains any info needed among the different components. Forward declared
// in BillingDlg.h so safe to change since only used in this .cpp
struct CBillingDlg::SaveInfo
{
	SaveInfo()
		: scr(SCR_SAVED)
		, IsNewBill(FALSE)
		, bChargesDeleted(false)
		, bChargesEdited(false)
		, bHadNewCharges(false)
		, bHadChangedServiceCodes(false)
		, nOldLocID(-1)
		, bDatesAccessible(FALSE)
		, sqlWhichCodes(CSqlFragment())
	{}

	int scr;

	BOOL IsNewBill;
	bool bChargesDeleted;
	bool bChargesEdited;
	bool bHadNewCharges;
	bool bHadChangedServiceCodes;
	// (j.jones 2008-09-16 09:09) - PLID 31376 - InvUtils::EnsureInventoryTodoAlarms
	// now supports multiple products at once, so build up an array as we save the charges
	CArray<long, long> aryProductIDs;
	long nOldLocID;
	BOOL bDatesAccessible;	//don't try to save the date if we can't access it
	COleDateTime dtOldBillDate;
	COleDateTime dtNewBillDate;
	COleDateTime dtCurrentCondition;
	// (r.gonet 2016-04-07) - NX-100072
	ClaimDates claimDates;
	// (r.gonet 07/01/2014) - PLID 62531 - The old bill status ID (BillStatusT.ID). -1 if no status selected.
	long nOldBillStatusID;
	// (r.gonet 07/01/2014) - PLID 62531 - The new bill status ID (BillStatusT.ID). -1 if no status selected.
	long nNewBillStatusID;
	// (r.gonet 07/01/2014) - PLID 62525 - The old bill status note ID (NoteDataT.ID). -1 if no note existed.
	long nOldBillStatusNoteID;
	// (r.gonet 07/01/2014) - PLID 62525 - The new bill status note ID (NoteDataT.ID). -1 if no note exists yet.
	long nNewBillStatusNoteID;
	// (r.gonet 07/01/2014) - PLID 62525 - The old bill status note text.
	CString strOldBillStatusNote;
	// (r.gonet 07/01/2014) - PLID 62525 - The new bill status note text.
	CString strNewBillStatusNote;

	// (j.jones 2013-08-20 10:57) - PLID 57959 - Renamed the existing boolean
	// for new charges, and added bHadChangedServiceCodes which tracks whether
	// the service code changed on an existing charge.
	CMap<long, long, bool, bool> mapChargeIDsWithChangedServiceCodes;
	CMap<long, long, COleCurrency, COleCurrency> mapChargeIDsToCoinsurance;

	// (j.gruber 2014-02-26 09:10) - PLID 60893 - whichCodes
	CSqlFragment sqlWhichCodes;
};

int CBillingDlg::SaveChanges_Validate(SaveInfo& info)
{

	/***********************************
	* Ensure practice is open          *
	***********************************/
	EnsureRemoteData();

	// (j.jones 2010-02-05 17:26) - PLID 37251 - check the old location and date now,
	// ValidateChanges() needs to know if the date changed
	info.dtOldBillDate.SetStatus(COleDateTime::invalid);
	if (GetBillID() != -1) {
		// (r.gonet 07/01/2014) - PLID 62531 - Get the original bill status so we can compare it to see if it changed.
		// (r.gonet 07/01/2014) - PLID 62525 - Get the original bill status note and the user so we can compare it to see if it changed.
		_RecordsetPtr rs = CreateParamRecordset(
			"SELECT BillsT.Location, BillsT.Date, "
			"	BillsT.StatusID AS BillStatusID, "
			"	StatusNoteDataT.ID AS BillStatusNoteID, StatusNoteDataT.Note AS BillStatusNote, StatusNoteInputUserT.Username AS BillStatusNoteUsername "
			"FROM BillsT "
			"LEFT JOIN NoteDataT StatusNoteDataT ON BillsT.StatusNoteID = StatusNoteDataT.ID "
			"LEFT JOIN UsersT StatusNoteInputUserT ON StatusNoteDataT.UserID = StatusNoteInputUserT.PersonID "
			"WHERE BillsT.ID = {INT}"
			, GetBillID());
		info.nOldLocID = AdoFldLong(rs, "Location");
		info.dtOldBillDate = AdoFldDateTime(rs, "Date");
		// (r.gonet 07/01/2014) - PLID 62520 - The original bill status
		info.nOldBillStatusID = AdoFldLong(rs, "BillStatusID", -1);
		// (r.gonet 07/01/2014) - PLID 62525 - The original bill status note
		info.nOldBillStatusNoteID = AdoFldLong(rs, "BillStatusNoteID", -1);
		// (r.gonet 07/01/2014) - PLID 62525 - We don't show the username in the billing dialog, so to compare the saved one to the current one, we
		// need to remove it.
		info.strOldBillStatusNote = RemoveUsernameFromStatusNote(AdoFldString(rs, "BillStatusNote", ""), AdoFldString(rs, "BillStatusNoteUsername", ""));
		rs->Close();
	} else {
		// (r.gonet 07/01/2014) - PLID 62531 - New bills don't have old bill statuses yet
		info.nOldBillStatusID = -1;
		// (r.gonet 07/01/2014) - PLID 62525 - New bills don't have old bill status notes yet
		info.nOldBillStatusNoteID = -1;
		info.strOldBillStatusNote = "";
	}

	info.dtNewBillDate = (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_date.GetValue());

	//default to true, so if this is a new bill, we will validate the bill date
	BOOL bBillDateChanged = TRUE;
	if (GetBillID() != -1 && CompareDateIgnoreTime(info.dtOldBillDate, info.dtNewBillDate) == 0) {
		bBillDateChanged = FALSE;
	}

	if (m_EntryType == 1) {
		// (r.gonet 07/01/2014) - PLID 62531 - Get the new selected bill status so we can compare it to the original
		NXDATALIST2Lib::IRowSettingsPtr pBillStatusRow = m_pBillStatusCombo->CurSel;
		if (pBillStatusRow != NULL) {
			info.nNewBillStatusID = VarLong(pBillStatusRow->GetValue((short)EBillStatusComboColumns::ID), -1);
		} else {
			// (r.gonet 07/01/2014) - PLID 62531 - This shouldn't happen because we don't allow them to select null, 
			// but handle it if it does.
			info.nNewBillStatusID = -1;
		}

		// (r.gonet 07/24/2014) - PLID 62520 - The bill needs to be put on hold if it consists entirely of
		//  on hold charges.
		if (GetBillStatusType() != EBillStatusType::OnHold && GetOnHoldChargeCount() > 0 && GetNotOnHoldChargeCount() == 0) {
			if (IDYES != MessageBox("This bill will be put on hold because all charges have been marked on hold. Do you want to continue saving?", "All Charges On Hold", MB_ICONWARNING | MB_YESNO)) {
				return SCR_ABORT_SAVE;
			}
			NXDATALIST2Lib::IRowSettingsPtr pBillStatusRow = m_pBillStatusCombo->GetFirstRow();
			while (pBillStatusRow) {
				long nStatusID = VarLong(pBillStatusRow->GetValue((short)EBillStatusComboColumns::ID));
				EBillStatusType eBillStatusType = (EBillStatusType)VarLong(pBillStatusRow->GetValue((short)EBillStatusComboColumns::Type), (long)EBillStatusType::None);
				BOOL bCustom = VarBool(pBillStatusRow->GetValue((short)EBillStatusComboColumns::Custom));
				BOOL bInactive = VarBool(pBillStatusRow->GetValue((short)EBillStatusComboColumns::Inactive));
				if (eBillStatusType == EBillStatusType::OnHold && !bCustom && !bInactive) {
					m_pBillStatusCombo->CurSel = pBillStatusRow;
					SelChosenBillStatusCombo(pBillStatusRow);
					info.nNewBillStatusID = nStatusID;
					break;
				}
				pBillStatusRow = pBillStatusRow->GetNextRow();
			}
		}

		// (r.gonet 07/01/2014) - PLID 62525 - Get the new status note se we can compare it to the original
		m_nxeditBillStatusNote.GetWindowText(info.strNewBillStatusNote);
		info.nNewBillStatusNoteID = -1;
	} else {
		// (r.gonet 07/01/2014) - PLID 62531 - Quotes don't have bill statuses.
		info.nNewBillStatusID = -1;
		// (r.gonet 07/01/2014) - PLID 62525 - Quotes don't have bill status notes.
		info.nNewBillStatusNoteID = -1;
		info.strNewBillStatusNote = "";
	}


	if (!ValidateChanges(bBillDateChanged)) {
		return SCR_ABORT_SAVE;
	}

	// (j.jones 2009-09-14 15:37) - PLID 35382 - try to link case histories to the bill
	if (m_pList->GetRowCount() > 0 && m_EntryType == 1 && IsSurgeryCenter(FALSE)) {
		TryLinkCaseHistoriesByProcedure();
	}

	/***********************************
	* Don't make a new empty bill      *
	***********************************/
	if (GetBillID() == -1 && m_pList->GetRowCount() == 0) {
		return SCR_NOT_SAVED;
	}

	/***********************************
	* Make new bill if non-existent    *
	***********************************/
	if (GetBillID() == -1) {
		info.IsNewBill = TRUE;
		SetBillID(CreateNewBill());
	}

	/************************************
	* If the bill is invalid,			*
	* CreateNewBill() will have already *
	* displayed an error box. Just exit.*
	*************************************/
	if (GetBillID() == -1) {
		// (j.jones 2013-07-11 10:03) - PLID 57148 - changed to SCR_ABORT_SAVE
		// from SCR_NOT_SAVED, so that the bill dialog doesn't close
		return SCR_ABORT_SAVE;
	}

	// Check for no charges
	if (m_pList->GetRowCount() == 0) {
		DeleteBill(GetBillID());
		return SCR_NOT_SAVED;
	}

	// (d.singleton 2014-03-06 12:05) - PLID 61221 - propt / warn if they have the icd10 pref enabled but the insured party on a bill requires icd9
	// dont warn if we dont have any icd9/10 codes selected
	if (!m_arypDiagCodes.IsEmpty()) {
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.EnsureInitialized();
			//get our insured party id's and ins company names from the insurance tab;
			long nRow, nPriInsID, nSecInsID;
			nRow = nPriInsID = nSecInsID = -1;
			CString strPriInsComp, strSecInsComp;
			nRow = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->CurSel;
			if (nRow != -1) {
				nPriInsID = VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->GetValue(nRow, 0), -1);
				strPriInsComp = VarString(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->GetValue(nRow, 1), "");
			}
			nRow = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->CurSel;
			if (nRow != -1) {
				nSecInsID = VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->GetValue(nRow, 0), -1);
				strSecInsComp = VarString(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->GetValue(nRow, 1), "");
			}

			//get our search pref
			DiagCodeSearchStyle eSearchStyle = DiagSearchUtils::GetPreferenceSearchStyle();
			//get our min service date
			COleDateTime dtMinServiceDate = g_cdtInvalid;
			for each(BillingItemPtr pItem in m_billingItems) {
				COleDateTime dtItemDate = COleVariant(pItem->Date);
				if (dtMinServiceDate.GetStatus() == COleDateTime::invalid || dtItemDate < dtMinServiceDate) {
					dtMinServiceDate = dtItemDate;
				}
			}

			//check stuff
			BOOL bWarn = FALSE;
			CString strCompanies;
			long nCompanyCount = 0;
			if (nPriInsID != -1 && !ShouldUseICD10(nPriInsID, dtMinServiceDate)) {
				bWarn = TRUE;
				strCompanies += strPriInsComp + "\n";
				nCompanyCount++;
			}

			if (nSecInsID != -1 && !ShouldUseICD10(nSecInsID, dtMinServiceDate)) {
				bWarn = TRUE;
				strCompanies += strSecInsComp + "\n";
				nCompanyCount++;
			}
			if (bWarn && eSearchStyle == eManagedICD10_Search) {
				CString strWarning;
				strWarning.Format("The following %s the use of ICD-9 codes, however, the preference to only use ICD-10 codes is enabled. "
					"Are you sure you want to save the bill?\n\n%s",
					nCompanyCount == 1 ? "company requires" : "companies require",
					strCompanies);

				if (MessageBox(strWarning, "Practice", MB_YESNO | MB_ICONWARNING) == IDNO) {
					return SCR_ABORT_SAVE;
				}
			}
		}
	}


	// (j.dinatale 2013-05-14 08:49) - PLID 30600 - while this doesn't cover all cases (there is that rare chance that one person can be saving, and during that save, some one decides to delete)
	//		I suspect it will catch most of them. The real problem here is that saving a bill is entire adhoc and has a ton of queries that fire. This is the best we can do without redoing the entire
	//		bill saving logic.
	if (ReturnsRecordsParam("SELECT TOP 1 1 FROM BillsT WHERE ID = {INT} AND Deleted = 1", GetBillID())){
		m_pBillingModuleWnd->MessageBox("This bill has been deleted by another user. Please close this bill and attempt to recreate it.", "Alert!", MB_OK | MB_ICONEXCLAMATION);
		return SCR_ABORT_SAVE;
	}

	// (j.dinatale 2012-03-20 14:41) - PLID 48893 - ensure that any glasses orders that were added are not already billed
	// TODO: Determine if we actually do need to prevent saving if a glasses order has already been billed.
	if (!m_setBilledOpticalOrderIDs.empty()){
		CArray<long, long> aryOpticalOrders;
		aryOpticalOrders.SetSize(m_setBilledOpticalOrderIDs.size());
		std::copy(m_setBilledOpticalOrderIDs.begin(), m_setBilledOpticalOrderIDs.end(),
			stdext::checked_array_iterator<long*>(aryOpticalOrders.GetData(), aryOpticalOrders.GetSize()));

		if (ReturnsRecordsParam(
			"SELECT TOP 1 1 FROM GlassesOrderT "
			"LEFT JOIN BillsT ON GlassesOrderT.BillID = BillsT.ID "
			"LEFT JOIN BillCorrectionsT ON BillsT.ID = BillCorrectionsT.OriginalBillID "
			"INNER JOIN ( "
			"	SELECT DISTINCT BillID "
			"	FROM "
			"	LineItemT "
			"	INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
			" 	WHERE LineItemT.Deleted = 0 "
			") ChargesSubQ ON BillsT.ID = ChargesSubQ.BillID "
			"WHERE BillsT.Deleted = 0 AND BillCorrectionsT.ID IS NULL AND GlassesOrderT.ID IN ({INTARRAY})",
			aryOpticalOrders)){
			m_pBillingModuleWnd->MessageBox("This bill has charges for an optical order that has already been billed. "
				"Please close this bill and attempt to recreate it.", "Alert!", MB_OK | MB_ICONEXCLAMATION);
			return SCR_ABORT_SAVE;
		}
	}

	return SCR_SAVED;
}

int CBillingDlg::SaveChanges_ValidateCPTICD9Link(SaveInfo& info)
{
	/***************************************
	* Check to see if ICD9s and CPTs match *
	***************************************/

	try {
		if (m_EntryType == 1) {
			// (r.gonet 02/20/2014) - PLID 60778 - Renamed to remove reference to ICD-9
			if (GetRemotePropertyInt("LinkCPTDiagnosisCodes", 0, 0, "<None>", TRUE) == 1) {

				//first check for BLOCKED codes

				//first ICD-9 codes
				if (!CheckForBlockedICD9Codes()) {
					return SCR_ABORT_SAVE;
				}

				//then CPT codes / products
				// (j.jones 2013-04-10 11:39) - PLID 56179 - renamed to say services, since it can
				// be CPT codes or products now
				if (!CheckForBlockedServices()) {
					return SCR_ABORT_SAVE;
				}

				//now check for LINKED codes

				// (j.jones 2013-04-10 11:39) - PLID 56179 - renamed to say services, since it can
				// be CPT codes or products now
				if (!CheckForLinkedServices()) {
					return SCR_ABORT_SAVE;
				}
			}
		}
		// (r.gonet 03/07/2014) - PLID 61117 - Remove references to ICD-9 in exceptions (aside from function names)
	}NxCatchAll(__FUNCTION__);

	return SCR_SAVED;
}


int CBillingDlg::SaveChanges_ValidateConditionDates(SaveInfo& info)
{
	COleDateTime dtInvalid;
	dtInvalid.SetStatus(COleDateTime::invalid);
	COleDateTime dtOldDate;
	dtOldDate.SetDateTime(1800, 1, 1, 1, 1, 1);

	info.bDatesAccessible = FALSE;	//don't try to save the date if we can't access it

	if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()
		&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetStatus() == 1) {

		info.bDatesAccessible = TRUE;

		info.dtCurrentCondition = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetDateTime();

		// (j.jones 2012-01-23 15:49) - PLID 47731 - added condition date combo
		// (r.gonet 2016-04-07) - NX-100072
		info.claimDates.eConditionDateType = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates.eConditionDateType;

		if (info.dtCurrentCondition < dtOldDate) {
			AfxMessageBox("The 'Date of Current Illness / Injury' date is before the year 1800.\n"
				"Please correct this date before saving.");
			return SCR_ABORT_SAVE;
		}

		if (info.dtCurrentCondition > COleDateTime::GetCurrentTime()) {
			AfxMessageBox("The 'Date of Current Illness / Injury' is after today.\n"
				"Please correct this date before saving.");
			return SCR_ABORT_SAVE;
		}
	} else {
		info.dtCurrentCondition = dtInvalid;	// Date of current accident
	}

	// (r.gonet 2016-04-07) - NX-100072 - Changed to use the ClaimDates structure.
	if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
		const ClaimDates& claimDates = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates;
		if (claimDates.AnyFilledAndValid()) {
			info.bDatesAccessible = TRUE;
			info.claimDates = claimDates;

			CString strValidationWarning = claimDates.GetValidationWarning();
			if (!strValidationWarning.IsEmpty()) {
				AfxMessageBox(strValidationWarning);
				return SCR_ABORT_SAVE;
			}
		} else {
			info.claimDates.Clear();
		}
	}

	return SCR_SAVED;
}

int CBillingDlg::SaveChanges_G2DiagCodes(SaveInfo& info)
{
	/***************************************
	* Check to see if DiagCodes match G2   *
	***************************************/

	try {
		//DRT 4/28/03 - Compare the diag codes with those chosen in general 2.  Then act appropriately based on the preference
		//		that is chosen.

		//0 = never update, 1 = prompt, 2 = always update
		if (m_EntryType == 1) {
			// (d.thompson 2012-06-27) - PLID 51220 - Changed default to never (0)
			long nDiagType = GetRemotePropertyInt("CopyDiagnosisCodes", 0, 0, "<None>", true);
			//(b.spivey - March 17th, 2014) PLID 61396 - Update the G2 diag codes. 
			if (info.IsNewBill && nDiagType != 0) {
				//only on new charges
				UpdateG2DefaultDiagnosisCodes(nDiagType == 1);
			}

		}
	}NxCatchAll("Error linking DiagCodes to General 2.");

	return SCR_SAVED;
}

int CBillingDlg::SaveChanges_TrackedAllocations(SaveInfo& info)
{
	// (j.jones 2007-12-11 12:42) - PLID 27988 - save any allocations that we worked on, that were not already completed
	if (!SaveTrackedAllocations()) {
		return SCR_ABORT_SAVE;
	}

	return SCR_SAVED;
}

void CBillingDlg::SaveChanges_BilledQuotes(SaveInfo& info)
{
	//save the newly billed quotes
	for (int q = 0; q < m_arypBilledQuotes.GetSize(); q++) {
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		if (!ReturnsRecordsParam("SELECT ID FROM BilledQuotesT WHERE QuoteID = {INT} AND BillID = {INT}", ((BilledQuote*)m_arypBilledQuotes.GetAt(q))->nQuoteID, GetBillID())) {
			//we have not already saved it to this bill, so save it now
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			ExecuteParamSql("INSERT INTO BilledQuotesT (ID, BillID, QuoteID) VALUES ({INT}, {INT}, {INT})",
				NewNumber("BilledQuotesT", "ID"), GetBillID(), ((BilledQuote*)m_arypBilledQuotes.GetAt(q))->nQuoteID);
		}
	}
}

void CBillingDlg::SaveChanges_CaseHistories(SaveInfo& info)
{
	long nAuditTransactionID_CaseHistories = -1;
	try {

		// (j.jones 2009-08-06 10:26) - PLID 35120 - supported multiple case histories per bill	
		if (IsSurgeryCenter(false) && m_EntryType == 1) {

			CString strSqlBatch;

			// (j.jones 2009-08-11 16:32) - PLID 35142 - we now track what case history IDs we loaded
			// when opening the bill, we need to save the new ones only
			int i = 0;
			for (i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {

				CaseHistoryInfo *pNewCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);

				BOOL bFound = FALSE;
				for (int j = 0; j < m_arypOldBilledCaseHistories.GetSize() && !bFound; j++) {

					CaseHistoryInfo *pOldCase = (CaseHistoryInfo*)m_arypOldBilledCaseHistories.GetAt(j);

					if (pNewCase->nCaseHistoryID == pOldCase->nCaseHistoryID) {
						bFound = TRUE;
					}
				}

				if (!bFound) {
					//save this case history
					AddStatementToSqlBatch(strSqlBatch, "INSERT INTO BilledCaseHistoriesT (BillID, CaseHistoryID) "
						"SELECT %li, %li WHERE NOT EXISTS (SELECT BillID FROM BilledCaseHistoriesT WHERE BillID = %li AND CaseHistoryID = %li)",
						GetBillID(), pNewCase->nCaseHistoryID, GetBillID(), pNewCase->nCaseHistoryID);

					// (j.jones 2009-08-12 13:29) - PLID 35179 - added auditing for this
					// audit even if the above does nothing, that code is just a failsafe that should rarely occur if ever

					CString strOldValue, strNewValue;
					strOldValue.Format("Case History: %s (%s)", pNewCase->strCaseHistoryName, FormatDateTimeForInterface(pNewCase->dtSurgeryDate, NULL, dtoDate));

					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
					CString strBillDesc = GetBillDescriptionWithPrefix();
					strNewValue.Format("Linked To Bill: %s (%s)", strBillDesc, FormatDateTimeForInterface((((CBillingModuleDlg*)m_pBillingModuleWnd)->m_date.GetValue()), NULL, dtoDate));

					if (nAuditTransactionID_CaseHistories == -1) {
						nAuditTransactionID_CaseHistories = BeginAuditTransaction();
					}
					AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID_CaseHistories, aeiLinkedCaseHistoryToBill, pNewCase->nCaseHistoryID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}

			// (j.jones 2009-08-11 16:32) - PLID 35142 - similarly, we need to unlink the ones we've removed
			for (i = 0; i < m_arypOldBilledCaseHistories.GetSize(); i++) {

				CaseHistoryInfo *pOldCase = (CaseHistoryInfo*)m_arypOldBilledCaseHistories.GetAt(i);

				BOOL bFound = FALSE;
				for (int j = 0; j < m_arypBilledCaseHistories.GetSize(); j++) {
					CaseHistoryInfo *pNewCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(j);
					if (pNewCase->nCaseHistoryID == pOldCase->nCaseHistoryID) {
						bFound = TRUE;
					}
				}

				if (!bFound) {
					//unlink this case history
					AddStatementToSqlBatch(strSqlBatch, "DELETE FROM BilledCaseHistoriesT WHERE BillID = %li AND CaseHistoryID = %li",
						GetBillID(), pOldCase->nCaseHistoryID);

					// (j.jones 2009-08-12 13:29) - PLID 35179 - added auditing for this

					CString strOldValue, strNewValue;
					strOldValue.Format("Case History: %s (%s)", pOldCase->strCaseHistoryName, FormatDateTimeForInterface(pOldCase->dtSurgeryDate, NULL, dtoDate));

					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
					CString strBillDesc = GetBillDescriptionWithPrefix();
					strNewValue.Format("Unlinked From Bill: %s (%s)", strBillDesc, FormatDateTimeForInterface((((CBillingModuleDlg*)m_pBillingModuleWnd)->m_date.GetValue()), NULL, dtoDate));

					if (nAuditTransactionID_CaseHistories == -1) {
						nAuditTransactionID_CaseHistories = BeginAuditTransaction();
					}
					AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID_CaseHistories, aeiUnlinkedCaseHistoryFromBill, pOldCase->nCaseHistoryID, strOldValue, strNewValue, aepMedium, aetChanged);
				}
			}

			if (!strSqlBatch.IsEmpty()) {
				ExecuteSqlBatch(strSqlBatch);
			}

			if (nAuditTransactionID_CaseHistories != -1) {
				CommitAuditTransaction(nAuditTransactionID_CaseHistories);
				nAuditTransactionID_CaseHistories = -1;
			}

			// (j.jones 2009-08-11 16:32) - PLID 35142 - now update so the "old" list matches the "new" list
			// (j.jones 2009-08-12 15:32) - PLID 35179 - this is now an array of pointers
			ClearOldCaseHistoryArray();

			for (i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {
				CaseHistoryInfo *pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);
				if (pCase) {
					CaseHistoryInfo *pNewCase = new CaseHistoryInfo;
					pNewCase->nCaseHistoryID = pCase->nCaseHistoryID;
					pNewCase->strCaseHistoryName = pCase->strCaseHistoryName;
					pNewCase->dtSurgeryDate = pCase->dtSurgeryDate;
					m_arypOldBilledCaseHistories.Add(pNewCase);
				}
			}
		}

	} NxCatchAllCall("Error saving linked case history information.",
		if (nAuditTransactionID_CaseHistories != -1) {
		RollbackAuditTransaction(nAuditTransactionID_CaseHistories);
		}
	);
}

void CBillingDlg::SaveChanges_BilledEMNs(SaveInfo& info)
{
	//save the newly billed EMNs
	long nAuditID = -1;
	// (j.jones 2012-01-19 12:24) - PLID 47653 - this now tracks the EMNID, the insured party ID
	// that the EMN was *originally* added to the bill under, and the resp. name
	for (int e = 0; e < m_aryBilledEMNInfo.GetSize(); e++) {
		BilledEMNInfo eInfo = (BilledEMNInfo)m_aryBilledEMNInfo.GetAt(e);
		// (j.jones 2012-01-19 12:22) - PLID 47653 - supported InsuredPartyID, which is nullable
		_variant_t varInsuredPartyID = g_cvarNull;
		if (eInfo.nInsuredPartyID != -1) {
			varInsuredPartyID = (long)eInfo.nInsuredPartyID;
		}
		_RecordsetPtr rsEMNCheck = CreateParamRecordset("SELECT ID FROM BilledEMNsT "
			"WHERE EMNID = {INT} AND BillID = {INT} AND InsuredPartyID = {VT_I4}", eInfo.nEMNID, GetBillID(), varInsuredPartyID);

		if (rsEMNCheck->eof) {
			//we have not already saved it to this bill, so save it now
			// (j.armen 2014-01-30 17:15) - PLID 60566 - Idenitate BilledEMNsT
			ExecuteParamSql("INSERT INTO BilledEMNsT (BillID, EMNID, InsuredPartyID) VALUES ({INT}, {INT}, {VT_I4})",
				GetBillID(), eInfo.nEMNID, varInsuredPartyID);

			// (j.jones 2009-06-25 09:36) - PLID 24076 - audit this
			if (nAuditID == -1) {
				nAuditID = BeginNewAuditEvent();
			}

			CString strOldValue, strEMNDesc;
			_RecordsetPtr rsEMNName = CreateParamRecordset("SELECT Description FROM EMRMasterT WHERE ID = {INT}", eInfo.nEMNID);
			if (!rsEMNName->eof) {
				strEMNDesc = AdoFldString(rsEMNName, "Description", "");
			}
			rsEMNName->Close();
			strOldValue.Format("EMN: %s", strEMNDesc);

			CString strNewValue;
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			CString strBillDesc = GetBillDescriptionWithPrefix();
			COleDateTime dtBillDate = (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_date.GetValue());

			// (j.jones 2012-01-19 12:23) - PLID 47653 - audit the ins. resp. name
			strNewValue.Format("Linked To Bill: %s (%s) for %s responsibility.", strBillDesc,
				FormatDateTimeForInterface(dtBillDate, NULL, dtoDate), eInfo.strRespTypeName);

			AuditEvent(m_nPatientID, GetBillPatientName(), nAuditID, aeiEMNBilled, eInfo.nEMNID, strOldValue, strNewValue, aepMedium, aetCreated);
		}
		rsEMNCheck->Close();
	}
}

void CBillingDlg::SaveChanges_DecrementPackageCount(SaveInfo& info)
{
	//decrement the package count
	if (m_bIsABilledPackage && m_nPackageType != 2) {
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		ExecuteParamSql("UPDATE PackagesT SET CurrentCount = CurrentCount - {INT} WHERE QuoteID = {INT}", m_RepeatPackageUses, m_nPackageID);
		//used so this won't decrement twice if the SaveChanges function is called twice
		m_bIsABilledPackage = FALSE;
	}
}

// (j.jones 2007-10-05 16:13) - PLID 25349 - Moved the deletion of old charges to be prior to the saving of
// new/existing charges. Now you might say "hey! what if saving the new charges fail?", but you'll note
// that there's a lot of critical code before this already that gets saved, and so we're already screwed
// if anything fails. A future PL item is going to stop this from occurring.

void CBillingDlg::SaveChanges_DeleteCharges(SaveInfo& info)
{
	///////////////////////////////////
	// Delete old charges
	for (int i = 0; i < m_adwDeletedCharges.GetSize(); i++) {
		DeleteCharge(m_adwDeletedCharges.GetAt(i), GetBillID(), FALSE, FALSE);
	}
}

void CBillingDlg::SaveChanges_Charges(SaveInfo& info)
{
	//TES 4/9/2008 - PLID 29585 - We're about to start looping through charges, let them know that it's ok to audit the
	// location, because we haven't done so yet in this save.
	m_bLocationAudited = false;

	/////////////////////////////////////////
	// Add new charges (if any)

	// (j.jones 2013-08-20 10:57) - PLID 57959 - Renamed the existing boolean
	// for new charges, and added bHadChangedServiceCodes which tracks whether
	// the service code changed on an existing charge.
	info.mapChargeIDsWithChangedServiceCodes.RemoveAll();
	info.mapChargeIDsToCoinsurance.RemoveAll();

	// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
	//LogDetail("Adding %d new charges", count);
	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {

		// Get ChargeID
		COleVariant var = pRow->GetValue(COLUMN_CHARGE_ID);
		// Must be a new charge
		if (var.lVal == -2) {
			CString strDesc;

			if (m_EntryType == 1)
				var = pRow->GetValue(BILL_COLUMN_DESCRIPTION);
			else
				var = pRow->GetValue(QUOTE_COLUMN_DESCRIPTION);

			if (var.vt != VT_NULL && strlen(CString(var.bstrVal)) > 0)
				strDesc = CString(var.bstrVal);
			else
				strDesc = "(no description)";
			strDesc = _Q(strDesc);

			var = pRow->GetValue(COLUMN_LINE_ID);

			// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
			//LogDetail(("Attempting to apply charge %d - Description = %s", var.lVal, strDesc);
			if (!ApplyChargeToBill(var.lVal, -2, info.IsNewBill, info.sqlWhichCodes)) {
				// (j.jones 2007-02-21 12:10) - PLID 24835 - changed to abort, instead of skipping the charge
				info.scr = SCR_ABORT_SAVE;
				return;
			}

			// (j.jones 2008-09-16 09:09) - PLID 31376 - if a product, track its ID (bills only)
			if (m_EntryType == 1) {
				long nItemType = VarLong(pRow->GetValue(COLUMN_ITEM_TYPE), -1);
				if (nItemType == ITEM_TYPE_PRODUCT) {
					long nServiceID = VarLong(pRow->GetValue(COLUMN_SERVICE_ID), -1);
					if (nServiceID != -1) {
						info.aryProductIDs.Add(nServiceID);
					}
				}
			}

			// (a.walling 2007-05-31 16:36) - PLID 26079
			info.bHadNewCharges = true;
		}

		pRow = pRow->GetNextRow();
	}

	// (j.jones 2008-02-12 11:42) - PLID 28848 - we may update the charge's batched status when we save,
	// but if the user edited an existing bill and didn't change anything, we have to mark those charges
	// as needing to be saved

	//require both preferences to be enabled for this to go into effect
	if (m_EntryType == 1 && GetRemotePropertyInt("DisallowBatchingPatientClaims", 0, 0, "<None>", TRUE) == 1 &&
		GetRemotePropertyInt("HidePatientChargesOnClaims", 0, 0, "<None>", TRUE) == 1) {

		//any batched charges with 100% patient resp need saved	
		int j = 0;
		for (j = 0; j < (int)m_billingItems.size(); j++) {

			BOOL bBatched = VarBool(m_billingItems[j]->Batched, TRUE);
			long nChargeID = VarLong(m_billingItems[j]->ChargeID, -2);
			if (bBatched && nChargeID != -2) {

				BOOL bHasInsResp = FALSE;
				RPCList* list = m_billingItems[j]->RPCList;
				int k = 0;
				for (k = 0; k < list->aryRPC.GetSize() && !bHasInsResp; k++) {
					RespPerCharge rpc = list->aryRPC.GetAt(k);

					COleCurrency cyInsResp = (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));

					if (cyInsResp > COleCurrency(0, 0)) {
						bHasInsResp = TRUE;
					}
				}

				if (!bHasInsResp) {
					//if we don't have any insurance resp. on this charge,
					//we have to uncheck the batched status, which saving will do,
					//so just mark the item as needing to be saved

					// (j.jones 2010-09-29 16:16) - PLID 40686 - this isn't necessarily true anymore
					// for all charges, but we will let the save code handle the check to unbatch
					AddToModifiedList(nChargeID);
				}
			}
		}
	}

	////////////////////////////////////
	// Edit existing charges
	try {

		// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
		//LogDetail("Editing %d existing charges...", m_adwEditedCharges.GetSize());

		for (int i = 0; i < m_adwEditedCharges.GetSize(); i++) {
			/* Get Line ID by searching for Charge ID */
			int q;
			_variant_t var;
			IRowSettingsPtr pLoopRow = m_pList->GetFirstRow();
			while (pLoopRow) {
				var = pLoopRow->GetValue(COLUMN_CHARGE_ID);
				q = (long)m_adwEditedCharges[i];
				if (var.lVal == (long)m_adwEditedCharges[i]) {
					break;
				}

				pLoopRow = pLoopRow->GetNextRow();
			}

			// Now fetch the line ID
			var = pLoopRow->GetValue(COLUMN_LINE_ID);

			// (j.jones 2013-08-20 10:57) - PLID 57959 - track whether
			// the service code changed on any existing charge
			{
				BOOL bFound = FALSE;
				for (int j = 0; j < (int)m_billingItems.size() && !bFound; j++) {
					if (VarLong(m_billingItems[j]->LineID, -1) == VarLong(var)) {
						bFound = TRUE;
						break;
					}
				}

				if (bFound && VarBool(m_billingItems[j]->HasServiceCodeChanged, FALSE)) {
					info.bHadChangedServiceCodes = true;
					//add to our map
					info.mapChargeIDsWithChangedServiceCodes.SetAt(m_adwEditedCharges[i], true);
				}
			}

			// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
			//LogDetail("Applying charge %d",  var.lVal);
			if (!ApplyChargeToBill(var.lVal, m_adwEditedCharges[i], info.IsNewBill, info.sqlWhichCodes)) {
				// (j.jones 2007-02-21 12:10) - PLID 24835 - changed to abort, instead of skipping the charge
				info.scr = SCR_ABORT_SAVE;
				return;
			}

			// (j.jones 2008-09-16 09:09) - PLID 31376 - if a product, track its ID (bills only)
			if (m_EntryType == 1) {
				long nItemType = VarLong(pLoopRow->GetValue(COLUMN_ITEM_TYPE), -1);
				if (nItemType == ITEM_TYPE_PRODUCT) {
					long nServiceID = VarLong(pLoopRow->GetValue(COLUMN_SERVICE_ID), -1);
					if (nServiceID != -1) {
						info.aryProductIDs.Add(nServiceID);
					}
				}
			}
		}

	}
	NxCatchAll("BillingDlg::SaveChanges - Existing Charges");
}

void CBillingDlg::SaveChanges_InventoryTodoAlarms(SaveInfo& info)
{
	_variant_t var;
	// (c.haag 2008-02-07 13:14) - PLID 28853 - Moved old call to ChangeInventoryQuantity
	// to after the transaction has completed. Also renamed call to EnsureInventoryTodoAlarms
	// and removed quantity parameter because it would always be 0 now that the charges have
	// been saved.
	// (j.jones 2008-09-16 09:12) - PLID 31376 - the call to EnsureInventoryTodoAlarms now supports
	// running one time for all products, so do it now if we have products, and this is a bill
	try {
		if (m_EntryType == 1 && info.aryProductIDs.GetSize() > 0) {

			long nLocationID = -1;
			if (m_LocationCombo->GetCurSel() == -1) {
				if (CString((LPCTSTR)m_LocationCombo->ComboBoxText) != "") {
					//It's an inactive location, leave it.
					//We don't want to change the location.
					_RecordsetPtr rsLocID = CreateParamRecordset("SELECT TOP 1 LocationID, LocationsT.Name FROM LineItemT INNER JOIN LocationsT ON LineItemT.LocationID = LocationsT.ID WHERE LineItemT.ID IN (SELECT ID FROM ChargesT WHERE BillID = {INT})", GetBillID());
					if (!rsLocID->eof) {
						nLocationID = AdoFldLong(rsLocID, "LocationID");
					}
				}
				else {
					nLocationID = GetCurrentLocationID();
				}
			}
			else {
				var = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0);
				if (var.vt == VT_I4) {
					nLocationID = VarLong(var);
				}
				else {
					nLocationID = GetCurrentLocationID();
				}
			}

			InvUtils::EnsureInventoryTodoAlarms(info.aryProductIDs, nLocationID, false);//Should be the bill location
		}
		// (c.haag 2008-02-07 13:43) - If this errors out, let the save continue. As with updating 
		// the HCFA table, the failure of the code block cannot roll back any transactions, and
		// will not have an adverse effect on the bill and inventory totals.
	} NxCatchAll("BillingDlg::SaveChanges - Inventory TODO Alarms");
}

void CBillingDlg::SaveChanges_Bill(SaveInfo& info)
{
	m_boChangesMade = FALSE;
	// (a.walling 2007-05-24 12:28) - PLID 26114
	info.bChargesDeleted = m_adwDeletedCharges.GetSize() > 0;
	info.bChargesEdited = m_adwEditedCharges.GetSize() > 0;

	m_adwDeletedCharges.RemoveAll();
	m_adwEditedCharges.RemoveAll();

	long nAuditTransactionID = -1;

	_variant_t var;
	CString str;

	try {
		//update bill info. here

		//Location Information
		long POS = -1, BillID, AuditID = -1;
		CString oldLoc, newLoc;

		BillID = GetBillID();

		CString strDate = FormatDateTimeForSql(info.dtNewBillDate, dtoDate);
		if (!info.IsNewBill) {
			if (CompareDateIgnoreTime(info.dtOldBillDate, info.dtNewBillDate) != 0) {
				if (AuditID == -1)
					AuditID = BeginNewAuditEvent();

				AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, m_EntryType == 1 ? aeiBillDate : aeiQuoteDate, GetBillID(), FormatDateTimeForInterface(info.dtOldBillDate), FormatDateTimeForInterface(info.dtNewBillDate), aepMedium);
			}
		}

		if (m_PlaceOfServiceCombo->CurSel == -1) {
			if (CString((LPCTSTR)m_PlaceOfServiceCombo->ComboBoxText) == "") {
				//This should have been caught in the validation section above.
				info.scr = SCR_NOT_SAVED;
				return;
			}
			else {
				POS = info.nOldLocID;
			}
		}
		else {
			var = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->GetCurSel(), 0);
			if (var.vt != VT_NULL && var.vt != VT_EMPTY)
				POS = var.lVal;
		}

		if (!info.IsNewBill && info.bDatesAccessible) {
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized, and removed the cursor
			// (r.gonet 2016-04-07) - NX-100072 - Split FirstConditionDate into multiple date fields.
			_RecordsetPtr rs = CreateParamRecordset("SELECT ConditionDate, ConditionDateType, "
				"FirstVisitOrConsultationDate, "
				"InitialTreatmentDate, "
				"LastSeenDate, "
				"AcuteManifestationDate, "
				"LastXRayDate, "
				"HearingAndPrescriptionDate, "
				"AssumedCareDate, "
				"RelinquishedCareDate, "
				"AccidentDate "
				"FROM BillsT WHERE ID = {INT}", GetBillID());
			if (!rs->eof) {

				COleDateTime dt;
				COleDateTime dtInvalid;
				dtInvalid.SetStatus(COleDateTime::invalid);

				dt = AdoFldDateTime(rs, "ConditionDate", dtInvalid);
				if (FormatDateTimeForInterface(dt) != FormatDateTimeForInterface(info.dtCurrentCondition)) {
					if (AuditID == -1)
						AuditID = BeginNewAuditEvent();
					CString strOld = FormatDateTimeForInterface(dt);
					CString strNew = FormatDateTimeForInterface(info.dtCurrentCondition);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillConditionDate, GetBillID(), strOld, strNew, aepLow);
				}

				// (j.jones 2012-01-23 16:42) - PLID 47731 - audit the condition date combo
				// (r.gonet 2016-04-07) - NX-100072 - Use the ClaimDates structure.
				ClaimDates oldClaimDates;
				oldClaimDates.eConditionDateType = (ConditionDateType)AdoFldLong(rs, "ConditionDateType", ConditionDateType::cdtFirstVisitOrConsultation444);
				
				if (oldClaimDates.eConditionDateType != info.claimDates.eConditionDateType) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}

					// (r.gonet 2016-04-07) - NX-100072 - Use the function to get the description.
					CString strOld = GetConditionDateTypeDescription(oldClaimDates.eConditionDateType);
					CString strNew = GetConditionDateTypeDescription(info.claimDates.eConditionDateType);

					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillConditionDateType, GetBillID(), strOld, strNew, aepLow);
				}
				
				// (r.gonet 2016-04-07) - NX-100072 - Load the old claim dates.
				oldClaimDates.dtFirstVisitOrConsultationDate = AdoFldDateTime(rs, "FirstVisitOrConsultationDate", g_cdtNull);
				oldClaimDates.dtInitialTreatmentDate = AdoFldDateTime(rs, "InitialTreatmentDate", g_cdtNull);
				oldClaimDates.dtLastSeenDate = AdoFldDateTime(rs, "LastSeenDate", g_cdtNull);
				oldClaimDates.dtAcuteManifestationDate = AdoFldDateTime(rs, "AcuteManifestationDate", g_cdtNull);
				oldClaimDates.dtLastXRayDate = AdoFldDateTime(rs, "LastXRayDate", g_cdtNull);
				oldClaimDates.dtHearingAndPrescriptionDate = AdoFldDateTime(rs, "HearingAndPrescriptionDate", g_cdtNull);
				oldClaimDates.dtAssumedCareDate = AdoFldDateTime(rs, "AssumedCareDate", g_cdtNull);
				oldClaimDates.dtRelinquishedCareDate = AdoFldDateTime(rs, "RelinquishedCareDate", g_cdtNull);
				oldClaimDates.dtAccidentDate = AdoFldDateTime(rs, "AccidentDate", g_cdtNull);

				if (FormatDateTimeForInterface(oldClaimDates.dtFirstVisitOrConsultationDate) != FormatDateTimeForInterface(info.claimDates.dtFirstVisitOrConsultationDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtFirstVisitOrConsultationDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtFirstVisitOrConsultationDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillFirstVisitOrConsultationDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtInitialTreatmentDate) != FormatDateTimeForInterface(info.claimDates.dtInitialTreatmentDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtInitialTreatmentDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtInitialTreatmentDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillInitialTreatmentDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtLastSeenDate) != FormatDateTimeForInterface(info.claimDates.dtLastSeenDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtLastSeenDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtLastSeenDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillLastSeenDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtAcuteManifestationDate) != FormatDateTimeForInterface(info.claimDates.dtAcuteManifestationDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtAcuteManifestationDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtAcuteManifestationDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillAcuteManifestationDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtLastXRayDate) != FormatDateTimeForInterface(info.claimDates.dtLastXRayDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtLastXRayDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtLastXRayDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillLastXRayDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtHearingAndPrescriptionDate) != FormatDateTimeForInterface(info.claimDates.dtHearingAndPrescriptionDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtHearingAndPrescriptionDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtHearingAndPrescriptionDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillHearingAndPrescriptionDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtAssumedCareDate) != FormatDateTimeForInterface(info.claimDates.dtAssumedCareDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtAssumedCareDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtAssumedCareDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillAssumedCareDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtRelinquishedCareDate) != FormatDateTimeForInterface(info.claimDates.dtRelinquishedCareDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtRelinquishedCareDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtRelinquishedCareDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillRelinquishedCareDate, GetBillID(), strOld, strNew, aepLow);
				}

				if (FormatDateTimeForInterface(oldClaimDates.dtAccidentDate) != FormatDateTimeForInterface(info.claimDates.dtAccidentDate)) {
					if (AuditID == -1) {
						AuditID = BeginNewAuditEvent();
					}
					CString strOld = FormatDateTimeForInterface(oldClaimDates.dtAccidentDate);
					CString strNew = FormatDateTimeForInterface(info.claimDates.dtAccidentDate);
					if (strOld.Find("Invalid") != -1)
						strOld = "";
					if (strNew.Find("Invalid") != -1)
						strNew = "";
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillAccidentDate, GetBillID(), strOld, strNew, aepLow);
				}
			}
		}

		if (!info.IsNewBill && POS != -1 && info.nOldLocID != POS) {
			AuditID = BeginNewAuditEvent();
			if (AuditID != -1) {
				oldLoc = newLoc = "No Location";
				_RecordsetPtr rs = CreateParamRecordset("SELECT Name FROM LocationsT WHERE ID = {INT}", info.nOldLocID);
				if (!rs->eof) {
					oldLoc = AdoFldString(rs, "Name", "No Location");
				}
				rs->Close();
				rs = CreateParamRecordset("SELECT Name FROM LocationsT WHERE ID = {INT}", POS);
				if (!rs->eof) {
					newLoc = AdoFldString(rs, "Name", "No Location");
				}
				rs->Close();
				//TES 4/9/2008 - PLID 29585 - Renamed from aeiBillLocation/aeiQuoteLocation to aeiBillPOS/aeiQuotePOS, since that's what they actually represent.
				AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, m_EntryType == 1 ? aeiBillPOS : aeiQuotePOS, BillID, oldLoc, newLoc, aepMedium);
			}
		}

		if (POS == -1)
			POS = GetCurrentLocation();

		// (r.gonet 07/01/2014) - PLID 62531 - Audit the change of the status. We need to audit even if the bill is new.
		CString strOldBillStatus, strNewBillStatus;
		_variant_t varNewBillStatusID = (info.nOldBillStatusID != -1 ? _variant_t(info.nOldBillStatusID, VT_I4) : g_cvarNull);
		if (m_EntryType == 1 && info.nOldBillStatusID != info.nNewBillStatusID) {
			// Audit any changes to the status
			AuditID = BeginNewAuditEvent();
			if (AuditID != -1) {
				strOldBillStatus = strNewBillStatus = "No Status";
				_RecordsetPtr rs = CreateParamRecordset(
					"SELECT Name FROM BillStatusT WHERE ID = {INT}; "
					"SELECT Name FROM BillStatusT WHERE ID = {INT}; "
					, info.nOldBillStatusID
					, info.nNewBillStatusID);
				if (!rs->eof) {
					strOldBillStatus = AdoFldString(rs, "Name", "No Status");
				}
				rs = rs->NextRecordset(NULL);
				if (!rs->eof) {
					strNewBillStatus = AdoFldString(rs, "Name", "No Status");
				}
				rs->Close();

				AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillStatusChanged, BillID, strOldBillStatus, strNewBillStatus, aepMedium);
				// (r.gonet 07/01/2014) - PLID 62531 - Put the status ID in a variant so we can save it in a nullable field later.
				varNewBillStatusID = (info.nNewBillStatusID != -1 ? _variant_t(info.nNewBillStatusID, VT_I4) : g_cvarNull);
			}
		} else {
			// (r.gonet 07/01/2014) - PLID 62531 - Either this is a quote, in which case it can't have a Bill Status,
			// or the bill status has not changed between saving and loading, in which case we don't audit it.
		}

		// (r.gonet 07/01/2014) - PLID 62525 - Save the note and audit the changes to the status note
		_variant_t varNewBillStatusNoteID = (info.nOldBillStatusNoteID != -1 ? _variant_t(info.nOldBillStatusNoteID, VT_I4) : g_cvarNull);
		if (m_EntryType == 1 && info.strOldBillStatusNote != info.strNewBillStatusNote) {
			// Audit any changes to the status note
			AuditID = BeginNewAuditEvent();
			if (AuditID != -1) {
				if (!info.strNewBillStatusNote.IsEmpty()) {
					CString strNoteWithUsername = AddCurrentUsernameToStatusNote(info.strNewBillStatusNote);
					CParamSqlBatch sqlBatch;
					sqlBatch.Declare(
						"DECLARE @nNewID INT; "
						"SET NOCOUNT ON ");
					sqlBatch.Add(
						"INSERT INTO Notes (PersonID, Date, UserID, Note) "
						"VALUES ({INT}, GETDATE(), {INT}, {STRING})",
						m_nPatientID, GetCurrentUserID(), strNoteWithUsername);
					sqlBatch.Add(
						"SET @nNewID = SCOPE_IDENTITY()");
					// (r.gonet 07/24/2014) - PLID 62524 - Flag this note as a bill status note
					sqlBatch.Add(
						"INSERT INTO NoteInfoT (NoteID, BillID, ShowOnStatement, SendOnClaim, IsBillStatusNote) "
						"VALUES (@nNewID, {INT}, 0, 0, 1) ",
						BillID);
					sqlBatch.Declare(
						"SET NOCOUNT OFF "
						"SELECT @nNewID AS NoteID");

					_RecordsetPtr rsID = sqlBatch.CreateRecordset(GetRemoteData());
					// (r.gonet 07/01/2014) - PLID 62525 - Need to know what the ID of the note is in order to audit and save it to the bill.
					info.nNewBillStatusNoteID = AdoFldLong(rsID->Fields, "NoteID");
					AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiPatientNote, info.nNewBillStatusNoteID, "", info.strNewBillStatusNote, aepMedium, aetCreated);
					// (r.gonet 07/01/2014) - PLID 62525 - Put the new status note ID into a variant so we can save it to a nullable field later.
					varNewBillStatusNoteID = _variant_t(info.nNewBillStatusNoteID, VT_I4);
				} else {
					info.nNewBillStatusNoteID = -1;
					varNewBillStatusNoteID = g_cvarNull;
				}
				
				AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiBillStatusNoteChanged, BillID, info.strOldBillStatusNote, info.strNewBillStatusNote, aepMedium);
			}
		} else {
			// (r.gonet 07/01/2014) - PLID 62525 - Either this is a quote, in which case it can't have a Bill Status Note,
			// or the bill status note has not changed between saving and loading, in which case we don't audit it.
		}

		long UseExp = 0;
		// (r.gonet 07/01/2014) - PLID 62531 - Changed ExpDays to a variant so I could parameterize a SQL query.
		_variant_t varExpDays;
		if (m_EntryType == 1) {
			UseExp = 0;
			varExpDays = g_cvarNull;
		}
		else {

			//Save Expiration Date Information
			if (m_quoteExpCheck.GetCheck()) {
				UseExp = 1;
				varExpDays = _variant_t((long)GetDlgItemInt(IDC_QUOTE_EXP_DAYS), VT_I4);
			}
			else {
				UseExp = 0;
				varExpDays = g_cvarNull;
			}


			if (GetIsAnyPackage()) {

				//Package Information
				long PackageTotalCount = 0;
				long PackageCurrentCount = 0;
				long PackageInitialCount = 0;
				CString strTotalAmount = FormatCurrencyForInterface(COleCurrency(0, 0));
				CString strCurrentAmount = FormatCurrencyForInterface(COleCurrency(0, 0));
				CString strInitialAmount = FormatCurrencyForInterface(COleCurrency(0, 0));

				PackageTotalCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
				PackageCurrentCount = GetDlgItemInt(IDC_PACKAGE_COUNT);
				GetDlgItemText(IDC_PACKAGE_TOTAL_COST, strTotalAmount);
				GetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, strCurrentAmount);

				// (j.jones 2009-12-23 09:48) - PLID 32587 - the original values are now editable
				PackageInitialCount = GetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT);
				GetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, strInitialAmount);

				COleCurrency cyTotalAmount = ParseCurrencyFromInterface(strTotalAmount);
				COleCurrency cyCurrentAmount = ParseCurrencyFromInterface(strCurrentAmount);
				COleCurrency cyInitialAmount = ParseCurrencyFromInterface(strInitialAmount);

				long nType = GetIsRepeatPackage() ? 1 : 2;

				// (j.jones 2009-12-23 16:38) - PLID 36699 - We cached all this information for auditing,
				// so we need no recordset. It's a new package if m_nOldPackageType is -1.
				if (m_nOldPackageType == -1) {
					//must add the record
					// (j.jones 2007-04-23 12:23) - PLID 25735 - supported OriginalCurrentAmount and OriginalCurrentCount
					// (j.jones 2009-12-23 09:48) - PLID 32587 - the original values are now editable
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized, and removed the cursor
					ExecuteParamSql("INSERT INTO PackagesT (QuoteID, Type, "
						"TotalCount, TotalAmount, "
						"CurrentCount, CurrentAmount, "
						"OriginalCurrentCount, OriginalCurrentAmount) "
						"VALUES "
						"({INT}, {INT}, "
						"{INT}, {OLECURRENCY}, "
						"{INT}, {OLECURRENCY}, "
						"{INT}, {OLECURRENCY})",
						GetBillID(), nType,
						PackageTotalCount, cyTotalAmount,
						PackageCurrentCount, cyCurrentAmount,
						PackageInitialCount, cyInitialAmount);
				}
				else {
					//update the existing record

					// (j.jones 2007-11-27 12:49) - PLID 28198 - this code was updating the OriginalCurrentAmount & Count on every save,
					// which meant that opening and closing a finished package would update the OriginalCurrentAmount to zero.
					// Instead, do not update the original current amount unless the total amount changed AND the current amount
					// also changed, and same with the original and total counts. Update to what the "current" fields are,
					// if the "total" and "current" both changed.

					// (j.jones 2009-12-23 09:48) - PLID 32587 - the original values are now editable, so we do not need to do this
					// calculation any more
					/*
					CString strOriginalUpdateCount = "";
					CString strOriginalUpdateAmount = "";
					if(m_nOldPackageTotalCount != PackageTotalCount && m_nOldPackageCurrentCount != PackageCurrentCount) {
					//total count changed, so update the "original current" count with the current count
					strOriginalUpdateCount.Format(", OriginalCurrentCount = %li",PackageCurrentCount);
					}
					if(FormatCurrencyForSql(m_cyOldPackageTotalAmount) != FormatCurrencyForSql(ParseCurrencyFromInterface(strTotalAmount))
					&& FormatCurrencyForSql(m_cyOldPackageCurrentAmount) != FormatCurrencyForSql(ParseCurrencyFromInterface(strCurrentAmount))) {
					//total amount changed, so update the "original current" count with the current count
					strOriginalUpdateAmount.Format(", OriginalCurrentAmount = Convert(money,'%s')", FormatCurrencyForSql(ParseCurrencyFromInterface(strCurrentAmount)));
					}
					*/

					// (j.jones 2009-12-23 16:38) - PLID 36699 - audit all of these fields
					if (m_nOldPackageType != nType) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld, strNew;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						if (m_nOldPackageType == 1) {
							strOld.Format("%s - Type: Repeatable", strDesc);
						}
						else if (m_nOldPackageType == 2) {
							strOld.Format("%s - Type: Multi-Use", strDesc);
						}
						if (nType == 1) {
							strNew = "Repeatable";
						}
						else if (nType == 2) {
							strNew = "Multi-Use";
						}
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageType, GetBillID(), strOld, strNew, aepMedium, aetChanged);
					}
					if (m_nOldPackageTotalCount != PackageTotalCount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Count: %li", strDesc, m_nOldPackageTotalCount);
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageTotalCount, GetBillID(), strOld, AsString(PackageTotalCount), aepMedium, aetChanged);
					}
					if (m_nOldPackageCurrentCount != PackageCurrentCount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Count: %li", strDesc, m_nOldPackageCurrentCount);
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageCurrentCount, GetBillID(), strOld, AsString(PackageCurrentCount), aepMedium, aetChanged);
					}
					if (m_nOldPackageOriginalCurrentCount != PackageInitialCount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Count: %li", strDesc, m_nOldPackageOriginalCurrentCount);
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageOriginalCurrentCount, GetBillID(), strOld, AsString(PackageInitialCount), aepMedium, aetChanged);
					}
					if (m_cyOldPackageTotalAmount != cyTotalAmount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Amount: %s", strDesc, FormatCurrencyForInterface(m_cyOldPackageTotalAmount));
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageTotalAmount, GetBillID(), strOld, FormatCurrencyForInterface(cyTotalAmount), aepMedium, aetChanged);
					}
					if (m_cyOldPackageCurrentAmount != cyCurrentAmount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Amount: %s", strDesc, FormatCurrencyForInterface(m_cyOldPackageCurrentAmount));
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageCurrentAmount, GetBillID(), strOld, FormatCurrencyForInterface(cyCurrentAmount), aepMedium, aetChanged);
					}
					if (m_cyOldPackageOriginalCurrentAmount != cyInitialAmount) {
						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}
						CString strOld;
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						CString strDesc = GetBillDescriptionWithPrefix();
						strOld.Format("%s - Amount: %s", strDesc, FormatCurrencyForInterface(m_cyOldPackageOriginalCurrentAmount));
						AuditEvent(m_nPatientID, GetBillPatientName(), nAuditTransactionID, aeiPackageOriginalCurrentAmount, GetBillID(), strOld, FormatCurrencyForInterface(cyInitialAmount), aepMedium, aetChanged);
					}

					ExecuteSql("UPDATE PackagesT SET Type = %li, TotalCount = %li, TotalAmount = Convert(money,'%s'), "
						"CurrentCount = %li, CurrentAmount = Convert(money,'%s'), "
						"OriginalCurrentCount = %li, OriginalCurrentAmount = Convert(money,'%s') "
						"WHERE QuoteID = %li", nType, PackageTotalCount, FormatCurrencyForSql(cyTotalAmount),
						PackageCurrentCount, FormatCurrencyForSql(cyCurrentAmount),
						PackageInitialCount, FormatCurrencyForSql(cyInitialAmount),
						GetBillID());
				}

				// (j.jones 2009-12-23 17:09) - PLID 36699 - update our cached variables
				m_cyOldPackageTotalAmount = cyTotalAmount;
				m_nOldPackageTotalCount = PackageTotalCount;
				m_cyOldPackageCurrentAmount = cyCurrentAmount;
				m_nOldPackageCurrentCount = PackageCurrentCount;
				m_cyOldPackageOriginalCurrentAmount = cyInitialAmount;
				m_nOldPackageOriginalCurrentCount = PackageInitialCount;
				m_nOldPackageType = nType;
			}
			else {
				if (GetBillID() != -1) {
					//time to remove the package info
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("DELETE FROM PackagesT WHERE QuoteID = {INT}", GetBillID());
				}
			}
		}

		//****REMEMBER: All new fields also need to be supported in FinancialCorrection.cpp
		//and in SplitChargesIntoNewBill() in GlobalFinancialUtils.****//

		// (r.gonet 07/01/2014) - PLID 62531 - Parameterized. Added saving of BillsT.StatusID
		// (r.gonet 07/01/2014) - PLID 62525 - Added saving of BillsT.StatusNoteID and BillsT.StatusModifiedDate
		ExecuteParamSql(
			"UPDATE BillsT SET "
			"Date = {STRING}, "
			"Location = {INT}, "
			"UseExp = {INT}, "
			"ExpDays = {VT_I4}, "
			"StatusID = {VT_I4}, "
			"StatusModifiedDate = (CASE WHEN COALESCE(StatusID, -1) <> COALESCE({VT_I4}, -1) THEN GETDATE() ELSE StatusModifiedDate END), "
			"StatusNoteID = {VT_I4} "
			"WHERE ID = {INT}",
			strDate, POS, UseExp, varExpDays, varNewBillStatusID, varNewBillStatusID, varNewBillStatusNoteID, GetBillID());

		if (info.bDatesAccessible) {
			// (r.gonet 2016-04-07) - NX-100072 - Split the FirstConditionDate into multiple date fields.
			ExecuteSql("UPDATE BillsT SET ConditionDate = %s, ConditionDateType = %li, "
				"FirstVisitOrConsultationDate = %s, "
				"InitialTreatmentDate = %s, "
				"LastSeenDate = %s, "
				"AcuteManifestationDate = %s, "
				"LastXRayDate = %s, "
				"HearingAndPrescriptionDate = %s, "
				"AssumedCareDate = %s, "
				"RelinquishedCareDate = %s, "
				"AccidentDate = %s "
				"WHERE ID = %li",
				info.dtCurrentCondition.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.dtCurrentCondition)) + "'" : "NULL",
				(long)info.claimDates.eConditionDateType,
				info.claimDates.dtFirstVisitOrConsultationDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtFirstVisitOrConsultationDate)) + "'" : "NULL",
				info.claimDates.dtInitialTreatmentDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtInitialTreatmentDate)) + "'" : "NULL",
				info.claimDates.dtLastSeenDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtLastSeenDate)) + "'" : "NULL",
				info.claimDates.dtAcuteManifestationDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtAcuteManifestationDate)) + "'" : "NULL",
				info.claimDates.dtLastXRayDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtLastXRayDate)) + "'" : "NULL",
				info.claimDates.dtHearingAndPrescriptionDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtHearingAndPrescriptionDate)) + "'" : "NULL",
				info.claimDates.dtAssumedCareDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtAssumedCareDate)) + "'" : "NULL",
				info.claimDates.dtRelinquishedCareDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtRelinquishedCareDate)) + "'" : "NULL",
				info.claimDates.dtAccidentDate.GetStatus() == COleDateTime::valid ? "'" + _Q(FormatDateTimeForSql(info.claimDates.dtAccidentDate)) + "'" : "NULL",
				GetBillID());
		}

		// (j.jones 2009-03-24 17:31) - PLID 9729 - now save the extra diag codes
		long nBillID = GetBillID();
		CSqlFragment sqlDiagBatch;

		//clear the existing codes that we are not saving
		CArray<long, long> aryIDsToSave;
		aryIDsToSave.Add(-1);
		for (int i = 0; i < m_arypDiagCodes.GetSize(); i++) {
			DiagCodeInfoPtr pDiag = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);
			if (pDiag->nID != -1) {
				aryIDsToSave.Add(pDiag->nID);
			}
		}

		/*CString strIDsToSave = "-1";
		for(i=0; i<m_arypDiagCodes.GetSize(); i++) {
		DiagCodeInfoPtr pDiag = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);
		if(pDiag->nID != -1) {
		strIDsToSave += ",";
		strIDsToSave += AsString(pDiag->nID);
		}
		}*/

		// (j.gruber 2014-02-25 09:58) - PLID 60893 - need to delete whichcodes first
		sqlDiagBatch += CSqlFragment("DELETE FROM ChargeWhichCodesT WHERE BillDiagCodeID IN (SELECT ID FROM BillDiagCodeT WHERE BillID = {INT} AND ID NOT IN ({INTARRAY})) \r\n", nBillID, aryIDsToSave);
		//delete IDs that are not still in our list
		sqlDiagBatch += CSqlFragment("DELETE FROM BillDiagCodeT WHERE BillID = {INT} AND ID NOT IN ({INTARRAY}) \r\n", nBillID, aryIDsToSave);

		// (b.spivey, March 12th, 2014) - PLID 60975 - UNIQUE constraint errors are possible if we try to update a row to have 
		//	 the same billid and order index as something already in the list. So we have to make everything a number not 
		//	 possible to be set in the interface and then update over it... again. 
		sqlDiagBatch += CSqlFragment("UPDATE BillDiagCodeT SET OrderIndex = (-1 * OrderIndex) WHERE BillID = {INT} ", nBillID);
		for (int i = 0; i < m_arypDiagCodes.GetSize(); i++) {

			DiagCodeInfoPtr pDiag = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);

			if (pDiag->nID == -1) {
				sqlDiagBatch += CSqlFragment("INSERT INTO BillDiagCodeT (BillID, ICD9DiagID, ICD10DiagID, OrderIndex) "
					"VALUES ({INT}, {VT_I4}, {VT_I4}, {INT}) \r\n"
					, nBillID
					, pDiag->nDiagCode9ID == -1 ? g_cvarNull : pDiag->nDiagCode9ID
					, pDiag->nDiagCode10ID == -1 ? g_cvarNull : pDiag->nDiagCode10ID
					, pDiag->nOrderIndex);
			}
			else {
				//the only thing that can change is the order index
				// (j.gruber 2014-04-01 15:53) - PLID 61602 - oh contrare?! we can update either 9's or 10's now!
				sqlDiagBatch += CSqlFragment("UPDATE BillDiagCodeT SET ICD9DiagID = {VT_I4}, ICD10DiagID = {VT_I4}, OrderIndex = {INT} "
					"WHERE ID = {INT} \r\n"
					, pDiag->nDiagCode9ID == -1 ? g_cvarNull : pDiag->nDiagCode9ID
					, pDiag->nDiagCode10ID == -1 ? g_cvarNull : pDiag->nDiagCode10ID
					, pDiag->nOrderIndex, pDiag->nID);
			}
		}

		// (j.jones 2009-03-25 10:55) - PLID 33653 - Nothing else on the bill audits when it is new,
		// so we will not audit extra diagnosis codes on a new bill either.
		if (!info.IsNewBill) {

			CString strPatientName = GetBillPatientName();

			// (j.jones 2009-03-25 10:08) - PLID 33653 - now audit the differences between the old and the new list
			// (b.spivey, February 26, 2014) - PLID 60975 - Refactored this to use a new audit. 
			for (int i = 0; i<m_arypOldDiagCodes.GetSize(); i++) {

				//for every index in the old, audit what happened to it

				DiagCodeInfoPtr pDiagOld = (DiagCodeInfoPtr)m_arypOldDiagCodes.GetAt(i);

				if (m_arypDiagCodes.GetSize() > i) {
					//we have a match, compare the code
					DiagCodeInfoPtr pDiagNew = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);

					ASSERT(pDiagNew->nOrderIndex == pDiagOld->nOrderIndex);

					//see if the code at this index changed
					if (pDiagNew->nDiagCode9ID != pDiagOld->nDiagCode9ID) {

						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}

						// (b.spivey, April 10, 2014) - PLID 60975 - We need to audit the correct value if the old diag code is empty. 
						CString strDiagDesc = "<None>";
						if (pDiagOld->nDiagCode9ID > 0) {
							strDiagDesc = pDiagOld->strDiagCode9Code;
						}

						CString strOld, strNew;
						strOld.Format("Diag. Code %li: %s", pDiagOld->nOrderIndex, strDiagDesc);
						strNew = pDiagNew->strDiagCode9Code;

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}

					// (b.spivey, February 26, 2014) - PLID 60975 - audit icd10 seperately. 
					if (pDiagNew->nDiagCode10ID != pDiagOld->nDiagCode10ID) {

						if (nAuditTransactionID == -1) {
							nAuditTransactionID = BeginAuditTransaction();
						}

						// (b.spivey, April 10, 2014) - PLID 60975 - We need to audit the correct value if the old diag code is empty. 
						CString strDiagDesc = "<None>";
						if (pDiagOld->nDiagCode10ID > 0) {
							strDiagDesc = pDiagOld->strDiagCode10Code;
						}

						CString strOld, strNew;
						strOld.Format("Diag. Code %li: %s", pDiagOld->nOrderIndex, strDiagDesc);
						strNew = pDiagNew->strDiagCode10Code;

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}

				}
				else {
					//we had more codes in the old list, so audit that they are removed

					if (nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}

					if (pDiagOld->nDiagCode9ID > 0) {
						CString strOld, strNew;
						strOld.Format("Diag. Code %li: %s", pDiagOld->nOrderIndex, pDiagOld->strDiagCode9Code);
						strNew = "<None>";

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}
					// (b.spivey, February 26, 2014) - PLID 60975 - audit ICD10 seperately. 
					if (pDiagOld->nDiagCode10ID > 0) {
						CString strOld, strNew;
						strOld.Format("Diag. Code %li: %s", pDiagOld->nOrderIndex, pDiagOld->strDiagCode10Code);
						strNew = "<None>";

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}
				}
			}

			//do we have more codes in the current list than in the old list?
			if (m_arypDiagCodes.GetSize() > m_arypOldDiagCodes.GetSize()) {
				//audit the new codes
				for (int i = m_arypOldDiagCodes.GetSize(); i < m_arypDiagCodes.GetSize(); i++) {

					DiagCodeInfoPtr pDiagNew = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);

					if (nAuditTransactionID == -1) {
						nAuditTransactionID = BeginAuditTransaction();
					}

					if (pDiagNew->nDiagCode9ID > 0) {
						CString strOld, strNew;
						strOld.Format("Diag. Code %li: <None>", pDiagNew->nOrderIndex);
						strNew = pDiagNew->strDiagCode9Code;

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}

					if (pDiagNew->nDiagCode10ID > 0) {

						// (b.spivey, February 26, 2014) - PLID 60975 - audit icd10 seperately. 
						CString strOld, strNew;
						strOld.Format("Diag. Code %li: <None>", pDiagNew->nOrderIndex);
						strNew = pDiagNew->strDiagCode10Code;

						AuditEvent(m_nPatientID, strPatientName, nAuditTransactionID, aeiBillDiagnosisCode, nBillID, strOld, strNew, aepMedium, aetChanged);
					}
				}
			}
		}

		if (!sqlDiagBatch.IsEmpty()) {
			CString str = sqlDiagBatch.Flatten();
			ExecuteParamSql(sqlDiagBatch);

			if (nAuditTransactionID != -1) {
				CommitAuditTransaction(nAuditTransactionID);
				nAuditTransactionID = -1;
			}

			//and now reload the codes in memory, because the bill might not be closing
			LoadDiagnosisCodes();
			// (d.singleton 2014-02-27 11:00) - PLID 60974 - need to display 12 diag code datalists that apply the global diagnosis search
			// (j.gruber 2014-03-31 09:55) - PLID 61033 - I moved this to ReflectDiagCodeArrayToInterface which is called from Load, so this isn't necessary
			//UpdateDiagnosisControlColumnSize();
		}

		// (j.gruber 2014-02-26 09:12) - PLID 60893 - save the whichcodes after the diagCodes
		if (!info.sqlWhichCodes.IsEmpty())
		{
			CSqlFragment sqlFinal = CSqlFragment("DECLARE @ChargeID INT; \r\n");
			ExecuteParamSql(sqlFinal + info.sqlWhichCodes);
		}

	}NxCatchAllCall("BillingDlg::SaveChanges - Update Bill",
		if (nAuditTransactionID != -1) {
		RollbackAuditTransaction(nAuditTransactionID);
		}
	);
}

void CBillingDlg::SaveChanges_RewardPoints(SaveInfo& info)
{
	// (a.walling 2007-05-21 10:46) - PLID 26079 - Update reward points
	try {
		if (m_EntryType == 1) { // ignore quotes
			if (info.bChargesDeleted || info.bChargesEdited || info.bHadNewCharges || info.IsNewBill) {
				if (!info.IsNewBill) {
					Rewards::UpdateBillAll(m_nPatientID, GetBillID()); // throws error
				} else {
					Rewards::ApplyBillAll(m_nPatientID, GetBillID()); // throws error
				}
			}
		}
	} NxCatchAll("BillingDlg::SaveChanges - Update Reward Points");
}

void CBillingDlg::SaveChanges_Tracking(SaveInfo& info)
{
	//Track that this bill was created.
	if (info.IsNewBill) {
		if (m_EntryType == 1) {
			PhaseTracking::CreateAndApplyEvent(PhaseTracking::ET_BillCreated, m_nPatientID, COleDateTime::GetCurrentTime(), GetBillID());

			//see if this person is a prospect, and that the user wants them to be converted to a patient

			// (j.jones 2007-04-10 16:11) - PLID 25526 - we now have the option to convert on any bill
			// or only on non-zero bills
			// (d.thompson 2012-06-27) - PLID 51220 - Changed default to Any bill (1)
			long nConvertProspectOnBill = GetRemotePropertyInt("ConvertProspectOnBill", 1, 0, "<None>", TRUE);
			BOOL bConvertProspectOnBill = FALSE;
			if (nConvertProspectOnBill == 1) { //any bill
				bConvertProspectOnBill = TRUE;
			}
			else if (nConvertProspectOnBill == 2) { //non-zero bill				
				for (int i = 0; i < (int)m_billingItems.size() && !bConvertProspectOnBill; i++) {
					BillingItemPtr bi = m_billingItems[i];
					COleCurrency cyTotal = VarCurrency(bi->LineTotal);
					if (cyTotal > COleCurrency(0, 0)) {
						bConvertProspectOnBill = TRUE;
					}
				}
			}

			if (bConvertProspectOnBill && GetMainFrame()->m_patToolBar.GetExistingPatientStatus(m_nPatientID) != 1) {

				if (GetRemotePropertyInt("ProspectConvertPref", 0, 0, "<None>", TRUE) == 0 ||
					IDYES == MessageBox("Would you like to convert this Prospect into a Patient now?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

					//we need to convert to patient
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("UPDATE PatientsT SET CurrentStatus = 1 WHERE PersonID = {INT}", m_nPatientID);
					long nStatHistID = NewNumber("PatientStatusHistoryT", "ID");
					ExecuteParamSql(
						"INSERT INTO PatientStatusHistoryT (ID, PersonID, OldStatus, NewStatus, DateConverted, ConvertedByUserName) "
						"VALUES ({INT}, {INT}, 2, 1, {OLEDATETIME}, {STRING})", nStatHistID, m_nPatientID, AsDateNoTime(COleDateTime::GetCurrentTime()), GetCurrentUserName());
					//TES 1/5/2010 - PLID 36761 - New accessor for toolbar values.
					short OldStatus = VarShort(GetMainFrame()->m_patToolBar.GetCurrentlySelectedValue(CPatientToolBar::ptbcCurrentStatus));
					CString strOld;
					if (OldStatus == 2)
						strOld = "Prospect";
					else if (OldStatus == 3)
						strOld = "Patient/Prospect";
					GetMainFrame()->m_patToolBar.SetCurrentlySelectedValue(CPatientToolBar::ptbcCurrentStatus, (short)1);
					//TES 8/13/2014 - PLID 63194 - Use the EX tablechecker here
					CClient::RefreshPatCombo(m_nPatientID, false, CClient::pcatUnchanged, CClient::pcstPatient);
					GetMainFrame()->UpdateAllViews();
					//Audit the change
					long nID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, GetBillPatientName(), nID, aeiCurrentStatus, m_nPatientID, strOld, "Patient", aepMedium, aetChanged);

					//TES 9/21/2010 - PLID 40595 - They may now need to be exported via HL7
					UpdateExistingPatientInHL7(m_nPatientID);
				}
			}
		}
		else {
			PhaseTracking::CreateAndApplyEvent(PhaseTracking::ET_QuoteCreated, m_nPatientID, COleDateTime::GetCurrentTime(), GetBillID());
		}
	}
}


void CBillingDlg::SaveChanges_SendPatBalTableChecker(SaveInfo& info)
{
	CClient::RefreshTable(NetUtils::PatBal, m_nPatientID);
}


void CBillingDlg::SaveChanges_Payments(SaveInfo& info)
{
	CString strQuoteIDs;
	COleCurrency cyQuoteGrandTotal(0, 0);
	_variant_t var;
	CString str;

	try {

		//TES 7/1/2008 - PLID 26143 - There are now two reasons we might auto-apply payments: 1.) When billing a quote with
		// linked prepayments (this was pre-existing).  2.) When billing an exchanged product (newly added).  In either case
		// get a list of the information about the payments to auto-apply, then we'll go through it and apply them.
		CArray<PaymentToApply, PaymentToApply&> arPaymentsToApply;
		BOOL bAppliedFromQuote = FALSE;

		//set this boolean to true when we don't want to try and make payments any further
		BOOL bPaymentOfferMade = FALSE;

		//TES 7/1/2008 - PLID 26143 - If we were given an array of payment IDs to apply, then apply them.
		if (!bPaymentOfferMade && info.IsNewBill && m_EntryType == 1 && m_dwaPaymentIDsToApply.GetSize() > 0) {
			CString strPayIDs;
			//generate a comma delimited list of our billed quotes
			for (int i = 0; i < m_dwaPaymentIDsToApply.GetSize(); i++) {
				strPayIDs += AsString((long)m_dwaPaymentIDsToApply[i]);
				strPayIDs += ",";
			}
			strPayIDs.TrimRight(",");
			//TES 7/1/2008 - PLID 26143 - Copied from the query below, which was in turn copied from ApplyListDlg.
			_RecordsetPtr rs = CreateRecordset("SELECT PaysQ.PayID, PaysQ.QuoteID, PaysQ.InsuredPartyID, PaysQ.PrePayment, "
				"PaysQ.Amount, Amount - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) "
				"+ (CASE WHEN PaymentAppliesQ.ApplyAmt IS NULL THEN 0 ELSE PaymentAppliesQ.ApplyAmt END) AS RespAmount, "
				"CASE WHEN InsuranceCoT.Name IS NULL THEN '<None>' ELSE InsuranceCoT.Name END AS InsCoName, "
				"CASE WHEN RespTypeT.ID IS NULL THEN 'Patient' ELSE RespTypeT.TypeName END AS RespType, "
				"Description, Date "
				"FROM "
				"(/* The amount of all non-deleted payments for this patient */ "
				"SELECT LineItemT.ID AS PayID, PaymentsT.QuoteID, PrePayment, Amount, PatientID, InsuredPartyID, Description, LineItemT.Date "
				"FROM LineItemT INNER JOIN PaymentsT ON LineItemT.ID = PaymentsT.ID "
				"WHERE Deleted = 0 AND Type >= 1 AND Type <= 2 "
				") PaysQ "
				"LEFT JOIN "
				"(/* The amt of each payment that has been applied for this patient */ "
				"SELECT AppliesT.SourceID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
				"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
				"WHERE Deleted = 0 "
				"GROUP BY SourceID, PatientID "
				") ChargeAppliesQ "
				"ON PaysQ.PayID = ChargeAppliesQ.SourceID "
				"LEFT JOIN "
				"(/* The amt of each payment that has had applies to it*/ "
				"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
				"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
				"WHERE Deleted = 0 "
				"GROUP BY DestID, PatientID "
				") PaymentAppliesQ "
				"ON PaysQ.PayID = PaymentAppliesQ.DestID "
				"LEFT JOIN InsuredPartyT ON PaysQ.InsuredPartyID = InsuredPartyT.PersonID "
				"LEFT JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
				"LEFT JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
				"WHERE PaysQ.PayID IN (%s) ", strPayIDs);
			while (!rs->eof) {
				PaymentToApply pta;
				pta.nID = AdoFldLong(rs, "PayID");
				pta.nInsuredPartyID = AdoFldLong(rs, "InsuredPartyID", -1);
				pta.cyRespAmount = AdoFldCurrency(rs, "RespAmount", COleCurrency(0, 0));
				// (j.jones 2009-10-27 17:32) - PLID 35934 - track the linked quote ID, original payment amount, and prepay status
				pta.nQuoteID = AdoFldLong(rs, "QuoteID", -1);
				pta.cyPayAmount = AdoFldCurrency(rs, "Amount", COleCurrency(0, 0));
				pta.bIsPrePayment = AdoFldBool(rs, "PrePayment", FALSE);
				arPaymentsToApply.Add(pta);
				rs->MoveNext();
			}
			
		} else if(!bPaymentOfferMade && info.IsNewBill && m_EntryType==1 && m_arypBilledQuotes.GetSize() > 0) {

			//if you are billing a package or quote, try to apply existing linked prepays
			long nApplyLinkedPrepays = GetRemotePropertyInt("ApplyLinkedPrepays",1,0,"<None>",true);

			if (nApplyLinkedPrepays != 2) {

				//generate a comma delimited list of our billed quotes
				for (int i = 0; i < m_arypBilledQuotes.GetSize(); i++) {
					strQuoteIDs += AsString(((BilledQuote*)m_arypBilledQuotes.GetAt(i))->nQuoteID);
					strQuoteIDs += ",";
				}
				strQuoteIDs.TrimRight(",");

				//JMJ - 4/21/2004 - this query is taken from the ApplyListDlg
				_RecordsetPtr rs = CreateRecordset("SELECT PaysQ.PayID, PaysQ.QuoteID, PaysQ.InsuredPartyID, PaysQ.PrePayment, "
					"PaysQ.Amount, Amount - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) "
					"+ (CASE WHEN PaymentAppliesQ.ApplyAmt IS NULL THEN 0 ELSE PaymentAppliesQ.ApplyAmt END) AS RespAmount, "
					"CASE WHEN InsuranceCoT.Name IS NULL THEN '<None>' ELSE InsuranceCoT.Name END AS InsCoName, "
					"CASE WHEN RespTypeT.ID IS NULL THEN 'Patient' ELSE RespTypeT.TypeName END AS RespType, "
					"Description, Date "
					"FROM "
					"(/* The amount of all non-deleted payments for this patient */ "
					"SELECT LineItemT.ID AS PayID, PaymentsT.QuoteID, PrePayment, Amount, PatientID, InsuredPartyID, Description, LineItemT.Date "
					"FROM LineItemT INNER JOIN PaymentsT ON LineItemT.ID = PaymentsT.ID "
					"WHERE Deleted = 0 AND Type >= 1 AND Type <= 2 "
					") PaysQ "
					"LEFT JOIN "
					"(/* The amt of each payment that has been applied for this patient */ "
					"SELECT AppliesT.SourceID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
					"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
					"WHERE Deleted = 0 "
					"GROUP BY SourceID, PatientID "
					") ChargeAppliesQ "
					"ON PaysQ.PayID = ChargeAppliesQ.SourceID "
					"LEFT JOIN "
					"(/* The amt of each payment that has had applies to it*/ "
					"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
					"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
					"WHERE Deleted = 0 "
					"GROUP BY DestID, PatientID "
					") PaymentAppliesQ "
					"ON PaysQ.PayID = PaymentAppliesQ.DestID "
					"LEFT JOIN InsuredPartyT ON PaysQ.InsuredPartyID = InsuredPartyT.PersonID "
					"LEFT JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
					"LEFT JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
					"WHERE PaysQ.PatientID = %li "
					"AND Amount - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) "
					"+ (CASE WHEN PaymentAppliesQ.ApplyAmt IS NULL THEN 0 ELSE PaymentAppliesQ.ApplyAmt END) <> 0 "
					"AND PaysQ.QuoteID IN (%s) ", m_nPatientID, strQuoteIDs);

				if (!rs->eof) {
					bAppliedFromQuote = TRUE;

					if (nApplyLinkedPrepays == 0 ||
						(nApplyLinkedPrepays == 1 &&
						IDYES == MessageBox("This patient has made PrePayments for the quote you have billed. Would you like to automatically apply these payments now?", "Practice", MB_ICONQUESTION | MB_YESNO))) {

						bPaymentOfferMade = TRUE;

						//TES 7/1/2008 - PLID 26143 - Just fill our array for now, we'll actually go ahead and apply below.
						while (!rs->eof) {
							PaymentToApply pta;
							pta.nID = AdoFldLong(rs, "PayID");
							pta.nInsuredPartyID = AdoFldLong(rs, "InsuredPartyID", -1);
							pta.cyRespAmount = AdoFldCurrency(rs, "RespAmount", COleCurrency(0, 0));
							// (j.jones 2009-10-27 17:32) - PLID 35934 - track the linked quote ID, original payment amount, and prepay status
							pta.nQuoteID = AdoFldLong(rs, "QuoteID", -1);
							pta.cyPayAmount = AdoFldCurrency(rs, "Amount", COleCurrency(0, 0));
							pta.bIsPrePayment = AdoFldBool(rs, "PrePayment", FALSE);
							arPaymentsToApply.Add(pta);
							rs->MoveNext();
						}
					}

					if (!bPaymentOfferMade && nApplyLinkedPrepays == 1)
						//we asked, they said no, so don't ask again
						bPaymentOfferMade = TRUE;
				}
				rs->Close();
			}
		}

		//TES 7/1/2008 - PLID 26143 - Were we given any payment to auto-apply?
		if (arPaymentsToApply.GetSize()) {
			//now go through and try to auto-apply as many linked payments as we can

			BOOL bInsPaysFailed = FALSE;
			BOOL bPatPaysFailed = FALSE;

			//TES 7/3/2008 - PLID 26143 - Track how much of the given payments we are unable to apply.
			COleCurrency cyLeftOver = COleCurrency(0, 0);

			for (int i = 0; i < arPaymentsToApply.GetSize(); i++) {
				PaymentToApply pta = arPaymentsToApply[i];

				COleCurrency cyCharges, cyPayments, cyInsurance;

				GetBillTotals(GetBillID(), m_nPatientID, &cyCharges, &cyPayments, 0, 0, &cyInsurance);

				//apply if there is balance left
				if (cyCharges - cyPayments > COleCurrency(0, 0)) {

					long nPaymentID = pta.nID;

					long InsuredPartyID = pta.nInsuredPartyID;

					COleCurrency cyPayAmount = pta.cyRespAmount;

					if (InsuredPartyID > 0) {
						//if insurance, let's see if it can be applied
						COleCurrency cyResp;
						// (j.jones 2011-07-22 12:19) - PLID 42231 - GetBillInsuranceTotals now takes in an insured party ID, not a RespTypeID
						GetBillInsuranceTotals(GetBillID(), m_nPatientID, InsuredPartyID, &cyResp, &cyPayments, 0, 0);

						// (j.jones 2011-08-25 12:28) - PLID 45176 - CanApplyLineItem will check the normal apply create permission,
						// but only after it checks to see if the source payment is closed
						// (j.jones 2013-07-01 10:45) - PLID 55517 - this function can now potentially correct the payment, if so
						// the payment ID will be changed to reflect the new, corrected line item
						if (cyResp > COleCurrency(0, 0) && CanApplyLineItem(nPaymentID) != ecalirCannotApply)  {
							if (cyResp < cyPayAmount) {
								//TES 7/3/2008 - PLID 26143 - Track how much we can't apply.
								cyLeftOver += (cyPayAmount - cyResp);
							}
							AutoApplyPayToBill(nPaymentID, m_nPatientID, "Bill", GetBillID(), FALSE, FALSE, FALSE);
						}
						else {
							bInsPaysFailed = TRUE;
							//TES 7/3/2008 - PLID 26143 - Track how much we can't apply.
							cyLeftOver += cyPayAmount;
						}
					}
					else {
						//if patients, see if it can be applied
						COleCurrency cyPatientResp = cyCharges - cyInsurance - cyPayments;

						// (j.jones 2011-08-25 12:28) - PLID 45176 - CanApplyLineItem will check the normal apply create permission,
						// but only after it checks to see if the source payment is closed
						// (j.jones 2013-07-01 10:45) - PLID 55517 - this function can now potentially correct the payment, if so
						// the payment ID will be changed to reflect the new, corrected line item
						if (cyPatientResp > COleCurrency(0, 0) && CanApplyLineItem(nPaymentID) != ecalirCannotApply) {
							if (cyPatientResp < cyPayAmount) {
								//TES 7/3/2008 - PLID 26143 - Track how much we can't apply
								cyLeftOver += (cyPayAmount - cyPatientResp);
							}
							AutoApplyPayToBill(nPaymentID, m_nPatientID, "Bill", GetBillID(), FALSE, FALSE, FALSE);
						}
						else {
							bPatPaysFailed = TRUE;
							//TES 7/3/2008 - PLID 26143 - Track how much we can't apply.
							cyLeftOver += cyPayAmount;
						}
					}
				}

			}

			//TES 7/1/2008 - PLID 26143 - Give different error messages depending on whether we were auto-applying prepays
			// or payments for an exchanged product.
			if (!bAppliedFromQuote) {
				COleCurrency cyCharges, cyPayments, cyInsurance;
				GetBillTotals(GetBillID(), m_nPatientID, &cyCharges, &cyPayments, 0, 0, &cyInsurance);

				//TES 7/3/2008 - PLID 26143 - If we applied less than the amount of the bill, prompt them to pay for the rest.
				if (cyCharges - cyInsurance - cyPayments > COleCurrency(0, 0) && IDYES ==
					MessageBox("The previously applied payments were less than the patient responsibility for the new bill. "
					"Would you like to enter a new payment for the remaining amount?", NULL, MB_YESNO)) {
					if (CheckCurrentUserPermissions(bioPayment, sptCreate)) {
						CPaymentDlg dlg(this);
						CString str;
						var.vt = VT_I4;
						var.lVal = GetBillID();
						dlg.m_varBillID = var;
						dlg.m_ApplyOnOK = TRUE;
						dlg.m_bIsCoPay = FALSE;
						//patient resp
						dlg.m_cyFinalAmount = cyCharges - cyInsurance - cyPayments;
						dlg.m_cyMaxAmount = dlg.m_cyFinalAmount;

						dlg.DoModal(__FUNCTION__, __LINE__);
					}
				}
				else {
					//TES 7/3/2008 - PLID 26143 - If the bill was less than what we had to apply, tell the user, and leave it
					// to them to figure out how to deal with it.
					if (cyLeftOver > COleCurrency(0, 0)) {
						MsgBox("The payments from the previous bill were less than the amount of the new bill.  There will be %s in unapplied credits remaining.", FormatCurrencyForInterface(cyLeftOver));
					}
				}
			}
			else {
				if (bInsPaysFailed) {
					AfxMessageBox("At least one insurance payment is linked to the quote and could not be applied\n"
						"because the specified insurance company has no balance for this bill.");
				}

				if (bPatPaysFailed) {
					AfxMessageBox("At least one patient payment is linked to the quote and could not be applied\n"
						"because no patient balance exists for this bill.");
				}

				// (j.jones 2009-11-02 15:23) - PLID 35934 - given a string of quote IDs and an array
				// of applied payments see if we just finished billing a package and applied linked
				// prepayments to it, and adjust the balance as necessary
				TryAdjustPackagePaymentDifference(strQuoteIDs, arPaymentsToApply);
			}
		}

		//NEW PAYMENT, COPAY, COINSURANCE CODE

		// (j.jones 2013-08-20 10:57) - PLID 57959 - allowed this code to fire
		// if a new charge was added or if the service code changed on any existing charge
		if (m_EntryType == 1 && (info.IsNewBill || info.bHadNewCharges || info.bHadChangedServiceCodes)) {

			CString strNextMsg;
			//CApplyToNewBillDlg dlg;
			COleCurrency cyCharges, cyInsurance;

			// (j.jones 2011-11-07 10:01) - PLID 39217 - this is not used in calculations,
			// this is just the total amount of money for all charges that is co-insurance,
			// it could be for multiple companies
			COleCurrency cyTotalCoInsurance_ForDisplay = COleCurrency(0, 0);

			/**COPAY / COINSURANCE CODE**/

			BOOL bIsCoPay = FALSE;	//will tell the payment if it is a copay or not
			BOOL bShiftCoPayBalance = FALSE;	//will determine if we are shifting amounts to patient later on
			// (j.jones 2007-05-02 13:39) - PLID 25844 - To cache the "billed CPT requires copay"
			// property, we have two places that may ask for this info., but any combination of
			// those two may be in effect. So set -1 as "we've not checked", 0 as "we've checked
			// and it doesn't require a copay", and 1 as "we've checked and it does require a copay"
			// (j.jones 2007-08-03 09:49) - PLID 25844 - moved up to be outside the copay if statement
			// because we need to use this field in the ShiftInsuranceResponsibility section later

			// (j.jones 2010-08-03 14:39) - PLID 39938 - This code has been reworked to handle pay groups,
			// such that charges are associated with pay groups, as are copays. Billing charges from multiple
			// pay groups shouldn't really happen, but we will calculate the highest applicable copay amount.

			COleCurrency cyDefaultCoPayAmt = COleCurrency(0, 0);

			// (j.jones 2011-11-04 16:25) - PLID 39217 - we can now make copays for multiple insured parties at the same time
			CArray<long, long> aryChargeIDs;
			CArray<long, long> aryInsuredPartyIDs;
			CArray<InsuranceCoPayApplyList*, InsuranceCoPayApplyList*> arypInsuranceCoPayApplyList;

			CMap<long, long, long, long> mapChargeIDToInsuredPartyID;
			CMap<long, long, COleCurrency, COleCurrency> mapInsuredPartyIDToDeductibleRemaining;
			CMap<long, long, COleCurrency, COleCurrency> mapInsuredPartyIDToOOPRemaining;
			CMap<long, long, BOOL, BOOL> mapInsuredPartyIDToHasDeductible;
			CMap<long, long, BOOL, BOOL> mapInsuredPartyIDToHasOOP;

			// (j.jones 2011-12-23 16:56) - PLID 47207 - just to make things nice and complicated,
			// deductibles and co-insurance can now optionally be per pay group instead of per
			// insured party - it's either or, so if DeductiblePerPayGroup is TRUE, we only use
			// the pay group info. and disregard the insured party info
			CMap<long, long, BOOL, BOOL> mapInsuredPartyIDToDeductiblePerPayGroup;
			CMap<long, long, COleCurrency, COleCurrency> mapPayGroupIDToDeductibleRemaining;
			CMap<long, long, COleCurrency, COleCurrency> mapPayGroupIDToOOPRemaining;
			CMap<long, long, BOOL, BOOL> mapPayGroupIDToHasDeductible;
			CMap<long, long, BOOL, BOOL> mapPayGroupIDToHasOOP;

			//check our preferences
			BOOL bPromptForCopay = (GetRemotePropertyInt("PromptForCoPay", 1, 0, "<None>", TRUE) == 1);
			BOOL bShiftCopayAmount = (GetRemotePropertyInt("ShiftCoPayAmount", 0, 0, "<None>", TRUE) == 1);
			// (j.jones 2010-08-04 09:53) - PLID 38613 - supported co-insurance
			BOOL bShiftCoInsuranceAmount = (GetRemotePropertyInt("ShiftCoInsuranceAmount", 1, 0, "<None>", TRUE) == 1);

			//if any of these options are checked, we need to calculate the source insured party ID
			if (bPromptForCopay || bShiftCopayAmount || bShiftCoInsuranceAmount) {

				//if they want a co-pay or co-insurance, let's first find out which insurance responsibility it needs to be for

				// (j.jones 2011-11-04 17:31) - PLID 39217 - we now have to do this for each charge that has
				// an insurance responsibility
				for (int i = 0; i < (int)m_billingItems.size(); i++) {
					BillingItemPtr pItem = m_billingItems[i];

					long nChargeID = VarLong(pItem->ChargeID);

					long nInsuredPartyID = -1;
					COleCurrency cyMaxInsResp = COleCurrency(0, 0);
					for (int j = 0; j < pItem->RPCList->aryRPC.GetSize(); j++) {
						RespPerCharge rpc = pItem->RPCList->aryRPC.GetAt(j);

						//get the highest ins. resp. on this charge
						if (VarLong(rpc.InsuredPartyID, -1) != -1 && rpc.InsAmount.vt == VT_CY && VarCurrency(rpc.InsAmount) > cyMaxInsResp) {
							nInsuredPartyID = rpc.InsuredPartyID;
						}
					}

					//we only want to look at charges with insurance resps.
					if (nInsuredPartyID == -1) {
						continue;
					}

					aryChargeIDs.Add(nChargeID);
					mapChargeIDToInsuredPartyID.SetAt(nChargeID, nInsuredPartyID);

					//add our insured party info, if we don't already have it
					BOOL bFound = FALSE;
					for (int j = 0; j < aryInsuredPartyIDs.GetSize() && !bFound; j++) {
						long nInsuredPartyIDToCompare = (long)aryInsuredPartyIDs.GetAt(j);

						if (nInsuredPartyIDToCompare == nInsuredPartyID) {
							bFound = TRUE;
							break;
						}
					}

					if (!bFound) {
						aryInsuredPartyIDs.Add(nInsuredPartyID);
					}
				}

				//load our insured party info
				if (aryInsuredPartyIDs.GetSize() > 0) {
					// (j.jones 2011-12-27 08:51) - PLID 47207 - load up the DeductiblePerPayGroup flag
					_RecordsetPtr rs = CreateParamRecordset("SELECT InsuredPartyT.PersonID, "
						"InsuredPartyT.DeductiblePerPayGroup, "
						"InsuredPartyT.DeductibleRemaining, InsuredPartyT.OOPRemaining "
						"FROM InsuredPartyT "
						"WHERE PersonID IN ({INTARRAY})", aryInsuredPartyIDs);
					while (!rs->eof) {

						long nInsuredPartyID = VarLong(rs->Fields->Item["PersonID"]->Value);

						BOOL bDeductiblePerPayGroup = VarBool(rs->Fields->Item["DeductiblePerPayGroup"]->Value, FALSE);
						mapInsuredPartyIDToDeductiblePerPayGroup.SetAt(nInsuredPartyID, bDeductiblePerPayGroup);

						// (j.jones 2011-12-27 08:51) - PLID 47207 - if DeductiblePerPayGroup is enabled,
						// we won't want to load up the global deductible values, because we will not use them
						if (!bDeductiblePerPayGroup) {

							// (j.jones 2010-08-05 13:49) - PLID 38613 - remember these can be NULL
							_variant_t varDeductibleRemaining = rs->Fields->Item["DeductibleRemaining"]->Value;
							if (varDeductibleRemaining.vt == VT_CY) {
								mapInsuredPartyIDToDeductibleRemaining.SetAt(nInsuredPartyID, VarCurrency(varDeductibleRemaining));
								mapInsuredPartyIDToHasDeductible.SetAt(nInsuredPartyID, TRUE); //will have no effect if the rem. amount is zero
							}

							_variant_t varOOPRemaining = rs->Fields->Item["OOPRemaining"]->Value;
							if (varOOPRemaining.vt == VT_CY) {
								mapInsuredPartyIDToOOPRemaining.SetAt(nInsuredPartyID, VarCurrency(varOOPRemaining));
								mapInsuredPartyIDToHasOOP.SetAt(nInsuredPartyID, TRUE);
							}
						}

						rs->MoveNext();
					}
					rs->Close();
				}
			}

			/**COPAY CODE**/

			if ((bPromptForCopay || bShiftCopayAmount) && aryChargeIDs.GetSize() > 0 && aryInsuredPartyIDs.GetSize() > 0) {

				//now find the copay amount to use from the pay group, remember that
				//if the service code is in an insurance specific pay-group, that
				//overrides the default pay group, even if there is no copay in the
				//insurance-specific pay group

				// (j.jones 2011-10-12 12:05) - PLID 44170 - now we return this information per charge
				// (j.jones 2011-11-07 09:18) - PLID 39217 - changed to run the recordset once per charge
				for (int iChargeCoPayIndex = 0; iChargeCoPayIndex < aryChargeIDs.GetSize(); iChargeCoPayIndex++) {

					long nChargeID = aryChargeIDs.GetAt(iChargeCoPayIndex);
					long nInsuredPartyID = -1;
					if (!mapChargeIDToInsuredPartyID.Lookup(nChargeID, nInsuredPartyID) || nInsuredPartyID == -1) {
						//no insured party for this charge, but if so, it shouldn't have been in our chargeID list
						ASSERT(FALSE);
						continue;
					}

					_RecordsetPtr rs = CreateParamRecordset(
						R"(

						SELECT ChargesT.ID AS ChargeID, 
						Min(Coalesce(InsServicePayGroupsT.ID, ServicePayGroupsT.ID)) AS PayGroupID, 
						CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayMoney ELSE DefaultPayGroupInfoQ.CopayMoney END AS CoPayMoney, 
						CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayPercentage ELSE DefaultPayGroupInfoQ.CoPayPercentage END AS CoPayPercentage 
						FROM ChargesT 
						INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID 
						INNER JOIN ServiceT ON ChargesT.ServiceID = ServiceT.ID 
						LEFT JOIN ServicePayGroupsT ON ServiceT.PayGroupID = ServicePayGroupsT.ID 
						LEFT JOIN (SELECT ServiceID, PayGroupID FROM InsCoServicePayGroupLinkT 
							WHERE InsuranceCoID IN (SELECT InsuranceCoID FROM InsuredPartyT WHERE PersonID = {INT}) 
						) AS InsPayGroupLinkQ ON ServiceT.ID = InsPayGroupLinkQ.ServiceID 
						LEFT JOIN ServicePayGroupsT InsServicePayGroupsT ON InsPayGroupLinkQ.PayGroupID = InsServicePayGroupsT.ID 
						LEFT JOIN (SELECT PayGroupID, CoPayMoney, CoPayPercentage 
							FROM InsuredPartyPayGroupsT 
							WHERE InsuredPartyID = {INT} 
							AND ((CoPayMoney Is Not Null AND CopayMoney <> Convert(money,0)) OR (CopayPercentage Is Not Null AND CopayPercentage <> 0)) 
						) AS DefaultPayGroupInfoQ ON ServicePayGroupsT.ID = DefaultPayGroupInfoQ.PayGroupID 
						LEFT JOIN (SELECT PayGroupID, CoPayMoney, CoPayPercentage 
							FROM InsuredPartyPayGroupsT 
							WHERE InsuredPartyID = {INT} 
							AND ((CoPayMoney Is Not Null AND CopayMoney <> Convert(money,0)) OR (CopayPercentage Is Not Null AND CopayPercentage <> 0)) 
						) AS InsurancePayGroupInfoQ ON InsServicePayGroupsT.ID = InsurancePayGroupInfoQ.PayGroupID 
						WHERE LineItemT.Deleted = 0 
						AND ChargesT.ID = {INT} 
						AND (CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayMoney ELSE DefaultPayGroupInfoQ.CopayMoney END Is Not Null 
							OR CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayPercentage ELSE DefaultPayGroupInfoQ.CoPayPercentage END Is Not Null) 
						GROUP BY 
						ChargesT.ID, 
						CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayMoney ELSE DefaultPayGroupInfoQ.CopayMoney END, 
						CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoPayPercentage ELSE DefaultPayGroupInfoQ.CoPayPercentage END 
						
						IF @@ROWCOUNT = 0 
						BEGIN 
						SELECT ChargesT.ID AS ChargeID, 
						InsuredPartyPayGroupsT.PaygroupID AS PayGroupID, 
						InsuredPartyPayGroupsT.CopayMoney AS CoPayMoney, 
						InsuredPartyPayGroupsT.CopayPercentage AS CoPayPercentage 
						FROM ChargesT 
						INNER JOIN ChargeRespT ON ChargesT.ID = ChargeRespT.ChargeID 
						INNER JOIN InsuredPartyPayGroupsT ON ChargeRespT.InsuredPartyID = InsuredPartyPayGroupsT.InsuredPartyID 
						INNER JOIN ServicePayGroupsT ON InsuredPartyPayGroupsT.PaygroupID = ServicePayGroupsT.ID 
						WHERE ChargesT.ID = {INT} AND ChargeRespT.InsuredPartyID = {INT} AND ServicePayGroupsT.Name = 'Copay' 
						END 

						)",
						nInsuredPartyID, nInsuredPartyID, nInsuredPartyID, nChargeID, nChargeID, nInsuredPartyID);

					// If no results were returned after the co-pay calculation, use the default copay $ amount from the "Copay" pay group
					if (rs->eof)
					{
						rs = rs->NextRecordset(nullptr);
					}

					if (!rs->eof) {

						long nChargeID = VarLong(rs->Fields->Item["ChargeID"]->Value);
						long nPayGroupID = VarLong(rs->Fields->Item["PayGroupID"]->Value);
						_variant_t varCoPayMoney = rs->Fields->Item["CoPayMoney"]->Value;
						_variant_t varCopayPercentage = rs->Fields->Item["CopayPercentage"]->Value;

						// (j.jones 2010-09-01 15:58) - PLID 40356 - changed so we never use $0.00 / 0% copays
						if (varCoPayMoney.vt == VT_CY && VarCurrency(varCoPayMoney) != COleCurrency(0, 0)) {
							//flat amount
							COleCurrency cyFlatFeeCopay = VarCurrency(varCoPayMoney, COleCurrency(0, 0));

							// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
							RoundCurrency(cyFlatFeeCopay);

							// (j.jones 2011-11-11 10:29) - PLID 39217 - first find or create the InsuranceCoPayApplyList
							InsuranceCoPayApplyList *icpaiApplyList = NULL;
							for (int indexInsCoPayApplyList = 0; indexInsCoPayApplyList < arypInsuranceCoPayApplyList.GetSize() && icpaiApplyList == NULL; indexInsCoPayApplyList++) {

								InsuranceCoPayApplyList *icpaiApplyListToCompare = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
								if (icpaiApplyListToCompare != NULL && icpaiApplyListToCompare->nInsuredPartyID == nInsuredPartyID) {
									//found our InsuranceCoPayApplyList
									icpaiApplyList = icpaiApplyListToCompare;
								}
							}

							//if not found, create it
							if (icpaiApplyList == NULL) {
								icpaiApplyList = new InsuranceCoPayApplyList();
								icpaiApplyList->nInsuredPartyID = nInsuredPartyID;
								arypInsuranceCoPayApplyList.Add(icpaiApplyList);
							}

							// (j.jones 2011-11-11 10:29) - PLID 39217 - now find or create the CoPayApplyInformation
							CoPayApplyInformation *cpaiApplyInfo = NULL;
							for (int indexCoPayApplies = 0; indexCoPayApplies < icpaiApplyList->aryCoPayApplyInformation.GetSize() && cpaiApplyInfo == NULL; indexCoPayApplies++) {

								CoPayApplyInformation *cpaiApplyInfoToCompare = (CoPayApplyInformation*)icpaiApplyList->aryCoPayApplyInformation.GetAt(indexCoPayApplies);
								if (cpaiApplyInfoToCompare != NULL && cpaiApplyInfoToCompare->nPayGroupID == nPayGroupID) {
									//This is a flat fee, so it's going to only have one entry, and potentially multiple charges,
									//so add our charge to it.
									cpaiApplyInfo = cpaiApplyInfoToCompare;
									cpaiApplyInfo->aryChargeIDs.Add(nChargeID);

									//Also change the flat fee only if it is higher, but ASSERT if the old
									//value was non-zero, because this should be impossible, and you've
									//found a combination that we do not currently support.
									if (cpaiApplyInfo->cyCoPayAmount < cyFlatFeeCopay) {

										ASSERT(cpaiApplyInfo->cyCoPayAmount == COleCurrency(0, 0));

										cpaiApplyInfo->cyCoPayAmount = cyFlatFeeCopay;
									}
								}
							}

							//if not found, create it
							if (cpaiApplyInfo == NULL) {
								cpaiApplyInfo = new CoPayApplyInformation();
								cpaiApplyInfo->cyCoPayAmount = cyFlatFeeCopay;
								cpaiApplyInfo->nPayGroupID = nPayGroupID;
								cpaiApplyInfo->aryChargeIDs.Add(nChargeID);

								icpaiApplyList->aryCoPayApplyInformation.Add(cpaiApplyInfo);
							}
						}
						else if (varCopayPercentage.vt == VT_I4 && VarLong(varCopayPercentage) != 0) {
							//percentage
							long nPercentage = VarLong(varCopayPercentage, 0);

							// (j.jones 2011-10-12 12:13) - PLID 44170 - now we calculate the percentage
							// of the charge this copay applies to, not the bill
							COleCurrency cyPercentageCopayForCharge = CalculatePercentOfBillTotalWithAllowables(nPercentage, nChargeID);

							// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
							RoundCurrency(cyPercentageCopayForCharge);

							//add this to our copay total, per charge
							if (cyPercentageCopayForCharge > COleCurrency(0, 0)) {

								// (j.jones 2011-11-11 10:29) - PLID 39217 - first find or create the InsuranceCoPayApplyList
								InsuranceCoPayApplyList *icpaiApplyList = NULL;
								for (int indexInsCoPayApplyList = 0; indexInsCoPayApplyList < arypInsuranceCoPayApplyList.GetSize() && icpaiApplyList == NULL; indexInsCoPayApplyList++) {

									InsuranceCoPayApplyList *icpaiApplyListToCompare = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
									if (icpaiApplyListToCompare != NULL && icpaiApplyListToCompare->nInsuredPartyID == nInsuredPartyID) {
										//found our InsuranceCoPayApplyList
										icpaiApplyList = icpaiApplyListToCompare;
									}
								}

								//if not found, create it
								if (icpaiApplyList == NULL) {
									icpaiApplyList = new InsuranceCoPayApplyList();
									icpaiApplyList->nInsuredPartyID = nInsuredPartyID;
									arypInsuranceCoPayApplyList.Add(icpaiApplyList);
								}

								// (j.jones 2011-11-11 10:29) - PLID 39217 - when a percent copay,
								// we always create a new CoPayApplyInformation, for just this charge
								CoPayApplyInformation *cpaiApplyInfo = new CoPayApplyInformation();
								cpaiApplyInfo->cyCoPayAmount = cyPercentageCopayForCharge;
								cpaiApplyInfo->nPayGroupID = nPayGroupID;
								cpaiApplyInfo->aryChargeIDs.Add(nChargeID);

								icpaiApplyList->aryCoPayApplyInformation.Add(cpaiApplyInfo);
							}
						}
						else {
							//why do we even have results?
						}
					}
					rs->Close();
				}

				//now we've loaded our copay information for all charges

				// (j.jones 2011-11-11 10:46) - PLID 39217 - calculate the
				// total copayment amount that needs to be entered
				for (int indexInsCoPayApplyList = 0; indexInsCoPayApplyList < arypInsuranceCoPayApplyList.GetSize(); indexInsCoPayApplyList++) {

					InsuranceCoPayApplyList *icpaiApplyList = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
					if (icpaiApplyList != NULL) {

						for (int indexCoPayApplies = 0; indexCoPayApplies < icpaiApplyList->aryCoPayApplyInformation.GetSize(); indexCoPayApplies++) {

							CoPayApplyInformation *cpaiApplyInfo = (CoPayApplyInformation*)icpaiApplyList->aryCoPayApplyInformation.GetAt(indexCoPayApplies);
							if (cpaiApplyInfo != NULL) {
								cyDefaultCoPayAmt += cpaiApplyInfo->cyCoPayAmount;
							}
						}
					}
				}

				//now make sure that they want to be prompted for a Co-Pay					
				if (bPromptForCopay) {

					//and now check their setting on when to be prompted
					long WhenUseCoPay = GetRemotePropertyInt("WhenUseCopay", 1, 0, "<None>", TRUE);

					if (WhenUseCoPay == 2) {
						//always use
						bIsCoPay = TRUE;
					}
					//WhenUseCoPay == 1 means that they only want to be prompted
					//if a copay was calculated
					else if (cyDefaultCoPayAmt > COleCurrency(0, 0)) {
						bIsCoPay = TRUE;
					}
				}

				//now see if they want to be prompted to shift the co-pay amount always
				//only shift when default co-pay is > $0.00
				if (bShiftCopayAmount && cyDefaultCoPayAmt > COleCurrency(0, 0)) {

					// (j.jones 2010-08-03 15:03) - PLID 39938 - with pay groups this preference
					// has been altered such that if enabled, we only shift if a default copay
					// was calculated to be > $0.00
					bShiftCoPayBalance = TRUE;
				}
			}

			/**END COPAY CODE**/

			/**COINSURANCE CODE**/

			// (j.jones 2010-08-04 10:59) - PLID 38613 - added co-insurance support
			if (bShiftCoInsuranceAmount && aryChargeIDs.GetSize() > 0 && aryInsuredPartyIDs.GetSize() > 0) {

				// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
				RoundCurrency(cyDefaultCoPayAmt);

				// (j.jones 2011-11-07 09:18) - PLID 39217 - changed to run the recordset once per charge
				for (int i = 0; i < aryChargeIDs.GetSize(); i++) {

					long nChargeID = aryChargeIDs.GetAt(i);
					long nInsuredPartyID = -1;
					if (!mapChargeIDToInsuredPartyID.Lookup(nChargeID, nInsuredPartyID) || nInsuredPartyID == -1) {
						//no insured party for this charge, but if so, it shouldn't have been in our chargeID list
						ASSERT(FALSE);
						continue;
					}

					//now find the co-insurance amount to use from the pay group, remember that
					//if the service code is in an insurance specific pay-group, that
					//overrides the default pay group, even if there is no co-insurance in the
					//insurance-specific pay group

					// (j.jones 2011-12-27 09:08) - PLID 47207 - now we also need load the deductible and OOP info for the pay group
					_RecordsetPtr rs = CreateParamRecordset("SELECT "
						"ChargesT.ID, "
						"Coalesce(InsServicePayGroupsT.ID, ServicePayGroupsT.ID) AS PayGroupID, "
						"CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoInsurance ELSE DefaultPayGroupInfoQ.CoInsurance END AS CoInsurance, "
						"CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.DeductibleRemaining ELSE DefaultPayGroupInfoQ.DeductibleRemaining END AS DeductibleRemaining, "
						"CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.OOPRemaining ELSE DefaultPayGroupInfoQ.OOPRemaining END AS OOPRemaining "
						"FROM ChargesT "
						"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
						"INNER JOIN ServiceT ON ChargesT.ServiceID = ServiceT.ID "
						"LEFT JOIN ServicePayGroupsT ON ServiceT.PayGroupID = ServicePayGroupsT.ID "
						"LEFT JOIN (SELECT ServiceID, PayGroupID FROM InsCoServicePayGroupLinkT "
						"	WHERE InsuranceCoID IN (SELECT InsuranceCoID FROM InsuredPartyT WHERE PersonID = {INT}) "
						") AS InsPayGroupLinkQ ON ServiceT.ID = InsPayGroupLinkQ.ServiceID "
						"LEFT JOIN ServicePayGroupsT InsServicePayGroupsT ON InsPayGroupLinkQ.PayGroupID = InsServicePayGroupsT.ID "
						"LEFT JOIN (SELECT PayGroupID, CoInsurance, DeductibleRemaining, OOPRemaining "
						"	FROM InsuredPartyPayGroupsT "
						"	WHERE InsuredPartyID = {INT} "
						"	AND CoInsurance Is Not Null "
						") AS DefaultPayGroupInfoQ ON ServicePayGroupsT.ID = DefaultPayGroupInfoQ.PayGroupID "
						"LEFT JOIN (SELECT PayGroupID, CoInsurance, DeductibleRemaining, OOPRemaining "
						"	FROM InsuredPartyPayGroupsT "
						"	WHERE InsuredPartyID = {INT} "
						"	AND CoInsurance Is Not Null "
						") AS InsurancePayGroupInfoQ ON InsServicePayGroupsT.ID = InsurancePayGroupInfoQ.PayGroupID "
						"WHERE LineItemT.Deleted = 0 "
						"AND ChargesT.ID = {INT} "
						"AND CASE WHEN InsServicePayGroupsT.ID Is Not Null THEN InsurancePayGroupInfoQ.CoInsurance ELSE DefaultPayGroupInfoQ.CoInsurance END Is Not Null",
						nInsuredPartyID, nInsuredPartyID, nInsuredPartyID, nChargeID);

					//each charge can only have one applicable co-insurance value

					//in the unlikely event that a co-pay is used for the same pay group,
					//we have to remove the copay amount first
					COleCurrency cyRemainingCopayToApply = cyDefaultCoPayAmt;

					if (!rs->eof) {

						_variant_t varCoInsurance = rs->Fields->Item["CoInsurance"]->Value;

						if (varCoInsurance.vt != VT_I4) {
							//shouldn't we not have had a record returned?
							rs->MoveNext();
							continue;
						}

						long nChargeID = AdoFldLong(rs, "ID");
						long nPayGroupID = AdoFldLong(rs, "PayGroupID");
						long nCoInsurance = VarLong(varCoInsurance);

						// (j.jones 2011-12-27 09:23) - PLID 47207 - if DeductiblePerPayGroup is not enabled,
						// these values are loaded per insured party, otherwise per pay group
						BOOL bHasDeductible = FALSE;
						COleCurrency cyRemainingDeductibleToApply = COleCurrency(0, 0);
						BOOL bHasOOP = FALSE;
						COleCurrency cyOOPRemaining = COleCurrency(0, 0);

						// (j.jones 2011-12-27 09:15) - PLID 47207 - if DeductiblePerPayGroup is enabled,
						// we need to load the the pay group deductible and OOP
						BOOL bDeductiblePerPayGroup = FALSE;
						mapInsuredPartyIDToDeductiblePerPayGroup.Lookup(nInsuredPartyID, bDeductiblePerPayGroup);
						if (bDeductiblePerPayGroup) {

							//remember these can be NULL

							//also, they need to cache the values per pay group, and not re-load from data
							//when we have multiple charges for the same pay group

							if (!mapPayGroupIDToHasDeductible.Lookup(nPayGroupID, bHasDeductible)
								|| !mapPayGroupIDToDeductibleRemaining.Lookup(nPayGroupID, cyRemainingDeductibleToApply)) {
								//we haven't loaded this info yet
								_variant_t varDeductibleRemaining = rs->Fields->Item["DeductibleRemaining"]->Value;
								if (varDeductibleRemaining.vt == VT_CY) {
									cyRemainingDeductibleToApply = VarCurrency(varDeductibleRemaining);
									// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
									RoundCurrency(cyRemainingDeductibleToApply);
									mapPayGroupIDToDeductibleRemaining.SetAt(nPayGroupID, cyRemainingDeductibleToApply);
									bHasDeductible = TRUE;
									mapPayGroupIDToHasDeductible.SetAt(nPayGroupID, bHasDeductible); //will have no effect if the rem. amount is zero
								}
							}

							if (!mapPayGroupIDToHasOOP.Lookup(nPayGroupID, bHasOOP)
								|| !mapPayGroupIDToOOPRemaining.Lookup(nPayGroupID, cyOOPRemaining)) {
								//we haven't loaded this info yet
								_variant_t varOOPRemaining = rs->Fields->Item["OOPRemaining"]->Value;
								if (varOOPRemaining.vt == VT_CY) {
									cyOOPRemaining = VarCurrency(varOOPRemaining);
									// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
									RoundCurrency(cyOOPRemaining);
									mapPayGroupIDToOOPRemaining.SetAt(nPayGroupID, cyOOPRemaining);
									bHasOOP = TRUE;
									mapPayGroupIDToHasOOP.SetAt(nPayGroupID, bHasOOP);
								}
							}
						}
						else {

							//load per insured party

							//with the deductible, we need to determine how much needs to be applied,
							//and co-insurance cannot begin calculations until after the deductible has
							//been applied down to $0.00

							mapInsuredPartyIDToHasDeductible.Lookup(nInsuredPartyID, bHasDeductible);
							if (bHasDeductible) {
								if (!mapInsuredPartyIDToDeductibleRemaining.Lookup(nInsuredPartyID, cyRemainingDeductibleToApply)) {
									bHasDeductible = FALSE;
								}
							}

							mapInsuredPartyIDToHasOOP.Lookup(nInsuredPartyID, bHasOOP);
							if (bHasOOP) {
								if (!mapInsuredPartyIDToOOPRemaining.Lookup(nInsuredPartyID, cyOOPRemaining)) {
									bHasOOP = FALSE;
								}
							}
						}

						//if we have a deductible, or a copay for this pay group,
						//both need the allowed total for this charge
						COleCurrency cyAllowedTotal = COleCurrency(0, 0);

						BOOL bUsedPayGroupInCopay = FALSE;
						// (j.jones 2011-11-11 11:05) - PLID 39217 - this is now a convoluted array of arrays,
						// because now the copay can be comprised of multiple pay groups
						for (int indexInsCoPayApplyList = 0; indexInsCoPayApplyList < arypInsuranceCoPayApplyList.GetSize() && !bUsedPayGroupInCopay; indexInsCoPayApplyList++) {

							InsuranceCoPayApplyList *icpaiApplyList = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
							if (icpaiApplyList != NULL) {

								for (int indexCoPayApplies = 0; indexCoPayApplies < icpaiApplyList->aryCoPayApplyInformation.GetSize() && !bUsedPayGroupInCopay; indexCoPayApplies++) {

									CoPayApplyInformation *cpaiApplyInfo = (CoPayApplyInformation*)icpaiApplyList->aryCoPayApplyInformation.GetAt(indexCoPayApplies);
									if (cpaiApplyInfo != NULL && cpaiApplyInfo->nPayGroupID == nPayGroupID) {
										bUsedPayGroupInCopay = TRUE;
									}
								}
							}
						}

						if ((cyRemainingCopayToApply > COleCurrency(0, 0) && bUsedPayGroupInCopay)
							|| (bHasDeductible && cyRemainingDeductibleToApply > COleCurrency(0, 0))) {

							//CalculateBillTotalWithAllowables will take allowables into account,
							//which is what we need to do before handling deductible and coinsurance
							cyAllowedTotal = CalculateBillTotalWithAllowables(nChargeID);
						}

						COleCurrency cyChargeCoInsurance = COleCurrency(0, 0);

						//in the unlikely event that a co-pay is used for the same pay group,
						//we have to remove the copay amount first
						if (cyRemainingCopayToApply > COleCurrency(0, 0) && bUsedPayGroupInCopay) {
							if (cyRemainingCopayToApply > cyAllowedTotal) {
								//remove the copay amount
								cyRemainingCopayToApply -= cyAllowedTotal;
								cyAllowedTotal = COleCurrency(0, 0);
							}
							else {
								cyAllowedTotal -= cyRemainingCopayToApply;
								cyRemainingCopayToApply = COleCurrency(0, 0);
							}
						}

						//do we have any deductible left to apply?
						if (bHasDeductible && cyRemainingDeductibleToApply > COleCurrency(0, 0)) {

							//apply the deductible amount
							if (cyRemainingDeductibleToApply > cyAllowedTotal) {
								//the entire amount will be deductible paid by patient
								cyChargeCoInsurance = cyAllowedTotal;
								cyRemainingDeductibleToApply -= cyAllowedTotal;
								cyAllowedTotal = COleCurrency(0, 0);
							}
							else {
								//patient owes the remaining deductible, and then their
								//co-insurance % of the remaining allowed amount
								cyChargeCoInsurance = cyRemainingDeductibleToApply;
								cyAllowedTotal -= cyRemainingDeductibleToApply;
								cyRemainingDeductibleToApply = COleCurrency(0, 0);

								//now calculate the co-insurance of the remaining value
								cyAllowedTotal = CalculatePercentOfAmount(cyAllowedTotal, nCoInsurance);
								RoundCurrency(cyAllowedTotal);

								//this is now added to the co-insurance amount
								cyChargeCoInsurance += cyAllowedTotal;
							}
						}
						else {
							//no deductible needed, just calculate the normal co-insurance percentage
							cyChargeCoInsurance = CalculatePercentOfBillTotalWithAllowables(nCoInsurance, nChargeID);
						}

						// (j.jones 2015-11-05 12:31) - PLID 63866 - ensure this is rounded
						RoundCurrency(cyChargeCoInsurance);

						// (j.jones 2011-11-07 09:37) - PLID 39217 - track the new deductible
						// (j.jones 2011-12-27 09:41) - PLID 47207 - this may be per pay group now
						if (bDeductiblePerPayGroup) {
							mapPayGroupIDToDeductibleRemaining.SetAt(nPayGroupID, cyRemainingDeductibleToApply);
						}
						else {
							mapInsuredPartyIDToDeductibleRemaining.SetAt(nInsuredPartyID, cyRemainingDeductibleToApply);
						}

						if (nPayGroupID != -1 && nChargeID != -1 && cyChargeCoInsurance > COleCurrency(0, 0)) {

							//account for the out-of-pocket remaining, remember that if cyOOPRemaining is zero
							//then we shift no co-insurance to patient, but it could have been NULL, in which
							//case bHasOOP would be FALSE
							if (bHasOOP) {

								//the amount we're about to shift for Co-Insurance exceeds the remaining out-of-pocket total,
								//meaning that due this patient either having an amazing insurance plan or a staggeringly
								//high amount of procedures this year, we cannot bill them the full Co-Insurance amount

								COleCurrency cyAmtToReduce = cyChargeCoInsurance - cyOOPRemaining;

								if (cyAmtToReduce > COleCurrency(0, 0)) {

									//reduce this amount
									if (cyAmtToReduce > cyChargeCoInsurance) {
										cyAmtToReduce -= cyChargeCoInsurance;
										cyChargeCoInsurance = COleCurrency(0, 0);
									}
									else {
										cyChargeCoInsurance -= cyAmtToReduce;
										cyAmtToReduce = COleCurrency(0, 0);
									}
								}

								//update the OOP
								cyOOPRemaining -= cyChargeCoInsurance;
								if (cyOOPRemaining < COleCurrency(0, 0)) {
									//this shouldn't be less than zero, it would mean we calculated our co-insurance wrong
									ASSERT(FALSE);
									cyOOPRemaining = COleCurrency(0, 0);
								}

								// (j.jones 2011-12-27 09:41) - PLID 47207 - this may be per pay group now
								if (bDeductiblePerPayGroup) {
									mapPayGroupIDToOOPRemaining.SetAt(nPayGroupID, cyOOPRemaining);
								}
								else {
									mapInsuredPartyIDToOOPRemaining.SetAt(nInsuredPartyID, cyOOPRemaining);
								}
							}

							//add this to our total co-insurance we're tracking for this bill
							cyTotalCoInsurance_ForDisplay += cyChargeCoInsurance;

							//Shift the co-insurance amount from insurance to patient, per charge
							if (cyChargeCoInsurance > COleCurrency(0, 0)) {

								// (j.jones 2013-08-21 13:17) - PLID 39987 - track the CoInsurance amount,
								// if we later have a copay we have to ensure the total of both
								info.mapChargeIDsToCoinsurance.SetAt(nChargeID, cyChargeCoInsurance);

								// (j.jones 2013-08-20 14:12) - PLID 57959 - turn on bForceExactResp if this charge had its service code changed
								bool bHadServiceCodeChanged = false;
								info.mapChargeIDsWithChangedServiceCodes.Lookup(nChargeID, bHadServiceCodeChanged);

								// (j.jones 2015-11-02 17:09) - PLID 67460 - we now shift to the next insurance responsibility
								long nNextInsuredPartyID = GetNextInsuredPartyIDByPriority(m_nPatientID, nInsuredPartyID);

								// (j.jones 2013-08-20 12:45) - PLID 39987 - changed to EnsureInsuranceResponsibility, which will
								// only shift enough money to match cyChargeCoInsurance, it won't shift shift more money if the
								// patient resp. is already >= cyChargeCoInsurance
								// (j.jones 2013-08-21 09:00) - PLID 58194 - added a descriptive audit string
								if (!EnsureInsuranceResponsibility(nChargeID, m_nPatientID, nInsuredPartyID, nNextInsuredPartyID, "Charge", cyChargeCoInsurance, "while saving a bill for coinsurance responsibility", COleDateTime::GetCurrentTime(), bHadServiceCodeChanged)) {
									//this failed, likely due to applies, so tell them so
									CString strWarn;
									strWarn.Format("A coinsurance amount of %s could not be set as %s responsibility because there was not enough available responsibility to shift from insurance. "
										"It is likely there are existing applies preventing this shifting from occurring.\n\n"
										"Please review the patient and insurance responsibilities on this bill to make sure they are correct.",
										FormatCurrencyForInterface(cyChargeCoInsurance),
										GetNameFromRespPartyID(nNextInsuredPartyID));
									AfxMessageBox(strWarn);
								}
							}
						}
					}
					rs->Close();
				}

				m_List->Clear();
				// (r.gonet 08/01/2014) - PLID 62834 - Pass true to signify we are only reloading the current bill. This ensures charge on hold status is preserved.
				FillTabInfo(true);
			}

			/**END COINSURANCE CODE**/

			/**END COPAY / COINSURANCE CODE**/

			//**PAYMENT CODE**/

			GetBillTotals(GetBillID(), m_nPatientID, &cyCharges, 0, 0, 0, &cyInsurance);

			// (c.haag 2009-02-16 12:56) - PLID 14298 - We now have a preference for showing the first two
			// variations of the message. If bIsCoPay is true and there is an insurance amount, we must still
			// show the co-pay prompt.
			BOOL bShowPaymentPrompt = (GetRemotePropertyInt("BillingDlg_PromptForNewBillPayment", 1, 0, "<None>", true)) ? TRUE : FALSE;
			// If there's a co-pay to prompt, override the value to be TRUE
			if (cyInsurance != COleCurrency(0, 0) && bIsCoPay) {
				bShowPaymentPrompt = TRUE;
			}
			// if not a copay, don't prompt if:
			// - we already prompted for a payment
			// - patient resp. is zero
			// - the bill flag says not to prompt
			else if (cyCharges - cyInsurance == COleCurrency(0, 0)
				|| bPaymentOfferMade || ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_boAskForNewPayment == FALSE) {
				bShowPaymentPrompt = FALSE;
			}

			// (c.haag 2009-02-16 12:58) - PLID 14298 - Show the prompt
			int nPromptResult;
			if (bShowPaymentPrompt) {
				// Show the prompt
				if (cyInsurance == COleCurrency(0, 0))
					strNextMsg = "Would you like to enter a payment for this bill now?";
				else {
					if (!bIsCoPay) {
						// (j.jones 2010-08-06 11:42) - PLID 38613 - if we have co-insurance, state the amount
						if (cyTotalCoInsurance_ForDisplay > COleCurrency(0, 0)) {
							strNextMsg.Format("The patient's co-insurance total is %s.\n"
								"Would you like to enter a patient payment for this bill now?\n\n"
								"(The payment will only be directed to the patient's responsibilities.)", FormatCurrencyForInterface(cyTotalCoInsurance_ForDisplay));
						}
						else {
							strNextMsg = "Would you like to enter a patient payment for this bill now?\n\n"
								"(The payment will only be directed to the patient's responsibilities.)";
						}
					}
					else {
						strNextMsg = "Would you like to enter a co-payment for this bill now?\n";
					}
				}
				nPromptResult = MessageBox(strNextMsg, "Practice", MB_ICONQUESTION|MB_YESNO);
			} else {
				// Prompt is off - assume the answer is "No" since the user doesn't want to be prompted in the first place
				// (or we can't prompt them because we can't go with the "Yes" action)
				nPromptResult = IDNO;
			}

			BOOL bPaymentCreated = FALSE;

			if (IDYES == nPromptResult) {
				if (CheckCurrentUserPermissions(bioPayment, sptCreate)) {
					CPaymentDlg dlg(this);
					CString str;
					var.vt = VT_I4;
					var.lVal = GetBillID();
					dlg.m_varBillID = var;
					dlg.m_ApplyOnOK = TRUE;
					dlg.m_bIsCoPay = bIsCoPay;

					// (j.jones 2011-11-09 16:20) - PLID 46348 - this is now a pointer to our existing
					// array of copay apply information, with details per insured party
					if (bIsCoPay) {
						dlg.m_parypInsuranceCoPayApplyList = &arypInsuranceCoPayApplyList;
					}

					// (j.jones 2010-08-04 17:00) - PLID 38613 - we also pass in what the bill's co-insurance was
					// (j.jones 2011-11-09 16:17) - PLID 46348 - this parameter was renamed to clearly reflect that this
					// represents the total co-insurance for the entire bill, it could be for multiple insurance resps.
					// (j.jones 2015-11-05 12:42) - PLID 63866 - ensure this is rounded
					RoundCurrency(cyTotalCoInsurance_ForDisplay);
					dlg.m_cyTotalCoInsuranceAmt = cyTotalCoInsurance_ForDisplay;
					if (!bIsCoPay) {
						//patient resp
						dlg.m_cyFinalAmount = cyCharges - cyInsurance;
						dlg.m_cyMaxAmount = dlg.m_cyFinalAmount;
					}
					else {
						//default co-pay amount
						// (j.jones 2015-11-05 12:42) - PLID 63866 - ensure this is rounded
						RoundCurrency(cyDefaultCoPayAmt);
						dlg.m_cyCopayAmount = cyDefaultCoPayAmt;
						dlg.m_cyFinalAmount = cyDefaultCoPayAmt;
						//total amount
						dlg.m_cyMaxAmount = cyCharges;
					}

					// (j.jones 2008-05-01 11:26) - PLID 29287 - the payment dialog
					// can return more than just IDOK, we can't assume that IDOK is 
					// the only result that indicates success
					if (dlg.DoModal(__FUNCTION__, __LINE__) != IDCANCEL) {
						bPaymentCreated = TRUE;
						if (bIsCoPay) {
							m_List->Clear();
							// (r.gonet 08/01/2014) - PLID 62834 - Pass true to signify we are only reloading the current bill. This ensures charge on hold status is preserved.
							FillTabInfo(true);
						}
					}
				}
			}

			//Now that they may or may not have made a payment, we need to check if we need to delegate the co-pay amount
			//to the patient. This code will run if they cancelled the prompt to make a payment, or cancelled the payment itself.

			// (j.jones 2011-11-11 11:11 (these go to eleven)) - PLID 39217 - now we have to shift different amounts per charge
			if (bShiftCoPayBalance && !bPaymentCreated && arypInsuranceCoPayApplyList.GetSize() > 0) {

				for (int indexInsCoPayApplyList = 0; indexInsCoPayApplyList < arypInsuranceCoPayApplyList.GetSize(); indexInsCoPayApplyList++) {

					InsuranceCoPayApplyList *icpaiApplyList = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
					long nCurInsuredPartyID = icpaiApplyList->nInsuredPartyID;

					for (int indexCoPayApplies = 0; indexCoPayApplies < icpaiApplyList->aryCoPayApplyInformation.GetSize(); indexCoPayApplies++) {

						CoPayApplyInformation *cpaiApplyInfo = (CoPayApplyInformation*)icpaiApplyList->aryCoPayApplyInformation.GetAt(indexCoPayApplies);

						if (cpaiApplyInfo->cyCoPayAmount > COleCurrency(0, 0)) {

							COleCurrency cyRemAmountToShift = cpaiApplyInfo->cyCoPayAmount;

							//now we need to shift, but only for specific charges
							for (int indexChargeIDs = 0; indexChargeIDs < cpaiApplyInfo->aryChargeIDs.GetSize() && cyRemAmountToShift > COleCurrency(0, 0); indexChargeIDs++) {

								long nChargeID = cpaiApplyInfo->aryChargeIDs.GetAt(indexChargeIDs);

								// (j.jones 2013-08-20 12:45) - PLID 39987 - get the patient resp,
								// and only shift if the resp. isn't already there

								COleCurrency cyPatAmtNeededForCharge = COleCurrency(0, 0);

								COleCurrency cyRealPatResp = GetChargePatientResp(nChargeID);
								COleCurrency cyInsResp = GetChargeInsResp(nChargeID, nCurInsuredPartyID);

								//the "working" pat resp may be less than the actual resp.
								//if we have already set some money aside for coinsurance purposes
								COleCurrency cyWorkingPatResp = cyRealPatResp;

								// (j.jones 2013-08-21 13:17) - PLID 39987 - get the CoInsurance amount,
								// if we had both a coinsurance and a copay then we have to ensure the total of both
								COleCurrency cyChargeCoInsurance = COleCurrency(0, 0);
								if (info.mapChargeIDsToCoinsurance.Lookup(nChargeID, cyChargeCoInsurance) && cyChargeCoInsurance > COleCurrency(0, 0)) {
									//reduce the "working" pat resp so we know we shouldn't be
									//counting coinsurance towards amount to be set aside for a copay
									cyWorkingPatResp -= cyChargeCoInsurance;
								}

								bool bHasEnoughPatientResp = false;
								bool bHasTooMuchPatientResp = false;
								if (cyWorkingPatResp >= cyRemAmountToShift) {
									//we already have enough resp. for patient
									cyPatAmtNeededForCharge = cyRemAmountToShift;
									cyRemAmountToShift = COleCurrency(0, 0);
									bHasEnoughPatientResp = true;
									bHasTooMuchPatientResp = (cyWorkingPatResp > cyRemAmountToShift ? true : false);
								}
								else {
									COleCurrency cyTotalPossibleResp = cyWorkingPatResp + cyInsResp;

									if (cyTotalPossibleResp < cyRemAmountToShift) {
										//cannot shift more than there is in insurance+patient resps
										cyPatAmtNeededForCharge = cyTotalPossibleResp;
										cyRemAmountToShift -= cyTotalPossibleResp;
									}
									else {
										//we can shift the entire amount needed
										cyPatAmtNeededForCharge = cyRemAmountToShift;
										cyRemAmountToShift = COleCurrency(0, 0);
									}
								}

								// (j.jones 2013-08-20 14:12) - PLID 57959 - turn on bForceExactResp if this charge had its service code changed
								bool bHadServiceCodeChanged = false;
								info.mapChargeIDsWithChangedServiceCodes.Lookup(nChargeID, bHadServiceCodeChanged);
								//we already checked this, so we don't need to call this function unless we really
								//don't have enough resp, or the service code changed and we have too much resp.
								if (!bHasEnoughPatientResp || (bHadServiceCodeChanged && bHasTooMuchPatientResp)) {

									// (j.jones 2013-08-21 13:17) - PLID 39987 - if there is an existing CoInsurance amount,
									// factor that into the amount to be ensured, so that if we need coinsurance and copay,
									// we want the patient resp. to cover both
									if (cyChargeCoInsurance > COleCurrency(0, 0)) {
										cyPatAmtNeededForCharge += cyChargeCoInsurance;
									}
																		
									// (j.jones 2015-11-02 17:09) - PLID 67460 - we now shift to the next insurance responsibility
									long nNextInsuredPartyID = GetNextInsuredPartyIDByPriority(m_nPatientID, nCurInsuredPartyID);

									// (j.jones 2013-08-21 09:00) - PLID 58194 - added a descriptive audit string
									if (!EnsureInsuranceResponsibility(nChargeID, m_nPatientID, nCurInsuredPartyID, nNextInsuredPartyID, "Charge", cyPatAmtNeededForCharge, "while saving a bill for copay responsibility", COleDateTime::GetCurrentTime(), bHadServiceCodeChanged)) {

										//this failed, likely due to applies, so tell them so
										CString strWarn;
										strWarn.Format("A %s of %s could not be set as %s responsibility because there was not enough available responsibility to shift from insurance. "
											"It is likely there are existing applies preventing this shifting from occurring.\n\n"
											"Please review the patient and insurance responsibilities on this bill to make sure they are correct.",
											(cyChargeCoInsurance > COleCurrency(0, 0) ? "copay and coinsurance total" : "copay amount"),
											FormatCurrencyForInterface(cyPatAmtNeededForCharge),
											GetNameFromRespPartyID(nNextInsuredPartyID));
										AfxMessageBox(strWarn);
									}
								}
							}
						}
					}
				}

				m_List->Clear();
				// (r.gonet 08/01/2014) - PLID 62834 - Pass true to signify we are only reloading the current bill. This ensures charge on hold status is preserved.
				FillTabInfo(true);
			}

			// (j.jones 2011-11-11 11:11 (because it's louder)) - PLID 39217 - clear the memory in arypInsuranceCoPayApplyList
			for (int indexInsCoPayApplyList = arypInsuranceCoPayApplyList.GetSize() - 1; indexInsCoPayApplyList >= 0; indexInsCoPayApplyList--) {

				InsuranceCoPayApplyList *icpaiApplyList = (InsuranceCoPayApplyList*)arypInsuranceCoPayApplyList.GetAt(indexInsCoPayApplyList);
				if (icpaiApplyList != NULL) {

					for (int indexCoPayApplies = icpaiApplyList->aryCoPayApplyInformation.GetSize() - 1; indexCoPayApplies >= 0; indexCoPayApplies--) {

						CoPayApplyInformation *cpaiApplyInfo = (CoPayApplyInformation*)icpaiApplyList->aryCoPayApplyInformation.GetAt(indexCoPayApplies);
						if (cpaiApplyInfo != NULL) {
							delete cpaiApplyInfo;
							icpaiApplyList->aryCoPayApplyInformation.RemoveAt(indexCoPayApplies);
						}
					}
				}

				delete icpaiApplyList;
				arypInsuranceCoPayApplyList.RemoveAt(indexInsCoPayApplyList);
			}

			/**END PAYMENT CODE**/

			// Put the bill total in the variant
			GetDlgItem(IDC_LABEL_TOTAL)->GetWindowText(str);
			var.SetString(str);
			var = UnformatCurrency(var);
		}
		else if (!bPaymentOfferMade && info.IsNewBill && m_EntryType == 2) {

			bPaymentOfferMade = TRUE;

			COleCurrency cyQuoteTotalForPrePay = COleCurrency(0, 0);
			COleCurrency cyQuoteDepositTotalForPrePay = COleCurrency(0, 0);

			if (GetIsAnyPackage()) {
				// (j.jones 2005-06-10 16:08) - the prepayment will need to reflect the total cost plus tax
				// (j.jones 2007-04-23 13:35) - PLID 25746 - needs to reflect the "original" value, not total value,
				// incase they reduced the current amount upon creation
				cyQuoteTotalForPrePay = CalculateOriginalPackageValueWithTax(GetBillID());
			}
			else {
				CString strFee;
				GetDlgItemText(IDC_LABEL_TOTAL, strFee);
				cyQuoteTotalForPrePay = ParseCurrencyFromInterface(strFee);
			}
			cyQuoteGrandTotal = cyQuoteTotalForPrePay;

			//see if they want to make a prepayment

			// (j.jones 2007-02-20 10:50) - PLID 23706 - added a check for the billing license (will cause a usage further down)
			if (g_pLicense->CheckForLicense(CLicense::lcBill, CLicense::cflrSilent)) {

				long nDepositTypeRequired = GetRemotePropertyInt("QuoteDepositTypeRequired", 0, 0, "<None>", true);
				if (nDepositTypeRequired == 1) {
					//a percentage is required
					long nPercent = GetRemotePropertyInt("QuoteDepositPercent", 0, 0, "<None>", true);
					if (nPercent > 0) {
						//calculate the percentage required
						CString strFee;
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rs = CreateParamRecordset("SELECT Round(Convert(money,({OLECURRENCY} * (Convert(float,{INT})/100))),2) AS DepositAmt", cyQuoteTotalForPrePay, nPercent);
						if (!rs->eof) {
							cyQuoteDepositTotalForPrePay = AdoFldCurrency(rs, "DepositAmt");
							strFee = FormatCurrencyForInterface(cyQuoteDepositTotalForPrePay, TRUE, TRUE);

							//this is the new prepayment amount
							cyQuoteTotalForPrePay = cyQuoteDepositTotalForPrePay;
						}
						rs->Close();

						// (j.jones 2011-09-16 17:06) - PLID 18759 - the deposit should only help calculate the prepayment value,
						// we should NOT prompt about the deposit
						/*
						strQuestion.Format("A deposit of %li%% (%s) is required before scheduling a procedure.\n"
						"Would you like to enter a PrePayment now?",nPercent,strFee);
						*/
					}
				}
				else if (nDepositTypeRequired == 2) {
					//a flat fee is required
					CString strFee = GetRemotePropertyText("QuoteDepositFee", FormatCurrencyForInterface(COleCurrency(0, 0), TRUE, TRUE), 0, "<None>", true);
					cyQuoteDepositTotalForPrePay.ParseCurrency(strFee);
					if (strFee != FormatCurrencyForInterface(COleCurrency(0, 0), TRUE, TRUE)) {

						// (j.jones 2011-09-16 17:06) - PLID 18759 - the deposit should only help calculate the prepayment value,
						// we should NOT prompt about the deposit
						/*
						strQuestion.Format("A deposit of %s is required before scheduling a procedure.\n"
						"Would you like to enter a PrePayment now?",strFee);
						*/

						//this is the new prepayment amount
						cyQuoteTotalForPrePay = cyQuoteDepositTotalForPrePay;
					}
				}

				//if no deposit is required, use the normal prompts for prepays
				//if(strQuestion == "") 
				CString strQuestion = "";
				{
					if (GetIsAnyPackage() && GetRemotePropertyInt("PackageMakePrepay", 1, 0, "<None>", true) == 1) {
						strQuestion = "Would you like to enter a PrePayment for this package now?";
					}
					else if (!GetIsAnyPackage() && GetRemotePropertyInt("QuoteMakePrepay", 0, 0, "<None>", true) == 1) {
						strQuestion = "Would you like to enter a PrePayment for this quote now?";
					}
				}

				if (strQuestion != "") {
					if (IDYES == MessageBox(strQuestion, NULL, MB_YESNO)) {
						// (j.jones 2007-02-20 10:50) - PLID 23706 - added a check for the billing license (constitutes one use)
						if (CheckCurrentUserPermissions(bioPayment, sptCreate) && g_pLicense->CheckForLicense(CLicense::lcBill, CLicense::cflrUse)) {
							CPaymentDlg dlg(this);
							var.vt = VT_I4;
							var.lVal = GetBillID();
							dlg.m_varBillID = var;
							dlg.m_bIsPrePayment = TRUE;
							dlg.m_QuoteID = GetBillID();
							dlg.m_cyFinalAmount = cyQuoteTotalForPrePay;
							dlg.DoModal(__FUNCTION__, __LINE__);
						}
					}
				}
			}
		}

		if (info.IsNewBill && m_EntryType == 2) {
			// (z.manning, 01/03/2007) - PLID 24078 - This is a new quote, so if they have the preference enabled,
			// ask them if they want to apply for CareCredit financing.
			// (z.manning, 01/09/2007) - PLID 24057 - Don't bother even trying to open if we're not licensed.
			// (z.manning, 01/11/2007) - PLID 24062 - No need to do anything if we don't have permissions for CareCredit.
			// (d.thompson 2012-08-07) - PLID 51969 - Changed default to No
			if (GetRemotePropertyInt("QuotePromptCareCredit", 0, 0, "<None>", true) == 1
				&& (GetCurrentUserPermissions(bioCareCreditIntegration) & (sptView | sptViewWithPass))
				&& g_pLicense->CheckForLicense(CLicense::lcCareCredit, CLicense::cflrSilent))
			{
				COleCurrency cyThreshold(GetRemotePropertyInt("QuotePromptCareCreditThreshold", 300, 0, "<None>", true), 0);
				if (cyQuoteGrandTotal >= cyThreshold) {
					NxCareCredit::OpenCCWare(m_nPatientID);
				}
			}

			// (j.jones 2011-07-08 13:49) - PLID 26785 - added ability to auto-bill new packages
			if (GetIsAnyPackage()) {
				//don't try to bill it now, just flag that we just saved a new package
				m_bSavedNewPackage = TRUE;
			}
		}

	}NxCatchAll("BillingDlg::SaveChanges - Payments");
}


void CBillingDlg::SaveChanges_DeleteBilledQuotes(SaveInfo& info)
{
	try {
		//delete the quote(s) now, not when you first make the bill
		for (int i = 0; i < m_arypBilledQuotes.GetSize(); i++) {
			if (((BilledQuote*)m_arypBilledQuotes.GetAt(i))->bDeleteQuote) {
				DeleteBill(((BilledQuote*)m_arypBilledQuotes.GetAt(i))->nQuoteID);
			}
		}
	}NxCatchAll("BillingDlg::SaveChanges - Delete Quote");
}



// (a.walling 2014-02-25 17:59) - PLID 61031 - Refactor BillingDlg::SaveChanges - Break up into major component functions
// Call the relevant SaveChanges component functions now.
int CBillingDlg::SaveChanges()
{
	CWaitCursor pWait;
	SaveInfo info;

	if (SCR_SAVED != (info.scr = SaveChanges_Validate(info))) {
		return info.scr;
	}
	if (SCR_SAVED != (info.scr = SaveChanges_ValidateCPTICD9Link(info))) {
		return info.scr;
	}
	if (SCR_SAVED != (info.scr = SaveChanges_ValidateConditionDates(info))) {
		return info.scr;
	}
	if (SCR_SAVED != (info.scr = SaveChanges_G2DiagCodes(info))) {
		return info.scr;
	}
	if (SCR_SAVED != (info.scr = SaveChanges_TrackedAllocations(info))) {
		return info.scr;
	}

	info.scr = SCR_SAVED;

	SaveChanges_BilledQuotes(info);
	SaveChanges_CaseHistories(info);
	SaveChanges_BilledEMNs(info);
	SaveChanges_DecrementPackageCount(info);
	SaveChanges_DeleteCharges(info);
	SaveChanges_Charges(info);
	SaveChanges_InventoryTodoAlarms(info);
	SaveChanges_Bill(info);
	SaveChanges_RewardPoints(info);
	SaveChanges_Tracking(info);
	SaveChanges_SendPatBalTableChecker(info);
	SaveChanges_Payments(info);
	SaveChanges_DeleteBilledQuotes(info);

	return info.scr;
}

// (r.gonet 07/08/2014) - PLID 62569 - Puts a charge on hold and cascades this to the related line item corrections
// - nLineID: Line the charge is on
// - bOnHold: True to put the charge and its correction group on hold. False to remove a hold from the charge and its correction group.
void CBillingDlg::CascadeOnHold(long nLineID, BOOL bOnHold)
{
	// Gather all the corrections related to this charge
	std::set<long> setCorrectionGroupLineIDs;
	const BillingItemPtr* pChargeBillingItem = NULL;
	// Find the billing item that matches the charge
	for each(const BillingItemPtr& billingItem in m_billingItems)
	{
		if (VarLong(billingItem->LineID) == nLineID) {
			pChargeBillingItem = &billingItem;
			break;
		}
	}

	while (pChargeBillingItem != NULL) {
		nLineID = VarLong((*pChargeBillingItem)->LineID);

		// Add the charge to the correction group
		if (setCorrectionGroupLineIDs.insert(nLineID).second == false) {
			// Element already existed. Cycle somehow. Should be impossible. Prevent an infinite loop.
			ASSERT(FALSE);
			break;
		}

		if (VarBool((*pChargeBillingItem)->OnHold, FALSE) != bOnHold) {
			(*pChargeBillingItem)->OnHold = (bOnHold ? g_cvarTrue : g_cvarFalse);
			long nChargeID = (*pChargeBillingItem)->ChargeID;
			if (nChargeID != -2) {
				AddToModifiedList(nChargeID, TRUE);
			}
		}

		long nVoidingLineItemID = VarLong((*pChargeBillingItem)->VoidingLineItemID, -1);
		long nOriginalLineItemID = VarLong((*pChargeBillingItem)->OriginalLineItemID, -1);


		const BillingItemPtr* pVoidingBillingItem = NULL;
		if (nVoidingLineItemID != -1) {
			// Find the billingitem related to the voiding charge
			for each(const BillingItemPtr& billingItem in m_billingItems)
			{
				// Careful. The above match compared the line ID because the charge could be unsaved. This on the other hand compares the charge ID because it is saved and it is all we have.
				if (VarLong(billingItem->ChargeID, -1) == nVoidingLineItemID) {
					pVoidingBillingItem = &billingItem;
					break;
				}
			}
			if (pVoidingBillingItem == NULL) {
				// Somehow it isn't in our bill. Huh.
			} else {
				// Add the voiding charge to the correction group
				long nVoidingLineID = (*pVoidingBillingItem)->LineID;
				setCorrectionGroupLineIDs.insert(nVoidingLineID);
				// Put the voiding charge on hold or remove the hold if this would change its OnHold status.
				if (VarBool((*pVoidingBillingItem)->OnHold, FALSE) != bOnHold) {
					(*pVoidingBillingItem)->OnHold = (bOnHold ? g_cvarTrue : g_cvarFalse);
					AddToModifiedList(nVoidingLineItemID, TRUE);
				}
			}
		}
		// We'll add the original charge next time around the loop

		// Go up to the parent
		pChargeBillingItem = NULL;
		if (nOriginalLineItemID != -1) {
			// Find the billing item that matches the charge
			for each(const BillingItemPtr& billingItem in m_billingItems)
			{
				if (VarLong(billingItem->ChargeID) == nOriginalLineItemID) {
					pChargeBillingItem = &billingItem;
					break;
				}
			}
		}
	}

	// Update the datalist
	IRowSettingsPtr pChargeRow = m_List->GetFirstRow();
	while (pChargeRow) {
		long nRowLineID = VarLong(pChargeRow->GetValue(COLUMN_LINE_ID), -1);
		if (setCorrectionGroupLineIDs.find(nRowLineID) != setCorrectionGroupLineIDs.end()) {
			pChargeRow->PutValue(BILL_COLUMN_ON_HOLD, (bOnHold ? g_cvarTrue : g_cvarFalse));
			pChargeRow->BackColor = bOnHold ? CHARGE_ON_HOLD_BACK_COLOR : RGB(255, 255, 255);
			pChargeRow->BackColorSel = bOnHold ? CHARGE_ON_HOLD_BACK_COLOR_SEL : 1;
		}
		pChargeRow = pChargeRow->GetNextRow();
	}
}

// (j.jones 2010-08-04 11:14) - PLID 38613 - broke this function down into multiple parts,
// and took in an optional charge ID, if left as -1 we calculate for the whole bill	
COleCurrency CBillingDlg::CalculateBillTotalWithAllowables(long nFilterByChargeID /*= -1*/)
{
	BillingItemPtr pItem;
	COleCurrency cyAmount = COleCurrency(0, 0);
	COleCurrency cyLineTotal = COleCurrency(0, 0);
	COleCurrency cyAllowableTotal = COleCurrency(0, 0);
	BOOL bUseAllowable = FALSE;

	BOOL bPref = GetRemotePropertyInt("UseAllowableForPercentageCopay", 1, 0, "<None>", TRUE);

	for (int i = 0; i < (int)m_billingItems.size(); i++) {

		pItem = m_billingItems[i];

		// (j.jones 2010-08-04 11:17) - PLID 38613 - if given a nFilterByChargeID,
		// ignore other charges
		if (nFilterByChargeID != -1 && VarLong(pItem->ChargeID, -1) != nFilterByChargeID) {
			continue;
		}

		if (pItem->HasAllowable.vt == VT_BOOL) {

			if (VarBool(pItem->HasAllowable)) {

				//check to see if they are using the preference
				if (bPref) {

					if (pItem->UnitAllowable.vt == VT_CY) {

						double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
						dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

						if (pItem->Quantity.vt == VT_R8) {
							dblQuantity = VarDouble(pItem->Quantity, 1.0);
						}
						if (pItem->Multiplier1.vt == VT_R8) {
							dblMultiplier1 = VarDouble(pItem->Multiplier1, 1.0);
						}
						if (pItem->Multiplier2.vt == VT_R8) {
							dblMultiplier2 = VarDouble(pItem->Multiplier2, 1.0);
						}
						if (pItem->Multiplier3.vt == VT_R8) {
							dblMultiplier3 = VarDouble(pItem->Multiplier3, 1.0);
						}
						if (pItem->Multiplier4.vt == VT_R8) {
							dblMultiplier4 = VarDouble(pItem->Multiplier4, 1.0);
						}

						cyAllowableTotal = VarCurrency(pItem->UnitAllowable, COleCurrency(0, 0));
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);
						cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
						bUseAllowable = TRUE;
					}
					else {
						ASSERT(FALSE);
					}
				}
				else {

					//use the charge amount
					cyAllowableTotal = COleCurrency(0, 0);
					cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
					bUseAllowable = FALSE;
				}
			}
			else {

				//just use the charge amount
				cyAllowableTotal = COleCurrency(0, 0);
				cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
				bUseAllowable = FALSE;
			}
		}
		else {
			//ASSERT(FALSE);
			//this can happen if they bill a quote or surgery as it doesn't check Multifees, so check it here

			//loop through the datalist rows to get the Insurance
			IRowSettingsPtr pRow = m_List->GetFirstRow();
			long nInsID = -1;

			while (pRow) {

				if (VarLong(pItem->LineID) == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {

					_variant_t varIns = pRow->GetValue(COLUMN_INS_RESP);

					if ((varIns.vt == VT_CY && COleCurrency(varIns.cyVal) > COleCurrency(0, 0))) {

						//our amount fits what we're looking for, so lookup the insurance co id

						long nInsuredPartyID = -2;
						_variant_t var = pRow->GetValue(COLUMN_INS_PARTY_ID);
						if (var.vt == VT_I4 && var.lVal >= -1)
							nInsuredPartyID = var.lVal;

						// (d.lange 2015-12-01 11:51) - PLID 67127 - Determine the most-primary insurance based on the insurance
						// category for the given insured party
						_RecordsetPtr rsIns = GetMostPrimaryInsCoIDForInsuredPartyRecordset(nInsuredPartyID);
						if (!rsIns->eof) {
							nInsID = AdoFldLong(rsIns, "InsuranceCoID");
						}
						else {
							nInsID = -1;
						}

					}
					else {
						nInsID = -1;
					}
				}

				pRow = pRow->GetNextRow();
			}

			if (nInsID != -1) {
				// (j.jones 2009-08-10 12:56) - PLID 34841 - properly initialized these variables
				BOOL bHasAllowable = FALSE;
				COleCurrency cyAllowable = COleCurrency(0, 0);

				long nLocationID;
				if (m_LocationCombo->GetCurSel() == -1)
					nLocationID = GetCurrentLocationID();
				else
					nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;


				// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
				long nPOSID = -1;
				if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
					nPOSID = GetCurrentLocationID();
				}
				else {
					nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
				}

				BOOL bInvalid;
				CString strInvalid;

				// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
				GetMultiFee(VarLong(pItem->ServiceID), VarLong(pItem->Provider, -1), nInsID, nLocationID, nPOSID, VarDateTime(pItem->Date), bInvalid, bInvalid, strInvalid, bHasAllowable, cyAllowable);
				if (bHasAllowable) {
					double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
					dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

					if (pItem->Quantity.vt == VT_R8) {
						dblQuantity = VarDouble(pItem->Quantity, 0.0);
					}
					if (pItem->Multiplier1.vt == VT_R8) {
						dblMultiplier1 = VarDouble(pItem->Multiplier1, 0.0);
					}
					if (pItem->Multiplier2.vt == VT_R8) {
						dblMultiplier2 = VarDouble(pItem->Multiplier2, 0.0);
					}
					if (pItem->Multiplier3.vt == VT_R8) {
						dblMultiplier3 = VarDouble(pItem->Multiplier3, 0.0);
					}
					if (pItem->Multiplier4.vt == VT_R8) {
						dblMultiplier4 = VarDouble(pItem->Multiplier4, 0.0);
					}

					cyAllowableTotal = cyAllowable;
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);
					cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
					pItem->HasAllowable = _variant_t(VARIANT_TRUE, VT_BOOL);
					// (j.jones 2010-09-02 09:42) - PLID 40330 - split allowable into Unit and Total
					pItem->UnitAllowable = _variant_t(cyAllowable);
					RoundCurrency(cyAllowableTotal);
					pItem->TotalAllowable = _variant_t(cyAllowableTotal);
					bUseAllowable = TRUE;
				}
				else {
					pItem->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
					cyAllowableTotal = COleCurrency(0, 0);
					cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
					pItem->TotalAllowable = g_cvarNull;
					bUseAllowable = FALSE;
				}
			}
			else {
				cyAllowableTotal = COleCurrency(0, 0);
				cyLineTotal = VarCurrency(pItem->LineTotal, COleCurrency(0, 0));
				bUseAllowable = FALSE;
			}
		}

		//now add it up
		if (bUseAllowable) {
			if (cyAllowableTotal > cyLineTotal) {
				//use the charge total
				cyAmount += cyLineTotal;
			}
			else {
				//use the allowable
				cyAmount += cyAllowableTotal;
			}
		}
		else {
			//use the line total
			cyAmount += cyLineTotal;
		}
	}

	RoundCurrency(cyAmount);
	return cyAmount;
}

// (j.jones 2010-08-04 11:14) - PLID 38613 - broke this function down into multiple parts,
// and took in an optional charge ID, if left as -1 we calculate for the whole bill	
COleCurrency CBillingDlg::CalculatePercentOfBillTotalWithAllowables(long nPercent, long nFilterByChargeID /*= -1*/)
{

	COleCurrency cyAmount = CalculateBillTotalWithAllowables(nFilterByChargeID);

	return CalculatePercentOfAmount(cyAmount, nPercent);
}

// (j.jones 2010-08-04 12:29) - PLID 38613 - added a generic function to calculate percentages of currencies
// (j.jones 2012-07-30 14:38) - PLID 47778 - moved to global financial utils
//COleCurrency CBillingDlg::CalculatePercentOfAmount(COleCurrency cyAmount, long nPercent)

// (j.jones 2016-02-26 15:09) - PLID 68339 - added a flag to optionally force a package recalculation
void CBillingDlg::Requery(bool bRecalculatePackageTotal /*= false*/)
{
	CWaitCursor pWait;

	if (m_EntryType == 1)
		FillBillList();
	else
		FillQuoteList();
	/* Recalculate the bill total */
	CalculateTotal(bRecalculatePackageTotal);
}

void CBillingDlg::ChangeAccess()
{
	// (j.jones 2011-01-21 10:10) - PLID 42156 - The access level is now an enum, to handle
	// partial access. Many billing columns are blocked by partial access, but very few
	// actual controls (like the location dropdown) require full access to use them.

	if (m_eHasAccess != batNoAccess && m_EntryType == 2 && m_bQuoteHasBeenBilled && GetIsAnyPackage()) {
		//the user is marking an existing package editable
		//warn them about their changes
		MessageBox("You are preparing to edit the contents of an existing package that has been billed.\n"
			"Be forewarned that any changes you make to this package will not automatically update \n"
			"any properties of this package, such as the total cost or patient's current balance.\n"
			"You will have to edit each one of these values manually.", "Practice", MB_ICONEXCLAMATION | MB_OK);
	}

	/* Disable items if necessary */
	GetDlgItem(IDC_COMBO_BILL_TO)->EnableWindow(m_eHasAccess != batNoAccess);
	// (j.armen 2014-08-06 14:49) - PLID 63161 - Enabled / Disable the billing search
	if (m_pBillingDiagSearch) m_pBillingDiagSearch->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_COMBO_CPT)->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_COMBO_QUOTE)->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_COMBO_PRODUCTS)->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_COMBO_SRGY)->EnableWindow(m_eHasAccess != batNoAccess);
	m_WhatToAddCombo->Enabled = (m_eHasAccess != batNoAccess);

	// (b.eyers 2015-02-19) - PLID 46934 - when the preference to default 'bill a' was set to appointments, this was enabled when it shouldn't have been
	GetDlgItem(IDC_COMBO_APPOINTMENTS)->EnableWindow(m_eHasAccess != batNoAccess);

	// (j.jones 2011-01-21 10:20) - PLID 42156 - you must have full access to change the bill location
	GetDlgItem(IDC_COMBO_LOCATION)->EnableWindow(m_eHasAccess == batFullAccess);

	GetDlgItem(IDC_COMBO_PLACEOFSERVICE)->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_COMBO_DESIGNATION)->EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_BTN_EDIT_POS_CODES)->EnableWindow(m_eHasAccess != batNoAccess);
	// (r.gonet 07/01/2014) - PLID 62531 - If they have no access to write to the bill, they can't change the status.
	m_pBillStatusCombo->Enabled = (m_eHasAccess != batNoAccess) ? VARIANT_TRUE : VARIANT_FALSE;
	m_btnBillStatusConfig.EnableWindow(m_eHasAccess != batNoAccess);
	// (r.gonet 07/01/2014) - PLID 62523 - If they have no access to write to the bill, they can't change the status note.
	m_pBillStatusNoteCombo->Enabled = (m_eHasAccess != batNoAccess) ? VARIANT_TRUE : VARIANT_FALSE;
	// (r.gonet 07/01/2014) - PLID 62524 - If they have no access to write to the bill, they can't change the satuts note.
	m_nxeditBillStatusNote.EnableWindow(m_eHasAccess != batNoAccess);
	m_btnBillStatusNoteConfig.EnableWindow(m_eHasAccess != batNoAccess);
	GetDlgItem(IDC_FILTER_CODES)->EnableWindow(m_eHasAccess != batNoAccess);


	// (j.gruber 2007-05-02 16:23) - PLID 14202 - add a button to discount entire bill
	// (j.gruber 2007-08-24 15:00) - PLID 24632 - permission it
	if (m_EntryType == 1) {

		// (j.jones 2011-01-21 10:20) - PLID 42156 - you must have full access to change the discounts on a bill

		// (j.gruber 2009-03-31 17:29) - PLID 33356 - the new advanced discount button
		GetDlgItem(IDC_BTN_ADVANCED_DISCOUNTING)->EnableWindow(m_eHasAccess == batFullAccess);

		if (!(GetCurrentUserPermissions(bioDiscountEntireBill) & (SPT___W_______))) {
			if (!(GetCurrentUserPermissions(bioDiscountEntireBill) & (SPT___W________ANDPASS))) {
				//they don't have permission
				GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(FALSE);
			}
			else {
				GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(m_eHasAccess == batFullAccess);
			}
		}
		else {
			GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(m_eHasAccess == batFullAccess);
		}
	}
	else {

		// (j.gruber 2009-03-31 17:29) - PLID 33356 - the new advanced discount button
		GetDlgItem(IDC_BTN_ADVANCED_DISCOUNTING)->EnableWindow(m_eHasAccess != batNoAccess);

		//its a quote
		if (!(GetCurrentUserPermissions(bioDiscountEntireQuote) & (SPT___W_______))) {
			if (!(GetCurrentUserPermissions(bioDiscountEntireQuote) & (SPT___W________ANDPASS))) {
				//they don't have permission
				GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(FALSE);
			}
			else {
				GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(m_eHasAccess != batNoAccess);
			}
		}
		else {
			GetDlgItem(IDC_BTN_APPLY_DISCOUNT_TO_ALL)->EnableWindow(m_eHasAccess != batNoAccess);
		}
	}




	if (m_nIDTemplate == IDD_BILLING_DLG)
	{
		m_packageCheck.EnableWindow(m_eHasAccess != batNoAccess);
		m_radioRepeatPackage.EnableWindow(m_eHasAccess != batNoAccess);
		m_radioMultiUsePackage.EnableWindow(m_eHasAccess != batNoAccess);
		m_quoteExpCheck.EnableWindow(m_eHasAccess != batNoAccess);
		GetDlgItem(IDC_QUOTE_EXP_DAY_LABEL)->EnableWindow(m_eHasAccess != batNoAccess);
		GetDlgItem(IDC_QUOTE_EXP_DAYS)->EnableWindow(m_eHasAccess != batNoAccess);
		GetDlgItem(IDC_QUOTE_EXPIRE_DATE_LABEL)->EnableWindow(m_eHasAccess != batNoAccess);
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_COUNT))->SetReadOnly(m_eHasAccess == batNoAccess);
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_TOTAL_COUNT))->SetReadOnly(m_eHasAccess == batNoAccess);
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_TOTAL_COST))->SetReadOnly(m_eHasAccess == batNoAccess);
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE))->SetReadOnly(m_eHasAccess == batNoAccess);
		// (j.jones 2009-12-22 14:32) - PLID 32587 - disable the original amount fields
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT))->SetReadOnly(m_eHasAccess == batNoAccess);
		((CNxEdit*)GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT))->SetReadOnly(m_eHasAccess == batNoAccess);
		m_checkPackageShowInitialValues.EnableWindow(m_eHasAccess != batNoAccess);
	}
	// (j.jones 2011-08-16 11:45) - PLID 44773 - datalists need to use the ReadOnly flag, not Enabled
	m_List->ReadOnly = !(m_eHasAccess != batNoAccess);
	m_QuoteList->ReadOnly = !(m_eHasAccess != batNoAccess);
}

BOOL CBillingDlg::OnInitDialog()
{
	CWaitCursor pWait;

	CNxDialog::OnInitDialog();

	try {

		// (c.haag 2008-05-01 15:29) - PLID 29871 - NxIconify the Apply Discount to All button
		m_nxibApplyDiscountToAll.AutoSet(NXB_MODIFY);

		// (j.gruber 2009-03-31 17:36) - PLID 33356 - make the adv discounts a modified status
		m_nxibAdvancedDiscounting.AutoSet(NXB_MODIFY);

		m_filterCodesButton.SetIcon(IDI_FILTER);
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);
		m_bCptCodesFilter = false;
		m_bProductsFilter = false;
		m_filterCodesButton.SetToolTip("Toggle a filter of Service Codes or Inventory Items according to specific keywords");

		m_rsBill.CreateInstance(__uuidof(Recordset));
		m_rsDoctors.CreateInstance(__uuidof(Recordset));

		// (j.jones 2011-10-04 15:38) - PLID 45799 - the two charge lists are now DL2s
		m_List = BindNxDataList2Ctrl(IDC_LIST, false);
		m_QuoteList = BindNxDataList2Ctrl(IDC_QUOTE_LIST, false);

		m_CPTCombo = BindNxDataListCtrl(IDC_COMBO_CPT, false);
		m_SrgyCombo = BindNxDataListCtrl(IDC_COMBO_SRGY, false);
		m_QuotesCombo = BindNxDataListCtrl(IDC_COMBO_QUOTE, false);
		m_ProductsCombo = BindNxDataListCtrl(IDC_COMBO_PRODUCTS, false);

		m_listBillTo = BindNxDataListCtrl(IDC_COMBO_BILL_TO, false);
		// (j.gruber 2012-07-26 10:07) - PLID 51777 - add more types
		NXDATALISTLib::IColumnSettingsPtr pCol = m_listBillTo->GetColumn(btcCategoryTypeName);
		if (pCol) {
			pCol->PutFieldName("CASE WHEN Priority IN (1,2) THEN 'Medical' WHEN Priority = -1 THEN '' ELSE "
				" CASE WHEN CategoryType = 2 THEN 'Vision' "
				" WHEN CategoryType = 3 THEN 'Auto' "
				" WHEN CategoryType = 4 THEN 'Workers'' Comp.' "
				" WHEN CategoryType = 5 THEN 'Dental' "
				" WHEN CategoryType = 6 THEN 'Study' "
				" WHEN CategoryType = 7 THEN 'Letter of Protection' "
				" WHEN CategoryType = 8 THEN 'Letter of Agreement' "
				" ELSE 'Medical' END END");
		}
		m_WhatToAddCombo = BindNxDataListCtrl(IDC_WHAT_TO_ADD_COMBO, false);

		m_CaseHistoryCombo = BindNxDataListCtrl(IDC_COMBO_CASE_HISTORY, false);
		m_EMRCombo = BindNxDataList2Ctrl(IDC_COMBO_EMR, false);

		// (j.jones 2008-06-20 10:38) - PLID 26153 - added Appointments
		m_AppointmentCombo = BindNxDataList2Ctrl(IDC_COMBO_APPOINTMENTS, false);

		//TES 4/13/2011 - PLID 43249 - Added Glasses Orders
		m_GlassesOrderCombo = BindNxDataList2Ctrl(IDC_COMBO_GLASSES_ORDERS, false);

		//also stretch the lists if the IDC_BTN_TOGGLE_INDIV_BATCH button isn't there
		// (j.jones 2009-06-09 15:31) - PLID 34545 - do not stretch the lists anymore,
		// we have other buttons that should not be hidden
		if (m_EntryType == 2) {
			//hide the button if a quote
			GetDlgItem(IDC_BTN_TOGGLE_INDIV_BATCH)->ShowWindow(SW_HIDE);
		}
		else if (m_EntryType == 1 &&
			!g_pLicense->CheckForLicense(CLicense::lcHCFA, CLicense::cflrSilent) &&
			!g_pLicense->CheckForLicense(CLicense::lcEbill, CLicense::cflrSilent)) {

			//hide the button if a bill and the client doesn't have HCFA or Ebilling
			GetDlgItem(IDC_BTN_TOGGLE_INDIV_BATCH)->ShowWindow(SW_HIDE);
		}

		// (j.jones 2012-03-21 11:38) - PLID 48155 - if the Alberta preference is on,
		// rename the POS field to Functional Centre
		if (UseAlbertaHLINK()) {
			m_nxstaticLabelDesig.SetWindowText("Functional Centre");
		}
		else {
			m_nxstaticLabelDesig.SetWindowText("Place of Service Designatio&n");
		}

		// (j.jones 2007-07-03 17:06) - PLID 26098 - load up our modifier array
		PopulateServiceModifierLinkArray();

		m_GiftCombo = BindNxDataListCtrl(IDC_COMBO_GIFT, false);

		m_bCPTCombo = FALSE;
		m_bSurgeryCombo = FALSE;
		m_bProductsCombo = FALSE;
		m_bQuotesCombo = FALSE;
		m_bEMRCombo = FALSE;
		m_bGiftCombo = FALSE;
		m_bRefCombo = FALSE;
		m_bAppointmentCombo = FALSE;	// (j.jones 2008-06-20 10:32) - PLID 26153
		m_bGlassesOrderCombo = FALSE;	//TES 4/13/2011 - PLID 43249

		// (j.jones 2008-06-20 10:26) - PLID 26153 - For the appointment list, I am setting the from clause
		// in code for readability purposes. There's no functional reason for it.
		// (j.jones 2008-06-24 09:22) - PLID 30455 - well now there's a reason, I made the query be global
		// so the scheduler can run it to confirm whether an appt. will exist in this list
		CString strFrom;
		strFrom.Format("(%s) AS AppointmentsQ", GetBillAppointmentQuery());
		m_AppointmentCombo->FromClause = _bstr_t(strFrom);
		//do not requery the appointments combo until it is requested

		//for surgeries, only sum up pay-to-practice and billable items, but...
		if (m_EntryType == 1)
			//for a bill, only display surgeries that have at least one PayToPractice and Billable item
			// (j.gruber 2009-03-12 11:59) - PLID 33361 - changed surgery structure
			// (j.jones 2009-08-24 10:32) - PLID 35271 - removed Billable
			// (j.jones 2010-01-06 16:17) - PLID 36757 - exposed SurgeriesT.IsPackage, and forcibly filtered on IsPackage = 0,
			// also the surgery total is the package total when it is a package
			m_SrgyCombo->FromClause = "(SELECT ID, IsPackage, Sum(Round(Convert(money, (Amount * Quantity * "
			"(CASE WHEN([PercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[PercentOff]))/100) END)) "
			"- (CASE WHEN [Discount] Is Null THEN 0 ELSE [Discount] END)),2)) AS Total, BillSurgeryComboSubQ.Name AS Surgery "
			"FROM (SELECT SurgeriesT.ID, SurgeriesT.Name, SurgeryDetailsT.Quantity, SurgeryDetailsT.Amount, "
			"(SELECT Sum(SurgeryDetailDiscountsT.PercentOff) FROM SurgeryDetailDiscountsT WHERE SurgeryDetailDiscountsT.SurgeryDetailID = SurgeryDetailsT.ID) as PercentOff, "
			"(SELECT Sum(SurgeryDetailDiscountsT.Discount) FROM SurgeryDetailDiscountsT  WHERE SurgeryDetailDiscountsT.SurgeryDetailID = SurgeryDetailsT.ID) as Discount, "
			"(CASE WHEN(Products.ProductID Is Not Null AND ServiceT.Taxable1=1) THEN 1 ELSE 0 END) AS Taxable1, "
			"(CASE WHEN(Products.ProductID Is Not Null AND ServiceT.Taxable2=1) THEN 1 ELSE 0 END) AS Taxable2, "
			"SurgeriesT.IsPackage "
			"FROM (SurgeriesT INNER JOIN SurgeryDetailsT ON SurgeriesT.ID = SurgeryDetailsT.SurgeryID) "
			"LEFT JOIN ServiceT ON SurgeryDetailsT.ServiceID = ServiceT.ID LEFT JOIN "
			"(SELECT ID AS ProductID FROM ProductT) AS Products ON SurgeryDetailsT.ServiceID = Products.ProductID "
			"WHERE SurgeriesT.IsPackage = 0 AND SurgeryDetailsT.PayToPractice = 1) AS BillSurgeryComboSubQ "
			"GROUP BY BillSurgeryComboSubQ.Name, BillSurgeryComboSubQ.IsPackage, BillSurgeryComboSubQ.ID) AS SurgeryComboQ";
		else
			//for a quote, display all surgeries that have at least one billable item, but only show the total that will be paid to the practice
			// (j.gruber 2009-03-12 11:58) - PLID 33361 - new surgeries structure
			// (j.jones 2009-08-24 10:32) - PLID 35271 - removed Billable
			// (j.jones 2010-01-06 16:17) - PLID 36757 - packages should show the package total
			m_SrgyCombo->FromClause = "(SELECT ID, IsPackage, CASE WHEN IsPackage = 1 THEN PackageTotalAmount ELSE "
			"Sum(Round(Convert(money, (Amount * Quantity * "
			"(CASE WHEN([PercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[PercentOff]))/100) END)) "
			"- (CASE WHEN [Discount] Is Null THEN 0 ELSE [Discount] END)),2)) END AS Total, "
			"BillSurgeryComboSubQ.Name AS Surgery "
			"FROM (SELECT SurgeriesT.ID, SurgeriesT.Name, SurgeryDetailsT.Quantity, "
			"(SELECT Sum(SurgeryDetailDiscountsT.PercentOff) FROM SurgeryDetailDiscountsT WHERE SurgeryDetailDiscountsT.SurgeryDetailID = SurgeryDetailsT.ID) as PercentOff, "
			"(SELECT Sum(SurgeryDetailDiscountsT.Discount) FROM SurgeryDetailDiscountsT  WHERE SurgeryDetailDiscountsT.SurgeryDetailID = SurgeryDetailsT.ID) as Discount, "
			"(CASE WHEN PayToPractice = 1 THEN SurgeryDetailsT.Amount ELSE 0 END) AS Amount, "
			"(CASE WHEN(Products.ProductID Is Not Null AND ServiceT.Taxable1=1) THEN 1 ELSE 0 END) AS Taxable1, "
			"(CASE WHEN(Products.ProductID Is Not Null AND ServiceT.Taxable2=1) THEN 1 ELSE 0 END) AS Taxable2, "
			"SurgeriesT.IsPackage, SurgeriesT.PackageTotalAmount "
			"FROM (SurgeriesT INNER JOIN SurgeryDetailsT ON SurgeriesT.ID = SurgeryDetailsT.SurgeryID) "
			"LEFT JOIN ServiceT ON SurgeryDetailsT.ServiceID = ServiceT.ID LEFT JOIN "
			"(SELECT ID AS ProductID FROM ProductT) AS Products ON SurgeryDetailsT.ServiceID = Products.ProductID "
			") AS BillSurgeryComboSubQ "
			"GROUP BY BillSurgeryComboSubQ.Name, "
			"BillSurgeryComboSubQ.IsPackage, BillSurgeryComboSubQ.PackageTotalAmount, "
			"BillSurgeryComboSubQ.ID) AS SurgeryComboQ";

		m_LocationCombo = BindNxDataListCtrl(IDC_COMBO_LOCATION);
		m_PlaceOfServiceCombo = BindNxDataListCtrl(IDC_COMBO_PLACEOFSERVICE);
		m_DesignationCombo = BindNxDataListCtrl(IDC_COMBO_DESIGNATION);

		// (r.gonet 06/30/2014) - PLID 62531 - Bind the bill status combo
		m_pBillStatusCombo = BindNxDataList2Ctrl(IDC_BILL_STATUS_COMBO);
		// (r.gonet 07/01/2014) - PLID 62531 - Add the default no selection row.
		NXDATALIST2Lib::IRowSettingsPtr pBillStatusRow = m_pBillStatusCombo->GetNewRow();
		pBillStatusRow->PutValue((short)EBillStatusComboColumns::ID, (long)-1);
		pBillStatusRow->PutValue((short)EBillStatusComboColumns::Name, _bstr_t(" <No Status>"));
		pBillStatusRow->PutValue((short)EBillStatusComboColumns::Type, g_cvarNull);
		pBillStatusRow->PutValue((short)EBillStatusComboColumns::Inactive, g_cvarFalse);
		pBillStatusRow->PutValue((short)EBillStatusComboColumns::Custom, g_cvarFalse);
		m_pBillStatusCombo->AddRowBefore(pBillStatusRow, m_pBillStatusCombo->GetFirstRow());

		// (r.gonet 06/30/2014) - PLID 62523 - Bind the bill status note combo. Should be blank by default.
		m_pBillStatusNoteCombo = BindNxDataList2Ctrl(IDC_BILL_STATUS_NOTE_COMBO);
		// (r.gonet 07/02/2014) - PLID 62524 - Limit the status note to 3000 characters. The NoteDataT.Note column
		// is the limiter here with it being 4000 chars. Technically, we could limit this field to 4000 - (length of the username suffix)
		// but since that is an ugly number, rounding down to 3000.
		m_nxeditBillStatusNote.SetLimitText(3000);

		NXDATALISTLib::IRowSettingsPtr pRow = m_DesignationCombo->GetRow(-1);
		pRow->PutValue(posdcID, (long)-1);
		pRow->PutValue(posdcCode, _bstr_t(""));
		pRow->PutValue(posdcDesc, _bstr_t("<No Code Selected>"));
		m_DesignationCombo->InsertRow(pRow, 0);

		//set default sort columns
		int iCol;

		iCol = GetRemotePropertyInt("CPTSearch", 1, 0, GetCurrentUserName(), TRUE);
		m_CPTCombo->TextSearchCol = iCol;
		m_CPTCombo->GetColumn(iCol)->PutSortPriority(0);
		m_CPTCombo->GetColumn(iCol)->PutSortAscending(TRUE);

		iCol = GetRemotePropertyInt("ProductSearch", 4, 0, GetCurrentUserName(), TRUE);
		m_ProductsCombo->TextSearchCol = iCol;
		m_ProductsCombo->GetColumn(iCol)->PutSortPriority(0);
		m_ProductsCombo->GetColumn(iCol)->PutSortAscending(TRUE);

		iCol = GetRemotePropertyInt("SrgySearch", 0, 0, GetCurrentUserName(), TRUE);
		m_SrgyCombo->TextSearchCol = iCol;
		m_SrgyCombo->GetColumn(iCol)->PutSortPriority(0);
		m_SrgyCombo->GetColumn(iCol)->PutSortAscending(TRUE);

		try {
			// Set up the columns
			if (m_EntryType == 1) {
				//bill list

				// (j.jones 2011-10-04 08:48) - PLID 45799 - converted this list to a DL2
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_LINE_ID, _T("LineID"), _T("LineID"), 0, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_CHARGE_ID, _T("ChargeID"), _T("ChargeID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				// (d.singleton 2012-03-07 09:41) - PLID 25098 new column
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_VALIDATION_STATUS, _T("ValidationStatus"), _T("Status"), 0, csVisible | csFixedWidth)))->FieldType = cftBitmapBuiltIn;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_DATE, _T("Date"), _T("Date"), 10, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_SERVICE_DATE_TO, _T("ServiceDateTo"), _T("Date To"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_INPUT_DATE, _T("InputDate"), _T("Input Date"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_PROVIDER, _T("Provider"), _T("Provider"), 10, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				// (j.jones 2010-11-09 09:36) - PLID 31392 - added claim provider
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CLAIM_PROVIDER, _T("ClaimProvider"), _T("Claim Provider"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				// (j.jones 2014-04-23 09:51) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_REFERRING_PROVIDER, _T("ReferringProvider"), _T("Referring Provider"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_ORDERING_PROVIDER, _T("OrderingProvider"), _T("Ordering Provider"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_SUPERVISING_PROVIDER, _T("SupervisingProvider"), _T("Supervising Provider"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_PATCOORD, _T("PatCoordID"), _T("Pat. Coord."), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_SERVICE_ID, _T("ServiceID"), _T("ServiceID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CPT_CODE, _T("CPTCode"), _T("Code"), 7, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CPT_SUB_CODE, _T("CPTSubCode"), _T("Sub"), 5, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				// (s.tullis 2015-03-24 09:28) - PLID 64973 -  New Column Charge Category 
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CPT_CATEGORY, _T("CPTCategory"), _T("Category"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple; 
				
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CPT_TYPE, _T("CPTType"), _T("Type"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;

				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_CPT_TYPEOFSERVICE, _T("TypeOfService"), _T("TOS"), 5, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_MODIFIER1, _T("Modifier1"), _T("Mod1"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_MODIFIER2, _T("Modifier2"), _T("Mod2"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_MODIFIER3, _T("Modifier3"), _T("Mod3"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_MODIFIER4, _T("Modifier4"), _T("Mod4"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
				// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_CALLS, _T("Calls"), _T("Calls"), 5, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				// (d.singleton 2012-05-21 10:41) - PLID 48152 added skill column alberta only
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_SKILL, _T("Skill"), _T("Skill"), 5, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				// (d.singleton 2012-03-22 15:58) - PLID 49136 added notes column
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_NOTES, _T("Notes"), _T("Notes"), 0, csVisible | csWidthPercent)))->FieldType = cftBitmapBuiltIn;

			


				// (s.dhole 2011-05-20 11:05) - PLID 33666 Depend upon prference show or hide column
				if (ShouldShowDiagExt())
				{
					IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_WHICH_CODES, _T("WhichDiagCodes"), _T("DiagCs"), 0, csFixedWidth | csEditable)))->FieldType = cftComboSimple;
					IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_WHICH_CODES_EXT, _T("WhichDiagCodesExt"), _T("DiagCs"), 7, csVisible | csWidthPercent)))->FieldType = cftTextSingleLineLink;

				}
				else
				{
					IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_WHICH_CODES, _T("WhichDiagCodes"), _T("DiagCs"), 7, csVisible | csWidthPercent | csEditable)))->FieldType = cftComboSimple;
					IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_WHICH_CODES_EXT, _T("WhichDiagCodesExt"), _T("DiagCs"), 0, csFixedWidth | csWidthPercent)))->FieldType = cftTextSingleLineLink;

				}

				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_DESCRIPTION, _T("Description"), _T("Description"), -1, csVisible | csWidthAuto | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_QUANTITY, _T("Quantity"), _T("Qty"), 5, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_UNIT_COST, _T("UnitCost"), _T("Price"), 10, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				// (r.gonet 2015-03-27 18:33) - PLID 65277 - Added a Value column, which corresponds with LineItemT.GCValue.
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_VALUE, _T("GCValue"), _T("Value"), 0, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				// (j.jones 2010-09-01 10:37) - PLID 40330 - added allowable column
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_ALLOWABLE, _T("Allowable"), _T("Allowable"), 10, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				// (j.gruber 2009-03-05 17:17) - PLID 33351 - take out discount fields and add Total Discount that is a link
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_TOTAL_DISCOUNT, _T("Total Discount"), _T("Discount"), 7, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLineLink;
				//			IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_PERCENT_OFF, _T("PercentOff"), _T("% Off"), 6, csVisible|csWidthPercent|csEditable)))->FieldType = cftTextSingleLine;
				//			IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_DISCOUNT, _T("Discount"), _T("Discount"), 7, csVisible|csWidthPercent|csEditable)))->FieldType = cftTextSingleLine;
				// (j.gruber 2007-03-21 15:36) - PLID 24870 - adding discount categories
				//IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_DISCOUNT_CATEGORY, _T(""), _T("DiscountCategory"), 3, csVisible|csWidthPercent)))->FieldType = cftBitmapBuiltIn;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_LINE_TOTAL, _T("LineTotal"), _T("Total"), 10, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_INS_RESP, _T("InsResp"), _T("Ins. Resp."), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_INS_PARTY_ID, _T("InsuredPartyID"), _T("InsuredPartyID"), 0, csVisible | csWidthPercent)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_TAX_RATE_1, _T("TaxRate"), _T("Tax1"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_TAX_RATE_2, _T("TaxRate2"), _T("Tax2"), 6, csVisible | csWidthPercent | csEditable)))->FieldType = cftTextSingleLine;
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType.  Changed type from VT_BOOL to VT_I4
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_ITEM_TYPE, _T("ItemType"), _T("ItemType"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_PRODUCT_ITEM_ID, _T("ProductItemID"), _T("ProductItemID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				// (j.jones 2007-12-14 10:38) - PLID 27988 - added the allocation detail list ID
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_ALLOCATION_DETAIL_LIST_ID, _T("ChargedAllocationDetailListID"), _T("ChargedAllocationDetailListID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_BATCHED, _T("Batch"), _T("Batch"), 0, csVisible | csFixedWidth | csEditable)))->FieldType = cftBoolCheckbox;
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(COLUMN_PACKAGE_CHARGE_REF_ID, _T("PackageChargeRefID"), _T("PackageChargeRefID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				// (r.gonet 07/07/2014) - PLID 62569 - Added the non-visible OnHold column, which tells if a charge is on hold or not.
				IColumnSettingsPtr(m_List->GetColumn(m_List->InsertColumn(BILL_COLUMN_ON_HOLD, _T("OnHold"), _T("OnHold"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;


				m_List->IsComboBox = FALSE;
				m_List->GetColumn(BILL_COLUMN_DATE)->DataType = VT_DATE;
				m_List->GetColumn(COLUMN_SERVICE_DATE_TO)->DataType = VT_DATE;
				m_List->GetColumn(COLUMN_INPUT_DATE)->DataType = VT_DATE;

				CString strProvCombo, strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo;

				// (j.jones 2014-04-22 16:49) - PLID 61836 - This is now loaded in a modular function.
				GetProviderComboSql(strProvCombo, strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo);

				m_List->GetColumn(BILL_COLUMN_PROVIDER)->ComboSource = _bstr_t(strProvCombo);
				m_List->GetColumn(BILL_COLUMN_PROVIDER)->DataType = VT_I4;

				// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
				m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER)->ComboSource = _bstr_t(strClaimProvCombo);
				m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER)->DataType = VT_I4;

				// (j.jones 2014-04-23 09:51) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER)->ComboSource = _bstr_t(strReferringProvCombo);
				m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER)->DataType = VT_I4;
				m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER)->ComboSource = _bstr_t(strOrderingProvCombo);
				m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER)->DataType = VT_I4;
				m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER)->ComboSource = _bstr_t(strSupervisingProvCombo);
				m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER)->DataType = VT_I4;

				m_List->GetColumn(COLUMN_PATCOORD)->ComboSource = "SELECT PersonT.ID, (PersonT.[Last] + ', ' + PersonT.[First] + ' ' + PersonT.Middle) AS Name "
					"FROM PersonT INNER JOIN UsersT ON PersonT.ID = UsersT.PersonID WHERE PersonT.Archived = 0 AND UsersT.PatientCoordinator = 1 ORDER BY (PersonT.[Last] + ', ' + PersonT.[First] + ' ' + PersonT.Middle)";
				m_List->GetColumn(COLUMN_PATCOORD)->DataType = VT_I4;
				// (s.tullis 2015-03-24 09:28) - PLID 64973 - Set the Charge Cat Datatype
				m_List->GetColumn(BILL_COLUMN_CPT_CATEGORY)->DataType = VT_I4;
				m_List->GetColumn(BILL_COLUMN_CPT_TYPEOFSERVICE)->DataType = VT_BSTR;
				m_List->GetColumn(COLUMN_MODIFIER1)->DataType = VT_BSTR;
				m_List->GetColumn(COLUMN_MODIFIER2)->DataType = VT_BSTR;
				m_List->GetColumn(COLUMN_MODIFIER3)->DataType = VT_BSTR;
				m_List->GetColumn(COLUMN_MODIFIER4)->DataType = VT_BSTR;
				// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
				m_List->GetColumn(COLUMN_CALLS)->DataType = VT_R8;
				// (d.singleton 2012-05-21 10:43) - PLID 48152 added skill column , alberta only
				m_List->GetColumn(COLUMN_SKILL)->DataType = VT_BSTR;

				// (d.singleton 2012-03-07 17:26) - PLID 49100 new column
				m_List->GetColumn(BILL_VALIDATION_STATUS)->DataType = VT_BSTR;
				// (d.singleton 2012-03-22 16:00) - PLID 49136 new notes column
				m_List->GetColumn(BILL_COLUMN_NOTES)->DataType = VT_BSTR;
				// (j.jones 2011-10-06 10:46) - PLID 44941 - I removed the modifier ComboSource code, it is
				// now handled per row using m_pfsCPTModifierComboSource, which is created right now, but used
				// only when rows are added. It is also not needed for Alberta billing.
				if (!UseAlbertaHLINK()) {
					RefreshCPTModifierComboSource();
				}
				m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->DataType = VT_BSTR;
				m_List->GetColumn(BILL_COLUMN_DESCRIPTION)->DataType = VT_BSTR;
				m_List->GetColumn(BILL_COLUMN_QUANTITY)->DataType = VT_R8;
				m_List->GetColumn(BILL_COLUMN_UNIT_COST)->DataType = VT_CY;
				// (r.gonet 2015-03-27 18:33) - PLID 65277 - The type of the Value column should be Currency.
				m_List->GetColumn(BILL_COLUMN_VALUE)->DataType = VT_CY;
				// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills
				m_List->GetColumn(BILL_COLUMN_ALLOWABLE)->DataType = VT_CY;
				// (j.gruber 2009-03-05 17:19) - PLID 33351 - take out discount fields and add total discount
				m_List->GetColumn(COLUMN_TOTAL_DISCOUNT)->DataType = VT_BSTR;
				//m_List->GetColumn(COLUMN_PERCENT_OFF)->DataType = VT_I4;
				//m_List->GetColumn(COLUMN_DISCOUNT)->DataType = VT_CY;
				m_List->GetColumn(COLUMN_INS_RESP)->DataType = VT_CY;
				m_List->GetColumn(COLUMN_INS_PARTY_ID)->DataType = VT_I4;
				m_List->GetColumn(COLUMN_TAX_RATE_1)->DataType = VT_R8;
				m_List->GetColumn(COLUMN_TAX_RATE_2)->DataType = VT_R8;
				m_List->GetColumn(COLUMN_LINE_ID)->PutSortPriority(0);
				m_List->GetColumn(COLUMN_LINE_ID)->PutSortAscending(TRUE);
				m_List->GetColumn(COLUMN_BATCHED)->DataType = VT_BOOL;
				// (r.gonet 07/07/2014) - PLID 62569 - Make the On Hold column boolean.
				m_List->GetColumn(BILL_COLUMN_ON_HOLD)->DataType = VT_BOOL;
				m_List->DragVisible = TRUE;
			}
			else {
				//quote list

				// (b.savon 2012-05-31 15:42) - PLID 50570 - Reworked the quotes column styles and default widths (All of them)
				// Getting away from PercentWidths and explicity defining default widths to better handle the saving/restoring of the sizes
				// (j.jones 2011-10-04 08:48) - PLID 45799 - converted this list to a DL2
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(COLUMN_LINE_ID, _T("LineID"), _T("LineID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(COLUMN_CHARGE_ID, _T("ChargeID"), _T("ChargeID"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_PROVIDER, _T("Provider"), _T("Provider"), 74, csVisible | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_SERVICE_ID, _T("ServiceID"), _T("ServiceID"), 0, csVisible)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_CPT_CODE, _T("CPTCode"), _T("Code"), 44, csVisible)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_CPT_SUB_CODE, _T("CPTSubCode"), _T("Sub"), 34, csVisible)))->FieldType = cftTextSingleLine;
				// (s.tullis 2015-03-24 09:28) - PLID 64973 -  New Column Charge Category 
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_CPT_CATEGORY, _T("CPTCategory"), _T("Category"), 0, csVisible | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_CPT_TYPE, _T("CPTType"), _T("Type"), 0, csVisible)))->FieldType = cftTextSingleLine;

				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_MODIFIER1, _T("Modifier1"), _T("Mod1"), 0, csVisible | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_MODIFIER2, _T("Modifier2"), _T("Mod2"), 0, csVisible | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_MODIFIER3, _T("Modifier3"), _T("Mod3"), 0, csVisible | csEditable)))->FieldType = cftComboSimple;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_MODIFIER4, _T("Modifier4"), _T("Mod4"), 0, csVisible | csEditable)))->FieldType = cftComboSimple;
				// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_CALLS, _T("Calls"), _T("Calls"), 29, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				// (d.singleton 2012-05-21 10:45) - PLID 48152 added skill column , alberta only
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_SKILL, _T("Skill"), _T("Skill"), 20, csVisible | csEditable)))->FieldType = cftTextSingleLine;

				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_DESCRIPTION, _T("Description"), _T("Description"), 133, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_QUANTITY, _T("Quantity"), _T("Qty"), 58, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_PACKAGE_QTY_REM, _T("PackageQtyRemaining"), _T("Qty Rem"), 63, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - supported the original qty. rem. column
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, _T("OriginalPackageQtyRemaining"), _T("Initial Qty"), 0, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_UNIT_COST, _T("UnitCost"), _T("Practice Charge"), 89, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _T("OthrUnitCost"), _T("Outside Charge"), 89, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				// (j.gruber 2009-10-15 16:37) - PLID 35947 - allowable column
				// (j.jones 2010-09-01 10:50) - PLID 40330 - moved to be after the unit cost
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_ALLOWABLE, _T("Allowable"), _T("Allowable"), 89, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				// (j.gruber 2009-03-05 17:28) - PLID 33351 - take out discount columns and insert total discount link
				// (j.gruber 2009-04-03 16:36) - PLID - meikin wanted this renamed to just discount
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_TOTAL_DISCOUNT, _T("TotalDiscount"), _T("Discount"), 60, csVisible | csEditable)))->FieldType = cftTextSingleLineLink;
				//IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_PERCENT_OFF, _T("PercentOff"), _T("% Off"), 6, csVisible|csWidthPercent|csEditable)))->FieldType = cftTextSingleLine;
				//IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_DISCOUNT, _T("Discount"), _T("Discount"), 7, csVisible|csWidthPercent|csEditable)))->FieldType = cftTextSingleLine;
				// (j.gruber 2007-03-21 15:36) - PLID 24870 - adding discount categories
				//IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_DISCOUNT_CATEGORY, _T(""), _T("Discount Category"), 3, csVisible|csWidthPercent)))->FieldType = cftBitmapBuiltIn;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_LINE_TOTAL, _T("LineTotal"), _T("Total"), 89, csVisible)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_TAX_RATE_1, _T("TaxRate"), _T("Tax1"), 37, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_TAX_RATE_2, _T("TaxRate2"), _T("Tax2"), 37, csVisible | csEditable)))->FieldType = cftTextSingleLine;
				IColumnSettingsPtr(m_QuoteList->GetColumn(m_QuoteList->InsertColumn(QUOTE_COLUMN_ITEM_TYPE, _T("ItemType"), _T("ItemType"), 0, csVisible | csFixedWidth)))->FieldType = cftTextSingleLine;

				m_QuoteList->IsComboBox = FALSE;
				m_QuoteList->GetColumn(COLUMN_LINE_ID)->PutSortPriority(0);
				m_QuoteList->GetColumn(COLUMN_LINE_ID)->PutSortAscending(TRUE);

				CString strProvCombo;

				// (j.jones 2014-04-22 16:49) - PLID 61836 - This is now loaded in a modular function, it will only load
				// strProvCombo when on quotes
				{
					//these are not used
					CString strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo;

					GetProviderComboSql(strProvCombo, strClaimProvCombo, strReferringProvCombo, strOrderingProvCombo, strSupervisingProvCombo);
				}

				m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER)->ComboSource = _bstr_t(strProvCombo);
				m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER)->DataType = VT_I4;
				// (s.tullis 2015-03-24 09:28) - PLID 64973 
				m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CATEGORY)->DataType = VT_I4;
				m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER1)->DataType = VT_BSTR;
				m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER2)->DataType = VT_BSTR;
				m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER3)->DataType = VT_BSTR;
				m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER4)->DataType = VT_BSTR;
				// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
				m_QuoteList->GetColumn(QUOTE_COLUMN_CALLS)->DataType = VT_R8;
				// (j.jones 2011-10-06 10:46) - PLID 44941 - I removed the modifier ComboSource code, it is
				// now handled per row using m_pfsCPTModifierComboSource, which is created right now, but used
				// only when rows are added. It is also not needed for Alberta billing.
				if (!UseAlbertaHLINK()) {
					RefreshCPTModifierComboSource();
				}
				// (d.singleton 2012-05-21 10:47) - PLID 48152 added skill column alberta only
				m_QuoteList->GetColumn(QUOTE_COLUMN_SKILL)->DataType = VT_BSTR;
				m_QuoteList->GetColumn(QUOTE_COLUMN_DESCRIPTION)->DataType = VT_BSTR;
				m_QuoteList->GetColumn(QUOTE_COLUMN_QUANTITY)->DataType = VT_R8;
				m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM)->DataType = VT_R8;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - supported the original qty. rem. column
				m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM)->DataType = VT_R8;
				m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST)->DataType = VT_CY;
				m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE)->DataType = VT_CY;
				// (j.gruber 2009-03-05 17:29) - PLID 33351 - take out discount fields and put in total discount link
				m_QuoteList->GetColumn(QUOTE_COLUMN_TOTAL_DISCOUNT)->DataType = VT_BSTR;
				//m_QuoteList->GetColumn(QUOTE_COLUMN_PERCENT_OFF)->DataType = VT_I4;
				//m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT)->DataType = VT_CY;
				m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_1)->DataType = VT_R8;
				m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_2)->DataType = VT_R8;
				// (j.gruber 2009-10-15 16:38) - PLID 35947 - allowable column
				m_QuoteList->GetColumn(QUOTE_COLUMN_ALLOWABLE)->DataType = VT_CY;
				m_QuoteList->DragVisible = TRUE;
			}

			//m.hancock PLID 16457 - Store default where clauses for CPT codes and Products data lists
			// (a.walling 2008-05-07 15:51) - PLID 26105 - Quote or not, we should store these variables.
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes, because Bills need to
			// not show any CPT Codes that are linked to products.  This needs to be kept in sync with the billing resources.
			// (j.jones 2011-03-28 16:15) - PLID 42575 - hide unbillable CPT Codes
			m_strQuoteCptCodesWhere = CString((LPCTSTR)m_CPTCombo->WhereClause);
			m_strBillCptCodesWhere = "ServiceT.Active = 1 AND CPTCodeT.Billable = 1 AND ServiceT.ID NOT IN (SELECT CptID FROM ServiceToProductLinkT "
				"WHERE CptID Is Not Null)";
			m_strProductsWhere = CString((LPCTSTR)m_ProductsCombo->WhereClause);

			// Remember the column styles of all the columns in case the user decides to go from remembering
			// to not remembering the column widths.
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			short i = 0;
			for (i = 0; i < m_List->GetColumnCount(); i++)
			{
				m_aBillColumnStyles.Add(m_List->GetColumn(i)->GetColumnStyle());
			}
			for (i = 0; i < m_QuoteList->GetColumnCount(); i++)
			{
				m_aQuoteColumnStyles.Add(m_QuoteList->GetColumn(i)->GetColumnStyle());
			}

		} NxCatchAll("Error in building columns.");

		GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_LABEL_TOTAL)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_LABEL_DISCOUNTS)->SetFont(&theApp.m_boldFont);
		//(e.lally 2010-10-22) PLID 30253 - Added outside discounts
		GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->SetFont(&theApp.m_boldFont);
		GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->SetFont(&theApp.m_boldFont);

		// (d.singleton 2012-04-24 14:44) - PLID 49086 hide the button to verify if there is no license.
		if (!g_pLicense->CheckForLicense(CLicense::lcCodeCorrect, CLicense::cflrSilent)) {
			GetDlgItem(IDC_VERIFY_BILL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_VERIFY_BILL)->EnableWindow(FALSE);
		}

		// (j.armen 2014-08-06 10:06) - PLID 63161 - If this is a bill, create our Diag Search Wnd
		if (m_EntryType == BillEntryType::Bill)
		{
			//get the current client statistics
			CRect rcClient;
			GetClientRect(&rcClient);

			// Get the position of our bill status nxcolor
			CRect rcColor;
			GetDlgItem(IDC_BILL_STATUS_NXCOLOR)->GetClientRect(&rcColor);

			// Position our window to fit in our allocated space
			// (j.jones 2014-12-22 10:48) - PLID 64490 - added ability to replace an existing code
			CRect rcBillingDiagSearch(9, 10, 200, rcClient.Height() - rcColor.Height() - 5);
			m_pBillingDiagSearch.reset(new CBillingDiagSearchDlg(m_EntryType,
				boost::bind(&CBillingDlg::AddDiagCode, this, _1, _2, _3, _4, _5, _6, FALSE),
				boost::bind(&CBillingDlg::DiagOrderModified, this),
				boost::bind(&CBillingDlg::RemoveDiagCode, this),
				boost::bind(&CBillingDlg::ReplaceDiagCode, this, _1, _2),
				boost::bind(&CBillingDlg::SetICD9ForDiagCodeInfo, this, _1),
				boost::bind(&CBillingDlg::SetICD10ForDiagCodeInfo, this, _1),
				boost::bind(&CBillingDlg::DetectDuplicateDiagnosisCode, this, _1, _2),
				boost::bind(&CBillingDlg::EndOfTabSequence, this),
				boost::bind(&CBillingDlg::BeginningOfTabSequence, this),
				boost::bind(&CBillingDlg::VerifyChargeCodeOrder, this, _1, _2)));
			m_pBillingDiagSearch->Create(this);
			m_pBillingDiagSearch->MoveWindow(rcBillingDiagSearch);
			m_pBillingDiagSearch->ShowWindow(SW_SHOW);

			// Create a right margin
			rcBillingDiagSearch.right -= 4;

			// Create a list of excluded windows that we don't want to resize
			vector<CWnd*> aryExcluded;
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_NXCOLOR));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_STATIC));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_COMBO));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_CONFIG_BTN));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_NOTE_STATIC));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_NOTE_COMBO));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_NOTE_CONFIG_BTN));
			aryExcluded.push_back(GetDlgItem(IDC_BILL_STATUS_NOTE_EDIT));

			// Calculate percent to resize existing windows
			double fPercent = (rcClient.Width() - rcBillingDiagSearch.right) / (double)rcClient.Width();

			// Iterate through all of our current windows to resize them
			for (auto it = m_aryControls.begin(); it != m_aryControls.end(); it++)
			{
				bool bFound = false;
				for each(CWnd* pWnd in aryExcluded)
				{
					if (pWnd->GetSafeHwnd() == it->hwnd)
					{
						bFound = true;
						break;
					}
				}

				// Skip excluded windows
				if (bFound)
					continue;

				double fWidth = (double)(it->nRight - it->nLeft) * fPercent;

				// Adjust the left side of each control to start at the right of the diag search pluh a percentage of the current left
				it->nLeft = (long)(rcBillingDiagSearch.right + (it->nLeft * fPercent));
				// Adjust the right side of each control to start at the new left + the original width based on a percentage of the new size
				it->nRight = (long)(it->nLeft + fWidth);
			}

			// Set the new coordinates as our defaults
			SetControlPositions();
			// Position the controls based on our new sizes
			GetControlPositions();
		}

	}NxCatchAll("Error in BillingDlg::OnInitDialog");

	return TRUE;
}

// (j.gruber 2007-08-21 10:22) - PLID 25846 - added allowable to this function
// (j.jones 2008-11-14 09:08) - PLID 32037 - added optional passed-in value to describe the charge
// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
COleCurrency CBillingDlg::GetMultiFee(long ServiceID, long DoctorID, long InsCoID, long LocationID, long PlaceOfServiceID, 
	const COleDateTime &dtServiceDate, BOOL& boMultiFeeExists, BOOL& boWarn,
	CString &strPrompt, BOOL &bHasAllowable, COleCurrency &cyAllowable, OPTIONAL IN CString strChargeInfo /*= ""*/)
{
	_RecordsetPtr rs;
	COleVariant var;
	long iFeeGroupID = -1;

	try {

		// (j.jones 2008-11-14 09:10) - PLID 32037 - Most of the time this function is called, it's when you're editing
		// a specific charge. But it can now also be called on charges you didn't directly edit, such as when you change
		// the provider for all the charges. When this happens, the caller should pass in a value for strChargeInfo, if
		// not, we just say that "this charge" changed.
		CString strChargeDesc = "this charge";
		if (!strChargeInfo.IsEmpty()) {
			strChargeDesc = strChargeInfo;
		}

		// These aren't set in every code path below so we need to initialize them
		boWarn = FALSE;
		strPrompt = "";

		//first check to see if all three are in a group
		if (InsCoID > 0 && DoctorID > 0 && (LocationID > 0 || PlaceOfServiceID > 0)) {
			// (j.jones 2009-10-23 11:37) - PLID 18558 - supported multifees by place of service
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee, UsePOS FROM MultiFeeGroupsT "
				"LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID "
				"LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID "
				"LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID "
				"WHERE ProviderID = {INT} AND InsuranceCoID = {INT} "
				"AND ((UsePOS = 0 AND LocationID = {INT}) OR (UsePOS = 1 AND LocationID = {INT})) "
				"AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				"ORDER BY UsePOS"
				, DoctorID, InsCoID, LocationID, PlaceOfServiceID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				CString strLocLabel = "Location";
				if (AdoFldBool(rs, "UsePOS", FALSE)) {
					//change the warning
					strLocLabel = "Place of Service";
				}

				strPrompt.Format("A unique unit cost for %s exists under this Date/Doctor/Insurance Company/%s combination.\nDo you wish to apply this cost to the charge?", strChargeDesc, strLocLabel);
			}
			rs->Close();
		}

		//check to see if both doctor and ins. co. are in a group
		if (iFeeGroupID == -1 && InsCoID > 0 && DoctorID > 0) {
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee FROM MultiFeeGroupsT LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID WHERE ProviderID = {INT} AND InsuranceCoID = {INT} AND LocationID Is Null AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				, DoctorID, InsCoID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				strPrompt.Format("A unique unit cost for %s exists under this Date/Doctor/Insurance Company combination.\nDo you wish to apply this cost to the charge?", strChargeDesc);
			}
			rs->Close();
		}

		//first check to see if both doctor and location are in a group
		if (iFeeGroupID == -1 && (LocationID > 0 || PlaceOfServiceID > 0) && DoctorID > 0) {
			// (j.jones 2009-10-23 11:37) - PLID 18558 - supported multifees by place of service
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee, UsePOS FROM MultiFeeGroupsT "
				"LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID "
				"LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID "
				"LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID "
				"WHERE ProviderID = {INT} AND InsuranceCoID Is Null "
				"AND ((UsePOS = 0 AND LocationID = {INT}) OR (UsePOS = 1 AND LocationID = {INT})) "
				"AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				"ORDER BY UsePOS"
				, DoctorID, LocationID, PlaceOfServiceID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				CString strLocLabel = "Location";
				if (AdoFldBool(rs, "UsePOS", FALSE)) {
					//change the warning
					strLocLabel = "Place of Service";
				}

				strPrompt.Format("A unique unit cost for %s exists under this Date/Doctor/%s combination.\nDo you wish to apply this cost to the charge?", strChargeDesc, strLocLabel);
			}
			rs->Close();
		}

		//check to see if both location and ins. co. are in a group
		if (iFeeGroupID == -1 && InsCoID > 0 && (LocationID > 0 || PlaceOfServiceID > 0)) {
			// (j.jones 2009-10-23 11:37) - PLID 18558 - supported multifees by place of service
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee, UsePOS FROM MultiFeeGroupsT "
				"LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID "
				"LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID "
				"LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID "
				"WHERE ProviderID Is Null AND InsuranceCoID = {INT} "
				"AND ((UsePOS = 0 AND LocationID = {INT}) OR (UsePOS = 1 AND LocationID = {INT})) "
				"AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				"ORDER BY UsePOS"
				, InsCoID, LocationID, PlaceOfServiceID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				CString strLocLabel = "Location";
				if (AdoFldBool(rs, "UsePOS", FALSE)) {
					//change the warning
					strLocLabel = "Place of Service";
				}

				strPrompt.Format("A unique unit cost for %s exists under this Date/Insurance Company/%s combination.\nDo you wish to apply this cost to the charge?", strChargeDesc, strLocLabel);
			}
			rs->Close();
		}

		//check to see if the insurance company is in a group of its own
		if (iFeeGroupID == -1 && InsCoID > 0) {
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee FROM MultiFeeGroupsT LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID WHERE ProviderID Is Null AND InsuranceCoID = {INT} AND LocationID Is Null AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				, InsCoID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				strPrompt.Format("A unique unit cost for %s exists under this Date and Insurance Company.\nDo you wish to apply this cost to the charge?", strChargeDesc);
			}
			rs->Close();
		}


		//check to see if the provider is in a group of its own
		if (iFeeGroupID == -1 && DoctorID > 0) {
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee FROM MultiFeeGroupsT LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID WHERE ProviderID = {INT} AND InsuranceCoID Is Null AND LocationID Is Null AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				, DoctorID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				strPrompt.Format("A unique unit cost for %s exists under this Date and Doctor.\nDo you wish to apply this cost to the charge?", strChargeDesc);
			}
			rs->Close();
		}

		//check to see if the location is in a group of its own
		if (iFeeGroupID == -1 && (LocationID > 0 || PlaceOfServiceID > 0)) {
			// (j.jones 2009-10-23 11:37) - PLID 18558 - supported multifees by place of service
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			rs = CreateParamRecordset("SELECT ID, WarnMultiFee, UsePOS FROM MultiFeeGroupsT "
				"LEFT JOIN MultiFeeProvidersT ON MultiFeeGroupsT.ID = MultiFeeProvidersT.FeeGroupID "
				"LEFT JOIN MultiFeeInsuranceT ON MultiFeeGroupsT.ID = MultiFeeInsuranceT.FeeGroupID "
				"LEFT JOIN MultiFeeLocationsT ON MultiFeeGroupsT.ID = MultiFeeLocationsT.FeeGroupID "
				"WHERE ProviderID Is Null AND InsuranceCoID Is Null "
				"AND ((UsePOS = 0 AND LocationID = {INT}) OR (UsePOS = 1 AND LocationID = {INT})) "
				"AND MultiFeeGroupsT.Inactive = 0 "
				"AND (MultiFeeGroupsT.EffectiveFromDate IS NULL "
				"   OR ({OLEDATETIME} >= MultiFeeGroupsT.EffectiveFromDate "
				"       AND (MultiFeeGroupsT.EffectiveToDate IS NULL OR {OLEDATETIME} <= MultiFeeGroupsT.EffectiveToDate))) "
				"ORDER BY UsePOS"
				, LocationID, PlaceOfServiceID, dtServiceDate, dtServiceDate);
			if (!rs->eof) {
				var = rs->Fields->Item["ID"]->Value;
				iFeeGroupID = var.lVal;
				var = rs->Fields->Item["WarnMultiFee"]->Value;
				boWarn = (var.boolVal == VARIANT_FALSE) ? FALSE : TRUE;

				CString strLocLabel = "Location";
				if (AdoFldBool(rs, "UsePOS", FALSE)) {
					//change the warning
					strLocLabel = "Place of Service";
				}

				strPrompt.Format("A unique unit cost for %s exists under this Date and %s.\nDo you wish to apply this cost to the charge?", strChargeDesc, strLocLabel);
			}
			rs->Close();
		}

		COleCurrency cyStdFee = COleCurrency(0, 0);

		rs = CreateParamRecordset("SELECT Price FROM ServiceT WHERE ID = {INT}", ServiceID);
		// May be EOF if a surgery line item has no matching CPT code
		if (!rs->eof)
			cyStdFee = AdoFldCurrency(rs, "Price", COleCurrency(0, 0));
		rs->Close();

		//if no fee group found, short circuit and return std. fee
		if (iFeeGroupID == -1) {
			// (j.jones 2009-08-10 12:56) - PLID 34841 - ensure bHasAllowable is FALSE
			bHasAllowable = FALSE;
			cyAllowable = COleCurrency(0, 0);

			// The only other output parameters, boWarn and strPrompt, have been set above.
			
			// Short circuit the rest of this function
			boMultiFeeExists = FALSE;
			return cyStdFee;
		}

		// Variable to store the fee we find so we can return it afterward.
		// (j.jones 2009-08-10 12:56) - PLID 34841 - properly initialized these variables
		// Notice: the initializion here is not necessary, since we set these four variables in 
		// every code path below before returning.
		COleCurrency cyFee;
		cyFee.SetStatus(COleCurrency::invalid);
		boMultiFeeExists = FALSE;
		bHasAllowable = FALSE;
		cyAllowable = COleCurrency(0, 0);

		//see if the CPT code matches
		rs = CreateParamRecordset("SELECT Price, Allowable FROM MultiFeeItemsT WHERE ServiceID = {INT} AND FeeGroupID = {INT}", ServiceID, iFeeGroupID);
		if (!rs->eof) {

			// (j.gruber 2007-08-21 10:27) - PLID 25846 - check for allowable
			COleCurrency cyNone(-1, 0);
			cyAllowable = AdoFldCurrency(rs, "Allowable", cyNone);

			if (cyAllowable == cyNone) {
				bHasAllowable = FALSE;
				cyAllowable = COleCurrency(0, 0);
			}
			else {
				bHasAllowable = TRUE;
			}

			var = rs->Fields->Item["Price"]->Value;
			if (var.vt == VT_CY) {
				cyFee = var.cyVal;
				//if the new fee is different from the std. fee, then bill the new fee
				if (cyFee != cyStdFee) {
					boMultiFeeExists = TRUE;
				} else {
					// Fee is same as standard fee; we traditionally treat this as if there were no special fee
					cyFee = cyStdFee;
					boMultiFeeExists = FALSE;
				}
			} else {
				// Price (fee) was null (or some other type, which should be impossible, so we assert null)
				ASSERT(var.vt == VT_NULL);
				
				// No specified fee so use the standard fee
				cyFee = cyStdFee;
				boMultiFeeExists = FALSE;
			}


		}
		else {
			// No entry for this service code in our multifeegroup

			bHasAllowable = FALSE;
			cyAllowable = COleCurrency(0, 0);

			// If there is no multi-fee, then return the standard fee.
			cyFee = cyStdFee;
			boMultiFeeExists = FALSE;
		}

		rs->Close();

		// (j.jones 2009-08-10 12:56) - PLID 34841 - do not clear the allowable here,
		// it is possible at this point we may have an allowable, and just no standard fee

	return cyFee;
}
	NxCatchAllCall("BillingDlg::GetMultiFee", {
		// We used to return cyFee even if we didn't know whether it had been set properly, not to 
		// mention we had no certainty that any of the output parameters had been set. We now set 
		// them all before returning.
		boWarn = FALSE;
		strPrompt = "";
		bHasAllowable = FALSE;
		cyAllowable = COleCurrency(0, 0);
		boMultiFeeExists = FALSE;
		return g_ccyInvalid;
	});
}

long CBillingDlg::GetBillID()
{
	return ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetBillID();
}

void CBillingDlg::SetBillID(long BillID)
{
	((CBillingModuleDlg*)m_pBillingModuleWnd)->SetBillID(BillID);
}

// Add charge to modified list.
// (j.jones 2011-08-24 08:41) - PLID 44868 - Added boolean for
// bAddEvenIfCorrected, which should only be TRUE if the charge
// we added to the modified list is permitted to save changes
// even if it is "Original" or "Void", which is typically read-only.
void CBillingDlg::AddToModifiedList(long ChargeID, BOOL bAddEvenIfCorrected /*= FALSE*/)
{
	if (ChargeID == -2) {
		return;
	}

	// (j.jones 2011-08-24 08:41) - PLID 44868 - is this an Original or Void charge?
	if (!bAddEvenIfCorrected && m_EntryType == 1) {
		if (IsOriginalOrVoidCharge(ChargeID)) {
			//This is an original or a void charge, and should never have had
			//AddToModifiedList called on it unless bAddEvenIfCorrected is TRUE.

			//If you hit this assertion, your calling code needs to disallow the change
			//that tried to modify this charge, OR set bAddEvenIfCorrected to TRUE
			//if your change is allowed on original/void charges.

			//***When in doubt, changing these charges is NOT permitted!***
			ASSERT(FALSE);
			return;
		}
	}

	for (int i = 0; i < m_adwEditedCharges.GetSize(); i++) {
		if (m_adwEditedCharges[i] == (DWORD)ChargeID)
			return;
	}

	/* Place the line ID in the edited charges array */
	m_adwEditedCharges.Add(ChargeID);
}

void CBillingDlg::DeleteFromModifiedList(long ChargeID) {

	for (int i = 0; i < m_adwEditedCharges.GetSize(); i++) {

		if ((long)m_adwEditedCharges.GetAt(i) == ChargeID)
			m_adwEditedCharges.RemoveAt(i);
	}
}

//Prevent user from exiting dialog by hitting enter
void CBillingDlg::OnOK()
{
}

//they should, however, be able to exit by hitting escape
void CBillingDlg::OnCancel()
{
	((CBillingModuleDlg*)m_pBillingModuleWnd)->OnCancel();
}

BOOL CBillingDlg::PreTranslateMessage(MSG* pMsg)
{
	BOOL IsShiftKeyDown = (GetAsyncKeyState(VK_SHIFT) & 0x80000000);

	NXDATALIST2Lib::_DNxDataListPtr pList;
	COleVariant var;

	if (pMsg->message == WM_SYSKEYDOWN) {
		switch (pMsg->wParam) {
			// For billing screen
			// (d.singleton 2014-02-26 12:05) - PLID 61022 - the new diag controls never have focus,  so set 1 - 4 to just go to diag search
			case '1': case '2': case '3': case '4':
				if (m_EntryType == BillEntryType::Bill)
					SetStartingFocus();
				break;
			case 'L': GetDlgItem(IDC_WHAT_TO_ADD_COMBO)->SetFocus(); break;
			case 'V': GetDlgItem(IDC_COMBO_PLACEOFSERVICE)->SetFocus(); break;
			case 'N': GetDlgItem(IDC_COMBO_DESIGNATION)->SetFocus(); break;
			case 'R': if (m_EntryType == 1) GetDlgItem(IDC_COMBO_BILL_TO)->SetFocus(); break;
			case 'S': OnBtnEditCodes(); return TRUE;

				/////////////////////////////////////////////////////////
				// For billing module (parent dialog)
			case 'O': ((CBillingModuleDlg*)m_pBillingModuleWnd)->OnSave(); return TRUE;

			case 'A': 
				//billing 2 dlg
				((CBillingModuleDlg*)m_pBillingModuleWnd)->SetActiveTab(m_EntryType == 1 ? 2 : 1);
				return TRUE;
				//SetChargeComboFocus(); break;
			case 'C':
			case 'X': ((CBillingModuleDlg*)m_pBillingModuleWnd)->OnCancel(); return TRUE;
			case 'D': ((CBillingModuleDlg*)m_pBillingModuleWnd)->OnBillDeleteBtn(); return TRUE;
			case 'E': ((CBillingModuleDlg*)m_pBillingModuleWnd)->OnBillEditBtn(); return TRUE;
			case 'P': ((CBillingModuleDlg*)m_pBillingModuleWnd)->OnBillPreviewBtn(); return TRUE;
			case 'T':
				if (m_EntryType == 2) {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->OnBtnEditText();
				}
				return TRUE;
			case 'I':
				//insurance dlg
				if (m_EntryType == 1) {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->SetActiveTab(1);
				}
				return TRUE;
		}
	}

	////////////////////////////////////////////////////
	// Handled when the key is released and we want
	// to give or take away the list focus
	////////////////////////////////////////////////////
	if (pMsg->message == WM_KEYUP && m_boSetListFocus) {
		m_boSetListFocus = FALSE;

		if (m_EntryType == 2)
			pList = m_QuoteList;
		else
			pList = m_List;

		// Nothing in the list -- move the focus to another
		// resource item instead.
		if (pList->GetRowCount() == 0) {
			if (IsShiftKeyDown) {
				if (m_EntryType == BillEntryType::Quote) {
					if (GetDlgItem(IDC_COMBO_CPT)->IsWindowVisible()) GetDlgItem(IDC_COMBO_CPT)->SetFocus();
					else if (GetDlgItem(IDC_COMBO_SRGY)->IsWindowVisible()) GetDlgItem(IDC_COMBO_CPT)->SetFocus();
					else if (GetDlgItem(IDC_COMBO_PRODUCTS)->IsWindowVisible()) GetDlgItem(IDC_COMBO_CPT)->SetFocus();
				}
				else
					SetStartingFocus();	// (j.armen 2014-08-14 14:20) - PLID 63334
			}
			else {
				GetParent()->SetFocus();
				GetDlgItem(IDC_WHAT_TO_ADD_COMBO)->SetFocus();
			}

			return TRUE;
		}

		return TRUE;
	}

	////////////////////////////////////////////////////
	// When a key is first pressed
	////////////////////////////////////////////////////
	if (pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_TAB) {

		// Shift is down
		if (IsShiftKeyDown) {
			if (m_EntryType == BillEntryType::Quote) {
				if (GetFocus()/*->GetParent()*/ == GetDlgItem(IDC_COMBO_BILL_TO)) {
					GetParent()->SetFocus();
					m_peditQuoteNotes->SetFocus();
					return TRUE;
				}
				// (c.haag 2007-03-14 14:25) - PLID 23156 - If the current focus is one
				// after the quote list, then start editing in the list
				else if (m_QuoteList->GetRowCount() > 0) {
					CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_QUOTE_LIST));
					if (pWnd->GetDlgCtrlID() == GetFocus()->GetDlgCtrlID()) {
						int nColumn = GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, QUOTE_COLUMN_PROVIDER, TRUE);
						// Set these foci here; or else successive tabs may do nothing
						GetParent()->SetFocus();
						GetDlgItem(IDC_QUOTE_LIST)->SetFocus();
						// Now start the edit

						m_QuoteList->StartEditing(m_QuoteList->GetLastRow(), nColumn);
						return TRUE;
					}
				}
			}
			else {
				// (j.armen 2014-08-14 14:20) - PLID 63334 - If we have our diag search, and we are on the billto,
				//	switch back to the diag search
				if (m_pBillingDiagSearch && GetFocus() == GetDlgItem(IDC_COMBO_BILL_TO))
				{
					m_pBillingDiagSearch->SetFocus();
					m_pBillingDiagSearch->SetShiftTabFocus();
					return TRUE;
				}
				// (c.haag 2007-03-14 09:04) - PLID 23156 - If the current focus is one
				// after the bill list, then start editing in the list
				else if (m_List->GetRowCount() > 0) {
					CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_LIST));
					if (pWnd->GetDlgCtrlID() == GetFocus()->GetDlgCtrlID()) {
						int nColumn = GetNextBillColumn(BILL_COLUMN_DATE, BILL_COLUMN_DATE, TRUE);
						// Set these foci here; or else successive tabs may do nothing
						GetParent()->SetFocus();
						GetDlgItem(IDC_LIST)->SetFocus();
						// Now start the edit

						// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
						// Original or Void charges once a correction has been made
						BOOL bContinue = TRUE;
						IRowSettingsPtr pRow = m_List->GetLastRow();
						while (bContinue && pRow != NULL) {

							bContinue = FALSE;

							long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

							if (IsOriginalOrVoidCharge(nChargeID)) {
								bContinue = TRUE;
								pRow = pRow->GetPreviousRow();
							}

							// (j.luckoski 2013-04-03 08:52) - PLID 46064 - Prevent tabbing into list when list is not full
							// access which should mean it has not been opened for editing. If batPartialAccess case is ever used it will
							// need to be added here in order to prevent missing open rows.
							if (m_eHasAccess != batFullAccess) {
								bContinue = TRUE;
								pRow = pRow->GetPreviousRow();
							}

							if (!bContinue) {
								m_List->StartEditing(pRow, nColumn);
							}
						}
						return TRUE;
					}
				}
			}
		}

		// Shift is not down
		else {
			if (GetFocus() == GetDlgItem(IDC_COMBO_LOCATION)) {
				GetDlgItem(IDC_WHAT_TO_ADD_COMBO)->SetFocus();
				GetParent()->SetFocus();
				m_peditBillDate->SetFocus();
				return TRUE;
			}
			// (c.haag 2007-03-13 17:56) - PLID 23156 - If the current focus is one before
			// the bill list, then start editing in the list
			else if (1 == m_EntryType && m_List->GetRowCount() > 0) {
				CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_LIST), TRUE);
				if (pWnd->GetDlgCtrlID() == GetFocus()->GetDlgCtrlID()) {
					int nColumn = GetNextBillColumn(BILL_COLUMN_DATE, -1, FALSE);
					// Set these foci here; or else successive tabs may do nothing
					GetParent()->SetFocus();
					GetDlgItem(IDC_LIST)->SetFocus();
					// Now start the edit

					// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
					// Original or Void charges once a correction has been made
					BOOL bContinue = TRUE;
					long nRowToEdit = 0;
					IRowSettingsPtr pRow = m_List->GetFirstRow();
					while (bContinue && pRow != NULL) {

						bContinue = FALSE;

						long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

						if (IsOriginalOrVoidCharge(nChargeID)) {
							bContinue = TRUE;
							pRow = pRow->GetNextRow();
						}

						// (j.luckoski 2013-04-03 08:52) - PLID 46064 - Prevent tabbing into list when list is not full
						// access which should mean it has not been opened for editing. If batPartialAccess case is ever used it will
						// need to be added here in order to prevent missing open rows.
						if (m_eHasAccess != batFullAccess) {
							bContinue = TRUE;
							pRow = pRow->GetNextRow();
						}

						if (!bContinue) {
							m_List->StartEditing(pRow, nColumn);
						}
					}
					return TRUE;
				}
			}
			// (c.haag 2007-03-14 14:28) - PLID 23156 - If the current focus is one before
			// the quote list, then start editing in the list
			else if (2 == m_EntryType && m_QuoteList->GetRowCount() > 0) {
				CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_QUOTE_LIST), TRUE);
				if (pWnd->GetDlgCtrlID() == GetFocus()->GetDlgCtrlID()) {
					int nColumn = GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, -1, FALSE);
					// Set these foci here; or else successive tabs may do nothing
					GetParent()->SetFocus();
					GetDlgItem(IDC_QUOTE_LIST)->SetFocus();
					// Now start the edit
					m_QuoteList->StartEditing(0, nColumn);
					return TRUE;
				}

			}
		}
	}

	if (pMsg->message == NXM_ADD_PACKAGE) {
		// (j.jones 2012-01-17 16:18) - PLID 47537 - Renamed from OnBillPackage as it was poorly named.
		// This function actually handles billing any quote or any package.
		OnBillQuoteOrPackage(pMsg->wParam);
		return TRUE;
	}

	if (pMsg->message == NXM_BILL_EMR) {
		OnBillEMR(pMsg->wParam, pMsg->lParam);
		return TRUE;
	}

	if (pMsg->message == NXM_BILL_GLASSES_ORDER){
		OnBillGlassesOrder(pMsg->wParam, pMsg->lParam);
		return TRUE;
	}

	// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to break out the logic for billing an EMR
	if (pMsg->message == NXM_BILL_EMR_FOR_INSUREDPARTY) {
		OnBillEMR(pMsg->wParam, pMsg->lParam, false);
		return TRUE;
	}

	// (j.jones 2008-06-24 08:40) - PLID 30455 - added ability to bill from the schedule
	if (pMsg->message == NXM_BILL_APPOINTMENT) {
		OnBillAppointment(pMsg->wParam);
		return TRUE;
	}

	return CNxDialog::PreTranslateMessage(pMsg);
}

/********************************************************
*	AppendChargeToList() will add a new charge to the list
*	after a new cpt code or product/service is selected.
*
* Callers:	OnSelectionChangeComboCpt
*			OnSelectionChangeComboProducts
********************************************************/

// (z.manning 2008-09-30 17:38) - PLID 31126 - Now return a BillingItem pointer
// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
BillingItemPtr CBillingDlg::AppendChargeToList(long nDefaultProviderID /*= -1*/, BOOL bHL7Bill /*= FALSE*/, long nOrdProvider /*= -1*/)
{
	CString strDoctor, strDate, strDiagCodes, strSQL;
	_RecordsetPtr rs(__uuidof(Recordset));
	COleVariant var;
	int iLineID = -1;

	BillingItemPtr pNew;
	try {
		if ((int)m_billingItems.size() > 0) {
			int MaxLineID = 0;
			for (int z = 0; z<(int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal > MaxLineID)
					MaxLineID = m_billingItems[z]->LineID.lVal;
			}
			iLineID = MaxLineID + 1;
		}
		else
			iLineID = 1;


		if (m_cyDefaultChargeDate.GetStatus() == COleDateTime::invalid) {
			strDate = FormatDateTimeForSql((COleDateTime)m_peditBillDate->GetValue(), dtoDate);
			m_cyDefaultChargeDate = (COleDateTime)m_peditBillDate->GetValue();
			m_cyDefaultChargeDate.SetDateTime(m_cyDefaultChargeDate.GetYear(), m_cyDefaultChargeDate.GetMonth(), m_cyDefaultChargeDate.GetDay(), 0, 0, 0);
		}
		else
			strDate = FormatDateTimeForSql(m_cyDefaultChargeDate, dtoDate);

		/////////////////////////////////////////////////////////
		// Insert the record
		pNew = BillingItem::Create();
		pNew->LineID = (long)iLineID;
		pNew->Date = COleVariant(m_cyDefaultChargeDate);
		pNew->ServiceDateTo = COleVariant(m_cyDefaultChargeDate);
		pNew->InputDate = COleVariant(COleDateTime::GetCurrentTime());
		//DRT 4/7/2006 - PLID 11734 - Removed ProcCode, added ItemType (default CPT)
		pNew->ItemType = (long)ITEM_TYPE_CPT;
		pNew->Batched.vt = VT_BOOL;
		pNew->Batched.boolVal = TRUE;
		pNew->ChargedProductItemListID = (long)-1;
		pNew->ChargedAllocationDetailListID = (long)-1;
		// (j.jones 2007-02-28 09:05) - PLID 24988 - ensured PackageChargeRefID is always filled
		pNew->PackageChargeRefID = (long)-1;
		// (a.walling 2007-05-24 09:32) - PLID 26114
		pNew->PointsUsed = COleCurrency(0, 0);
		pNew->Modifier1 = g_cvarNull;
		pNew->Modifier2 = g_cvarNull;
		pNew->Modifier3 = g_cvarNull;
		pNew->Modifier4 = g_cvarNull;

		// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
		// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
		// (v.maida 2014-12-26 09:24) - PLID 64470 - Ignore the default charges to no provider preference if this charge is being created from an HL7 bill.
		if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 1 && !bHL7Bill) {
			pNew->Provider = (long)-1;
		}
		else if (nDefaultProviderID == -1) {
			if (m_DefaultProvider == -1) {
				m_DefaultProvider = GetDefaultBillProviderID();
			}
			pNew->Provider = m_DefaultProvider;
		}
		// (j.jones 2011-06-24 15:25) - PLID 22586 - for specifically a blank provider, we use -2
		else if (nDefaultProviderID == -2) {
			pNew->Provider = g_cvarNull;
		}
		else {
			pNew->Provider = nDefaultProviderID;
		}

		// (d.singleton 2012-05-30 11:40) - PLID 50744 if alberta need to select the skill code for the default provider
		CString strSkillCode = "";
		if (UseAlbertaHLINK() && m_DefaultProvider > -1) {
			_RecordsetPtr prs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", m_DefaultProvider);
			if (!prs->eof) {
				strSkillCode = AdoFldString(prs, "TaxonomyCode", "");
				if (strSkillCode.GetLength() > 4) {
					strSkillCode = "";
				}
			}
			prs->Close();
		}

		// (j.jones 2010-11-09 10:34) - PLID 31392 - added ClaimProvider
		pNew->ClaimProvider = m_DefaultClaimProvider;

		// (j.jones 2014-04-23 08:40) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
		pNew->ReferringProviderID = (long)-1;
		pNew->ReferringProviderIDRequired = g_cvarFalse;
		// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
		pNew->OrderingProviderID = nOrdProvider; //default is -1
		if (nOrdProvider != -1)
			pNew->OrderingProviderIDRequired = g_cvarTrue;
		else 
			pNew->OrderingProviderIDRequired = g_cvarFalse;
		
		pNew->SupervisingProviderID = (long)-1;
		pNew->SupervisingProviderIDRequired = g_cvarFalse;

		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel() != -1) {
			var = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetValue(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel(), 0);
			if (VarLong(var, -1) != -1)
				pNew->PatCoordinator = var;
		}

		/////////////////////////////////////////////////////////
		// Now update the record with diagnosis codes
		strDiagCodes.Empty();

		// (j.jones 2009-03-25 12:33) - PLID 9729 - changed to use GenerateDefaultWhichCodesValue
		// (j.gruber 2014-02-19 10:24) - PLID 60878 - use our map structure
		pNew->whichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		LoadDefaultWhichCodes(pNew->whichCodes);


		// (j.gruber 2007-03-22 16:21) - PLID 24870 - discount categories
		// (j.gruber 2009-03-05 12:40) - PLID 33351 - take out old discount information
		/*pNew->CustomDiscountDescription = _variant_t("");
		pNew->DiscountCategoryID.vt = VT_NULL;
		pNew->HasDiscountCategory.boolVal = FALSE;*/

		// (j.gruber 2007-04-04 09:57) - PLID 9796 - Coupons
		//pNew->CouponID.vt = VT_NULL;

		// (r.gonet 2015-03-27 19:15) - PLID 65279 - Default the Value to null
		pNew->Value = g_cvarNull;

		// (j.gruber 2007-08-21 12:01) - PLID 25846 - AllowableInformation
		pNew->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
		pNew->UnitAllowable = g_cvarNull;
		pNew->TotalAllowable = g_cvarNull;

		// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
		pNew->Calls = (double)0.0;

		// (d.singleton 2012-05-21 10:48) - PLID 48152 added skill column , albeta only
		pNew->Skill = _bstr_t(strSkillCode);

		// (d.singleton 2012-03-07 17:23) - PLID 49100 new column
		pNew->ValidationStatus = g_cvarNull;

		// (d.singleton 2012-03-22 16:20) - PLID 49136 notes column
		pNew->Notes = _variant_t((long)m_hIconNotes);
		// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes
		pNew->NDCCode = g_cvarNull;

		// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
		pNew->DrugUnitPrice = COleCurrency(0, 0);
		pNew->DrugUnitType = (LPCTSTR)"";
		pNew->DrugUnitQuantity = (double)0.0;
		pNew->PrescriptionNumber = (LPCTSTR)"";

		// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
		pNew->IsEmergency = (long)cietUseDefault;

		// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID
		pNew->EMRChargeID = g_cvarNull;

		// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
		pNew->AppointmentID = g_cvarNull;

		pNew->RPCList = new RPCList;	//create the list for setting up insurance stuff

		// (j.gruber 2009-03-05 12:39) - PLID 33351 - add discount list
		pNew->DiscountList = NULL;

		//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
		pNew->GlassesOrderServiceID = g_cvarNull;

		// (r.gonet 07/07/2014) - PLID 62569 - Added OnHold
		pNew->OnHold = g_cvarFalse;

		m_billingItems.push_back(pNew);
	}
	NxCatchAll("BillingDlg::AppendChargeToList");
	return pNew;
}

void CBillingDlg::OnDestroy()
{
	CNxDialog::OnDestroy();
	m_boInitialized = FALSE;
	// (j.jones 2011-01-21 10:10) - PLID 42156 - this is now an enum
	m_eHasAccess = batNoAccess;
}

void CBillingDlg::OnBtnEditCodes()
{
	//create a menu

	CMenu mnu;
	mnu.m_hMenu = CreatePopupMenu();
	long nIndex = 0;
	mnu.InsertMenu(nIndex++, MF_BYPOSITION, ID_EDIT_CPT_CODES, "Edit &Service/Diag Codes");

	if (g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)) {
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, ID_EDIT_INV_ITEMS, "Edit &Inventory Items");
	}

	mnu.InsertMenu(nIndex++, MF_BYPOSITION, ID_EDIT_CPT_INS_NOTES, "Edit Service Code Insurance &Notes");

	if (GetRemotePropertyInt("EnableCodeLinkLaunching", 0, 0, "<None>", true) == 1) {
		mnu.InsertMenu(nIndex++, MF_BYPOSITION | MF_SEPARATOR);
		mnu.InsertMenu(nIndex++, MF_BYPOSITION, ID_LAUNCH_CODELINK, "Launch CodeLink");
	}

	CRect rc;
	CWnd *pWnd = GetDlgItem(IDC_BTN_EDIT_CODES);
	if (pWnd) {
		pWnd->GetWindowRect(&rc);
		mnu.TrackPopupMenu(TPM_LEFTALIGN, rc.right, rc.top, this, NULL);
	} else {
		CPoint pt;
		GetCursorPos(&pt);
		mnu.TrackPopupMenu(TPM_LEFTALIGN, pt.x, pt.y, this, NULL);
	}
}

// Simply matches the given cost to the old total given the preferred 
// insurance (primary or secondary), and if there's a valid match, 
// sets the datalist accordingly
// Returns TRUE if the value was matched and changed
// Returns FALSE if the value was either not matched or not changed
BOOL CBillingDlg::MatchCostToResp(BillingItemPtr pBillingItem, const COleCurrency &cyOldTotal, const COleCurrency &cyNewTotal, const COleCurrency &cyNewTotalNoTax, const _variant_t &varInsResp, long nInsuredPartyID)
{
	// Make sure our variant is actually a currency value as we expect
	if (varInsResp.vt == VT_CY) {
		// It IS a currency so get its value
		COleCurrency cyInsResp = COleCurrency(varInsResp.cyVal);

		COleCurrency cyInsRespWithTax = cyInsResp;
		BOOL bPatientWasTaxed = FALSE;
		//only needed if we are billing all tax to the patient
		if (GetInsuranceCoTaxType(nInsuredPartyID) == 2) {

			bPatientWasTaxed = TRUE;

			double dblTax1 = 0.0;
			if (pBillingItem->TaxRate1.vt == VT_R8)
				dblTax1 = VarDouble(pBillingItem->TaxRate1);

			double dblTax2 = 0.0;
			if (pBillingItem->TaxRate2.vt == VT_R8)
				dblTax2 = VarDouble(pBillingItem->TaxRate2);

			COleCurrency taxResult1, taxResult2;

			taxResult1 = CalculateTax(cyInsRespWithTax, 1.0 + (dblTax1 / 100.0));
			taxResult2 = CalculateTax(cyInsRespWithTax, 1.0 + (dblTax2 / 100.0));

			cyInsRespWithTax += taxResult1;
			cyInsRespWithTax += taxResult2;

			RoundCurrency(cyInsRespWithTax);
		}

		// Okay, we have the currency, now let's try to match it: is it primary insurance?
		if (cyInsResp == cyOldTotal || (bPatientWasTaxed && cyInsRespWithTax == cyOldTotal)) {
			// Yes, it is primary, let's see if the patient has a primary insured party
			if (nInsuredPartyID > 0) {
				// yay! We have a match
				// NOW, handle the special case where the old total was 0 and the charge is not billed to selected insurance
				if ((cyOldTotal == COleCurrency(0, 0)) && (nInsuredPartyID != GetCurrentBillToInsuredPartyID())) {
					//if we are changing a $0.00 value, the insurance resp. could potentially also be $0.00.
					//in this case, do NOT increase the insurance resp. unless the resp. selection is correct
					return FALSE;
				}

				// Log it for tech support (just in case we're wrong)
				// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
				//LogDetail("#$# Setting InsResp line '%li' to %s - MatchCostAndInsurance", nInsuredPartyID, FormatCurrencyForInterface(bPatientWasTaxed ? cyNewTotalNoTax : cyNewTotal));

				// FINALLY we reach our goal, we have found a match and we are applying the change

				//we may (probably) already have something for this resp, so try to update it first.
				long nIndex = -1;
				for (int i = 0; i < (int)m_billingItems.size() && nIndex < 0; i++) {
					if (m_billingItems[i]->LineID == pBillingItem->LineID) {
						nIndex = i;
					}
				}

				if (!SetListInsAmount(nIndex, nInsuredPartyID, COleVariant(bPatientWasTaxed ? cyNewTotalNoTax : cyNewTotal))) {
					//if that fails, add it into the array
					RPCList *list = pBillingItem->RPCList;
					RespPerCharge rpc;
					rpc.InsAmount = COleVariant(cyNewTotal);
					rpc.InsuredPartyID = nInsuredPartyID;

					// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
					rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
					rpc.RespTypeName = GetCurrentBillToRespTypeName();

					list->aryRPC.Add(rpc);
				}

				return TRUE;
			} else {
				// We matched the old total to the primary insurance responsibility, 
				// but SOMEHOW this patient doesn't have a primary insured party
				// I don't think this is possible, so I'm throwing an exception.  If it is 
				// possible and legitimate we need to handle it correctly in this ELSE block
				AfxThrowNxException(
					"The primary insurance responsibility matches the old charge "
					"total, but this patient does not have a primary insured party.");
				return FALSE;
			}
		} else {
			// We have a responsibility that just doesn't match the old total.  No problem, just return.
			return FALSE;
		}
	} else {
		// varIns1Resp is not a currency so we assume there is no responsibility so just return.

		//we put an assert here to see if this is ever VT_NULL or VT_EMPTY, and it's both!
		//ASSERT(varInsResp.vt == VT_NULL);
		return FALSE;
	}
}


/********************************************************
*	MatchCostAndInsurance() will ensure that if a change
*	was made to the line total, and the insurance amount
*	previously matched the line total, that the insurance
*	amount will also be updated.
*
* Callers:	CalculateLineTotal
********************************************************/
void CBillingDlg::MatchCostAndInsurance(int record, COleCurrency cyOldTotal, COleCurrency cyNewTotal, COleCurrency cyNewPreTaxTotal)
{
	_variant_t varInsResp;
	long nInsuredPartyID;
	_variant_t varIns1Resp, varIns2Resp;
	CString str;

	if (m_EntryType == 2)
		return;

	try {
		//loop to the current charge
		bool bDone = false;
		for (int i = 0; i < (int)m_billingItems.size() && !bDone; i++) {
			BillingItemPtr pItem = m_billingItems[i];
			if (pItem->LineID.lVal == record) {
				RPCList *list = pItem->RPCList;
				RespPerCharge rpc;

				for (int j = 0; j < list->aryRPC.GetSize() && !bDone; j++) {
					rpc = list->aryRPC.GetAt(j);
					varInsResp = rpc.InsAmount;
					nInsuredPartyID = VarLong(rpc.InsuredPartyID);

					if (nInsuredPartyID > 0) {
						if (MatchCostToResp(pItem, cyOldTotal, cyNewTotal, cyNewPreTaxTotal, varInsResp, nInsuredPartyID)) {
							bDone = true;	//success!
						}
						else {
							//we need to keep looping until one matches, or we run out of things to try
						}
					}
				}	//end for
			}
		}
	}
	NxCatchAll("Error in MatchCostAndInsurance");
}

void CBillingDlg::FillBillList() {

	CWaitCursor wait;

	CArray<long, long> arServices;

	DisableBillingScreen();
	try{

		// (j.jones 2007-06-27 11:27) - PLID 26471 - we clear the list here,
		// and should make an attempt to revert to the same area of the list on display
		// (the calling function is responsible for any specific SetSelByColumn calls
		// that may be needed, this code will solely return to the same row indices)
		// (j.jones 2011-10-04 10:52) - PLID 45799 - this is now a DL2, which makes this slightly
		// harder, need to track the LineID
		long nOldTopRowLineID = -1;
		long nOldCurSelLineID = -1;
		{
			IRowSettingsPtr pTopRow = m_List->GetTopRow();
			if (pTopRow) {
				nOldTopRowLineID = VarLong(pTopRow->GetValue(COLUMN_LINE_ID), -1);
			}

			IRowSettingsPtr pCurSel = m_List->GetCurSel();
			if (pCurSel) {
				nOldCurSelLineID = VarLong(pCurSel->GetValue(COLUMN_LINE_ID), -1);
			}
		}
		// (s.tullis 2015-04-07 16:54) - PLID 64975  - Autoshow CPT category column if there are charges with multiple categories configured
		BOOL bShowCPTCategoryColumn = FALSE;
		// (j.jones 2011-10-05 09:24) - PLID 45799 - Do not clear the list entirely, instead update
		// each existing row as needed. But first, remove any rows with line IDs not in our array.
		IRowSettingsPtr pLoopRow = m_List->GetFirstRow();
		while (pLoopRow) {

			long nLineID = VarLong(pLoopRow->GetValue(COLUMN_LINE_ID), -1);

			BOOL bFound = FALSE;
			for (int i = 0; i < (int)m_billingItems.size() && !bFound; i++) {
				if (m_billingItems[i]->LineID.lVal == nLineID) {
					bFound = TRUE;
					break;
				}
			}

			if (!bFound) {

				// (j.jones 2011-10-05 11:00) - This should be impossible, because it would mean
				// some code removed a charge from our array, but not from the datalist.
				// The code that did this should really be cleaned up.
				ASSERT(FALSE);

				IRowSettingsPtr pRowToRemove = pLoopRow;
				pLoopRow = pLoopRow->GetNextRow();

				m_List->RemoveRow(pRowToRemove);
			}
			else {
				pLoopRow = pLoopRow->GetNextRow();
			}
		}

		if (m_pSuggestedSalesDlg)
			m_pSuggestedSalesDlg->Clear();

		// (r.gonet 2015-03-27 18:33) - PLID 65277 - While we are looping over the billing items and adding them to
		// the datalist, see if there are any gift certificates.
		bool bHasGiftCertificate = false;
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr billitem = m_billingItems[i];

			// (j.jones 2011-10-05 09:30) - PLID 45799 - update the existing row, if we have one
			BOOL bNeedAddRow = FALSE;
			IRowSettingsPtr pRow = m_List->FindByColumn(COLUMN_LINE_ID, billitem->LineID, m_List->GetFirstRow(), FALSE);
			if (pRow == NULL) {
				bNeedAddRow = TRUE;
				pRow = m_List->GetNewRow();
			}
			// (s.tullis 2015-03-24 09:28) - PLID 64973 - set CPT cat combo source
			if (bNeedAddRow){
				SetCPTCategoryCombo(pRow, billitem, BillEntryType::Bill);
			}

			// (j.jones 2011-10-06 10:37) - PLID 44941 - Set up its modifier dropdown content.
			// This will fill the four modifier columns for a row with the appropriate
			// modifier combo source, whether US or Alberta.
			// For Alberta, this has to be done every time the list is filled because you can now change
			// the service code. We cache the content per service code though to save data accesses.
			if (bNeedAddRow || UseAlbertaHLINK()) {
				SetModifierComboSource(pRow, billitem);
			}



			pRow->PutValue(COLUMN_LINE_ID, billitem->LineID);
			pRow->PutValue(COLUMN_CHARGE_ID, billitem->ChargeID);
			pRow->PutValue(BILL_COLUMN_DATE, billitem->Date);
			pRow->PutValue(COLUMN_SERVICE_DATE_TO, billitem->ServiceDateTo);
			pRow->PutValue(COLUMN_INPUT_DATE, billitem->InputDate);
			pRow->PutValue(BILL_COLUMN_PROVIDER, billitem->Provider);
			// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
			pRow->PutValue(BILL_COLUMN_CLAIM_PROVIDER, billitem->ClaimProvider);

			// (j.jones 2014-04-23 10:11) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID,
			// each of which will try to show the column if it has data but is not currently displayed
			pRow->PutValue(BILL_COLUMN_REFERRING_PROVIDER, billitem->ReferringProviderID);
			if (VarLong(billitem->ReferringProviderID) != -1) {
				ShowReferringProviderColumn();
			}
			
			pRow->PutValue(BILL_COLUMN_ORDERING_PROVIDER, billitem->OrderingProviderID);
			if (VarLong(billitem->OrderingProviderID) != -1) {
				ShowOrderingProviderColumn();
			}
		

			pRow->PutValue(BILL_COLUMN_SUPERVISING_PROVIDER, billitem->SupervisingProviderID);
			if (VarLong(billitem->SupervisingProviderID) != -1) {
				ShowSupervisingProviderColumn();
			}
		
			pRow->PutValue(COLUMN_PATCOORD, billitem->PatCoordinator);
			pRow->PutValue(COLUMN_SERVICE_ID, billitem->ServiceID);
			pRow->PutValue(BILL_COLUMN_CPT_CODE, billitem->CPTCode);

			// (s.tullis 2015-04-07 16:54) - PLID 64975  - If there is atleast one charge with multiple categories configured we need to show this column
			if (VarLong(billitem->CPTCategoryCount, 0) > 1)
			{
				bShowCPTCategoryColumn = TRUE;
			}
			// (s.tullis 2015-03-24 09:28) - PLID 64973 - Select None if no category else select the category
			pRow->PutValue(BILL_COLUMN_CPT_CATEGORY, (billitem->CPTCategoryID.vt == VT_NULL) ? -1 /*none*/ : billitem->CPTCategoryID);
			pRow->PutValue(BILL_COLUMN_CPT_SUB_CODE, billitem->CPTSubCode);
			pRow->PutValue(BILL_COLUMN_CPT_TYPE, billitem->CPTType);
			pRow->PutValue(BILL_COLUMN_CPT_TYPEOFSERVICE, billitem->TypeOfService);
			pRow->PutValue(COLUMN_MODIFIER1, billitem->Modifier1);
			pRow->PutValue(COLUMN_MODIFIER2, billitem->Modifier2);
			pRow->PutValue(COLUMN_MODIFIER3, billitem->Modifier3);
			pRow->PutValue(COLUMN_MODIFIER4, billitem->Modifier4);
			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			pRow->PutValue(COLUMN_CALLS, billitem->Calls);
			// (d.singleton 2012-05-21 10:49) - PLID 48152 added skill column , alberta only
			pRow->PutValue(COLUMN_SKILL, billitem->Skill);

			// (d.singleton 2012-03-07 17:23) - PLID 49100 new column
			pRow->PutValue(BILL_VALIDATION_STATUS, billitem->ValidationStatus);
			// (d.singleton 2012-03-22 16:33) - PLID 49136 new notes column
			pRow->PutValue(BILL_COLUMN_NOTES, billitem->Notes);
			// (s.dhole 2011-05-20 11:08) - PLID 33666 Set WhichCode code string
			// (j.gruber 2014-02-19 10:44) - PLID 60895 - use the new functionality
			// (s.tullis 2015-06-08 16:53) - PLID 66190 - Need to change the Icon if we have unsaved Bill Notes
			if (!billitem->m_arUnsavedChargeNotes.IsEmpty())
			{
				pRow->PutValue(BILL_COLUMN_NOTES, _variant_t((long)m_hIconHasNotes));
			}
			DisplayWhichCodes(pRow, billitem->whichCodes);
			/*if (m_bShowDiagExt==TRUE)
				pRow->PutValue(BILL_COLUMN_WHICH_CODES_EXT,billitem->WhichDiagCodeExts );
				pRow->PutValue(BILL_COLUMN_WHICH_CODES,billitem->WhichDiagCodes);*/
			pRow->PutValue(BILL_COLUMN_DESCRIPTION, billitem->Description);
			pRow->PutValue(BILL_COLUMN_QUANTITY, billitem->Quantity);
			pRow->PutValue(BILL_COLUMN_UNIT_COST, billitem->UnitCost);
			// (r.gonet 2015-03-27 18:58) - PLID 65279 - Fill the billing item's value.
			pRow->PutValue(BILL_COLUMN_VALUE, billitem->Value);
			// (r.gonet 2015-03-27 18:33) - PLID 65277 - Check if this is a gift certificate
			if (billitem->ItemType.vt == VT_I4 && VarLong(billitem->ItemType) == ITEM_TYPE_GIFT) {
				// (r.gonet 2015-03-27 18:33) - PLID 65277 - It is, flag that we have run into one.
				bHasGiftCertificate = true;
			}
			// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills, this is the total allowable
			pRow->PutValue(BILL_COLUMN_ALLOWABLE, billitem->TotalAllowable);
			// (j.gruber 2009-03-05 17:16) - PLID 33351 - take out discounts fields and add total discount
			pRow->PutValue(COLUMN_TOTAL_DISCOUNT, billitem->TotalDiscount);
			//pRow->PutValue(COLUMN_PERCENT_OFF,billitem->PercentOff);
			//pRow->PutValue(COLUMN_DISCOUNT,billitem->Discount);
			pRow->PutValue(BILL_COLUMN_LINE_TOTAL, billitem->LineTotal);

			//These need to display the value of whatever resp is currently chosen in the BillTo combo.
			RespPerCharge rpc;
			if (FindRPCInList(billitem->RPCList, GetCurrentBillToInsuredPartyID(), rpc)) {
				pRow->PutValue(COLUMN_INS_RESP, rpc.InsAmount);
				pRow->PutValue(COLUMN_INS_PARTY_ID, rpc.InsuredPartyID);
			}
			else {
				_variant_t var = COleCurrency(0, 0);
				pRow->PutValue(COLUMN_INS_RESP, var);
				pRow->PutValue(COLUMN_INS_PARTY_ID, (long)-1);
			}

			pRow->PutValue(COLUMN_TAX_RATE_1, billitem->TaxRate1);
			pRow->PutValue(COLUMN_TAX_RATE_2, billitem->TaxRate2);
			//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType (both the column and the data)
			pRow->PutValue(COLUMN_ITEM_TYPE, billitem->ItemType);
			pRow->PutValue(COLUMN_PRODUCT_ITEM_ID, billitem->ChargedProductItemListID);
			// (j.jones 2007-12-14 10:39) - PLID 27988 - added the allocation detail list ID
			pRow->PutValue(COLUMN_ALLOCATION_DETAIL_LIST_ID, billitem->ChargedAllocationDetailListID);
			pRow->PutValue(COLUMN_BATCHED, billitem->Batched);
			pRow->PutValue(COLUMN_PACKAGE_CHARGE_REF_ID, billitem->PackageChargeRefID);
			// (r.gonet 07/07/2014) - PLID 62569 - Fill the On Hold column
			pRow->PutValue(BILL_COLUMN_ON_HOLD, billitem->OnHold);
			// (r.gonet 07/07/2014) - PLID 62569 - If the charge is on hold, then the background color needs to be orange
			if (VarBool(billitem->OnHold)) {
				pRow->BackColor = CHARGE_ON_HOLD_BACK_COLOR;
				pRow->BackColorSel = CHARGE_ON_HOLD_BACK_COLOR_SEL;
			} else {
				// (r.gonet 07/07/2014) - PLID 62569 - Otherwise, it is white, as normal.
				pRow->BackColor = RGB(255, 255, 255);
				// (r.gonet 07/07/2014) - PLID 62569 - 1 is special for the default highlight color
				pRow->BackColorSel = 1;
			}

			// (j.jones 2011-08-24 08:41) - PLID 44868 - color the foreground of
			// original and void charges light gray, so they are visibly marked
			// as non-editable
			if (VarBool(billitem->IsOriginalCharge, FALSE) || VarBool(billitem->IsVoidingCharge, FALSE)) {
				pRow->PutForeColor(CORRECTED_CHARGE_FOREGROUND_COLOR);
			}
			else {
				pRow->PutForeColor(RGB(0, 0, 0));
			}

			// (s.tullis 2015-04-10 15:04) - PLID 65537 - Update Cell Colors 
			UpDateBillQuoteListCellColors(pRow, billitem, BillEntryType::Bill);
			
			// (j.jones 2011-10-05 09:31) - PLID 45799 - only add new rows, existing are updated in place
			if (bNeedAddRow) {
				m_List->AddRowSorted(pRow, NULL);
			}

			if (m_pSuggestedSalesDlg) // (a.walling 2007-05-04 11:31) - PLID 14717 - Add to our list of services
				m_pSuggestedSalesDlg->AddService(billitem->ServiceID);

			arServices.Add(billitem->ServiceID);
		}
		// (s.tullis 2015-04-07 16:54) - PLID 64975  -check if we need Show the Charge category column
		if (bShowCPTCategoryColumn){
			ShowCPTCategoryColumn(BillEntryType::Bill);
		}
		// (r.gonet 2015-03-27 18:33) - PLID 65277 - If we have a gift certificate in the billing items list,
		// we should show the Value column, which is only good for Gift Certificates. Otherwise, hide the Value
		// column.
		ShowValueColumn(bHasGiftCertificate);

		// (r.gonet 07/08/2014) - PLID 62569 - Color the on hold correction groups
		for each(const BillingItemPtr& billingItem in m_billingItems)
		{
			long nLineID = VarLong(billingItem->LineID);
			if (VarBool(billingItem->OnHold, FALSE)
				&& VarBool(billingItem->IsNewChargeFromCorrection, FALSE)
				&& !VarBool(billingItem->IsVoidingCharge, FALSE) && !VarBool(billingItem->IsOriginalCharge, FALSE)) {
				CascadeOnHold(nLineID, TRUE);
			}
		}
		// (d.singleton 2014-03-21 09:06) - PLID 61428 - remove old medassist code.
		// (d.singleton 2012-03-07 13:52) - PLID 49100 make sure we refill the validation status if there are any results
		//for( int i = 0; i < m_aryValidatedParsedResults.GetCount(); i++ )
		//{
		//	IRowSettingsPtr pRow;
		//	//match the result in array to the correct row based on ChargesT.ID
		//	pRow = m_List->FindByColumn(COLUMN_CHARGE_ID, m_aryValidatedParsedResults.GetAt(i).nChargeID, m_List->GetFirstRow(), FALSE);

		//	if(pRow)
		//	{
		//		//assign statuses to rows
		//		if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsFailure)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconRedX));
		//		}
		//		else if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsWarning)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconWarning));
		//		}
		//		else if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsPass)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconCheck));
		//		}
		//	}
		//}
		SortList();

		if (m_pSuggestedSalesDlg) // (a.walling 2007-05-04 11:31) - PLID 14717 - And refresh the dialog if needed
			m_pSuggestedSalesDlg->RefreshIfNeeded();

		CBillingSuggestedSalesDlg::CheckSuggestionsExist(arServices, this);

		// (j.jones 2007-06-27 11:28) - PLID 26471 - revert to the row view we were previously at
		if (nOldTopRowLineID != -1) {
			IRowSettingsPtr pNewTopRow = m_List->FindByColumn(COLUMN_LINE_ID, nOldTopRowLineID, m_List->GetFirstRow(), FALSE);
			if (pNewTopRow) {
				m_List->PutTopRow(pNewTopRow);
			}
		}

		//and reselect the previous index, if available
		if (nOldCurSelLineID != -1) {
			IRowSettingsPtr pNewCurSel = m_List->FindByColumn(COLUMN_LINE_ID, nOldCurSelLineID, m_List->GetFirstRow(), FALSE);
			if (pNewCurSel) {
				m_List->PutCurSel(pNewCurSel);
			}
		}

		 

	}NxCatchAll("Error in FillBillList()");
	EnableBillingScreen();
}

void CBillingDlg::FillQuoteList() {

	CWaitCursor wait;

	CArray<long, long> arServices;

	DisableBillingScreen();
	try{

		// (j.jones 2007-06-27 11:27) - PLID 26471 - we clear the list here,
		// and should make an attempt to revert to the same area of the list on display
		// (the calling function is responsible for any SetSelByColumn calls that may
		// be needed, this code will solely return to the same row indices)
		// (j.jones 2011-10-04 10:52) - PLID 45799 - this is now a DL2, which makes this slightly
		// harder, need to track the LineID
		long nOldTopRowLineID = -1;
		long nOldCurSelLineID = -1;
		{
			IRowSettingsPtr pTopRow = m_QuoteList->GetTopRow();
			if (pTopRow) {
				nOldTopRowLineID = VarLong(pTopRow->GetValue(COLUMN_LINE_ID), -1);
			}

			IRowSettingsPtr pCurSel = m_QuoteList->GetCurSel();
			if (pCurSel) {
				nOldCurSelLineID = VarLong(pCurSel->GetValue(COLUMN_LINE_ID), -1);
			}
		}

		// (j.jones 2011-10-05 09:24) - PLID 45799 - Do not clear the list entirely, instead update
		// each existing row as needed. But first, remove any rows with line IDs not in our array.
		IRowSettingsPtr pLoopRow = m_QuoteList->GetFirstRow();
		while (pLoopRow) {

			long nLineID = VarLong(pLoopRow->GetValue(COLUMN_LINE_ID), -1);

			BOOL bFound = FALSE;
			for (int i = 0; i < (int)m_billingItems.size() && !bFound; i++) {
				if (m_billingItems[i]->LineID.lVal == nLineID) {
					bFound = TRUE;
					break;
				}
			}

			if (!bFound) {

				// (j.jones 2011-10-05 11:00) - This should be impossible, because it would mean
				// some code removed a charge from our array, but not from the datalist.
				// The code that did this should really be cleaned up.
				ASSERT(FALSE);

				IRowSettingsPtr pRowToRemove = pLoopRow;
				pLoopRow = pLoopRow->GetNextRow();

				m_QuoteList->RemoveRow(pRowToRemove);
			}
			else {
				pLoopRow = pLoopRow->GetNextRow();
			}
		}

		

		if (m_pSuggestedSalesDlg)
			m_pSuggestedSalesDlg->Clear();
		// (s.tullis 2015-04-07 16:54) - PLID 64975  - Autoshow CPT category column is there are charges with multiple categories configured
		BOOL bShowCPTCategoryColumn = FALSE;

		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr billitem = m_billingItems[i];

			// (j.jones 2011-10-05 09:30) - PLID 45799 - update the existing row, if we have one
			BOOL bNeedAddRow = FALSE;
			IRowSettingsPtr pRow = m_QuoteList->FindByColumn(COLUMN_LINE_ID, billitem->LineID, m_QuoteList->GetFirstRow(), FALSE);
			if (pRow == NULL) {
				bNeedAddRow = TRUE;
				pRow = m_QuoteList->GetNewRow();
			}

			// (s.tullis 2015-03-24 09:28) - PLID 64973 - Set Charge Category combo source
			if (bNeedAddRow){
				SetCPTCategoryCombo(pRow, billitem, BillEntryType::Quote);
			}

			// (j.jones 2011-10-06 10:37) - PLID 44941 - Set up its modifier dropdown content.
			// This will fill the four modifier columns for a row with the appropriate
			// modifier combo source, whether US or Alberta.
			// For Alberta, this has to be done every time the list is filled because you can now change
			// the service code. We cache the content per service code though to save data accesses.
			if (bNeedAddRow || UseAlbertaHLINK()) {
				SetModifierComboSource(pRow, billitem);
			}

			pRow->PutValue(COLUMN_LINE_ID, billitem->LineID);
			pRow->PutValue(COLUMN_CHARGE_ID, billitem->ChargeID);
			pRow->PutValue(QUOTE_COLUMN_PROVIDER, billitem->Provider);
			pRow->PutValue(QUOTE_COLUMN_SERVICE_ID, billitem->ServiceID);
			pRow->PutValue(QUOTE_COLUMN_CPT_CODE, billitem->CPTCode);
			pRow->PutValue(QUOTE_COLUMN_CPT_SUB_CODE, billitem->CPTSubCode);
			// (s.tullis 2015-04-07 16:54) - PLID 64975 - If there is atleast one charge with multiple categories configured we need to show category column
			if (VarLong(billitem->CPTCategoryCount, -1) > 1)
			{
				bShowCPTCategoryColumn = TRUE;
			}
			// (s.tullis 2015-03-24 09:28) - PLID 64973 - Select None if no category else select the category
			pRow->PutValue(QUOTE_COLUMN_CPT_CATEGORY, billitem->CPTCategoryID.vt == VT_NULL ? -1 /*none*/ : billitem->CPTCategoryID);
			pRow->PutValue(QUOTE_COLUMN_CPT_TYPE, billitem->CPTType);
			pRow->PutValue(QUOTE_COLUMN_MODIFIER1, billitem->Modifier1);
			pRow->PutValue(QUOTE_COLUMN_MODIFIER2, billitem->Modifier2);
			pRow->PutValue(QUOTE_COLUMN_MODIFIER3, billitem->Modifier3);
			pRow->PutValue(QUOTE_COLUMN_MODIFIER4, billitem->Modifier4);
			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			pRow->PutValue(QUOTE_COLUMN_CALLS, billitem->Calls);
			// (d.singleton 2012-05-21 10:50) - PLID 48152 addes skill column, alberta only
			pRow->PutValue(QUOTE_COLUMN_SKILL, billitem->Skill);
			pRow->PutValue(QUOTE_COLUMN_DESCRIPTION, billitem->Description);
			pRow->PutValue(QUOTE_COLUMN_QUANTITY, billitem->Quantity);
			pRow->PutValue(QUOTE_COLUMN_PACKAGE_QTY_REM, billitem->PackageQtyRemaining);
			// (j.jones 2009-12-22 16:53) - PLID 32587 - supported the original qty. rem. column
			pRow->PutValue(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, billitem->OriginalPackageQtyRemaining);
			pRow->PutValue(QUOTE_COLUMN_UNIT_COST, billitem->UnitCost);
			pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, billitem->OthrUnitCost);
			// (j.gruber 2009-03-05 17:21) - PLID 33351 - take out discount fields, add total discount
			pRow->PutValue(QUOTE_COLUMN_TOTAL_DISCOUNT, billitem->TotalDiscount);
			//pRow->PutValue(QUOTE_COLUMN_DISCOUNT,billitem->Discount);
			pRow->PutValue(QUOTE_COLUMN_LINE_TOTAL, billitem->LineTotal);
			pRow->PutValue(QUOTE_COLUMN_TAX_RATE_1, billitem->TaxRate1);
			pRow->PutValue(QUOTE_COLUMN_TAX_RATE_2, billitem->TaxRate2);
			// (j.jones 2007-07-06 13:45) - PLID 26098 - supported Quote item type
			pRow->PutValue(QUOTE_COLUMN_ITEM_TYPE, billitem->ItemType);

			// (j.gruber 2009-10-19 08:47) - PLID 35947 - added Allowable column
			// (j.jones 2010-09-02 09:44) - PLID 40330 - this is the UnitAllowable
			pRow->PutValue(QUOTE_COLUMN_ALLOWABLE, billitem->UnitAllowable);

			// (j.jones 2011-10-05 09:31) - PLID 45799 - only add new rows, existing are updated in place
			if (bNeedAddRow) {
				m_QuoteList->AddRowSorted(pRow, NULL);
			}
			// (s.tullis 2015-04-09 17:24) - PLID 65537- added 
			UpDateBillQuoteListCellColors(pRow, billitem, BillEntryType::Quote);
			if (m_pSuggestedSalesDlg) // (a.walling 2007-05-04 11:31) - PLID 14717 - Add to our list of services
				m_pSuggestedSalesDlg->AddService(billitem->ServiceID);

			arServices.Add(billitem->ServiceID);
		}
		SortList();

		// (s.tullis 2015-04-07 16:54) - PLID 64975 - Show Category Column if multiple are configured
		if (bShowCPTCategoryColumn){
			ShowCPTCategoryColumn(BillEntryType::Quote);
		}

		if (m_pSuggestedSalesDlg) // (a.walling 2007-05-04 11:31) - PLID 14717 - And refresh the dialog if needed
			m_pSuggestedSalesDlg->RefreshIfNeeded();

		CBillingSuggestedSalesDlg::CheckSuggestionsExist(arServices, this);

		// (j.jones 2007-06-27 11:28) - PLID 26471 - revert to the row view we were previously at
		if (nOldTopRowLineID != -1) {
			IRowSettingsPtr pNewTopRow = m_QuoteList->FindByColumn(COLUMN_LINE_ID, nOldTopRowLineID, m_QuoteList->GetFirstRow(), FALSE);
			if (pNewTopRow) {
				m_QuoteList->PutTopRow(pNewTopRow);
			}
		}

		//and reselect the previous index, if available
		if (nOldCurSelLineID != -1) {
			IRowSettingsPtr pNewCurSel = m_QuoteList->FindByColumn(COLUMN_LINE_ID, nOldCurSelLineID, m_QuoteList->GetFirstRow(), FALSE);
			if (pNewCurSel) {
				m_QuoteList->PutCurSel(pNewCurSel);
			}
		}

	}NxCatchAll("Error in FillQuoteList()");
	EnableBillingScreen();
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLButtonDownList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	// (d.singleton 2012-03-07 17:31) - PLID 25098 need to be able to click the validation column even if bill is read only
	if (nCol == BILL_VALIDATION_STATUS) {
		OnLeftClickBillList(lpRow, nCol, x, y, nFlags);
	}
	else {
		OnLeftClickList(lpRow, nCol);
	}
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnRButtonDownList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	OnRightClick(lpRow, nCol);
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingStartingList(LPDISPATCH lpRow, short nCol, VARIANT FAR* pvarValue, BOOL FAR* pbContinue)
{
	IRowSettingsPtr pRow(lpRow);
	if (pRow == NULL) {
		return;
	}

	long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
	// (r.gonet 2015-03-27 18:38) - PLID 65280 - Get the item type of the line item.
	long nItemType = VarLong(pRow->GetValue(COLUMN_ITEM_TYPE));

	// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
	// Original or Void charges once a correction has been made
	if (nChargeID != -2) {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr bi = m_billingItems[i];
			if (VarLong(bi->ChargeID) == nChargeID) {
				if (VarBool(bi->IsOriginalCharge, FALSE)) {
					MessageBox("This charge has been corrected, and is no longer editable.", "Practice", MB_ICONINFORMATION | MB_OK);
					*pbContinue = FALSE;
					return;
				}
				else if (VarBool(bi->IsVoidingCharge, FALSE)) {
					MessageBox("This charge is a voiding line item for a corrected charge, and is not editable.", "Practice", MB_ICONINFORMATION | MB_OK);
					*pbContinue = FALSE;
					return;
				}
			}
		}
	}

	// (j.jones 2011-01-21 14:14) - PLID 42156 - We now have to check the ability to change fields
	// on existing charges. Even if you are an Administrator or m_eHasAccess is set to Full, we
	// have to check because you might need a password, and we always warn on items protected by a
	// financial close. Only certain columns are allowed to be changed, and they are listed here.
	// (j.jones 2011-10-13 09:59) - PLID 44941 - you cannot change modifiers for Alberta, if closed,
	// because they always change the price
	BOOL bUseAlbertaHLINK = UseAlbertaHLINK();
	if (nChargeID != -2
		//permitted columns:
		&& nCol != COLUMN_SERVICE_DATE_TO	//this is the only date they are allowed to change
		&& nCol != BILL_COLUMN_CLAIM_PROVIDER
		// (j.jones 2014-05-02 15:59) - PLID 61836 - the referring/ordering/supervising providers can change
		&& nCol != BILL_COLUMN_REFERRING_PROVIDER
		&& nCol != BILL_COLUMN_ORDERING_PROVIDER
		&& nCol != BILL_COLUMN_SUPERVISING_PROVIDER
		&& nCol != BILL_COLUMN_CPT_TYPEOFSERVICE
		&& (bUseAlbertaHLINK || nCol != COLUMN_MODIFIER1)	//we will stop them later if they pick a modifier that
		&& (bUseAlbertaHLINK || nCol != COLUMN_MODIFIER2)	//would change the total due to a new multiplier
		&& (bUseAlbertaHLINK || nCol != COLUMN_MODIFIER3)
		&& (bUseAlbertaHLINK || nCol != COLUMN_MODIFIER4)
		// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
		&& (bUseAlbertaHLINK || nCol != COLUMN_CALLS)
		// (d.singleton 2012-05-21 11:16) - PLID 48152 added skill column , alberta only
		&& (bUseAlbertaHLINK || nCol != COLUMN_SKILL)
		&& nCol != BILL_COLUMN_WHICH_CODES
		&& nCol != BILL_COLUMN_WHICH_CODES_EXT // (s.dhole 2011-05-20 11:18) - PLID 33666  check Whcic code ext
		&& nCol != BILL_COLUMN_DESCRIPTION
		&& nCol != BILL_COLUMN_ALLOWABLE
		&& nCol != COLUMN_INS_RESP			//changes to ins. resp are permitted
		&& nCol != COLUMN_BATCHED
		&& nCol != BILL_COLUMN_ON_HOLD
		) {

		//they are editing a protected field, check permissions
		if (!CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
			*pbContinue = FALSE;
			return;
		}

		//In the uncommon case where they need a password for this and also need a password
		//to edit a given column later (line input date), they are going to be password-prompted again.
	}

	switch (nCol) {
		case COLUMN_INPUT_DATE:
			if (!CheckCurrentUserPermissions(bioBill, sptDynamic0)) {
				*pbContinue = FALSE;
				return;
			}
			else {
				if (IDNO == MessageBox("WARNING: You are about to change the input date for this charge.\n"
					"Changing this date will affect the Aged Receivables for this patient, as well as many financial reports.\n\n"
					"Are you absolutely sure you wish to do this?", "Practice", MB_YESNO | MB_ICONEXCLAMATION)) {
					*pbContinue = FALSE;
					return;
				}
			}

			break;
			// (j.gruber 2007-08-24 14:53) - PLID 24632 - discount and price permissions
			// (j.gruber 2009-03-05 17:22) - PLID 33351 - don't need this anymore
			/*case COLUMN_PERCENT_OFF:
				if (!CheckCurrentUserPermissions(bioChargePercentOff, sptWrite)) {
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
				}
				break;

				case COLUMN_DISCOUNT:
				if (!CheckCurrentUserPermissions(bioChargeAmountOff, sptWrite)) {
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
				}
				break;*/

		case BILL_COLUMN_UNIT_COST:
			// (d.singleton 2011-12-21 15:37) - PLID 40036 - this used to only check for bioChargePrice permission,  i changed to also look for the
			// bioEditZeroChargeAmounts permission as well,  since its looking at multiple permissions i opted to throw the warning message myself
			// since it would be silly for the user to get two of them if both of these permissions returned false.
			// (j.jones 2012-05-10 10:47) - PLID 49213 - corrected these permission checks so that we skip the bioEditZeroChargeAmounts permission
			// check if you have full bioChargePrice permission, but not if you have bioChargePrice w/pass permission
			// (r.gonet 2015-03-27 18:38) - PLID 65280 - If the item is a gift certificate, we follow a different permission.
			if (nItemType == ITEM_TYPE_GIFT)
			{
				// (r.gonet 2015-05-28 17:38) - PLID 66032 - Its a gift certificate. Don't follow the Edit Charges permission but instead
				// the Edit Gift Certificate Values permission.
				if (!(CheckCurrentUserPermissions(bioEditGiftCertificatePrice, sptWrite, FALSE, 0, TRUE))) {
					MessageBox("You do not have permission to change Gift Certificate Prices.", "Error", MB_ICONERROR | MB_OK);
					*pbContinue = FALSE;
					m_List->StopEditing(FALSE);
					return;
				} else {
					// They have permission to edit gift certificate prices. Proceed.
				}
			// (r.gonet 2015-05-28 17:38) - PLID 66032 - Its not a gift certificate. Check if they have the charge price or zero charge price permissions.
			} else if(!(GetCurrentUserPermissions(bioChargePrice) & sptWrite)
				&& (GetCurrentUserPermissions(bioEditZeroChargeAmounts) & (sptWrite | sptWriteWithPass)))
			{
				//they do not have permission to edit charge prices in general (they might have w/pass),
				//but they DO have permission to edit zero dollar standard fees, so let that take precedence

				//get the code and look it up in our list of codes with std fee of $0
				long nCodeID = VarLong(pRow->GetValue(COLUMN_SERVICE_ID));
				if (!m_lstZeroAmountCodes.Find(nCodeID)) {
					//this is not a zero dollar standard fee, so just run the normal charge price permission check,
					//which might prompt for a password
					if (!CheckCurrentUserPermissions(bioChargePrice, sptWrite)) {
						*pbContinue = FALSE;
						m_List->StopEditing(FALSE);
						return;
					}
				}
				else {
					//this is a zero dollar standard fee, so check the zero charge amount permission
					if (!CheckCurrentUserPermissions(bioEditZeroChargeAmounts, sptWrite)) {
						*pbContinue = FALSE;
						m_List->StopEditing(FALSE);
						return;
					}
				}
			}
			//check the permission for the charge price, it may prompt for a password
			else if (!CheckCurrentUserPermissions(bioChargePrice, sptWrite)) {
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
			break;

		case BILL_COLUMN_VALUE:
		{
			// (r.gonet 2015-03-27 18:39) - PLID 65277 - If this isn't a gift certificate, we shouldn't let them edit the Value field.
			if (nItemType != ITEM_TYPE_GIFT) {
				MessageBox("You can only edit the Value column for Gift Certificate charges.", "Error", MB_ICONERROR | MB_OK);
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
			// (r.gonet 2015-03-27 18:40) - PLID 65280 - check the permission for editing Gift Certificate Values
			if (!CheckCurrentUserPermissions(bioEditGiftCertificateValue, sptWrite, FALSE, 0, TRUE)) {
				MessageBox("You do not have permission to change Gift Certificate Values.", "Error", MB_ICONERROR | MB_OK);
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
		}
			break;

			// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills, NOT editable
		case BILL_COLUMN_ALLOWABLE:
		{
			*pbContinue = FALSE;
			m_List->StopEditing(FALSE);
			return;
		}
			break;

		case BILL_COLUMN_QUANTITY: {
			// (j.jones 2008-06-10 11:00) - PLID 28392 - CheckWarnAlteringReturnedProducts will warn
			// if there are products returned from this charge			
			// (j.jones 2013-07-23 10:03) - PLID 46493 - this function has a void flag now, always false here
			if (nItemType == ITEM_TYPE_PRODUCT
				&& nChargeID != -2
				&& !CheckWarnAlteringReturnedProducts(false, false, nChargeID, true)) {

				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
		}
			break;

		case COLUMN_TAX_RATE_1: {
			// (d.singleton 2012-09-25 10:33) - PLID 50996 added permission to allow editing of tax fields for charge line items
			if (!CheckCurrentUserPermissions(bioChargeLineTax, sptWrite)) {
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
		}
			break;

		case COLUMN_TAX_RATE_2: {
			// (d.singleton 2012-09-25 10:33) - PLID 50996 added permission to allow editing of tax fields for charge line items
			if (!CheckCurrentUserPermissions(bioChargeLineTax, sptWrite)) {
				*pbContinue = FALSE;
				m_List->StopEditing(FALSE);
				return;
			}
		}
			break;
	}
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingFinishedList(LPDISPATCH lpRow, short nCol, const VARIANT FAR& varOldValue, const VARIANT FAR& varNewValue, BOOL bCommit) 
{
	//*******************************************************************************************************
	//*TES 6/16/03: OK, the deal is, we're going to be requerying the charge list.  Therefore, the datalist
	//*will get confused, and, if we hit the tab key, will not put us into the next field.  So, we'll need
		//*to do it ourselves, so we need to check whether the tab key is depressed ASAP, because the user could
		//*lift up their finger at any time.
		//*********
		// (b.cardillo 2004-03-02 09:54 - PLID 8894 - billingdlg.cpp;559) - I made it also check to see if the 
		// keyup VK_TAB message is in the message queue right now.  As Tom points out above, the user could let 
		// go of the key at any time, including 1 tick before we call GetAsyncKeyState(VK_TAB).  So if the key 
		// is down right now (which iswhat the GetAsyncKeyState(VK_TAB) tells us, OR if there is a keyup VK_TAB 
		// message in the queue, which means the key WAS down at some point right before we started handling 
		// this event, then we take that to mean the "tab key is down" in the context of this function.
		//*******************************************************************************************************
		BOOL bIsShiftDown = (GetAsyncKeyState(VK_SHIFT) & 0x80000000);
		BOOL bIsTabDown = (GetAsyncKeyState(VK_TAB) & 0x80000000) || IsMessageInQueue(NULL, WM_KEYUP, VK_TAB, 0, IMIQ_MATCH_WPARAM);
		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);
		// (j.gruber 2007-03-27 11:31) - PLID 25352 - check whether they want to popup the category dialog
		BOOL bCheckPopupDiscount = FALSE;
		// (j.gruber 2007-03-29 11:00) - PLID 25351 - used for checking whether they want to change the discount
		BillingItemPtr pItem;

		// (j.jones 2008-11-14 08:38) - PLID 21149 - tracks whether they edited the provider
		BOOL bEditedProvider = FALSE;

		// (j.jones 2010-11-09 10:51) - PLID 31392 - tracks whether they edited the claim provider
		BOOL bEditedClaimProvider = FALSE;

		IRowSettingsPtr pRow(lpRow);
		m_pList->PutCurSel(pRow);


		

		if (bCommit && pRow != NULL) {
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {
					pItem = m_billingItems[i];
					switch (nCol) {
						case BILL_COLUMN_DATE:
						{
							if (m_bPromptedChargeDate || COleVariant(varNewValue) == COleVariant(varOldValue) || (int)m_billingItems.size() < 2 ||
								(GetRemotePropertyInt("ChangeChargeDatesPrompt", 1, 0, GetCurrentUserName(), true) == 0) ||
								MsgBox(MB_YESNO, "You are changing the date of service of a charge in the current bill.  Would you like to apply this same "
								"date to all other charges in the bill?") == IDNO) {
								//We just update the date they changed if:
								//1)  They didn't change the date.  This probably isn't necessary, but the code used to 
								//		do it, so I'm not changing it.
								//2)  There are less than 2 charges.  No need to prompt them if there is only 1 charge.
								//3)  They say 'No' to the message box that asks if they want to change them.
								//4)  They have the preference turned off
								//5)  They have been prompted already (m_bPromptedChargeDate)
								//do the old stuff

								// (j.jones 2006-11-29 09:54) - PLID 23684 - if the "service date to" is the same date,
								// or the column for it is size 0, auto-update it
								IColumnSettingsPtr pCol = m_pList->GetColumn(COLUMN_SERVICE_DATE_TO);
								if (pCol->GetStoredWidth() <= 0 || m_billingItems[i]->ServiceDateTo == m_billingItems[i]->Date) {
									m_billingItems[i]->ServiceDateTo = varNewValue;
								}

								m_billingItems[i]->Date = varNewValue;
								// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Update allowable because the charge date now matters (and it just changed)
								LoadAllowableColumn(m_billingItems[i], TRUE);
							}
							else {
								//they want to.  Loop through all items in the list and the array
								int j = 0;
								for (j = 0; j < (int)m_billingItems.size(); j++) {

									long nChargeID = VarLong(m_billingItems[j]->ChargeID, -2);

									// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
									if (IsOriginalOrVoidCharge(nChargeID)) {
										continue;
									}

									// (j.jones 2006-11-29 09:54) - PLID 23684 - if the "service date to" is the same date,
									// or the column for it is size 0, auto-update it
									IColumnSettingsPtr pCol = m_pList->GetColumn(COLUMN_SERVICE_DATE_TO);
									if (pCol->GetStoredWidth() <= 0 || m_billingItems[j]->ServiceDateTo == varOldValue) {
										m_billingItems[j]->ServiceDateTo = varNewValue;
									}

									m_billingItems[j]->Date = varNewValue;
									// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Update allowable because the charge date now matters (and it just changed)
									// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Fixed to use j, not i!
									LoadAllowableColumn(m_billingItems[j], TRUE);
								}

								// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
								IRowSettingsPtr pLoopRow = m_pList->GetFirstRow();
								while (pLoopRow) {

									long nChargeID = VarLong(pLoopRow->GetValue(COLUMN_CHARGE_ID));

									// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
									if (IsOriginalOrVoidCharge(nChargeID)) {
										pLoopRow = pLoopRow->GetNextRow();
										continue;
									}

									// (j.jones 2006-11-29 09:54) - PLID 23684 - if the "service date to" is the same date,
									// or the column for it is size 0, auto-update it
									IColumnSettingsPtr pCol = m_pList->GetColumn(COLUMN_SERVICE_DATE_TO);
									if (pCol->GetStoredWidth() <= 0 || pLoopRow->GetValue(COLUMN_SERVICE_DATE_TO) == varOldValue) {
										pLoopRow->PutValue(COLUMN_SERVICE_DATE_TO, varNewValue);
									}

									pLoopRow->PutValue(BILL_COLUMN_DATE, varNewValue);
									AddToModifiedList(VarLong(pLoopRow->GetValue(COLUMN_CHARGE_ID)));	//we need to mark this charge as modified so it saves the date on editing

									pLoopRow = pLoopRow->GetNextRow();
								}
							}

							m_bPromptedChargeDate = true;		//we've been prompted, don't ask again
						}
							break;
						case COLUMN_SERVICE_DATE_TO:
						{
							if (m_bPromptedChargeServiceDateTo || COleVariant(varNewValue) == COleVariant(varOldValue) || (int)m_billingItems.size() < 2 ||
								(GetRemotePropertyInt("ChangeChargeDatesPrompt", 1, 0, GetCurrentUserName(), true) == 0) ||
								MsgBox(MB_YESNO, "You are changing the 'service date to' of a charge in the current bill.  Would you like to apply this same "
								"date as the 'service date to' for all other charges in the bill?") == IDNO) {
								//We just update the date they changed if:
								//1)  They didn't change the date.  This probably isn't necessary, but the code used to 
								//		do it, so I'm not changing it.
								//2)  There are less than 2 charges.  No need to prompt them if there is only 1 charge.
								//3)  They say 'No' to the message box that asks if they want to change them.
								//4)  They have the preference turned off
								//5)  They have been prompted already (m_bPromptedChargeDate)
								//do the old stuff
								m_billingItems[i]->ServiceDateTo = varNewValue;
							}
							else {
								//they want to.  Loop through all items in the list and the array
								int j = 0;
								for (j = 0; j < (int)m_billingItems.size(); j++) {
									m_billingItems[j]->ServiceDateTo = varNewValue;
								}
								// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
								IRowSettingsPtr pLoopRow = m_pList->GetFirstRow();
								while (pLoopRow) {
									pLoopRow->PutValue(COLUMN_SERVICE_DATE_TO, varNewValue);
									AddToModifiedList(VarLong(pLoopRow->GetValue(COLUMN_CHARGE_ID)));	//we need to mark this charge as modified so it saves the date on editing

									pLoopRow = pLoopRow->GetNextRow();
								}
							}

							m_bPromptedChargeServiceDateTo = true;		//we've been prompted, don't ask again
						}
							break;
						case COLUMN_INPUT_DATE:
						{
							if (m_bPromptedChargeInputDate || COleVariant(varNewValue) == COleVariant(varOldValue) || (int)m_billingItems.size() < 2 ||
								(GetRemotePropertyInt("ChangeChargeDatesPrompt", 1, 0, GetCurrentUserName(), true) == 0) ||
								MsgBox(MB_YESNO, "You are changing the input date of a charge in the current bill.  Would you like to apply this same "
								"date to all other charges in the bill?") == IDNO) {
								//We just update the date they changed if:
								//1)  They didn't change the date.  This probably isn't necessary, but the code used to 
								//		do it, so I'm not changing it.
								//2)  There are less than 2 charges.  No need to prompt them if there is only 1 charge.
								//3)  They say 'No' to the message box that asks if they want to change them.
								//4)  They have the preference turned off
								//5)  They have been prompted already (m_bPromptedChargeDate)
								//do the old stuff
								m_billingItems[i]->InputDate = varNewValue;
							}
							else {
								//they want to.  Loop through all items in the list and the array
								int j = 0;
								for (j = 0; j < (int)m_billingItems.size(); j++) {
									m_billingItems[j]->InputDate = varNewValue;
								}
								// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
								IRowSettingsPtr pLoopRow = m_pList->GetFirstRow();
								while (pLoopRow) {
									pLoopRow->PutValue(COLUMN_INPUT_DATE, varNewValue);
									AddToModifiedList(VarLong(pLoopRow->GetValue(COLUMN_CHARGE_ID)));	//we need to mark this charge as modified so it saves the date on editing

									pLoopRow = pLoopRow->GetNextRow();
								}
							}

							m_bPromptedChargeInputDate = true;		//we've been prompted, don't ask again
						}
							break;

						case BILL_COLUMN_PROVIDER: {
							m_billingItems[i]->Provider = varNewValue;

							// (j.jones 2008-11-14 08:38) - PLID 21149 - track that they edited the provider,
							// don't bother checking to see if it changed, just that they edited it
							bEditedProvider = TRUE;

							// (d.singleton 2012-05-22 11:00) - PLID 50744 if alberta billing need to update the skill code
							if (UseAlbertaHLINK()) {
								long nProviderID = varNewValue.lVal;
								if (nProviderID > -1) {
									_RecordsetPtr prs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", nProviderID);
									CString strSkillCode = AdoFldString(prs, "TaxonomyCode", "");
									if (strSkillCode.GetLength() > 4) {
										strSkillCode = "";
									}
									m_billingItems[i]->Skill = strSkillCode;
								}
							}
							break;
						}

							// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
						case BILL_COLUMN_CLAIM_PROVIDER: {
							m_billingItems[i]->ClaimProvider = VarLong(varNewValue, -1);

							bEditedClaimProvider = TRUE;

							break;
						}

							// (j.jones 2014-04-23 11:06) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
						case BILL_COLUMN_REFERRING_PROVIDER: {
							m_billingItems[i]->ReferringProviderID = VarLong(varNewValue, -1);
							break;
						}
						case BILL_COLUMN_ORDERING_PROVIDER: {
							m_billingItems[i]->OrderingProviderID = VarLong(varNewValue, -1);
							break;
						}
						case BILL_COLUMN_SUPERVISING_PROVIDER: {
							m_billingItems[i]->SupervisingProviderID = VarLong(varNewValue, -1);
							break;
						}

						case COLUMN_PATCOORD: {
							m_billingItems[i]->PatCoordinator = varNewValue;
							break;
						}
						case BILL_COLUMN_CPT_CODE:
							m_billingItems[i]->CPTCode = varNewValue;
							break;
						case BILL_COLUMN_CPT_SUB_CODE:
							m_billingItems[i]->CPTSubCode = varNewValue;
							break;
						// (s.tullis 2015-03-24 09:28) - PLID 64973 -  Set the Billitem Cpt Catgory ID to the selection ID
						case BILL_COLUMN_CPT_CATEGORY:
							m_billingItems[i]->CPTCategoryID = VarLong(varNewValue,-1);
							break;
						case BILL_COLUMN_CPT_TYPEOFSERVICE:
							m_billingItems[i]->TypeOfService = varNewValue;
							break;
						case COLUMN_MODIFIER1:
						{
							try {

								if (varNewValue.vt == VT_EMPTY && varOldValue.vt == VT_EMPTY) {
									break;
								}

								BillingItemPtr billitem = m_billingItems[i];

								CString Mod1;
								if (varNewValue.vt == VT_BSTR)
									Mod1 = CString(varNewValue.bstrVal);
								else if (varNewValue.vt == VT_I4)
									Mod1.Format("%li", varNewValue.lVal);
								// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
								// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
								double dblNew = 1.0;
								if (!UseAlbertaHLINK()) {
									_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod1);
									if (!rs->eof) {
										_variant_t var = rs->Fields->Item["Multiplier"]->Value;
										if (var.vt == VT_R8) {
											dblNew = VarDouble(var, 1.0);
										}
									}
									rs->Close();
								}

								// (j.jones 2011-01-25 16:15) - PLID 42156 - if the new multiplier differs from the old
								// multiplier, and this is not a new charge, check permissions
								double dblOld = 1.0;
								if (billitem->Multiplier1.vt == VT_R8) {
									dblOld = VarDouble(billitem->Multiplier1);
								}
								if (m_EntryType == 1 && dblOld != dblNew) {
									long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
									if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptDelete)) {
										//reset the datalist to the old value
										pRow->PutValue(nCol, varOldValue);
										return;
									}
								}

								billitem->Multiplier1 = (double)dblNew;
								billitem->Modifier1 = varNewValue;

								// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
								// the unit cost based on the modifier we just chose
								// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
								// only if we changed the modifier, so it can change back to the std. fee
								if (UseAlbertaHLINK()) {
									UpdateChargePriceWithAlbertaModifiers(billitem, VarString(varOldValue, "") != VarString(varNewValue, ""));
								}

							}NxCatchAll("Error in changing Modifier1");
						}
							break;
						case COLUMN_MODIFIER2:
						{
							try {

								if (varNewValue.vt == VT_EMPTY && varOldValue.vt == VT_EMPTY) {
									break;
								}

								BillingItemPtr billitem = m_billingItems[i];

								CString Mod2;
								if (varNewValue.vt == VT_BSTR)
									Mod2 = CString(varNewValue.bstrVal);
								else if (varNewValue.vt == VT_I4)
									Mod2.Format("%li", varNewValue.lVal);
								// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
								// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
								double dblNew = 1.0;
								if (!UseAlbertaHLINK()) {
									_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod2);
									if (!rs->eof) {
										_variant_t var = rs->Fields->Item["Multiplier"]->Value;
										if (var.vt == VT_R8) {
											dblNew = VarDouble(var, 1.0);
										}
									}
									rs->Close();
								}

								// (j.jones 2011-01-25 16:15) - PLID 42156 - if the new multiplier differs from the old
								// multiplier, and this is not a new charge, check permissions
								double dblOld = 1.0;
								if (billitem->Multiplier2.vt == VT_R8) {
									dblOld = VarDouble(billitem->Multiplier2);
								}
								if (m_EntryType == 1 && dblOld != dblNew) {
									long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
									if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptDelete)) {
										//reset the datalist to the old value
										pRow->PutValue(nCol, varOldValue);
										return;
									}
								}

								billitem->Multiplier2 = (double)dblNew;
								billitem->Modifier2 = varNewValue;

								// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
								// the unit cost based on the modifier we just chose
								// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
								// only if we changed the modifier, so it can change back to the std. fee
								if (UseAlbertaHLINK()) {
									UpdateChargePriceWithAlbertaModifiers(billitem, VarString(varOldValue, "") != VarString(varNewValue, ""));
								}

							}NxCatchAll("Error in changing Modifier2");
						}
							break;
						case COLUMN_MODIFIER3:
						{
							try{

								if (varNewValue.vt == VT_EMPTY && varOldValue.vt == VT_EMPTY) {
									break;
								}

								BillingItemPtr billitem = m_billingItems[i];

								CString Mod3;
								if (varNewValue.vt == VT_BSTR)
									Mod3 = CString(varNewValue.bstrVal);
								else if (varNewValue.vt == VT_I4)
									Mod3.Format("%li", varNewValue.lVal);
								// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
								// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
								double dblNew = 1.0;
								if (!UseAlbertaHLINK()) {
									_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod3);
									if (!rs->eof) {
										_variant_t var = rs->Fields->Item["Multiplier"]->Value;
										if (var.vt == VT_R8) {
											dblNew = VarDouble(var, 1.0);
										}
									}
									rs->Close();
								}

								// (j.jones 2011-01-25 16:15) - PLID 42156 - if the new multiplier differs from the old
								// multiplier, and this is not a new charge, check permissions
								double dblOld = 1.0;
								if (billitem->Multiplier3.vt == VT_R8) {
									dblOld = VarDouble(billitem->Multiplier3);
								}
								if (m_EntryType == 1 && dblOld != dblNew) {
									long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
									if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptDelete)) {
										//reset the datalist to the old value
										pRow->PutValue(nCol, varOldValue);
										return;
									}
								}

								billitem->Multiplier3 = (double)dblNew;
								billitem->Modifier3 = varNewValue;

								// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
								// the unit cost based on the modifier we just chose
								// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
								// only if we changed the modifier, so it can change back to the std. fee
								if (UseAlbertaHLINK()) {
									UpdateChargePriceWithAlbertaModifiers(billitem, VarString(varOldValue, "") != VarString(varNewValue, ""));
								}

							}NxCatchAll("Error in changing Modifier3");
						}
							break;
						case COLUMN_MODIFIER4:
						{
							try{

								if (varNewValue.vt == VT_EMPTY && varOldValue.vt == VT_EMPTY) {
									break;
								}

								BillingItemPtr billitem = m_billingItems[i];

								CString Mod4;
								if (varNewValue.vt == VT_BSTR)
									Mod4 = CString(varNewValue.bstrVal);
								else if (varNewValue.vt == VT_I4)
									Mod4.Format("%li", varNewValue.lVal);
								// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
								// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
								double dblNew = 1.0;
								if (!UseAlbertaHLINK()) {
									_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod4);
									if (!rs->eof) {
										_variant_t var = rs->Fields->Item["Multiplier"]->Value;
										if (var.vt == VT_R8) {
											dblNew = VarDouble(var, 1.0);
										}
									}
									rs->Close();
								}

								// (j.jones 2011-01-25 16:15) - PLID 42156 - if the new multiplier differs from the old
								// multiplier, and this is not a new charge, check permissions
								double dblOld = 1.0;
								if (billitem->Multiplier4.vt == VT_R8) {
									dblOld = VarDouble(billitem->Multiplier4);
								}
								if (m_EntryType == 1 && dblOld != dblNew) {
									long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
									if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptDelete)) {
										//reset the datalist to the old value
										pRow->PutValue(nCol, varOldValue);
										return;
									}
								}

								billitem->Multiplier4 = (double)dblNew;
								billitem->Modifier4 = varNewValue;

								// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
								// the unit cost based on the modifier we just chose
								// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
								// only if we changed the modifier, so it can change back to the std. fee
								if (UseAlbertaHLINK()) {
									UpdateChargePriceWithAlbertaModifiers(billitem, VarString(varOldValue, "") != VarString(varNewValue, ""));
								}

							}NxCatchAll("Error in changing Modifier4");
						}
							break;

							// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
						case COLUMN_CALLS: {

							BillingItemPtr billitem = m_billingItems[i];

							billitem->Calls = varNewValue;

							//if Alberta, we need to change the unit cost based on the calls
							// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
							// price unless there are modifiers
							if (UseAlbertaHLINK()) {
								UpdateChargePriceWithAlbertaModifiers(billitem, FALSE);

								// (d.singleton 2012-03-30 12:10) - PLID 48151 - support alberta calls creating notes
								if (GetRemotePropertyInt("AddNoteOnCallValues", 1, 0, "<none>", true)) {
									BOOL bIsUnsavedCharge = FALSE;
									_variant_t varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
									_variant_t varLineID = pRow->GetValue(COLUMN_LINE_ID);
									if (!ReturnsRecordsParam("SELECT * FROM ChargesT WHERE ID = {VT_I4}", varChargeID)) {
										bIsUnsavedCharge = TRUE;
									}
									//add the note
									AddUnsavedNotes(bIsUnsavedCharge, varChargeID, varLineID);
								}
							}
							break;
						}
						case COLUMN_SKILL:
							m_billingItems[i]->Skill = varNewValue;
							break;
						case BILL_COLUMN_WHICH_CODES:
							// (j.gruber 2014-02-19 10:49) - PLID 60878
							SaveToWhichCodesMap(m_billingItems[i]->whichCodes, varNewValue);
							//m_billingItems[i]->WhichDiagCodes = varNewValue;
							break;
						case BILL_COLUMN_DESCRIPTION:
							m_billingItems[i]->Description = varNewValue;
							break;
						case BILL_COLUMN_QUANTITY: {
							double Quantity = varNewValue.dblVal;
							//if a product
							if (VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_PRODUCT) {

								//if there are charged product items
								if (m_billingItems[i]->ChargedProductItemListID.lVal != -1) {
									//then change them
									if (!ChangeProductItems(Quantity))
										Quantity = varOldValue.dblVal;
								}
								else {
									//if they are increasing the quantity but now it needs serialized information, yell at them.
									// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
									if (ReturnsRecordsParam("SELECT ID FROM ProductT WHERE (HasSerialNum = 1 OR HasExpDate = 1) "
										"AND ID = {INT}", m_billingItems[i]->ServiceID.lVal)
										&& varOldValue.dblVal < Quantity) {
										AfxMessageBox("The product you are editing has been set up to use a serial number or expiration date, after this charge was created.\n"
											"The existing quantity on this charge is not using a serial number or expiration date, but any changes to the quantity would require that information.\n\n"
											"Practice requires you to make a new charge for this product if you wish to change the quantity.");
										Quantity = varOldValue.dblVal;
									}
								}
							}

							m_billingItems[i]->Quantity = Quantity;
							m_billingItems[i]->PackageQtyRemaining = Quantity;
							// (j.jones 2009-12-22 16:53) - PLID 32587 - supported the original qty. rem. column
							m_billingItems[i]->OriginalPackageQtyRemaining = Quantity;

							//JMJ - 5/20/2003 - We have to check DoIHaveEnough last because the
							//GetUnsavedQuantityCount is dependent on the correct quantity being in the list

							long LocationID = -1;

							if (m_LocationCombo->GetCurSel() == -1)
								LocationID = GetCurrentLocationID();
							else
								LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

							//if a product
							if (VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_PRODUCT) {
								//check quantity in stock

								long nServiceID = VarLong(m_billingItems[i]->ServiceID);

								// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations
								InvUtils::DoIHaveEnough(
									nServiceID,
									LocationID,
									-GetUnsavedQuantityCount(nServiceID),
									-GetUnsavedAllocationQuantityCount(nServiceID),
									m_EntryType == 2);
							}
						}
							break;
						case BILL_COLUMN_UNIT_COST:
							m_billingItems[i]->UnitCost = varNewValue;
							break;
						case BILL_COLUMN_VALUE:
							// (r.gonet 2015-03-27 18:40) - PLID 65277 - Sync the billing item's Value up with the datalist's Value column.
							m_billingItems[i]->Value = varNewValue;
							break;
						case BILL_COLUMN_LINE_TOTAL:
							m_billingItems[i]->LineTotal = varNewValue;
							break;
						case COLUMN_INS_RESP:
						{

							//this gets more complicated than it used to be.
							RPCList *list = m_billingItems[i]->RPCList;
							//find the current resp
							bool bRespFound = false;
							// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
							int j = 0;
							for (j = 0; j < list->aryRPC.GetSize() && !bRespFound; j++) {
								if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == GetCurrentBillToInsuredPartyID()) {
									//this is the currently selected resp, so update the list with the new value
									bRespFound = true;
									j--;	//because the for loop will inc it again.
								}
							}

							// (j.gruber 2007-08-21 16:29) - PLID 25846 - 
							//this could make it so that we have an allowable, get rid of any results previous so that its checked again when saving
							m_billingItems[i]->HasAllowable.vt = VT_NULL;



							if (m_billingItems[i]->ChargeID.lVal != -2) {

								if (VarCurrency(varOldValue, COleCurrency(0, 0)) != VarCurrency(varNewValue, COleCurrency(0, 0))) {

									//we need to warn because it isn't a new charge
									if (MsgBox(MB_YESNO, "By changing this amount, all aging for this charge will begin on the current charge date.  Are you sure you wish to do this?  \nNote: To transfer responsibilities please use the dragging method from the billing tab.") == IDNO) {

										//they said no, so change the date back and get outta here
										if (bRespFound) {
											list->aryRPC.GetAt(j).InsAmount = varOldValue;
										}
										pRow->PutValue(COLUMN_INS_RESP, varOldValue);
										bCommit = FALSE;
										return;
									}
								}
							}

							if (bRespFound) {

								//this insurance already has something here, update it.
								UpdateListInsAmount(list, j, varNewValue);
							}
							else {
								//this insurance does not exist here.  add it.
								RespPerCharge rpc;
								rpc.InsAmount = varNewValue;
								rpc.InsuredPartyID = GetCurrentBillToInsuredPartyID();
								// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
								rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
								rpc.RespTypeName = GetCurrentBillToRespTypeName();
								list->aryRPC.Add(rpc);
							}

							// (j.jones 2008-02-12 16:04) - PLID 28848 - if shifting from patient to primary,
							// and the preferences are set to unbatch patient-only charges, and the charge
							// is unbatched, prompt to batch it
							if (m_EntryType == 1 && VarCurrency(varOldValue, COleCurrency(0, 0)) == COleCurrency(0, 0) &&
								VarCurrency(varNewValue, COleCurrency(0, 0)) > COleCurrency(0, 0) &&
								GetRemotePropertyInt("DisallowBatchingPatientClaims", 0, 0, "<None>", TRUE) == 1 &&
								GetRemotePropertyInt("HidePatientChargesOnClaims", 0, 0, "<None>", TRUE) == 1 &&
								!VarBool(pRow->GetValue(COLUMN_BATCHED), FALSE)) {

								//prompt to batch
								if (IDYES == MessageBox("This charge is not currently 'batched' and is not included on claims.\n"
									"Would you like to include this charge when a claim is generated?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

									pRow->PutValue(COLUMN_BATCHED, g_cvarTrue);
									m_billingItems[i]->Batched = g_cvarTrue;
								}
							}
						}
							break;
						case COLUMN_TAX_RATE_1:
							m_billingItems[i]->TaxRate1 = varNewValue;
							break;
						case COLUMN_TAX_RATE_2:
							m_billingItems[i]->TaxRate2 = varNewValue;
							break;
							//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
						case COLUMN_ITEM_TYPE:
							m_billingItems[i]->ItemType = varNewValue;
							break;
						case COLUMN_BATCHED:
							m_billingItems[i]->Batched = varNewValue;
							break;
					}
				}
			}

			// Calculate the line total

			m_varBoundItem = pRow->GetValue(COLUMN_LINE_ID);
			if (m_varBoundItem.vt == VT_EMPTY)
				return;

			// CAH
			COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
			if (varChargeID.vt == VT_EMPTY)
				return;
			if (varChargeID.lVal != -2)
			{
				AddToModifiedList(varChargeID.lVal);
			}

			// (j.jones 2008-11-13 16:58) - PLID 21149 - if they edited the provider, prompt to apply the new provider to each charge
			// (j.gruber 2009-10-19 12:34) - PLID 35995 - fix this to check the multifee even if they have only 1 charge or say no to updating the other charges, etc
			if (bEditedProvider) {

				if (pRow) {

					if (m_pList->GetRowCount() > 1) {

						if (GetRemotePropertyInt("ChangeChargeProviderPrompt", 1, 0, GetCurrentUserName(), true) == 1
							&& HasChargesWithDifferentProvider(pItem->Provider) // don't warn if there are no charges with a different provider
							&& MsgBox(MB_YESNO, "You are editing the provider of a charge in the current bill. "
							"Would you like to apply this same provider to all other charges in the bill?") == IDYES) {

							//first we need to update the current row
							UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);

							//like CheckApplyDiscountThroughout(), this needs to be called before CalculateLineTotal
							UpdateAllChargesWithNewProvider(pItem->Provider);
						}
						else {

							//we still need to update this one						
							UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);
						}
					}
					else if (m_pList->GetRowCount() == 1) {
						UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);
					}
				}
			}

			// (j.jones 2010-11-09 10:51) - PLID 31392 - if they changed the claim provider, ask to update the other charges
			if (bEditedClaimProvider) {

				// (j.jones 2014-04-30 15:25) - PLID 61837 - the new claim provider may
				// potentially change additional provider columns
				if (m_EntryType == 1) {
					TryShowChargeProviderColumns(pItem, false, true, true);
				}

				if (pRow != NULL && m_pList->GetRowCount() > 1) {

					//same preference as the regular provider
					if (GetRemotePropertyInt("ChangeChargeProviderPrompt", 1, 0, GetCurrentUserName(), true) == 1
						&& HasChargesWithDifferentClaimProvider(pItem->ClaimProvider) // don't warn if there are no charges with a different claim provider
						&& MsgBox(MB_YESNO, "You are editing the claim provider of a charge in the current bill. "
						"Would you like to apply this same claim provider to all other charges in the bill?") == IDYES) {

						//like CheckApplyDiscountThroughout(), this needs to be called before CalculateLineTotal
						UpdateAllChargesWithNewClaimProvider(pItem->ClaimProvider);
					}
				}
			}

			// (j.gruber 2007-03-27 11:32) - PLID 25352 - check if they want to popup the dialog
			// (j.jones 2008-04-17 09:59) - PLID 29693 - This needs to be BEFORE CalculateLineTotal,
			// because the row index may change during a sort, and ShowDiscountCategoryList() needs
			// the row index. CheckApplyDiscountThroughout() will call CalculateLineTotal() before
			// it changes the bound item now.
			// (j.gruber 2009-03-06 13:01) - PLID 33351 - take out discounts
			/*if (bCheckPopupDiscount) {
				long nSelection = GetRemotePropertyInt("BillShowDiscountCatScreenWhenAddDiscount", 2, 0, "<None>", true);
				if (nSelection == 1) {
				//always show it
				ShowDiscountCategoryList(nRow, TRUE);
				}
				else if (nSelection == 2) {
				//prompt
				if (MsgBox(MB_YESNO, "Would you like to set a discount category?") == IDYES) {
				if (IDOK != ShowDiscountCategoryList(nRow, TRUE) ) {
				//they cancelled out of the dialog, but we still need to ask them about the other preference
				CheckApplyDiscountThroughout(pItem, TRUE);
				}
				else {
				//it was handled already
				}
				}
				else {
				CheckApplyDiscountThroughout(pItem, TRUE);
				}
				}
				else {
				// (j.gruber 2007-03-29 10:55) - PLID 25351 -  check to see if they want to apply this discount to the rest of the charges
				CheckApplyDiscountThroughout(pItem, TRUE);
				}
				}*/

			//***after this line, you should not do anything that references the current line ID
			//or pItem, because they may no longer be valid if the list is sorted***//
			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			if (!bIsTabDown) {
				GetParent()->SetFocus();
				GetDlgItem(IDC_COMBO_BILL_TO)->SetFocus();
			}
		} // if(bCommit && nRow != -1)

		// (c.haag 2007-03-14 14:46) - PLID 23156 - Regardless of whether we committed or not, we now support
		// tabbing between rows
		// (j.jones 2008-11-17 09:57) - PLID 29694 - If the sorting changed, nRow is no longer the same charge we
		// initially edited. The only way we can find the new row is look at the new LineID from the BillingItem we
		// edited, find the matching datalist row with the same LineID, and tab through that row instead of nRow.
		IRowSettingsPtr pRowIndex = NULL;
		if (pItem) {
			pRowIndex = m_List->FindByColumn(COLUMN_LINE_ID, VarLong(pItem->LineID), m_List->GetFirstRow(), FALSE);
		}

		if (pRowIndex == NULL) {
			//if nRowIndex wasn't found, then we probably didn't commit the change,
			//so continue on with the nRow we started editing
			pRowIndex = pRow;
		}

		if (pRowIndex != NULL && bIsTabDown) {

			//Find the next editable column.
			int nNextCol = -1;
			nNextCol = GetNextBillColumn(nCol, nCol, bIsShiftDown);
			if (nNextCol != -1) {
				// (c.haag 2007-03-13 17:25) - PLID 23156 - If the shift key is up and the next column
				// is behind the current column, then skip to the next row
				if (!bIsShiftDown && nNextCol < nCol) {
					// If we're not on the last row, go to the next row
					BOOL bContinue = TRUE;
					IRowSettingsPtr pNextRowIndex = pRowIndex;
					while (bContinue) {

						bContinue = FALSE;

						pNextRowIndex = pNextRowIndex->GetNextRow();

						if (pNextRowIndex) {

							// (j.jones 2011-08-24 08:41) - PLID 44868 - auto-skip charges
							// that are original or void, since nobody can ever edit them
							long nChargeID = VarLong(pNextRowIndex->GetValue(COLUMN_CHARGE_ID));
							// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
							// Original or Void charges once a correction has been made
							if (IsOriginalOrVoidCharge(nChargeID)) {
								bContinue = TRUE;
							}

							if (!bContinue) {
								m_List->PutCurSel(pNextRowIndex);
								m_List->StartEditing(pNextRowIndex, nNextCol);
							}
						}
						// If we're on the last row, go to the next dialog control
						else {

							bContinue = FALSE;

							CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_LIST));
							if (pWnd) {
								m_List->StopEditing(VARIANT_TRUE);
								GetParent()->SetFocus();
								pWnd->SetFocus();
							}
						}
					}
				}
				// (c.haag 2007-03-13 17:27) - PLID 23156 - If the shift key is down and the next column
				// is after the current column, then skip to the previous row
				else if (bIsShiftDown && nNextCol > nCol) {

					// If we're not on the last row, go to the next row
					BOOL bContinue = TRUE;
					IRowSettingsPtr pNextRowIndex = pRowIndex;
					while (bContinue) {

						bContinue = FALSE;

						// If we are on the first row, go to the previous dialog control
						if (pNextRowIndex == m_List->GetFirstRow()) {
							CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_LIST), TRUE);
							if (pWnd) {
								m_List->StopEditing(VARIANT_TRUE);
								GetParent()->SetFocus();
								pWnd->SetFocus();
							}
						}
						// If we're not on the first row, then go up one row
						else {

							if (pNextRowIndex) {

								// (j.jones 2011-08-24 08:41) - PLID 44868 - auto-skip charges
								// that are original or void, since nobody can ever edit them
								long nChargeID = VarLong(pNextRowIndex->GetValue(COLUMN_CHARGE_ID));

								// (j.jones 2011-08-24 08:41) - PLID 44868 - nobody, not even administrators, can edit
								// Original or Void charges once a correction has been made
								if (IsOriginalOrVoidCharge(nChargeID)) {
									bContinue = TRUE;
									pNextRowIndex = pNextRowIndex->GetPreviousRow();
								}

								if (!bContinue && pNextRowIndex != NULL) {
									m_List->PutCurSel(pNextRowIndex);
									m_List->StartEditing(pNextRowIndex, nNextCol);
								}
							}
						}
					}
				}
				else {
					m_List->PutCurSel(pRowIndex);
				m_List->StartEditing(pRowIndex, nNextCol);
			}
		}
	}
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLButtonDownQuoteList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	OnLeftClickQuoteList(lpRow, nCol);
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnRButtonDownQuoteList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	OnRightClick(lpRow, nCol);
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingFinishedQuoteList(LPDISPATCH lpRow, short nCol, const VARIANT FAR& varOldValue, const VARIANT FAR& varNewValue, BOOL bCommit)
{
	//*******************************************************************************************************
	//*TES 6/16/03: OK, the deal is, we're going to be requerying the charge list.  Therefore, the datalist
	//*will get confused, and, if we hit the tab key, will not put us into the next field.  So, we'll need
	//*to do it ourselves, so we need to check whether the tab key is depressed ASAP, because the user could
	//*lift up their finger at any time.
	//*********
	// (b.cardillo 2004-03-02 09:54 - PLID 8894 - billingdlg.cpp;559) - I made it also check to see if the 
	// keyup VK_TAB message is in the message queue right now.  As Tom points out above, the user could let 
	// go of the key at any time, including 1 tick before we call GetAsyncKeyState(VK_TAB).  So if the key 
	// is down right now (which iswhat the GetAsyncKeyState(VK_TAB) tells us, OR if there is a keyup VK_TAB 
	// message in the queue, which means the key WAS down at some point right before we started handling 
	// this event, then we take that to mean the "tab key is down" in the context of this function.
	//*******************************************************************************************************
	BOOL bIsShiftDown = (GetAsyncKeyState(VK_SHIFT) & 0x80000000);
	BOOL bIsTabDown = (GetAsyncKeyState(VK_TAB) & 0x80000000) || IsMessageInQueue(NULL, WM_KEYUP, VK_TAB, 0, IMIQ_MATCH_WPARAM);
	COleCurrency cyInvalid;
	cyInvalid.SetStatus(COleCurrency::invalid);
	// (j.gruber 2007-03-27 11:31) - PLID 25352 - check whether they want to popup the category dialog
	BOOL bCheckPopupDiscount = FALSE;
	// (j.gruber 2007-03-29 11:00) - PLID 25351 - used for checking whether they want to change the discount
	BillingItemPtr pItem;

	// (j.jones 2008-11-14 09:25) - PLID 21149 - tracks whether they edited the provider
	BOOL bEditedProvider = FALSE;

	IRowSettingsPtr pRow(lpRow);
	if (pRow == NULL) {
		return;
	}

	if (bCommit) {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {
				pItem = m_billingItems[i];
				switch (nCol) {
					case QUOTE_COLUMN_PROVIDER:
						m_billingItems[i]->Provider = varNewValue;

						// (j.jones 2008-11-14 09:25) - PLID 21149 - track that they edited the provider,
						// don't bother checking to see if it changed, just that they edited it
						bEditedProvider = TRUE;

						// (d.singleton 2012-05-22 11:00) - PLID 50744 if alberta billing need to update the skill code
						if (UseAlbertaHLINK()) {
							long nProviderID = varNewValue.lVal;
							if (nProviderID > -1) {
								_RecordsetPtr prs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", nProviderID);
								CString strSkillCode = AdoFldString(prs, "TaxonomyCode", "");
								if (strSkillCode.GetLength() > 4) {
									strSkillCode = "";
								}
								m_billingItems[i]->Skill = strSkillCode;
							}
						}
						break;

					case QUOTE_COLUMN_CPT_CODE:
						m_billingItems[i]->CPTCode = varNewValue;
						break;
					case QUOTE_COLUMN_CPT_SUB_CODE:
						m_billingItems[i]->CPTSubCode = varNewValue;
						break;
					// (s.tullis 2015-03-24 09:28) - PLID 64973 - update category in billitem list
					case QUOTE_COLUMN_CPT_CATEGORY:
						m_billingItems[i]->CPTCategoryID = VarLong(varNewValue,-1);
						break;
					case QUOTE_COLUMN_MODIFIER1:
					{
						try {
							if (varNewValue.vt == VT_EMPTY)
								break;

							BillingItemPtr billitem = m_billingItems[i];

							m_billingItems[i]->Modifier1 = varNewValue;

							CString Mod1;
							if (varNewValue.vt == VT_BSTR)
								Mod1 = CString(varNewValue.bstrVal);
							else if (varNewValue.vt == VT_I4)
								Mod1.Format("%li", varNewValue.lVal);
							// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
							// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
							//set the multiplier to a default value first
							m_billingItems[i]->Multiplier1 = (double)1.0;
							if (!UseAlbertaHLINK()) {
								_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod1);
								if (!rs->eof) {
									_variant_t var = rs->Fields->Item["Multiplier"]->Value;
									if (var.vt == VT_R8)
										m_billingItems[i]->Multiplier1 = var;
								}
								rs->Close();
							}

							// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
							// the unit cost based on the modifier we just chose
							// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
							// only if we changed the modifier, so it can change back to the std. fee
							if (UseAlbertaHLINK()) {
								UpdateChargePriceWithAlbertaModifiers(billitem, VarString(varOldValue, "") != VarString(varNewValue, ""));
							}

						}NxCatchAll("Error in changing Modifier1");
					}
						break;
					case QUOTE_COLUMN_MODIFIER2:
					{
						try{
							if (varNewValue.vt == VT_EMPTY)
								break;
							m_billingItems[i]->Modifier2 = varNewValue;
							CString Mod2;
							if (varNewValue.vt == VT_BSTR)
								Mod2 = CString(varNewValue.bstrVal);
							else if (varNewValue.vt == VT_I4)
								Mod2.Format("%li", varNewValue.lVal);
							// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
							// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
							//set the multiplier to a default value first
							m_billingItems[i]->Multiplier2 = (double)1.0;
							if (!UseAlbertaHLINK()) {
								_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod2);
								if (!rs->eof) {
									_variant_t var = rs->Fields->Item["Multiplier"]->Value;
									if (var.vt == VT_R8)
										m_billingItems[i]->Multiplier2 = var;
								}
								rs->Close();
							}

							// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
							// the unit cost based on the modifier we just chose
							// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
							// only if we changed the modifier, so it can change back to the std. fee
							if (UseAlbertaHLINK()) {
								UpdateChargePriceWithAlbertaModifiers(m_billingItems[i], VarString(varOldValue, "") != VarString(varNewValue, ""));
							}

						}NxCatchAll("Error in changing Modifier2");
					}
						break;
					case QUOTE_COLUMN_MODIFIER3:
					{
						try{
							if (varNewValue.vt == VT_EMPTY)
								break;
							m_billingItems[i]->Modifier3 = varNewValue;
							CString Mod3;
							if (varNewValue.vt == VT_BSTR)
								Mod3 = CString(varNewValue.bstrVal);
							else if (varNewValue.vt == VT_I4)
								Mod3.Format("%li", varNewValue.lVal);
							// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
							// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
							//set the multiplier to a default value first
							m_billingItems[i]->Multiplier3 = (double)1.0;
							if (!UseAlbertaHLINK()) {
								_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod3);
								if (!rs->eof) {
									_variant_t var = rs->Fields->Item["Multiplier"]->Value;
									if (var.vt == VT_R8)
										m_billingItems[i]->Multiplier3 = var;
								}
								rs->Close();
							}

							// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
							// the unit cost based on the modifier we just chose
							// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
							// only if we changed the modifier, so it can change back to the std. fee
							if (UseAlbertaHLINK()) {
								UpdateChargePriceWithAlbertaModifiers(m_billingItems[i], VarString(varOldValue, "") != VarString(varNewValue, ""));
							}

						}NxCatchAll("Error in changing Modifier3");
					}
						break;
					case QUOTE_COLUMN_MODIFIER4:
					{
						try{
							if (varNewValue.vt == VT_EMPTY)
								break;
							m_billingItems[i]->Modifier4 = varNewValue;
							CString Mod4;
							if (varNewValue.vt == VT_BSTR)
								Mod4 = CString(varNewValue.bstrVal);
							else if (varNewValue.vt == VT_I4)
								Mod4.Format("%li", varNewValue.lVal);
							// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
							// (j.jones 2011-10-11 10:34) - PLID 44941 - if Alberta, don't bother loading multipliers
							//set the multiplier to a default value first
							m_billingItems[i]->Multiplier4 = (double)1.0;
							if (!UseAlbertaHLINK()) {
								_RecordsetPtr rs = CreateParamRecordset("SELECT Multiplier FROM CPTModifierT WHERE Number = {STRING}", Mod4);
								if (!rs->eof) {
									_variant_t var = rs->Fields->Item["Multiplier"]->Value;
									if (var.vt == VT_R8)
										m_billingItems[i]->Multiplier4 = var;
								}
								rs->Close();
							}

							// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
							// the unit cost based on the modifier we just chose
							// (j.jones 2012-01-23 09:13) - PLID 47695 - force the calculation to run
							// only if we changed the modifier, so it can change back to the std. fee
							if (UseAlbertaHLINK()) {
								UpdateChargePriceWithAlbertaModifiers(m_billingItems[i], VarString(varOldValue, "") != VarString(varNewValue, ""));
							}

						}NxCatchAll("Error in changing Modifier4");
					}
						break;

						// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
					case QUOTE_COLUMN_CALLS: {

						BillingItemPtr billitem = m_billingItems[i];

						billitem->Calls = varNewValue;

						//if Alberta, we need to change the unit cost based on the calls
						// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
						// price unless there are modifiers
						if (UseAlbertaHLINK()) {
							UpdateChargePriceWithAlbertaModifiers(billitem, FALSE);
						}
						break;
					}
					case QUOTE_COLUMN_SKILL:
						m_billingItems[i]->Skill = varNewValue;
						break;
					case QUOTE_COLUMN_DESCRIPTION:
						m_billingItems[i]->Description = varNewValue;
						break;
					case QUOTE_COLUMN_QUANTITY: {
						m_billingItems[i]->Quantity = varNewValue;

						double dblQuantity = VarDouble(varNewValue, 1.0);
						double dblOriginalPackageQuantity = VarDouble(m_billingItems[i]->OriginalPackageQtyRemaining, 1.0);

						long LocationID = -1;

						if (m_LocationCombo->GetCurSel() == -1)
							LocationID = GetCurrentLocationID();
						else
							LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

						//if a product
						if (VarLong(m_billingItems[i]->ItemType) == ITEM_TYPE_PRODUCT) {
							//check quantity in stock

							long nServiceID = VarLong(m_billingItems[i]->ServiceID);

							// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations,
							InvUtils::DoIHaveEnough(
								nServiceID,
								LocationID,
								-GetUnsavedQuantityCount(nServiceID),
								-GetUnsavedAllocationQuantityCount(nServiceID),
								m_EntryType == 2);
						}

						if ((GetIsMultiUsePackage() && (GetBillID() == -1 || (!m_bQuoteHasBeenBilled && m_boInitialized)))
							|| !GetIsMultiUsePackage()) {
							//if a multi-use package, only update if new/unbilled, otherwise update at all times (it won't be used anyways)
							m_billingItems[i]->PackageQtyRemaining = varNewValue;
							pRow->PutValue(QUOTE_COLUMN_PACKAGE_QTY_REM, varNewValue);

							// (j.jones 2009-12-22 16:53) - PLID 32587 - also update the original qty. rem. column
							m_billingItems[i]->OriginalPackageQtyRemaining = varNewValue;
							pRow->PutValue(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, varNewValue);
						}
						// (j.jones 2009-12-22 16:53) - PLID 32587 - also update the original qty. rem. column
						// if the total quantity has become lower than the original quantity
						else if (dblQuantity < dblOriginalPackageQuantity) {
							dblOriginalPackageQuantity = dblQuantity;
							// (j.jones 2009-12-22 16:53) - PLID 32587 - also update the original qty. rem. column
							m_billingItems[i]->OriginalPackageQtyRemaining = dblOriginalPackageQuantity;
							pRow->PutValue(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, dblOriginalPackageQuantity);
						}

					}
						break;
					case QUOTE_COLUMN_PACKAGE_QTY_REM: {
						m_billingItems[i]->PackageQtyRemaining = varNewValue;

						// (j.jones 2009-12-23 12:57) - PLID 32587 - if new/unbilled, set the original amount to match this amount
						if (GetBillID() == -1 || (!m_bQuoteHasBeenBilled && m_boInitialized)) {
							m_billingItems[i]->OriginalPackageQtyRemaining = varNewValue;
							pRow->PutValue(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, varNewValue);

							//if this does not match the total, show the initial value fields
							if (m_billingItems[i]->Quantity != varNewValue) {
								m_checkPackageShowInitialValues.SetCheck(TRUE);
								OnPackageShowInitialValues();
							}
						}
					}
						break;
						// (j.jones 2009-12-22 16:53) - PLID 32587 - added the original qty. rem. column
					case QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM: {
						m_billingItems[i]->OriginalPackageQtyRemaining = varNewValue;

						//if this does not match the total, show the initial value fields
						if (m_billingItems[i]->Quantity != varNewValue) {
							m_checkPackageShowInitialValues.SetCheck(TRUE);
							OnPackageShowInitialValues();
						}
					}
						break;
					case QUOTE_COLUMN_UNIT_COST:
						m_billingItems[i]->UnitCost = varNewValue;
						break;
					case QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE:
						m_billingItems[i]->OthrUnitCost = varNewValue;
						break;
						// (j.gruber 2009-03-05 17:31) - PLID 33351 - don't need this anymore
						/*case QUOTE_COLUMN_PERCENT_OFF:
							{
							// (j.gruber 2007-03-27 11:27) - PLID 25352 - Get the current amount
							_variant_t varPercentOff = m_billingItems[i]->PercentOff;
							if (varPercentOff.vt == VT_EMPTY || varPercentOff.vt == VT_NULL) {
							varPercentOff.lVal = (long)0;
							}

							m_billingItems[i]->PercentOff = varNewValue;


							// (j.gruber 2007-03-27 11:27) - PLID 25352 - see if they want to popup the discount category dialog
							//just set a boolean here because we want to wait to do this until after the recalculation
							if (varPercentOff != varNewValue) {

							//see if this item already has a discount category on it
							_variant_t varHasCategory = m_billingItems[i]->HasDiscountCategory;
							if (varHasCategory.vt != VT_NULL && varHasCategory.vt != VT_EMPTY) {
							if (!varHasCategory.boolVal) {
							bCheckPopupDiscount = TRUE;
							}
							}
							else {
							bCheckPopupDiscount = TRUE;
							}

							}
							}
							break;
							case QUOTE_COLUMN_DISCOUNT:
							{
							// (j.gruber 2007-03-27 11:27) - PLID 25352 - Get the current amount
							_variant_t varDiscount = m_billingItems[i]->Discount;
							if (varDiscount.vt == VT_EMPTY || varDiscount.vt == VT_NULL) {
							varDiscount = _variant_t(COleCurrency(0,0));
							}

							m_billingItems[i]->Discount = varNewValue;

							// (j.gruber 2007-03-27 11:27) - PLID 25352 - see if they want to popup the discount category dialog
							//just set a boolean here because we want to wait to do this until after the recalculation
							if (varDiscount != varNewValue) {
							//see if this item already has a discount category on it
							_variant_t varHasCategory = m_billingItems[i]->HasDiscountCategory;
							if (varHasCategory.vt != VT_NULL && varHasCategory.vt != VT_EMPTY) {
							if (!varHasCategory.boolVal) {
							bCheckPopupDiscount = TRUE;
							}
							}
							else {
							bCheckPopupDiscount = TRUE;
							}
							}
							}

							break;*/
					case QUOTE_COLUMN_LINE_TOTAL:
						m_billingItems[i]->LineTotal = varNewValue;
						break;
					case QUOTE_COLUMN_TAX_RATE_1:
						m_billingItems[i]->TaxRate1 = varNewValue;
						break;
					case QUOTE_COLUMN_TAX_RATE_2:
						m_billingItems[i]->TaxRate2 = varNewValue;
						break;
						// (j.jones 2007-07-06 13:46) - PLID 26098 - supported Quote item type
					case QUOTE_COLUMN_ITEM_TYPE:
						m_billingItems[i]->ItemType = varNewValue;
						break;

						// (j.gruber 2009-10-19 16:14) - PLID 35947 - allowable
					case QUOTE_COLUMN_ALLOWABLE:
						m_billingItems[i]->UnitAllowable = varNewValue;
						break;
				}
			}
		}

		// Calculate the line total
		m_varBoundItem = pRow->GetValue(COLUMN_LINE_ID);
		if (m_varBoundItem.vt == VT_EMPTY)
			return;

		// CAH
		COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
		if (varChargeID.vt == VT_EMPTY)
			return;
		if (varChargeID.lVal != -2)
		{
			AddToModifiedList(varChargeID.lVal);
		}

		// (j.jones 2008-11-14 09:25) - PLID 21149 - if they edited the provider, prompt to apply the new provider to each charge		
		// (j.gruber 2009-10-19 10:50) - PLID 35995 - fix this so that the mutifee still gets checked
		if (bEditedProvider) {

			if (pRow) {

				if (m_pList->GetRowCount() > 1) {

					if (GetRemotePropertyInt("ChangeChargeProviderPrompt", 1, 0, GetCurrentUserName(), true) == 1
						&& HasChargesWithDifferentProvider(pItem->Provider) // don't warn if there are no charges with a different provider
						&& MsgBox(MB_YESNO, "You are editing the provider of a charge in the current quote. "
						"Would you like to apply this same provider to all other charges in the quote?") == IDYES) {

						//first we need to update the current row
						UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);

						//like CheckApplyDiscountThroughout(), this needs to be called before CalculateLineTotal
						UpdateAllChargesWithNewProvider(pItem->Provider);
					}
					else {

						//we still need to update this one						
						UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);
					}
				}
				else if (m_pList->GetRowCount() == 1) {
					UpdateOneChargeWithNewProvider(pItem, pRow, pItem->Provider);
				}
			}
		}

		// (j.gruber 2007-03-27 11:32) - PLID 25352 - check if they want to popup the dialog
		// (j.jones 2008-04-17 09:59) - PLID 29693 - This needs to be BEFORE CalculateLineTotal,
		// because the row index may change during a sort, and ShowDiscountCategoryList() needs
		// the row index. CheckApplyDiscountThroughout() will call CalculateLineTotal() before
		// it changes the bound item now.
		// (j.gruber 2009-03-06 13:01) - PLID 33351 - take out discounts
		/*if (bCheckPopupDiscount) {
			long nSelection = GetRemotePropertyInt("BillShowDiscountCatScreenWhenAddDiscount", 2, 0, "<None>", true);
			if (nSelection == 1) {
			//always show it
			ShowDiscountCategoryList(nRow, FALSE);
			}
			else if (nSelection == 2) {
			//prompt
			if (MsgBox(MB_YESNO, "Would you like to set a discount category?") == IDYES) {
			if (IDOK != ShowDiscountCategoryList(nRow, FALSE) ) {
			//they cancelled out of the dialog, but we still need to ask them about the other preference
			CheckApplyDiscountThroughout(pItem, FALSE);
			}
			else {
			//it was handled already
			}
			}
			else {
			CheckApplyDiscountThroughout(pItem, FALSE);
			}
			}
			else {
			// (j.gruber 2007-03-29 10:55) - PLID 25351 -  check to see if they want to apply this discount to the rest of the charges
			CheckApplyDiscountThroughout(pItem, FALSE);
			}
			}*/

		//***after this line, you should not do anything that references the current line ID
		//or pItem, because they may no longer be valid if the list is sorted***//
		// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
		CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

		//if we warn about packages with tax, so it after we change the totals but before we edit the next row
		if (GetIsAnyPackage() && (nCol == QUOTE_COLUMN_TAX_RATE_1 || nCol == QUOTE_COLUMN_TAX_RATE_2) &&
			varNewValue.vt == VT_R8 && VarDouble(varNewValue) > 0.0) {

			WarnTaxedPackage();
		}

		if (!bIsTabDown) {
			GetParent()->SetFocus();
			if (m_EntryType == 1)
				GetDlgItem(IDC_COMBO_CPT)->SetFocus();
			else
				GetDlgItem(IDC_COMBO_SRGY)->SetFocus();
		}
	} // if (bCommit)

	// (c.haag 2007-03-14 14:47) - PLID 23156 - Regardless of whether we committed or not, we now support
	// tabbing between rows
	// (j.jones 2008-11-17 10:38) - PLID 29694 - If the sorting changed, nRow is no longer the same charge we
	// initially edited. The only way we can find the new row is look at the new LineID from the BillingItem we
	// edited, find the matching datalist row with the same LineID, and tab through that row instead of nRow.
	IRowSettingsPtr pRowIndex = NULL;
	if (pItem) {
		pRowIndex = m_QuoteList->FindByColumn(COLUMN_LINE_ID, VarLong(pItem->LineID), m_QuoteList->GetFirstRow(), FALSE);
	}

	if (pRowIndex == NULL) {
		//if nRowIndex wasn't found, then we probably didn't commit the change,
		//so continue on with the nRow we started editing
		pRowIndex = pRow;
	}

	if (pRowIndex != NULL && bIsTabDown) {
		//Find the next editable column, start editing it.
		int nNextCol = -1;
		nNextCol = GetNextQuoteColumn(nCol, nCol, bIsShiftDown);
		if (nNextCol != -1) {
			// (c.haag 2007-03-14 14:32) - PLID 23156 - If the shift key is up and the next column
			// is behind the current column, then skip to the next row
			if (!bIsShiftDown && nNextCol < nCol) {
				// If we're not on the last row, go to the next row
				IRowSettingsPtr pNextRowIndex = pRowIndex->GetNextRow();
				if (pNextRowIndex) {
					m_QuoteList->PutCurSel(pNextRowIndex);
					m_QuoteList->StartEditing(pNextRowIndex, nNextCol);
				}
				// If we're on the last row, go to the next dialog control
				else {
					CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_QUOTE_LIST));
					if (pWnd) {
						m_QuoteList->StopEditing(VARIANT_TRUE);
						GetParent()->SetFocus();
						pWnd->SetFocus();
					}
				}
			}
			// (c.haag 2007-03-14 14:33) - PLID 23156 - If the shift key is down and the next c olumn
			// is after the current oclumn, then skip to the previous row
			else if (bIsShiftDown && nNextCol > nCol) {
				// If we are on the first row, go to the previous dialog control
				IRowSettingsPtr pNextRowIndex = pRowIndex->GetPreviousRow();
				if (pNextRowIndex == NULL) {
					CWnd* pWnd = GetNextDlgTabItem(GetDlgItem(IDC_QUOTE_LIST), TRUE);
					if (pWnd) {
						m_QuoteList->StopEditing(VARIANT_TRUE);
						GetParent()->SetFocus();
						pWnd->SetFocus();
					}
				}
				// If we're not on the first row, then go up one row
				else {
					m_QuoteList->PutCurSel(pNextRowIndex);
					m_QuoteList->StartEditing(pNextRowIndex, nNextCol);
				}
			}
			else {
				m_QuoteList->PutCurSel(pRowIndex);
				m_QuoteList->StartEditing(pRowIndex, nNextCol);
			}
		}
	}
}

BOOL CBillingDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
	try {
		switch (wParam) {
			case ID_DELCHARGE:
				if (IDYES == MessageBox("Are you sure you wish to delete this charge?", "NexTech", MB_YESNO)) {

					// (j.jones 2008-05-27 17:06) - PLID 27982 - CheckWarnDeletingChargedProductItems will potentially
					// warn a second time, if there are existing saved product items linked to the charge
					// (j.jones 2008-06-09 17:20) - PLID 28392 - CheckWarnAlteringReturnedProducts will warn yet again
					// if there are products returned from this charge
					IRowSettingsPtr pCurSel = m_pList->GetCurSel();
					if (m_EntryType == 1) {
						long nChargeID = VarLong(pCurSel->GetValue(COLUMN_CHARGE_ID));
						long nItemType = VarLong(pCurSel->GetValue(COLUMN_ITEM_TYPE));

						// (j.jones 2011-01-25 14:58) - PLID 42156 - check permissions
						if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptDelete)) {
							break;
						}
						//TES 7/25/2014 - PLID 63048 - Don't allow them to delete chargeback charges
						if (DoesChargeHaveChargeback(CSqlFragment("ChargesT.ID = {INT}", nChargeID))) {
							MsgBox("This charge is associated with a Chargeback, and cannot be deleted. In order to delete this charge, you must first expand the bill "
								"on the Billing tab, right-click on the associated Chargeback, and select 'Undo Chargeback.'");
							break;
						}

						// (j.jones 2013-07-23 10:03) - PLID 46493 - these functions have a void flag now, always false here
						// (j.jones 2015-11-04 09:36) - PLID 67459 - flipped the return product warning and product item warning
						if (nItemType != ITEM_TYPE_PRODUCT ||
							(CheckWarnAlteringReturnedProducts(false, false, nChargeID)
								&& CheckWarnDeletingChargedProductItems(false, false, nChargeID))) {
							DeleteChargeFromList(VarLong(pCurSel->GetValue(COLUMN_LINE_ID)));
						}
					}
					else {
						DeleteChargeFromList(VarLong(pCurSel->GetValue(COLUMN_LINE_ID)));
					}
				}
				break;

				// (r.gonet 07/07/2014) - PLID 62569 - Handle when the user marks a charge on hold or removes the hold on a charge
			case ID_MARK_CHARGE_ON_HOLD:
				// Fall through
			case ID_REMOVE_CHARGE_HOLD: {
				if (m_EntryType == 1) {
					IRowSettingsPtr pRow = m_List->GetCurSel();
					if (!pRow) {
						// (r.gonet 07/07/2014) - PLID 62569 - How did we ever get here?
						break;
					}

					long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
					long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID));

					if (IsOriginalOrVoidCharge(nChargeID)) {
				MessageBox("Original and voided charges cannot have their On Hold status changed directly. "
					"To change the On Hold status of an original or voided charge, you must change the On Hold "
					"status of the corrected charge.", "Error", MB_ICONERROR | MB_OK);
				break;
			} else {
				// (r.gonet 07/07/2014) - PLID 62569 - Can be edited.
			}

			// (r.gonet 07/07/2014) - PLID 62569 - Check the permissions to edit saved charges. This is allowed even under financial closes.
			if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite, FALSE, NULL, TRUE)) {
				break;
			} else {
				// (r.gonet 07/07/2014) - PLID 62569 - They don't have permission to change the bill, so don't allow
				// putting charges on hold or removing the hold either.
			}

			if (wParam == ID_MARK_CHARGE_ON_HOLD) {
				CascadeOnHold(nLineID, TRUE);
			} else { // ID_REMOVE_CHARGE_HOLD
				CascadeOnHold(nLineID, FALSE);
			}
		} else {
			// (r.gonet 07/07/2014) - PLID 62569 - Charges on quotes don't support on hold.
		}
			}
				break;

			case ID_EDIT_TEST_CODES: {
				// (r.gonet 08/05/2014) - PLID 63098 - Edit the charge associated lab test codes
				// by bringing up a dialog that allows the user to select multiple test codes and
				// add/edit/delete test codes as well.
				IRowSettingsPtr pRow = m_List->GetCurSel();
				long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID), -1);
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -1);
				for each(BillingItemPtr pBillingItem in m_billingItems)
				{
					if (VarLong(pBillingItem->LineID) == nLineID) {
						CEditBillTestCodesDlg dlg(this, pBillingItem->TestCodeList);
						if (IDOK == dlg.DoModal()) {
							dlg.GetSelectedTestCodeIDs(pBillingItem->TestCodeList);
							if (nChargeID >= 0) {
								AddToModifiedList(nChargeID);
							}
						}

						break;
					}
				}
			}
				break;

			case ID_EDITPRODITEMS: {

				for (int i = 0; i < (int)m_billingItems.size(); i++) {
					IRowSettingsPtr pRow = m_List->GetCurSel();
					if (pRow != NULL &&
						m_billingItems[i]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {

						long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
						long nItemType = VarLong(pRow->GetValue(COLUMN_ITEM_TYPE));

						// (j.jones 2011-01-25 14:58) - PLID 42156 - check permissions
						if (m_EntryType == 1) {
							long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
							if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
								break;
							}
						}

						// (j.jones 2008-06-10 11:00) - PLID 28392 - CheckWarnAlteringReturnedProducts will warn
						// if there are products returned from this charge
						// (j.jones 2013-07-23 10:03) - PLID 46493 - this function has a void flag now, always false here
						if (nItemType == ITEM_TYPE_PRODUCT
							&& nChargeID != -2
							&& !CheckWarnAlteringReturnedProducts(false, false, nChargeID, true)) {
							break;
						}

						double OldQuantity = m_billingItems[i]->Quantity;
						double Quantity = OldQuantity;

						if (ChangeProductItems(Quantity) && Quantity != OldQuantity) {

							long LocationID = -1;

							if (m_LocationCombo->GetCurSel() == -1)
								LocationID = GetCurrentLocationID();
							else
								LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

							long nServiceID = VarLong(m_billingItems[i]->ServiceID);

							//check quantity in stock
							// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations,

							double dblAllocationOffset = -GetUnsavedAllocationQuantityCount(nServiceID);
							//is this item an allocation? if so, update our allocation offset amount
							if (VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1) > 0) {
								dblAllocationOffset += OldQuantity;
								dblAllocationOffset -= Quantity;
							}

							InvUtils::DoIHaveEnough(
								nServiceID,
								LocationID,
								-GetUnsavedQuantityCount(nServiceID) + OldQuantity - Quantity,
								dblAllocationOffset, m_EntryType == 2);

							//if they changed the quantity, we must save appropriately
							m_billingItems[i]->Quantity = Quantity;

							if ((GetIsMultiUsePackage() && (GetBillID() == -1 || (!m_bQuoteHasBeenBilled && m_boInitialized)))
								|| !GetIsMultiUsePackage()) {
								//if a multi-use package, only update if new/unbilled, otherwise update at all times (it won't be used anyways)
								m_billingItems[i]->PackageQtyRemaining = Quantity;

								// (j.jones 2009-12-22 16:53) - PLID 32587 - also update the original qty. rem. column
								m_billingItems[i]->OriginalPackageQtyRemaining = Quantity;

								//if this does not match the total, show the initial value fields
								if (GetIsMultiUsePackage() && VarDouble(m_billingItems[i]->Quantity) != Quantity) {
									m_checkPackageShowInitialValues.SetCheck(TRUE);
									OnPackageShowInitialValues();
								}
							}

							m_varBoundItem = pRow->GetValue(COLUMN_LINE_ID);
							if (m_varBoundItem.vt == VT_EMPTY)
								break;

							if (nChargeID != -2) {
								AddToModifiedList(nChargeID);
							}

							COleCurrency cyInvalid;
							cyInvalid.SetStatus(COleCurrency::invalid);

							// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
							CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

							if (GetAsyncKeyState(VK_TAB) == 0) {
								GetParent()->SetFocus();
								GetDlgItem(IDC_COMBO_BILL_TO)->SetFocus();
							}
						}
						break;
					}
				}
			}
				break;

			case ID_CHANGE_ANESTH_TIME: {
				//if they clicked on this, we already know they clicked on an anesthesia code

				IRowSettingsPtr pCurSel = m_pList->GetCurSel();

				long nServiceID = VarLong(pCurSel->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

				// (j.jones 2011-01-25 14:58) - PLID 42156 - they are allowed to change the times,
				// but if the charge is locked via historical permissions, the prices won't change

				if (m_PlaceOfServiceCombo->CurSel == -1)
					m_PlaceOfServiceCombo->CurSel = 0;
				long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

				long nAnesthTimePromptType = 1;

				// (j.jones 2007-10-15 15:33) - PLID 27757 - changed to reflect new structure
				_RecordsetPtr rs = CreateParamRecordset("SELECT AnesthTimePromptType FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT}", nServiceID, nPlaceOfServiceID);
				if (!rs->eof) {
					nAnesthTimePromptType = AdoFldLong(rs, "AnesthTimePromptType", 1);
				}
				rs->Close();

				long nCurAnesthMinutes = 0;
				CString strStartTime = "";
				CString strEndTime = "";

				//prompt for minutes
				if (nAnesthTimePromptType == 1) {
					//prompt for begin and end times

					BOOL bDone = FALSE;
					while (!bDone) {
						CAnesthesiaTimePromptDlg dlg(this);
						dlg.m_nServiceID = nServiceID;
						if (dlg.DoModal() == IDCANCEL) {
							if (IDYES == MessageBox("You must enter anesthesia start and end times in order to change this anesthesia charge.\n"
								"If you cancel, the charge will not be changed.\n\n"
								"Do you still wish to cancel changing this charge?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else bDone = TRUE;

						nCurAnesthMinutes = dlg.m_nMinutes;
						strStartTime = dlg.m_strStartTime;
						strEndTime = dlg.m_strEndTime;
					}
				}
				else if (nAnesthTimePromptType == 2) {

					//prompt for anesthesia minutes

					BOOL bDone = FALSE;

					CString strPrompt = "Anesthesia Minutes";

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description FROM ServiceT "
						"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID WHERE CPTCodeT.ID = {INT}", nServiceID);
					if (!rs->eof) {
						CString strDesc = AdoFldString(rs, "Description", "");
						strPrompt.Format("Enter the minutes of anesthesia for code:\r\n%s", strDesc);
					}
					rs->Close();

					while (!bDone) {
						CString strMinutes = "0";

						if (InputBox(this, strPrompt, strMinutes, "", false, false, "Cancel", TRUE) != IDOK) {
							if (IDYES == MessageBox("You must enter the anesthesia minutes in order to change this anesthesia charge.\n"
								"If you cancel, the charge will not be changed.\n\n"
								"Do you still wish to cancel changing this charge?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else {

							if (strMinutes == "0") {
								AfxMessageBox("You must enter an amount between 1 and 1440 for the anesthesia minutes.");
								continue;
							}

							if (strMinutes.GetLength() > 6) {
								AfxMessageBox("You have entered an invalid amount for the anesthesia minutes.");
								continue;
							}

							if (atoi(strMinutes) > 1440) {
								AfxMessageBox("You may not enter more than 1440 minutes.");
								continue;
							}

							bDone = TRUE;
						}

						nCurAnesthMinutes = atoi(strMinutes);
						strStartTime = "";
						strEndTime = "";
					}
				}

				SetAnesthStartTime(strStartTime);
				SetAnesthEndTime(strEndTime);
				SetAnesthMinutes(nCurAnesthMinutes, TRUE);
			}
				break;

			case ID_CHANGE_FACILITY_TIME: {
				//if they clicked on this, we already know they clicked on a facility code

				IRowSettingsPtr pCurSel = m_pList->GetCurSel();

				long nServiceID = VarLong(pCurSel->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

				// (j.jones 2011-01-25 14:58) - PLID 42156 - they are allowed to change the times,
				// but if the charge is locked via historical permissions, the prices won't change

				if (m_PlaceOfServiceCombo->CurSel == -1)
					m_PlaceOfServiceCombo->CurSel = 0;
				long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

				long nFacilityTimePromptType = 1;

				// (j.jones 2007-10-15 15:33) - PLID 27757 - changed to reflect new structure
				_RecordsetPtr rs = CreateParamRecordset("SELECT FacilityTimePromptType FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT}", nServiceID, nPlaceOfServiceID);
				if (!rs->eof) {
					nFacilityTimePromptType = AdoFldLong(rs, "FacilityTimePromptType", 1);
				}
				rs->Close();

				long nCurFacilityMinutes = 0;
				CString strStartTime = "";
				CString strEndTime = "";

				//prompt for minutes

				if (nFacilityTimePromptType == 1) {
					//prompt for begin and end times

					BOOL bDone = FALSE;
					while (!bDone) {
						CAnesthesiaTimePromptDlg dlg(this);
						dlg.m_nServiceID = nServiceID;
						// (j.jones 2010-11-22 17:23) - PLID 39602 - this is now an enum
						dlg.m_eTimePromptType = tptFacilityFee;
						if (dlg.DoModal() == IDCANCEL) {
							if (IDYES == MessageBox("You must enter facility start and end times in order to change this facility charge.\n"
								"If you cancel, the charge will not be changed.\n\n"
								"Do you still wish to cancel changing this charge?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else bDone = TRUE;

						nCurFacilityMinutes = dlg.m_nMinutes;
						strStartTime = dlg.m_strStartTime;
						strEndTime = dlg.m_strEndTime;
					}
				}
				else if (nFacilityTimePromptType == 2) {
					//prompt for minutes

					BOOL bDone = FALSE;

					CString strPrompt = "Facility Minutes";

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description FROM ServiceT "
						"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID WHERE CPTCodeT.ID = {INT}", nServiceID);
					if (!rs->eof) {
						CString strDesc = AdoFldString(rs, "Description", "");
						strPrompt.Format("Enter the facility fee minutes for code:\r\n%s", strDesc);
					}
					rs->Close();

					while (!bDone) {
						CString strMinutes = "0";

						if (InputBox(this, strPrompt, strMinutes, "", false, false, "Cancel", TRUE) != IDOK) {
							if (IDYES == MessageBox("You must enter the facility fee minutes in order to change this facility charge.\n"
								"If you cancel, the charge will not be changed.\n\n"
								"Do you still wish to cancel changing this charge?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else {

							if (strMinutes == "0") {
								AfxMessageBox("You must enter an amount between 1 and 1440 for the facility minutes.");
								continue;
							}

							if (strMinutes.GetLength() > 6) {
								AfxMessageBox("You have entered an invalid amount for the facility minutes.");
								continue;
							}

							if (atoi(strMinutes) > 1440) {
								AfxMessageBox("You may not enter more than 1440 minutes.");
								continue;
							}

							bDone = TRUE;
						}

						nCurFacilityMinutes = atoi(strMinutes);
						strStartTime = "";
						strEndTime = "";
					}
				}

				SetFacilityStartTime(strStartTime);
				SetFacilityEndTime(strEndTime);
				SetFacilityMinutes(nCurFacilityMinutes, TRUE);
			}
				break;

				// (j.jones 2011-11-01 12:44) - PLID 41558 - added ability to change assisting time
			case ID_CHANGE_ASSISTING_TIME: {

				//if they clicked on this, we already know they clicked on an assisting code

				IRowSettingsPtr pCurSel = m_pList->GetCurSel();

				long nServiceID = VarLong(pCurSel->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

				//they are allowed to change the times,  but if the charge is locked via historical permissions, the prices won't change

				long nTimePrompt = GetRemotePropertyInt("OHIPAssistingCode_TimePrompt", 0, 0, "<None>", true);
				//0 - times, 1 - minutes

				CString strStartTime, strEndTime;
				long nMinutes = 0;

				//prompt for the time spent
				if (nTimePrompt == 0) {
					//prompt for begin and end times

					BOOL bDone = FALSE;
					while (!bDone) {
						CAnesthesiaTimePromptDlg dlg(this);
						dlg.m_eTimePromptType = tptAssistingCode;
						dlg.m_nServiceID = nServiceID;
						if (dlg.DoModal() == IDCANCEL) {
							if (IDYES == MessageBox("You must enter assisting start and end times in order to change this assisting code charge.", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else bDone = TRUE;

						nMinutes = dlg.m_nMinutes;
						strStartTime = dlg.m_strStartTime;
						strEndTime = dlg.m_strEndTime;
					}
				}
				else if (nTimePrompt == 1) {

					//prompt for minutes

					BOOL bDone = FALSE;

					CString strPrompt = "Assisting Minutes";

					_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description FROM ServiceT "
						"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID WHERE CPTCodeT.ID = {INT}", nServiceID);
					if (!rs->eof) {
						CString strDesc = AdoFldString(rs, "Description", "");
						strPrompt.Format("Enter the assisting minutes for code:\r\n%s", strDesc);
					}
					rs->Close();

					while (!bDone) {
						CString strMinutes = "0";

						if (InputBox(this, strPrompt, strMinutes, "", false, false, "Cancel", TRUE) != IDOK) {
							if (IDYES == MessageBox("You must enter the assisting minutes in order to change this assisting code charge.", "Practice", MB_ICONQUESTION | MB_YESNO)) {
								return FALSE;
							}
						}
						else {

							if (strMinutes == "0") {
								AfxMessageBox("You must enter an amount between 1 and 1440 for the assisting minutes.");
								continue;
							}

							if (strMinutes.GetLength() > 6) {
								AfxMessageBox("You have entered an invalid amount for the assisting minutes.");
								continue;
							}

							if (atoi(strMinutes) > 1440) {
								AfxMessageBox("You may not enter more than 1440 minutes.");
								continue;
							}

							bDone = TRUE;
						}

						nMinutes = atoi(strMinutes);
					}
				}

				SetAssistingStartTime(strStartTime);
				SetAssistingEndTime(strEndTime);
				SetAssistingMinutes(nMinutes, TRUE);
				break;
			}

				// (s.dhole 2011-05-24 16:37) - PLID 44953 Call BillChangeServiceCodeDlg Dialog
			case ID_CHANGE_SERVICE_CODE:
			{
				if (!CheckCurrentUserPermissions(bioBillChangeServiceCode, sptWrite)) {
					return FALSE;
				}

				IRowSettingsPtr pCurSel = m_List->GetCurSel();
				if (!pCurSel) {
					return FALSE;
				}

				long nServiceID;
				//  setup line
				m_varBoundItem = pCurSel->GetValue(COLUMN_LINE_ID);
				if (m_varBoundItem.vt == VT_EMPTY) {
					return FALSE;
				}
				_variant_t var = pCurSel->GetValue(COLUMN_SERVICE_ID);
				if (var.vt != VT_I4) {
					return FALSE;
				}
				nServiceID = VarLong(var);

				var = pCurSel->GetValue(COLUMN_CHARGE_ID);

				long nChargeID = (var.vt != VT_I4) ? -1 : VarLong(var);

				// (a.walling 2014-04-22 14:46) - PLID 61847 - Billing - 'Edit Service Code' menu item allows modification of charges and costs in locked dates before a financial close.
				if (nChargeID > 0 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
					return FALSE;
				}


				long nRowLineID = VarLong(pCurSel->GetValue(COLUMN_LINE_ID));

				long nRowAry = -1;
				for (int i = 0; i < (int)m_billingItems.size(); i++) {
					long nAryLineID = VarLong(m_billingItems[i]->LineID);
					if (nAryLineID == nRowLineID) {
						nRowAry = i;
						break;
					}
				}
				if (nRowAry == -1) {
					ASSERT(FALSE);
					return FALSE;
				}
				BillingItemPtr pItem = m_billingItems[nRowAry];
				if (!pItem) {
					ASSERT(FALSE);
					return FALSE;
				}

				// (a.walling 2014-04-22 14:46) - PLID 61847 - Billing - Additionally check that this is not involved in corrections
				if (VarBool(pItem->IsOriginalCharge, FALSE)) {
					MessageBox("This charge has been corrected, and is no longer editable.", "Practice", MB_ICONINFORMATION | MB_OK);
					return FALSE;
				}
				else if (VarBool(pItem->IsVoidingCharge, FALSE)) {
					MessageBox("This charge is a voiding line item for a corrected charge, and is not editable.", "Practice", MB_ICONINFORMATION | MB_OK);
					return FALSE;
				}

				CBillChangeServiceCodeDlg dlg(this);
				dlg.m_nServiceCodeID = nServiceID;
				if (IDOK != dlg.DoModal()) {
					return FALSE;
				}

				if (dlg.m_nServiceCodeID == nServiceID) {
					return FALSE;
				}

				ChangeServiceCode(pItem, dlg.m_nServiceCodeID);
			}
				break;
		}
	}NxCatchAll(__FUNCTION__);
	return CNxDialog::OnCommand(wParam, lParam);
}
// (s.dhole 2011-05-24 16:37) - PLID 44953
void CBillingDlg::ChangeServiceCode(BillingItemPtr pItem, long nServiceCodeID)
{
	int nRow = FindCPTRowInComboByServiceID(nServiceCodeID, FALSE);
	if (nRow < 0) {
		//unfound
		MsgBox("This item was not able to be added to the bill.  Ensure the item still exists and is not inactivated or deleted.");
		return;
	}

	if (m_EntryType == 1) {
		// (j.jones 2012-04-12 10:00) - PLID 49609 - Add the default claim note, if it exists.
		// Add a new note even if a note already exists.
		CString strClaimNote = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_CLAIM_NOTE), "");
		strClaimNote.TrimLeft(); strClaimNote.TrimRight();
		if (strClaimNote.GetLength() > 0) {
			AddNewUnsavedChargeNote(pItem, strClaimNote, TRUE);
		}

		// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
		CString strNDCCode = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_NDCDEFCODE), "");
		double dblNDCQty = VarDouble(m_CPTCombo->GetValue(nRow, CPT_COLUMN_NDCDEFQTY), 0.0);
		COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(nRow, CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
		CString strNDCUnitType = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_NDCDEFUNITTYPE), "");

		pItem->NDCCode = strNDCCode;
		pItem->DrugUnitPrice = cyNDCUnitPrice;
		pItem->DrugUnitType = strNDCUnitType;
		pItem->DrugUnitQuantity = dblNDCQty;
	}

	//we have to get the patient's primary insurance company
	// (d.lange 2015-12-01 12:10) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
	long nInsuranceCoID = GetCurrentBillToMostPriInsCoIDForCategory();

	//don't do any of this if not a CPT code
	// (j.jones 2013-04-12 14:30) - PLID 56250 - allowables are allowed on products now,
	// though you should not be able to get to this function on products
	if (nInsuranceCoID != -1 &&
		(VarLong(pItem->ItemType) == ITEM_TYPE_CPT || VarLong(pItem->ItemType) == ITEM_TYPE_PRODUCT)) {

		BOOL bExists, bWarn, bHasAllowable;
		COleCurrency cyAllowable;
		CString strMsg;

		long nLocationID;
		if (m_LocationCombo->GetCurSel() == -1)
			nLocationID = GetCurrentLocationID();
		else
			nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

		long nPOSID = -1;
		if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
			nPOSID = GetCurrentLocationID();
		}
		else {
			nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
		}
		COleCurrency cyUnitCost;

		// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
		cyUnitCost = GetMultiFee(nServiceCodeID, VarLong(pItem->Provider, -1), nInsuranceCoID, nLocationID, nPOSID, VarDateTime(pItem->Date), bExists, bWarn, strMsg, bHasAllowable, cyAllowable);
		if ((bExists && bWarn && IDYES == MessageBox(strMsg, "Practice", MB_YESNO)) ||
			(bExists&& !bWarn)) {
			//multifee exists, and they DO want to keep it
			pItem->UnitCost = _variant_t(cyUnitCost);
		}
		else {
			pItem->UnitCost = _variant_t(m_CPTCombo->GetValue(nRow, CPT_COLUMN_PRICE));
		}

		if (bHasAllowable) {
			pItem->HasAllowable = g_cvarTrue;
			pItem->UnitAllowable = _variant_t(cyAllowable);

			// (j.jones 2010-09-02 09:50) - PLID 40330 - the TotalAllowable takes quantity and modifiers into account
			double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
			dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

			if (pItem->Quantity.vt == VT_R8) {
				dblQuantity = VarDouble(pItem->Quantity, 1.0);
			}
			if (pItem->Multiplier1.vt == VT_R8) {
				dblMultiplier1 = VarDouble(pItem->Multiplier1, 1.0);
			}
			if (pItem->Multiplier2.vt == VT_R8) {
				dblMultiplier2 = VarDouble(pItem->Multiplier2, 1.0);
			}
			if (pItem->Multiplier3.vt == VT_R8) {
				dblMultiplier3 = VarDouble(pItem->Multiplier3, 1.0);
			}
			if (pItem->Multiplier4.vt == VT_R8) {
				dblMultiplier4 = VarDouble(pItem->Multiplier4, 1.0);
			}

			COleCurrency cyAllowableTotal = VarCurrency(pItem->UnitAllowable, COleCurrency(0, 0));
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
			cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

			RoundCurrency(cyAllowableTotal);

			pItem->TotalAllowable = _variant_t(cyAllowableTotal);
		}
		else {
			pItem->HasAllowable = g_cvarFalse;
			pItem->UnitAllowable = COleCurrency(0, 0);
			//TotalAllowable is NULL if one does not exist
			pItem->TotalAllowable = g_cvarNull;
		}

	}
	else {
		//patient or non-CPT, set it to NULL
		pItem->HasAllowable = g_cvarFalse;
		pItem->UnitAllowable = g_cvarNull;
		// TotalAllowable is NULL if one does not exist
		pItem->TotalAllowable = g_cvarNull;
		pItem->UnitCost = _variant_t(m_CPTCombo->GetValue(nRow, CPT_COLUMN_PRICE));
	}
	pItem->CPTCode = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_CODE), "");
	pItem->CPTSubCode = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_SUBCODE), "");
	pItem->ServiceID = nServiceCodeID;
	pItem->Description = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_NAME), "");

	// (j.jones 2013-08-20 10:57) - PLID 57959 - added boolean to track that
	// the service code changed on this charge, it only persists until it is saved
	pItem->HasServiceCodeChanged = g_cvarTrue;

	// (j.jones 2011-11-07 11:39) - PLID 44941 - if Alberta, we need to do a few things
	if (UseAlbertaHLINK()) {
		//first clear out our modifiers, odds are they are no longer applicable
		//to what the user just chose, even if they were we need them to re-select
		//them to properly 
		pItem->Modifier1 = g_cvarNull;
		pItem->Modifier2 = g_cvarNull;
		pItem->Modifier3 = g_cvarNull;
		pItem->Modifier4 = g_cvarNull;
		pItem->Multiplier1 = g_cvarNull;
		pItem->Multiplier2 = g_cvarNull;
		pItem->Multiplier3 = g_cvarNull;
		pItem->Multiplier4 = g_cvarNull;

		//the modifier dropdown lists will reload in FillBillList, called by CalculateLineTotal

		//we do NOT need to call UpdateChargePriceWithAlbertaModifiers, because
		//we just re-loaded the unit cost and have no remaining modifiers

		//we do not need to clear the Calls field, it does nothing without a modifier
	}

	// TAX
	long TaxType = 2;
	double dblTax1, dblTax2;
	_variant_t v;

	long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
	if (nInsuredPartyID > 0)
		TaxType = GetInsuranceCoTaxType(nInsuredPartyID);

	//now load the default taxrate for this CPT code
	v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_TAXABLE1);
	//if TaxType = 3, we aren't going to charge tax at all
	if (v.boolVal == 0 || TaxType == 3) {
		dblTax1 = 1.0;
	}
	else {
		dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
	}

	double dblTaxCalc1 = dblTax1;

	dblTax1 -= 1.0;
	dblTax1 *= 100.0;

	v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_TAXABLE2);
	//if TaxType = 3, we aren't going to charge tax at all
	if (v.boolVal == 0 || TaxType == 3) {
		dblTax2 = 1.0;
	}
	else {
		dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
	}

	double dblTaxCalc2 = dblTax2;

	dblTax2 -= 1.0;
	dblTax2 *= 100.0;
	pItem->TaxRate1 = (double)dblTax1;
	pItem->TaxRate2 = (double)dblTax2;

	//		

	COleVariant varChargeID = pItem->ChargeID;
	if (varChargeID.vt == VT_EMPTY){
		return;
	}
	if (varChargeID.lVal != -2){
		AddToModifiedList(varChargeID.lVal);
	}
	COleCurrency cyInvalid;
	cyInvalid.SetStatus(COleCurrency::invalid);

	//  changed to use totaldiscount
	CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
	//			FillBillList(); 

	// (j.jones 2014-05-01 08:36) - PLID 61837 - the new service code may
	// potentially show additional provider columns
	if (m_EntryType == 1) {
		TryShowChargeProviderColumns(pItem, false);
	}

}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingFinishingList(LPDISPATCH lpRow, short nCol, const VARIANT FAR& varOldValue, LPCTSTR strUserEntered, VARIANT FAR* pvarNewValue, BOOL FAR* pbCommit, BOOL FAR* pbContinue)
{
	COleCurrency cyInvalid;
	COleVariant var;
	CString str;

	cyInvalid.SetStatus(COleCurrency::invalid);

	IRowSettingsPtr pRow(lpRow);
	if (pRow == NULL) {
		return;
	}

	/////////////////////////////////////
	// No NULL's allowed
	if (pvarNewValue->vt == VT_NULL || *pbCommit == FALSE) {
		*pbCommit = FALSE;
		return;
	}

	//DRT 9/13/2004 - PLID 14005 - Gift certificate charges have certain restrictions placed on them, like not allowing multiple
	//	quantity, modifiers, etc.
	BOOL bIsGiftCertificate = FALSE;
	long nRowAry = -1;
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		long nAryLineID = VarLong(m_billingItems[i]->LineID);
		long nRowLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID));
		if (nAryLineID == nRowLineID) {
			nRowAry = i;
			break;
		}
	}
	if (nRowAry == -1) {
		//we can't find this row, so how can we tell what's going on?
		ASSERT(FALSE);
	}
	var = m_billingItems[nRowAry]->GiftID;
	if (var.vt == VT_I4)
		bIsGiftCertificate = TRUE;

	if (nCol == BILL_COLUMN_VALUE) {
		// (r.gonet 2015-03-27 18:47) - PLID 65277 - They shouldn't be able to enter a negative value
		// for gift certificates. I don't get the point of allowing 0, but that's valid I suppose.
		if (pvarNewValue->vt == VT_CY && VarCurrency(*pvarNewValue) < g_ccyZero) {
			*pvarNewValue = varOldValue;
			*pbCommit = FALSE;
			AfxMessageBox("You can not have a Gift Certificate Value less than zero.");
			return;
		} else if (pvarNewValue->dblVal == varOldValue.dblVal) {
			*pbCommit = FALSE;
			return;
		}
	}

	//TES 2/24/2004: See whether they clicked on the "None" row on a CPT Modifier.
	if (nCol == COLUMN_MODIFIER1 ||
		nCol == COLUMN_MODIFIER2 ||
		nCol == COLUMN_MODIFIER3 ||
		nCol == COLUMN_MODIFIER4) {
		if (pvarNewValue->vt == VT_BSTR && VarString(*pvarNewValue) == "-1") {
			_variant_t varNull;
			varNull.vt = VT_NULL;
			*pvarNewValue = varNull;
			return;
		}

		//DRT 9/10/2004 - PLID 14005 - Not a "none" row, we need to tell them they cannot change this field if a gift certificate
		if (bIsGiftCertificate) {
			//using a GC
			MsgBox("You cannot choose modifiers for gift certificates.");
			*pbCommit = FALSE;
			return;
		}
	}

	/////////////////////////////////////
	// No zero-length strings allowed
	if (nCol == BILL_COLUMN_CPT_TYPE && strlen(CString(pvarNewValue->bstrVal)) == 0) {
		*pbCommit = FALSE;
		return;
	}

	if ((nCol == BILL_COLUMN_DATE || nCol == COLUMN_SERVICE_DATE_TO || nCol == COLUMN_INPUT_DATE) && pvarNewValue->vt == VT_DATE) {
		if (pvarNewValue->date == (COleDateTime::invalid) || pvarNewValue->date <= 1.0) {
			MsgBox("Please enter a valid date for this charge.");
			*pbCommit = FALSE;
			*pbContinue = FALSE;
			return;
		}
	}

	// (j.jones 2011-02-15 14:28) - PLID 42156 - the input date check now occurs only when you change
	// the input date, as opposed to always checking modified charges upon saving
	long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
	if (nCol == COLUMN_INPUT_DATE
		&& GetBillID() != -1 && nChargeID != -1
		&& VarDateTime(pvarNewValue) != VarDateTime(varOldValue)) {

		//they changed the input date, so see if it is in a locked period
		if (!CanChangeHistoricFinancial_ByInputDate("Charge", VarDateTime(pvarNewValue))) {
			// The user cannot change the date, and they've already been prompted about it.
			*pbCommit = FALSE;
			*pbContinue = FALSE;
			return;
		}
	}

	if (nCol == BILL_COLUMN_DATE && pvarNewValue->vt == VT_DATE && pvarNewValue->date != varOldValue.date) {
		if (GetBillID() == -1) {
			//checks for any active global period for the new date, that we weren't already warned about
			// (a.walling 2008-07-07 18:03) - PLID 29900 - Do not use GetActive[Patient,Contact][ID,Name]
			if (!CheckWarnGlobalPeriod(m_nPatientID, pvarNewValue->date, TRUE, COleDateTime::GetCurrentTime())) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				return;
			}
		}
		else {
			//checks for any active global period for the new date
			// (a.walling 2008-07-07 18:03) - PLID 29900 - Do not use GetActive[Patient,Contact][ID,Name]
			if (!CheckWarnGlobalPeriod(m_nPatientID, pvarNewValue->date)) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				return;
			}
		}
	}

	/////////////////////////////////////
	// Set the new default date
	if (nCol == BILL_COLUMN_DATE) {
		m_cyDefaultChargeDate = pvarNewValue->date;
	}

	if (nCol == BILL_COLUMN_PROVIDER) {
		m_DefaultProvider = pvarNewValue->lVal;
	}

	// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
	if (nCol == BILL_COLUMN_CLAIM_PROVIDER) {
		m_DefaultClaimProvider = VarLong(pvarNewValue, -1);
	}

	/////////////////////////////////////
	// Round currency
	if (pvarNewValue->vt == VT_CY) {
		COleCurrency cy = pvarNewValue->cyVal;
		RoundCurrency(cy);
		pvarNewValue->cyVal = cy;
	}

	if (pvarNewValue->vt == VT_I4 && (nCol == COLUMN_MODIFIER1 || nCol == COLUMN_MODIFIER2 || nCol == COLUMN_MODIFIER3 || nCol == COLUMN_MODIFIER4)) {
		CString str;
		str.Format("%li", pvarNewValue->lVal);
		::SetVariantString(*pvarNewValue, str);
	}

	if (pvarNewValue->vt == VT_BSTR) {
		CString str;
		str = VarString(*pvarNewValue);
		if (str.GetLength() > 255) {
			str = str.Left(255);
			::SetVariantString(*pvarNewValue, str);
			AfxMessageBox("Your description is longer then the maximum amount (255) and has been shortened.\n"
				"Please double-check the description and make changes as needed.");
		}
	}

	// (j.gruber 2009-03-05 17:33) - PLID 33351 - removed discount field
	if (pvarNewValue->vt == VT_BSTR && (nCol == BILL_COLUMN_UNIT_COST || nCol == COLUMN_INS_RESP /*|| nCol == COLUMN_DISCOUNT*/)) {
		COleCurrency cy;
		cy = ParseCurrencyFromInterface(CString(pvarNewValue->bstrVal));
		RoundCurrency(cy);
		pvarNewValue->vt = VT_CY;
		pvarNewValue->cyVal = cy;
	}

	// (j.jones 2008-02-12 11:51) - PLID 28848 - disable checking the batched column
	// if there is a $0.00 insurance total and the preferences are enabled
	// require both preferences to be enabled for this to go into effect
	if (nCol == COLUMN_BATCHED && GetRemotePropertyInt("DisallowBatchingPatientClaims", 0, 0, "<None>", TRUE) == 1 &&
		GetRemotePropertyInt("HidePatientChargesOnClaims", 0, 0, "<None>", TRUE) == 1) {

		if (VarBool(pvarNewValue)) {
			//check the resps for this charge

			BOOL bHasInsResp = FALSE;
			RPCList* list = m_billingItems[nRowAry]->RPCList;
			for (int j = 0; j < list->aryRPC.GetSize() && !bHasInsResp; j++) {
				RespPerCharge rpc = list->aryRPC.GetAt(j);

				COleCurrency cyInsResp = (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));

				if (cyInsResp > COleCurrency(0, 0)) {
					bHasInsResp = TRUE;
				}
			}

			// (j.jones 2010-09-29 16:19) - PLID 40686 - is the entire charge zero?
			COleCurrency cyLineTotal = (m_billingItems[nRowAry]->LineTotal.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(m_billingItems[nRowAry]->LineTotal, COleCurrency(0, 0));

			BOOL bAllowedBatched = FALSE;

			if (cyLineTotal == COleCurrency(0, 0) && VarLong(m_billingItems[nRowAry]->ItemType) == ITEM_TYPE_CPT) {
				//ok, it's a zero dollar CPT code, so check for this exclusion
				_RecordsetPtr rsCPTZeroOK = CreateParamRecordset("SELECT BatchIfZero FROM CPTCodeT WHERE BatchIfZero = 1 AND ID = {INT}", VarLong(m_billingItems[nRowAry]->ServiceID));
				if (!rsCPTZeroOK->eof) {
					//this service code is set to NOT unbatch, so permit this
					bAllowedBatched = TRUE;
				}
			}

			if (!bHasInsResp && !bAllowedBatched) {
				//if we don't have any insurance resp. on this charge,
				//and we do not permit batching this service code,
				//we can't allow checking the batched status

				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("You attempted to batch a charge that is 100% patient responsibility, but your preferences are "
					"set to disallow sending charges that have no insurance responsibility.");
				return;
			}
		}
	}

	/////////////////////////////////////
	// No negative tax rates
	if (nCol == COLUMN_TAX_RATE_1 || nCol == COLUMN_TAX_RATE_2) {
		if (pvarNewValue->vt == VT_BSTR) {
			double tax = atof(CString(pvarNewValue->bstrVal));
			pvarNewValue->vt = VT_R8;
			pvarNewValue->dblVal = tax;
		}
		if (pvarNewValue->dblVal < 0)
			*pvarNewValue = varOldValue;

		if (pvarNewValue->dblVal >= 100) {
			*pvarNewValue = varOldValue;
			AfxMessageBox("Your tax rate cannot be greater than 99%");
		}

		//DRT 9/10/2004 - PLID 14005 - Don't allow tax rates for gift certificates
		if (bIsGiftCertificate) {
			//using a GC
			MsgBox("You cannot add tax to gift certificates.");
			*pbCommit = FALSE;
			return;
		}
	}

	try {

		// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
		if (nCol == COLUMN_CALLS && pvarNewValue->vt == VT_R8) {

			if (pvarNewValue->dblVal < 0.0) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("You can not have a Call count less than zero.");
				return;
			}
			// (d.singleton 2012-05-30 16:21) - PLID 48151 if the new value is same as old value no reason to continue editing and pop up the notes dialog
			else if (pvarNewValue->dblVal == varOldValue.dblVal) {
				*pbCommit = FALSE;
				return;
			}
		}

		// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
		if (nCol == QUOTE_COLUMN_CALLS && pvarNewValue->vt == VT_R8) {

			if (pvarNewValue->dblVal < 0.0) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("You can not have a Call count less than zero.");
				return;
			}
		}

		// (d.singleton 2012-05-22 12:04) - PLID 48152 added skillcode alberta only
		if (nCol == COLUMN_SKILL) {
			CString strNewVal = VarString(pvarNewValue, "");
			if (strNewVal.GetLength() > 4) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("You cannot have a Skill code greater than four characters.");
				return;
			}
		}

		// (d.singleton 2012-05-22 12:04) - PLID 48152 added skillcode alberta only
		if (nCol == QUOTE_COLUMN_SKILL) {
			CString strNewVal = VarString(pvarNewValue, "");
			if (strNewVal.GetLength() > 4) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("You cannot have a Skill code greater than four characters.");
				return;
			}
		}

		if (nCol == BILL_COLUMN_QUANTITY && pvarNewValue->vt == VT_R8) {

			// (j.gruber 2013-05-16 17:22) - PLID 53262 - and less than 99,999,999.99
			if (pvarNewValue->dblVal <= 0.0 || pvarNewValue->dblVal > 99999999.99) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				CString strQtyTop = FormatNumberForInterface("99999999.99", FALSE, TRUE, 2);
				AfxMessageBox("You must have a quantity greater than zero and less than " + strQtyTop + ".");
				return;
			}

			//if quantity, check and see if there are charged product items
			if (nCol == BILL_COLUMN_QUANTITY && pRow->GetValue(COLUMN_PRODUCT_ITEM_ID).vt == VT_I4 && VarLong(pRow->GetValue(COLUMN_PRODUCT_ITEM_ID), -1) != -1) {
				//if so, make sure the quantity is a whole number
				if ((long)pvarNewValue->dblVal != pvarNewValue->dblVal) {
					*pvarNewValue = varOldValue;
					*pbCommit = FALSE;
					AfxMessageBox("This product is being tracked by either a serial number or expiration date,\n"
						"and requires that it is billed in increments of 1.\n"
						"Please enter a whole number for the quantity.");
					return;
				}
			}
			else {
				//if we did the above, we must be an inventory item.  We need to check to see if we are a gift
				//	certificate item.  If so, they are not allowed to change the quantity.
				if (bIsGiftCertificate) {
					//it is a gift certificate!
					double dbl = VarDouble(*pvarNewValue);
					if (!(dbl >= (1.0 - 0.001) && dbl <= (1.0 + 0.001))) {	//stupid double comparison
						MsgBox("You may not bill more than 1 gift certificate quantity.  Please add another gift certificate charge instead of increasing the quantity.");
						*pbCommit = FALSE;
					}
				}
			}

			long nPackageChargeRefID = -1;
			var = pRow->GetValue(COLUMN_PACKAGE_CHARGE_REF_ID);
			if (var.vt == VT_I4)
				nPackageChargeRefID = VarLong(var, -1);

			if (nPackageChargeRefID != -1) {

				// (j.jones 2007-03-26 14:40) - PLID 25287 - disallow increasing the quantity from the billing tab,
				// instead force the user to add the package again and use the package selection interface.
				// However, DO allow decreasing the quantity.

				if (VarDouble(pvarNewValue, 0.0) > VarDouble(varOldValue, 0.0)) {
					*pvarNewValue = varOldValue;
					*pbCommit = FALSE;
					AfxMessageBox("You may not edit the quantity inside the bill in order to increase the number of uses.\n"
						"To add more uses to this bill, you must select this package again and choose from the package selection screen.");
					return;
				}

				// (j.jones 2007-03-26 14:40) - PLID 25287 - we also cannot allow decreasing the quantity if 
				// this happens to be a targeted charge for an "overage" amount

				//if our target charge, it would have been a quantity of only 1.0
				if (VarDouble(pvarNewValue, 0.0) < 1.0 && VarDouble(varOldValue, 0.0) == 1.0) {

					long nQuoteID = -1;
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT BillID FROM ChargesT WHERE ID = {INT}", nPackageChargeRefID);
					if (!rs->eof) {
						nQuoteID = AdoFldLong(rs, "BillID", -1);
					}
					rs->Close();

					COleCurrency cyMatchRemainingPackageAmount = CalculateMultiUsePackageOverageAmount_ForBalance(nQuoteID);

					// (j.jones 2011-02-03 09:12) - PLID 42291 - changed to calculate the package charge ID, not service ID
					long nTargetChargeID = -1;
					//no need to calculate the charge ID if the offset is zero
					if (cyMatchRemainingPackageAmount != COleCurrency(0, 0)) {
						nTargetChargeID = CalculateMultiUsePackageOverageChargeID(nQuoteID);
					}

					if (nTargetChargeID != -1 && nTargetChargeID == nPackageChargeRefID) {

						//it's our targeted charge ID, there is an overage, the quantity is 1,
						//just disallow changing the quantity to be less than 1 because we cannot
						//reliably enforce that it is indeed the "last" charge
						*pvarNewValue = varOldValue;
						*pbCommit = FALSE;
						AfxMessageBox("You may not edit the quantity of this package charge to be a usage of less than 1.");
						return;
					}
				}

				/*
				//j.jones - if this is a billed multi-use package, don't allow them to
				//change it to be more uses than the package allows
				if(!GetIsPackageQuantityChangeAllowed(VarDouble(*pvarNewValue,0.0) - VarDouble(varOldValue,0.0), nServiceID, nPackageChargeRefID)) {
				*pvarNewValue = varOldValue;
				*pbCommit = FALSE;
				AfxMessageBox("There are not enough uses remaining in your package to support this new quantity.\n"
				"You may edit the package in the Quotes tab to add more uses, if necessary.");
				return;
				}
				*/
			}
		}

	}NxCatchAll("Error checking serialized status.");

	try {
		if (nCol == BILL_COLUMN_UNIT_COST) {

			if (COleCurrency(pvarNewValue->cyVal) > COleCurrency(100000000, 00)) {

				AfxMessageBox("You cannot charge an amount greater than $100,000,000.00.");

				*pbCommit = FALSE;
				return;
			}

			_variant_t var = pRow->GetValue(BILL_COLUMN_CPT_CODE);
			if (var.vt == VT_BSTR && VarString(var) == "Package") {
				//check the current balance of the package, and do not let them bill a value that is higher
				COleCurrency balance, value;
				balance = COleCurrency(0, 0);
				value = value = pvarNewValue->cyVal;
				if (pRow->GetValue(COLUMN_CHARGE_ID).lVal == -2) {
					//if is new charge
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsTemp = CreateParamRecordset("SELECT CurrentAmount FROM PackagesT WHERE QuoteID = {INT}", m_nPackageID);
					if (!rsTemp->eof) {
						balance = rsTemp->Fields->Item["CurrentAmount"]->Value.cyVal;
					}
					rsTemp->Close();
				}
				else {
					//existing charge
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsTemp = CreateParamRecordset("SELECT Amount FROM LineItemT WHERE ID = {INT}", pRow->GetValue(COLUMN_CHARGE_ID).lVal);
					COleCurrency oldAmt;
					oldAmt = COleCurrency(0, 0);
					if (!rsTemp->eof) {
						oldAmt = rsTemp->Fields->Item["Amount"]->Value.cyVal;
					}
					rsTemp->Close();

					//if is new charge
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					rsTemp = CreateParamRecordset("SELECT CurrentAmount FROM PackagesT INNER JOIN BilledQuotesT ON PackagesT.QuoteID = BilledQuotesT.QuoteID WHERE BilledQuotesT.BillID = {INT}", GetBillID());
					if (!rsTemp->eof) {
						balance = rsTemp->Fields->Item["CurrentAmount"]->Value.cyVal;
						balance = balance + oldAmt;
					}
					rsTemp->Close();
				}

				if (value > balance) {
					*pvarNewValue = _variant_t(balance);
					AfxMessageBox("You cannot charge an amount greater than the remaining balance of the package. \n"
						"The amount has been changed to reflect the remaining balance.");
				}
			}
		}
	}NxCatchAll("Error validating package fee.");
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingFinishingQuoteList(LPDISPATCH lpRow, short nCol, const VARIANT FAR& varOldValue, LPCTSTR strUserEntered, VARIANT FAR* pvarNewValue, BOOL FAR* pbCommit, BOOL FAR* pbContinue)
{
	COleCurrency cyInvalid;
	COleCurrency cyUnitCost;

	IRowSettingsPtr pRow(lpRow);
	if (pRow == NULL) {
		return;
	}

	cyInvalid.SetStatus(COleCurrency::invalid);

	//TES 2/24/2004: See whether they clicked on the "None" row on a CPT Modifier.
	if (nCol == QUOTE_COLUMN_MODIFIER1 ||
		nCol == QUOTE_COLUMN_MODIFIER2 ||
		nCol == QUOTE_COLUMN_MODIFIER3 ||
		nCol == QUOTE_COLUMN_MODIFIER4) {
		if (pvarNewValue->vt == VT_BSTR && VarString(*pvarNewValue) == "-1") {
			_variant_t varNull;
			varNull.vt = VT_NULL;
			*pvarNewValue = varNull;
			return;
		}
	}

	if (pvarNewValue->vt == VT_I4 && (nCol == QUOTE_COLUMN_MODIFIER1 || nCol == QUOTE_COLUMN_MODIFIER2 || nCol == QUOTE_COLUMN_MODIFIER3 || nCol == QUOTE_COLUMN_MODIFIER4)) {
		CString str;
		str.Format("%li", pvarNewValue->lVal);
		::SetVariantString(*pvarNewValue, str);
	}

	if (pvarNewValue->vt == VT_NULL || *pbCommit == FALSE) {
		*pbCommit = FALSE;
		return;
	}

	/* Round currency */
	if (pvarNewValue->vt == VT_CY) {
		COleCurrency cy = pvarNewValue->cyVal;
		RoundCurrency(cy);
		pvarNewValue->cyVal = cy;
	}

	if (pvarNewValue->vt == VT_BSTR) {
		CString str;
		str = VarString(*pvarNewValue);
		if (str.GetLength() > 255) {
			str = str.Left(255);
			::SetVariantString(*pvarNewValue, str);
			AfxMessageBox("Your description is longer then the maximum amount (255) and has been shortened.\n"
				"Please double-check the description and make changes as needed.");
		}
	}

	// (j.gruber 2009-03-05 17:34) - PLID 33351 - take out discount field
	if (pvarNewValue->vt == VT_BSTR && (nCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE || nCol == QUOTE_COLUMN_UNIT_COST /*|| nCol == QUOTE_COLUMN_DISCOUNT*/)) {
		COleCurrency cy = ParseCurrencyFromInterface(CString(pvarNewValue->bstrVal));
		RoundCurrency(cy);
		pvarNewValue->vt = VT_CY;
		pvarNewValue->cyVal = cy;
	}

	if (nCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE || nCol == QUOTE_COLUMN_UNIT_COST) {
		if (COleCurrency(pvarNewValue->cyVal) > COleCurrency(100000000, 00)) {

			AfxMessageBox("You cannot charge an amount greater than $100,000,000.00.");

			*pbCommit = FALSE;
			return;
		}
	}

	if (nCol == QUOTE_COLUMN_QUANTITY && pvarNewValue->vt == VT_R8) {

		// (j.gruber 2013-05-20 14:08) - PLID 53262 - check its not over our highest value
		if (pvarNewValue->dblVal <= 0.0 || pvarNewValue->dblVal > 99999999.99) {
			*pvarNewValue = varOldValue;
			*pbCommit = FALSE;
			CString strQtyTop = FormatNumberForInterface("99999999.99", FALSE, TRUE, 2);
			AfxMessageBox("You must have a quantity greater than zero and less than " + strQtyTop + ".");
			return;
		}
	}

	if (nCol == QUOTE_COLUMN_PACKAGE_QTY_REM && pvarNewValue->vt == VT_R8) {

		if (pvarNewValue->dblVal < 0.0) {
			*pvarNewValue = varOldValue;
			*pbCommit = FALSE;
			AfxMessageBox("You must have a non-negative remaining quantity.");
			return;
		}
		else {
			//it's a valid quantity, but compare that it's a valid amount remaining

			if (pvarNewValue->dblVal != varOldValue.dblVal) {
				double dblCount = VarDouble(pRow->GetValue(QUOTE_COLUMN_QUANTITY), 0.0);
				if (pvarNewValue->dblVal > dblCount) {
					*pvarNewValue = varOldValue;
					*pbCommit = FALSE;
					AfxMessageBox("You cannot have more remaining uses than there are total uses for this service.\n"
						"Please update the Quantity column first.");
					return;
				}
			}
		}
	}

	// (j.jones 2009-12-22 17:01) - PLID 32587 - support the original quantity
	if (nCol == QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM && pvarNewValue->vt == VT_R8) {

		if (pvarNewValue->dblVal < 0.0) {
			*pvarNewValue = varOldValue;
			*pbCommit = FALSE;
			AfxMessageBox("You must have a non-negative initial quantity.");
			return;
		}
		else {
			//it's a valid quantity, but compare that it's a valid amount

			if (pvarNewValue->dblVal != varOldValue.dblVal) {
				double dblCount = VarDouble(pRow->GetValue(QUOTE_COLUMN_QUANTITY), 0.0);
				if (pvarNewValue->dblVal > dblCount) {
					*pvarNewValue = varOldValue;
					*pbCommit = FALSE;
					AfxMessageBox("You cannot have more initial uses than there are total uses for this service.\n"
						"Please update the Quantity column first.");
					return;
				}
			}
		}
	}

	if (nCol == QUOTE_COLUMN_TAX_RATE_1 || nCol == QUOTE_COLUMN_TAX_RATE_2) {
		if (pvarNewValue->vt == VT_BSTR) {
			double tax = atof(CString(pvarNewValue->bstrVal));
			pvarNewValue->vt = VT_R8;
			pvarNewValue->dblVal = tax;
		}

		if (pvarNewValue->dblVal < 0)
			*pvarNewValue = varOldValue;

		if (pvarNewValue->dblVal >= 100) {
			*pvarNewValue = varOldValue;
			AfxMessageBox("Your tax rate cannot be greater than 99%");
		}
	}

	if (nCol == QUOTE_COLUMN_PROVIDER) {
		m_DefaultProvider = pvarNewValue->lVal;
	}

	// (d.singleton 2012-05-24 11:24) - PLID 48152 limit skill code column to 4 char
	if (nCol == QUOTE_COLUMN_SKILL) {
		CString strSkillCode = VarString(pvarNewValue);
		if (strSkillCode.GetLength() > 4) {
			AfxMessageBox("You cannot have a skill code greater than four characters");
			*pvarNewValue = varOldValue;
			*pbCommit = FALSE;
		}
	}
}

void CBillingDlg::OnSelChosenComboCpt(long iNewRow)
{
	CWaitCursor pWait;

	try {

		if (iNewRow == -1) {
			return;
		}
		else {

			// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
			if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
				AfxMessageBox("You must first select a Responsibility before adding new charges.");
				return;
			}

			// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
			CMaintainFocus maintainFocus(__FUNCTION__);

			long ServiceID;
			_variant_t v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_SERVICE_ID);
			if (v.vt != VT_NULL && v.vt != VT_EMPTY)
				ServiceID = v.lVal;
			else
				ServiceID = -1;

			// (j.jones 2006-04-25 16:37) - we cached the Anesthesia, UseAnesthesiaBilling, FacilityFee, and UseFacilityBilling
			// values, so don't check for these if we already know it's irrelevant
			BOOL bIsAnesthesia = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_ANESTHESIA), FALSE);
			BOOL bUseAnesthesia = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_USE_ANESTH_BILLING), FALSE);
			BOOL bIsFacilityFee = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_FACILITY_FEE), FALSE);
			BOOL bUseFacilityFee = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_USE_FACILITY_BILLING), FALSE);
			// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
			BOOL bOHIPPremiumCode = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_OHIP_PREMIUM_CODE), FALSE);

			// (j.jones 2009-03-31 10:39) - PLID 33747 - if a CPT code, check if it is an OHIP Premium Code
			if (UseOHIP() && bOHIPPremiumCode) {
				if (ProcessOHIPPremiumCode(ServiceID)) {
					//if the above function returns true, we will not add this charge in this function
					return;
				}
			}

			//check and see if this is an anesthesia code or facility code, and already exists in the charge list
			if (((bIsAnesthesia && bUseAnesthesia) || (bIsFacilityFee && bUseFacilityFee))
				&& !CheckAllowAddAnesthesiaFacilityCharge(ServiceID))
				return;

			AddNewChargeToBill(ServiceID);

			PostChargeAdded();


			// (s.tullis 2014-08-06 12:24) - PLID 62779 
			//check to see if the client can use alberta before setting bill status to pending 
			// (s.tullis 2015-03-27 10:59) - PLID 65457 - Only set the bill status if this is the bill dialog
			if (m_EntryType == BillEntryType::Bill && UseAlbertaHLINK()){
				SetAlbertaBillStatus();	
			}


			
		}
	
	}NxCatchAll("Error in OnSelChosenComboCpt()");
}

void CBillingDlg::OnSelChangedComboDesignation(long iNewRow)
{
	// (j.jones 2011-08-24 08:41) - PLID 44868 - this is allowed to
	// change original and void charges because this does not affect A/R
	SaveAllCharges(TRUE);
}

void CBillingDlg::OnSelChosenComboPlaceofservice(long iNewRow)
{
	if (iNewRow == -1)
		return;

	try {

		//do the anesthesia/facility calculations here so that we know it's only done when
		//the place of service is legitimately changed

		long nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(iNewRow, 0), -1);

		if (nPOSID == -1)
			return;

		if (m_nCurPlaceOfServiceID != nPOSID) {

			OnAnesthesiaTimeChanged(GetAnesthMinutes(), TRUE);
			OnFacilityTimeChanged(GetFacilityMinutes(), TRUE);
		}

		PostPlaceOfServiceChanged();

	}
	NxCatchAll("Error in OnSelChosenComboPlaceofservice");
}

void CBillingDlg::PostPlaceOfServiceChanged()
{
	if (m_PlaceOfServiceCombo->CurSel == -1)
		return;

	//this function is called when we want to process changes from the POS changing,
	//but may be called at times when the POS is being initially loaded and not "changed"

	try {

		_RecordsetPtr rs;
		_variant_t var;
		CString str;

		long nPOSID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

		//if they didn't change the selection, don't do anything
		if (m_nCurPlaceOfServiceID == nPOSID)
			return;

		m_nCurPlaceOfServiceID = nPOSID;

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_List->GetFirstRow();
		while (pRow) {
			var = pRow->GetValue(COLUMN_CHARGE_ID);
			if (var.lVal != -2) {
				AddToModifiedList(var.lVal);
			}

			pRow = pRow->GetNextRow();
		}

		//for the designation, first check to see if the insurance company has a particular code for it
		//now check to see if there is just one associated with the location		

		long nPOSDesignation = -1;
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		rs = CreateParamRecordset("SELECT POSID FROM POSLocationLinkT INNER JOIN InsuranceCoT ON POSLocationLinkT.HCFASetupGroupID = InsuranceCoT.HCFASetupGroupID "
			"WHERE LocationID = {INT} AND InsuranceCoT.PersonID = {INT}", m_nCurPlaceOfServiceID, GetInsuranceCoID(m_GuarantorID1));
		if (!rs->eof) {
			nPOSDesignation = AdoFldLong(rs, "POSID", -1);
		}
		rs->Close();


		if (nPOSDesignation == -1) {
			//now check to see if there is just one associated with the location
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			rs = CreateParamRecordset("SELECT POSID FROM LocationsT WHERE ID = {INT}", m_nCurPlaceOfServiceID);
			if (!rs->eof) {
				nPOSDesignation = AdoFldLong(rs, "POSID", -1);
			}
			rs->Close();
		}

		m_DesignationCombo->SetSelByColumn(posdcID, nPOSDesignation);

		/////////////////////////////////////////////////////
		// Get the practice tax rate - reflect the rax rate of the NEW location

		if (GetRemotePropertyInt("DefaultTaxSource", 1, 0, "<None>", TRUE) == 2) {

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rs = CreateParamRecordset("SELECT TaxRate, TaxRate2 FROM LocationsT WHERE ID = {INT}", m_nCurPlaceOfServiceID);
			if (!rs->eof) {
				_variant_t var;
				var = rs->Fields->Item["TaxRate"]->Value;
				m_fltPracticeTax1 = ((var.dblVal - 1) * 100);
				var = rs->Fields->Item["TaxRate2"]->Value;
				m_fltPracticeTax2 = ((var.dblVal - 1) * 100);

				PromptUpdateTaxRates(TRUE);
			}
			else {
				m_fltPracticeTax1 = 0.0;
				m_fltPracticeTax2 = 0.0;
			}
			rs->Close();
		}

		// (j.jones 2009-10-23 11:36) - PLID 18558 - check if the allowable changed
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr pItem = m_billingItems[i];
			LoadAllowableColumn(pItem, TRUE);
		}

	}NxCatchAll("Error in PostPlaceOfServiceChanged()");
}

//when the default tax rates have changed, offer to update any taxed charges with the new rate
void CBillingDlg::PromptUpdateTaxRates(BOOL bPOSChanged)
{
	try {

		long Tax1ChangeCount = 0, Tax2ChangeCount = 0;

		//first run through the charges, see if any have tax on them that is nonzero and different from the new tax
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			_variant_t var = pRow->GetValue(m_EntryType == 1 ? COLUMN_TAX_RATE_1 : QUOTE_COLUMN_TAX_RATE_1);
			if (var.vt == VT_R8) {
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (var.dblVal != m_fltPracticeTax1 && (var.dblVal != 0.0 ||
					ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE Taxable1 = 1 AND ID = {INT}",
					VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1)))) {

					Tax1ChangeCount++;
				}
			}

			var = pRow->GetValue(m_EntryType == 1 ? COLUMN_TAX_RATE_2 : QUOTE_COLUMN_TAX_RATE_2);
			if (var.vt == VT_R8) {
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (var.dblVal != m_fltPracticeTax2 && (var.dblVal != 0.0 ||
					ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE Taxable2 = 1 AND ID = {INT}",
					VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1)))) {

					Tax2ChangeCount++;
				}
			}

			pRow = pRow->GetNextRow();
		}

		//if not, return
		if (Tax1ChangeCount == 0 && Tax2ChangeCount == 0)
			return;

		//if so, prompt to update them
		CString strPrompt, strCharges;
		if (Tax1ChangeCount > 0 && Tax2ChangeCount > 0) {
			strCharges.Format("%li %s using/requiring Tax 1 and the %li %s using/requiring Tax 2", Tax1ChangeCount, Tax1ChangeCount == 1 ? "charge" : "charges", Tax2ChangeCount, Tax2ChangeCount == 1 ? "charge" : "charges");
		}
		else if (Tax1ChangeCount > 0 && Tax2ChangeCount == 0) {
			strCharges.Format("%li %s using/requiring Tax 1", Tax1ChangeCount, Tax1ChangeCount == 1 ? "charge" : "charges");
		}
		else if (Tax1ChangeCount == 0 && Tax2ChangeCount > 0) {
			strCharges.Format("%li %s using/requiring Tax 2", Tax2ChangeCount, Tax2ChangeCount == 1 ? "charge" : "charges");
		}
		strPrompt.Format("Changing the %s for this %s has updated the default tax rates to be used on new charges.\n"
			"The new tax rates are:\n\n"
			"Tax 1: %g%%\n"
			"Tax 2: %g%%\n\n"
			"Would you like to update the %s to use the new tax rate?",
			bPOSChanged ? "place of service" : "location", m_EntryType == 2 ? "quote" : "bill",
			m_fltPracticeTax1, m_fltPracticeTax2, strCharges);

		if (IDNO == MessageBox(strPrompt, "Practice", MB_ICONQUESTION | MB_YESNO)) {
			return;
		}

		//if the user approves, update the tax rates and recalculate the bill

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		pRow = m_pList->GetFirstRow();
		while (pRow) {
			_variant_t var = pRow->GetValue(m_EntryType == 1 ? COLUMN_TAX_RATE_1 : QUOTE_COLUMN_TAX_RATE_1);
			if (var.vt == VT_R8) {
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (var.dblVal != m_fltPracticeTax1 && (var.dblVal != 0.0 ||
					ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE Taxable1 = 1 AND ID = {INT}",
					VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1)))) {

					pRow->PutValue(m_EntryType == 1 ? COLUMN_TAX_RATE_1 : QUOTE_COLUMN_TAX_RATE_1, m_fltPracticeTax1);

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {
							m_varBoundItem.lVal = m_billingItems[j]->LineID.lVal;
							m_billingItems[j]->TaxRate1 = m_fltPracticeTax1;
						}
					}

					// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
					CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
				}
			}

			var = pRow->GetValue(m_EntryType == 1 ? COLUMN_TAX_RATE_2 : QUOTE_COLUMN_TAX_RATE_2);
			if (var.vt == VT_R8) {
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (var.dblVal != m_fltPracticeTax2 && (var.dblVal != 0.0 ||
					ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE Taxable2 = 1 AND ID = {INT}",
					VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1)))) {

					pRow->PutValue(m_EntryType == 1 ? COLUMN_TAX_RATE_2 : QUOTE_COLUMN_TAX_RATE_2, m_fltPracticeTax2);

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {
							m_varBoundItem.lVal = m_billingItems[j]->LineID.lVal;
							m_billingItems[j]->TaxRate2 = m_fltPracticeTax2;
						}
					}

					// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
					CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
				}
			}

			pRow = pRow->GetNextRow();
		}

		CalculateTotal();

	} NxCatchAll("Error updating tax rates.");
}

void CBillingDlg::OnSelChosenComboProducts(long iNewRow)
{
	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection, but not if the 
	// "add as patient" pref. is enabled
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1
		&& GetRemotePropertyInt("AddInventoryAsPatResp", 0, 0, GetCurrentUserName(), true) == 0) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return;
	}

	// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
	CMaintainFocus maintainFocus(__FUNCTION__);
	AddNewProductToBill(iNewRow);
}

// (a.walling 2007-05-07 16:48) - PLID 14717 - Add a product to the bill by service ID
// (j.jones 2008-06-11 12:51) - PLID 28379 - now this returns a BillingItem pointer
//TES 7/1/2008 - PLID 26143 - This now takes a quantity to add.
//TES 7/16/2008 - PLID 27983 - This now also takes bAddedFromAllocation, which if true, means that the product being added was
// on an allocation, and the user has already been prompted about that allocation.
//TES 7/17/2008 - PLID 27983 - Added bMassAdding, set this to true to tell the code to not force all allocations to be completed,
// it is then the caller's reponsibility to do that once it's finished adding charges.
// (j.jones 2010-11-23 16:13) - PLID 41549 - added nPackageChargeRefID, optional cyUnitPrice override, and discount info
// (b.eyers 2015-06-17) - PLID 66206 - added optional parameters: whichcodes, mods, service date, provider, hl7bill
// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
BillingItemPtr CBillingDlg::AddNewProductToBillByServiceID(long nServiceID, double dblQtyDefault /*= 1.0*/, BOOL bAutoAddingSerialNumber /*= FALSE*/,
	BOOL bAddedFromAllocation /*= FALSE*/, bool bMassAdding /*= false*/,
	IN COleCurrency *cyUnitPrice /*= NULL*/, long nPackageChargeRefID /*= -1*/,
	long nLoadDiscountFromChargeID /*= -1*/, BOOL bLoadDiscountFromSurgery /*= FALSE*/, 
	CChargeWhichCodesMapPtr pWhichCodes /*= NULL*/, const CString &strMod1 /*= ""*/, 
	const CString &strMod2 /*= ""*/, const CString &strMod3 /*= ""*/, const CString &strMod4 /*= ""*/, 
	COleDateTime *pdtService /*= NULL*/, long nDefaultProviderID /*= -1*/, BOOL bHL7Bill /*= FALSE */, long nOrdProvider /*= -1*/)
{
	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return BillingItemPtr();
	}

	// from OnSelChosenWhatToAdd
	if (m_bProductsCombo == FALSE) {
		// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
		RequeryProductCombo();
	}

	// (j.jones 2008-12-15 15:02) - PLID 32431 - changed this code to call FindProductRowInComboByServiceID,
	// which will force finding the product, incase the combo is still requerying
	long iRow = FindProductRowInComboByServiceID(nServiceID, FALSE);
	if (iRow < 0) {
		MessageBox("This item was not able to be added to the bill.  Ensure the item is billable for this location.");
		return BillingItemPtr();
	} else {
		//TES 7/16/2008 - PLID 27983 - If bAddedFromAllocation is TRUE, pass in -2 for the nFromAllocationID, which tells
		// the function that this product was added from an allocation, but that the caller is responsible for prompting
		// the user about it.
		// (j.jones 2010-11-23 17:00) - PLID 41549 - passed in our cyUnitPrice, nPackageChargeRefID, and discount info.
		// (b.eyers 2015-06-17) - PLID 66206 - added optional parameters: whichcodes, mods, service date, provider, hl7bill
		// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
		return AddNewProductToBill(iRow, bAutoAddingSerialNumber, bAddedFromAllocation ? -2 : -1, -1, dblQtyDefault, bMassAdding,
			cyUnitPrice, nPackageChargeRefID, nLoadDiscountFromChargeID, bLoadDiscountFromSurgery, pWhichCodes, strMod1, 
			strMod2, strMod3, strMod4, pdtService, nDefaultProviderID, bHL7Bill, nOrdProvider);
	}
}

// (j.jones 2008-06-11 12:51) - PLID 28379 - now this returns a BillingItem pointer, and can take in optional allocation information
//TES 7/1/2008 - PLID 26143 - This now takes a quantity to add.
//TES 7/16/2008 - PLID 27983 - You can now pass in -2 for nFromAllocationID, which will tell this function to treat the product
// as coming from an allocation, but not prompt the user about that allocation (that's the caller's responsibility).
//TES 7/17/2008 - PLID 27983 - Added bMassAdding, set this to true to tell the code to not force all allocations to be completed,
// it is then the caller's reponsibility to do that once it's finished adding charges.
// (j.jones 2010-11-23 16:13) - PLID 41549 - added nPackageChargeRefID, optional cyUnitPrice override, and discount info
// (b.eyers 2015-06-17) - PLID 66206 - added optional parameters: whichcodes, mods, service date, provider, hl7bill
// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
BillingItemPtr CBillingDlg::AddNewProductToBill(long iNewRow, BOOL bAutoAddingSerialNum /*= FALSE*/,
	long nFromAllocationID /*= -1*/, long nFromAllocationDetailID /*= -1*/,
	double dblQtyDefault /*= 1.0*/, bool bMassAdding /*= false*/,
	IN COleCurrency *cyUnitPrice /*= NULL*/, long nPackageChargeRefID /*= -1*/,
	long nLoadDiscountFromChargeID /*= -1*/, BOOL bLoadDiscountFromSurgery /*= FALSE*/,
	CChargeWhichCodesMapPtr pWhichCodes /*= NULL*/, const CString &strMod1 /*= ""*/,
	const CString &strMod2 /*= ""*/, const CString &strMod3 /*= ""*/, const CString &strMod4 /*= ""*/,
	COleDateTime *pdtService /*= NULL*/, long nDefaultProviderID /*= -1*/, BOOL bHL7Bill /*= FALSE */, long nOrdProvider /*= -1*/)
{
	CWaitCursor pWait;


	try {

		if (iNewRow == -1) {
			return BillingItemPtr();
		}

		BillingItemPtr pLineItem;

		// (j.jones 2010-09-03 08:45) - PLID 38319 - if a bill, and a product,
		// and they want to add products as patient responsibility, switch the resp. dropdown now
		BOOL bSwitchedResponsibilitySel = FALSE;
		long nOldRespType = -1;
		if (m_EntryType == 1
			&& GetRemotePropertyInt("AddInventoryAsPatResp", 0, 0, GetCurrentUserName(), true) == 1) {
			//cache the current resp type and then select patient
			if (m_listBillTo->CurSel != -1) {
				nOldRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
			}
			m_listBillTo->SetSelByColumn(btcPriority, (long)0);
			PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
			bSwitchedResponsibilitySel = TRUE;
		}

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return BillingItemPtr();
		}

		COleVariant var;
		CString strCPTCode, strCPTSubCode, strDescription, strCPTCategory, strSQL;
		double dblTax1, dblTax2;

		long ServiceID = VarLong(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_ID));

		CString strProductName = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NAME), "");

		long LocationID = -1;
		//TES 7/1/2008 - PLID 26143 - This function now takes a default quantity.
		//double dblQuantity = 1.0; //this can be changed in the ProductItemsDlg or via CheckProductAgainstAllocations()
		double dblQuantity = dblQtyDefault;
		long nChargedProductItemListID = -1;
		long nChargedAllocationDetailListID = -1;

		if (m_LocationCombo->GetCurSel() == -1) {
			LocationID = GetCurrentLocationID();
		}
		else {
			LocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
		}

		// (j.jones 2008-06-12 09:02) - PLID 28379 - don't try to auto-increment if
		// we are told to add from an allocation
		if ((nFromAllocationID == -1 || nFromAllocationDetailID == -1)
			&& GetRemotePropertyInt("ChargeAllowQtyIncrement", 0, 0, "<None>", TRUE) == 1) {
			// (j.jones 2008-06-11 12:21) - PLID 28379 - CheckIncreaseDuplicateChargeQuantity now returns a BillingItem pointer
			BillingItemPtr pLineItem = CheckIncreaseDuplicateChargeQuantity(ServiceID, TRUE, 1.0, bAutoAddingSerialNum);
			if (pLineItem) {

				// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
				if (bSwitchedResponsibilitySel) {
					if (nOldRespType == -1) {
						//there was no resp type, so select the blank row
						m_listBillTo->PutCurSel(-1);
					}
					else {
						m_listBillTo->SetSelByColumn(btcID, nOldRespType);
					}
					PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				}

				return pLineItem;
			}
		}

		//DRT 5/6/03 - Inv items can't be entered to authorizations.  Therefore this should always fail.
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

			// (j.jones 2008-05-01 11:53) - PLID 28606 - this should not fail if the authorization doesn't
			// have any services at all
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (ReturnsRecordsParam("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID)) {

				//there are services on this referral, so NOW we can warn

				if (MsgBox(MB_YESNO, "The chosen item does not exist in your insurance authorization.  Are you sure you wish to select this item?") == IDNO) {

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}

					return BillingItemPtr();
				}
			}
		}

		// (j.jones 2007-11-14 14:14) - PLID 27988 - check to see if this product is in an allocation
		// this *can* change the ServiceID, strProductName, and dblQuantity!
		long nOldServiceID = ServiceID;

		ProductAllocationReturnValue arvRet = arvAddNormally;

		//it's on an allocation, so we need to link to that allocation now

		// (j.jones 2008-06-11 16:27) - PLID 28379 - check that we might have been given an allocation to link to already
		// first see if we are tracking it already
		if (nFromAllocationID != -1 && nFromAllocationDetailID != -1) {

			InvUtils::AllocationMasterInfo *pInfo = NULL;
			int i = 0;
			for (i = 0; i < m_paryAllocationInfo.GetSize() && pInfo == NULL; i++) {
				InvUtils::AllocationMasterInfo *pInfoToCheck = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
				if (pInfoToCheck != NULL && pInfoToCheck->nAllocationID == nFromAllocationID) {
					//we are tracking it, use it
					pInfo = pInfoToCheck;
				}
			}
			arvRet = LaunchAllocationScreen(ServiceID, strProductName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID, pInfo, nFromAllocationID, nFromAllocationDetailID);
		}
		else if (nFromAllocationID == -2) {
			//TES 7/16/2008 - PLID 27983 - Treat this as coming from an allocation, but don't prompt the user about it.
			arvRet = arvUsingAllocation;
		}
		//don't try to add from an allocation if we are auto-adding a specific serial number
		else if (!bAutoAddingSerialNum) {
			arvRet = CheckProductAgainstAllocations(ServiceID, strProductName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID);
		}

		//did the user decide to cancel adding the product?
		if (arvRet == arvAbortAdding) {

			// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
			if (bSwitchedResponsibilitySel) {
				if (nOldRespType == -1) {
					//there was no resp type, so select the blank row
					m_listBillTo->PutCurSel(-1);
				}
				else {
					m_listBillTo->SetSelByColumn(btcID, nOldRespType);
				}
				PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
			}

			return BillingItemPtr();
		}

		//did the product ID change?
		if (ServiceID != nOldServiceID) {
			//make sure we re-select the product row
			// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
			iNewRow = FindProductRowInComboByServiceID(ServiceID, TRUE);
			if (iNewRow < 0) {
				//this would mean the product in the allocation is not billable to this location
				//give a warning
				CString strWarn;
				strWarn.Format("The product '%s' is not billable to the currently selected location on the bill.", strProductName);
				AfxMessageBox(strWarn);

				if (nChargedAllocationDetailListID != -1) {
					DeleteOneFromChargedAllocationDetailsArray(nChargedAllocationDetailListID);
				}

				// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
				if (bSwitchedResponsibilitySel) {
					if (nOldRespType == -1) {
						//there was no resp type, so select the blank row
						m_listBillTo->PutCurSel(-1);
					}
					else {
						m_listBillTo->SetSelByColumn(btcID, nOldRespType);
					}
					PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				}

				return BillingItemPtr();
			}
		}

		//the qty check should be after the allocation check
		// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations
		InvUtils::DoIHaveEnough(ServiceID, LocationID, -GetUnsavedQuantityCount(ServiceID) - (arvRet == arvAddNormally ? dblQuantity : 0.0), -GetUnsavedAllocationQuantityCount(ServiceID), m_EntryType == 2);

		// Check and see if these products have serial numbers or exp. dates.	
		// (j.jones 2007-11-15 13:18) - PLID 27988 - but if bFoundInAllocation is true, and ChargedProductItemListID != -1,
		// then don't compare against the product items
		// (j.jones 2008-06-11 17:31) - PLID 28379 - do not prompt for items if we are auto-adding a serial number
		if (m_EntryType == 1 && arvRet == arvAddNormally && nChargedProductItemListID == -1 && !bAutoAddingSerialNum) {
			CString strWhere = GetProductItemWhereClause();
			if (strWhere.GetLength() > 0)
				strWhere += " AND ";
			// (j.jones 2007-11-21 16:40) - PLID 28037 - ensure we account for allocated items
			if (!IsRecordsetEmpty("SELECT ID FROM ProductItemsT WHERE %s ProductID = %li "
				"AND ID NOT IN (SELECT ProductItemID FROM ChargedProductItemsT) "
				"AND ID NOT IN (SELECT ProductItemID FROM PatientInvAllocationDetailsT "
				"			    WHERE (Status = %li OR Status = %li) "
				"				AND ProductItemID Is Not Null) "
				"AND Deleted = 0  AND (ProductItemsT.LocationID = %li OR ProductItemsT.LocationID Is Null)",
				strWhere, ServiceID, InvUtils::iadsActive, InvUtils::iadsUsed, LocationID)) {

				BOOL bCancel = FALSE;
				BOOL bLoop = TRUE;

				//while we still need to prompt
				while (bLoop) {

					//prompt
					CProductItemsDlg dlg(this);
					dlg.m_EntryType = PI_SELECT_DATA;
					dlg.m_ProductID = ServiceID;
					dlg.m_nLocationID = LocationID;
					dlg.m_CountOfItemsNeeded = (long)dblQuantity;
					dlg.m_strWhere = GetProductItemWhereClause();

					//we will only allow the auto-qty-grow when selecting an individual product
					// (j.jones 2010-11-24 09:53) - PLID 41549 - if this is a package, surgery, or quote (which
					// we know is the case if nLoadDiscountFromChargeID is filled in), don't enable
					// m_bAllowQuantityGrow, which means they will be warned if they increase the quantity
					if (nPackageChargeRefID == -1 && nLoadDiscountFromChargeID == -1) {
						dlg.m_bAllowQtyGrow = TRUE;
					}

					// (j.jones 2010-11-24 09:53) - PLID 41549 - if this is a package, don't let them change
					// the quantity at all
					if (nPackageChargeRefID != -1) {
						dlg.m_bDisallowQtyChange = TRUE;
					}

					if (IDCANCEL == dlg.DoModal()) {
						//if they cancelled, warn them!
						if (IDYES == MessageBox("You have chosen to cancel adding this product."
							"\nThe item will not be added to the list if you do not fill in the requested information."
							"\nAre you SURE you wish to cancel?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
							//if they wish to not bill the item, stop looping, cancel adding this item
							bLoop = FALSE;
							bCancel = TRUE;
						}
					}
					else {
						//if they selected an item, then stop looping
						bLoop = FALSE;
						dblQuantity = dlg.m_CountOfItemsNeeded;
						nChargedProductItemListID = NewChargedProductItemListID();
						AddToChargedProductItemsArray(-2, nChargedProductItemListID, dlg.m_adwProductItemIDs);
					}
				}
				if (bCancel) {
					//if the loop ended with a cancellation, quit

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}

					return BillingItemPtr();
				}
			}
			else {
				//if the product doesn't have any ProductItems, see if it requires them, in which case they cannot bill it
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Name, HasSerialNum, HasExpDate FROM ServiceT "
					"INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
					"WHERE ServiceT.ID = {INT} AND (HasSerialNum = 1 OR HasExpDate = 1)", ServiceID);
				if (!rs->eof) {
					CString strName = AdoFldString(rs, "Name", "");
					BOOL bHasSerialNum = AdoFldBool(rs, "HasSerialNum", FALSE);
					BOOL bHasExpDate = AdoFldBool(rs, "HasExpDate", FALSE);
					CString str;
					str.Format("The product '%s' requires %s%s%s, but has no items in stock.\n"
						"This product cannot be billed until there are items in stock.", strName,
						bHasSerialNum ? "a serial number" : "",
						(bHasSerialNum && bHasExpDate) ? " and " : "",
						bHasExpDate ? "an expiration date" : "");
					AfxMessageBox(str);

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					return BillingItemPtr();
				}
				rs->Close();
			}
		}

		DisableBillingScreen();

		long nPercentOff = 0;
		CString strCode = "";

		//check procedure discounts
		// (j.gruber 2009-03-06 09:09) - PLID 33351 - Load the discount list
		DiscountList *pDiscountList = new DiscountList;
		COleCurrency cyPointsUsed;
		BOOL bUsingPoints = FALSE;

		COleCurrency cyRewardDiscountDollars = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_DISCOUNTDOLLARS), COleCurrency(0, 0));
		long nRewardDiscountPercent = VarLong(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_DISCOUNTPERCENT), 0);
		COleCurrency cyPointCost = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_POINTCOST), COleCurrency(0, 0));

		// (j.jones 2010-11-24 09:33) - PLID 41549 - do not load discounts if this is a package
		if (nPackageChargeRefID == -1) {

			// (j.jones 2010-11-24 09:33) - PLID 41549 - pass in discount information that we may have been given
			LoadDiscountList(TRUE, nLoadDiscountFromChargeID, ServiceID, pDiscountList,
				cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent,
				bUsingPoints, cyPointsUsed, FALSE, bLoadDiscountFromSurgery);
		}

		// (b.eyers 2015-06-17) - PLID 66206 - if there is a provider already passed in, don't need to look one up
		if (nDefaultProviderID == -1) {
			//long nDefaultProviderID = -1;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
			_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
				"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
				"FROM ServiceT "
				"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", ServiceID);
			if (!rs->eof) {
				nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
			}
			rs->Close();
		}

		// (b.eyers 2015-06-17) - PLID 66206 - pass in if this came from an hl7 message
		// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
		// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Keep a reference to the item so we can use its date
		BillingItemPtr pNewBillingItem = AppendChargeToList(nDefaultProviderID, bHL7Bill, nOrdProvider);
		int iLineID = pNewBillingItem->LineID.lVal;

		// CPT code (should be set to InsCode from ProductT table)
		_variant_t v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_INS_CODE);

		if (v.vt != VT_NULL) {
			strCPTCode = CString(v.bstrVal);
		}

		// Description (Name from ServiceT table)
		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NAME);
		if (v.vt != VT_NULL)
			strDescription = CString(v.bstrVal);

		/* Update description on parent billing module dialog */
		CString str;
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDescription);
			}
		}

		// (j.jones 2015-03-18 15:17) - PLID 64974 - Category is now nullable
		_variant_t varCategoryID = g_cvarNull;
		var = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CATEGORYID);
		if (var.vt == VT_I4 && VarLong(var) > 0) {
			varCategoryID = var;
		}
		// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
		_variant_t varCategoryCount = (long)0;
		var = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CATEGORY_COUNT);
		if (var.vt == VT_I4 && VarLong(var) > 0) {
			varCategoryCount = var;
		}

		// Get unit price
		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_SALES_PRICE);
		var = v;
		if (var.vt == VT_NULL)
			var = COleCurrency(0, 0);

		COleCurrency cyDefaultUnitCost = VarCurrency(var);

		// (b.eyers 2015-06-17) - PLID 66206 - the check in the else only works for manually added products
		if (bHL7Bill) {
			COleCurrency cyCheckPrice = *cyUnitPrice;
			if (cyCheckPrice.GetStatus() != COleCurrency::invalid) {
				cyDefaultUnitCost = *cyUnitPrice;
			}
		}
		else {
			// (j.jones 2010-11-23 17:02) - PLID 41549 - if we were given an override cyUnitPrice, use it
			if (cyUnitPrice)
				cyDefaultUnitCost = *cyUnitPrice;
		}

		COleCurrency cyUnitCost = cyDefaultUnitCost;

		// (d.lange 2015-12-01 10:49) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
		long nInsuranceCoID = GetCurrentBillToMostPriInsCoIDForCategory();

		long nPOSID = -1;
		if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
			nPOSID = GetCurrentLocationID();
		}
		else {
			nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
		}

		// (j.jones 2013-04-12 14:02) - PLID 56250 - check for multi-fees (bills only)
		if (m_EntryType == 1) {
			BOOL bMultiFeeExists = FALSE;
			BOOL bWarn = TRUE;
			CString strWarn;
			BOOL bHasAllowable = FALSE;
			COleCurrency cyAllowable = COleCurrency(0, 0);

			// (b.eyers 2015-06-17) - PLID 66206 - updated to use passed in default provider
			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			cyUnitCost = GetMultiFee(ServiceID, nDefaultProviderID != -1 ? nDefaultProviderID : (m_DefaultProvider == -1 ? m_Main_Physician : m_DefaultProvider), (nInsuranceCoID > 0) ? nInsuranceCoID : -1, LocationID, nPOSID, pNewBillingItem->Date, bMultiFeeExists, bWarn, strWarn, bHasAllowable, cyAllowable);

			//if there is no multi-fee or they decline to use it, revert to the default price
			if (!bMultiFeeExists || (bMultiFeeExists && bWarn && IDNO == MessageBox(strWarn, "NexTech", MB_YESNO))) {
				cyUnitCost = cyDefaultUnitCost;
			}

			// (j.jones 2013-04-12 14:02) - PLID 56250 - check for allowables
			//this is outside the above because they can have an allowable without a multifee
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {

					m_billingItems[i]->UnitAllowable = _variant_t(cyAllowable);

					if (bHasAllowable) {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_TRUE, VT_BOOL);

						//products don't have modifiers by default
						COleCurrency cyAllowableTotal = cyAllowable;
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

						RoundCurrency(cyAllowableTotal);

						m_billingItems[i]->TotalAllowable = _variant_t(cyAllowableTotal);
					}
					else {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
						m_billingItems[i]->TotalAllowable = g_cvarNull;
					}
				}
			}
		}

		COleCurrency cyOthrUnit = COleCurrency(0, 0);

		// (j.jones 2013-04-12 13:42) - PLID 56250 - This code used to just build up
		// cyUnitCost and use it as a total. I properly named the variable cyTotal
		// so it's clearer that's what it is really used for.
		COleCurrency cyTotal = cyUnitCost;

		////////////////////////////////////////////////////
		// Get Taxable status

		long TaxType = 2;

		//find the insurance company's taxable status
		TaxType = GetInsuranceCoTaxType(GetCurrentBillToInsuredPartyID());

		COleCurrency taxTotal1, taxTotal2;

		cyTotal = CalculateAmtQuantity(cyTotal, dblQuantity);

		// (j.gruber 2009-03-06 10:50) - PLID 33351 - calculate the total discount
		COleCurrency cyTotalDollarDiscount;
		long nTotalPercent = 0;
		COleCurrency cyTotalLineDiscount;

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		CalculateTotalDiscount(pDiscountList, cyTotal, cyInvalid, nTotalPercent, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);

		cyTotal = (cyTotal * (100000 - nTotalPercent * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cyTotal = cyTotal / long(100000);

		// (a.wetta 2007-05-08 11:17) - PLID 25959 - Subtract the discount from the total
		cyTotal -= cyTotalDollarDiscount;

		//now load the default taxrate for this product
		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_1);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
			dblTax1 = 1.0;
		}
		else {
			dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
		}

		taxTotal1 = CalculateTax(cyTotal, dblTax1);

		dblTax1 -= 1.0;
		dblTax1 *= 100.0;

		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_2);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
			dblTax2 = 1.0;
		}
		else {
			dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
		}

		taxTotal2 = CalculateTax(cyTotal, dblTax2);

		dblTax2 -= 1.0;
		dblTax2 *= 100.0;

		var = cyTotal;
		cyTotal += taxTotal1;
		cyTotal += taxTotal2;

		RoundCurrency(cyTotal);
		_variant_t varTotal = cyTotal;

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->ChargeID = (long)-2;
				m_billingItems[i]->Quantity = (double)dblQuantity;
				m_billingItems[i]->PackageQtyRemaining = (double)dblQuantity;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
				m_billingItems[i]->OriginalPackageQtyRemaining = (double)dblQuantity;
				m_billingItems[i]->ServiceID = ServiceID;
				m_billingItems[i]->CPTCode = _bstr_t(strCPTCode);
				m_billingItems[i]->CPTSubCode = _bstr_t("0");
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
				m_billingItems[i]->CPTCategoryID = varCategoryID;
				// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
				m_billingItems[i]->CPTCategoryCount = varCategoryCount;
				m_billingItems[i]->Description = _bstr_t(strDescription);
				m_billingItems[i]->UnitCost = cyUnitCost;
				m_billingItems[i]->OthrUnitCost = cyOthrUnit;
				// (j.gruber 2009-03-06 09:15) - PLID 33351 - take out discount fields
				//m_billingItems[i]->PercentOff = (long)nPercentOff;
				// (a.wetta 2007-05-08 10:39) - PLID 25959 - Also set the discount
				//m_billingItems[i]->Discount = cyDiscount;
				m_billingItems[i]->DiscountList = pDiscountList;
				m_billingItems[i]->TotalDiscount = cyTotalLineDiscount;
				m_billingItems[i]->TaxRate1 = (double)dblTax1;
				m_billingItems[i]->TaxRate2 = (double)dblTax2;
				m_billingItems[i]->LineTotal = cyTotal;
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				m_billingItems[i]->ItemType = (long)ITEM_TYPE_PRODUCT;
				m_billingItems[i]->Batched.vt = VT_BOOL;
				m_billingItems[i]->Batched.boolVal = TRUE;
				m_billingItems[i]->ChargedProductItemListID = nChargedProductItemListID;
				m_billingItems[i]->ChargedAllocationDetailListID = nChargedAllocationDetailListID;
				m_billingItems[i]->PointsUsed = bUsingPoints ? cyPointsUsed : COleCurrency(0, 0); // (a.walling 2007-05-24 09:36) - PLID 26172
				// (j.jones 2010-11-23 17:02) - PLID 41549 - use our nPackageChargeRefID, even if -1
				m_billingItems[i]->PackageChargeRefID = (long)nPackageChargeRefID;

				// (j.jones 2013-04-12 14:54) - PLID 56250 - load allowables for products
				LoadAllowableColumn(m_billingItems[i], FALSE);

				// (b.eyers 2015-06-17) - PLID 66206 - if whichcodes, mods, and servicedate was passed in, use them
				if (pWhichCodes != NULL) {
					m_billingItems[i]->whichCodes = pWhichCodes;
				}

				if (strMod1 != "") {
					m_billingItems[i]->Modifier1 = _bstr_t(strMod1);
				}
				if (strMod2 != "") {
					m_billingItems[i]->Modifier2 = _bstr_t(strMod2);
				}
				if (strMod3 != "") {
					m_billingItems[i]->Modifier3 = _bstr_t(strMod3);
				}
				if (strMod4 != "") {
					m_billingItems[i]->Modifier4 = _bstr_t(strMod4);
				}
				if (pdtService) {
					m_billingItems[i]->Date = *pdtService;
					m_billingItems[i]->ServiceDateTo = *pdtService;
				}

				// (j.dinatale 2012-06-13 13:34) - PLID 50959 - NDC defaults values
				if (iNewRow >= 0) {

					//bills only
					if (m_EntryType == 1) {
						// (j.dinatale 2012-06-15 10:51) - PLID 51000 - Added claim notes to inventory items
						CString strClaimNote = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CLAIM_NOTE), "");
						strClaimNote.TrimLeft(); strClaimNote.TrimRight();
						if (strClaimNote.GetLength() > 0) {
							AddNewUnsavedChargeNote(m_billingItems[i], strClaimNote, TRUE);
						}

						CString strNDCCode = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFCODE), "");
						double dblNDCQty = VarDouble(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFQTY), 0.0);
						COleCurrency cyNDCUnitPrice = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
						CString strNDCUnitType = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITTYPE), "");

						m_billingItems[i]->NDCCode = strNDCCode;
						m_billingItems[i]->DrugUnitPrice = cyNDCUnitPrice;
						m_billingItems[i]->DrugUnitType = strNDCUnitType;
						m_billingItems[i]->DrugUnitQuantity = dblNDCQty;
					}

					//the remaining features are for bills and quotes

					// (j.jones 2016-04-07 13:16) - NX-100077 - added RememberChargeProvider setting
					bool bRememberChargeProvider = VarBool(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_REMEMBER_CHARGE_PROVIDER), FALSE) ? true : false;
					if (bRememberChargeProvider) {
						//this function will auto-update the provider to the last one who sold
						//the patient this product, if a prior sale exists
						UpdateChargeToMostRecentProviderSold(m_billingItems[i]);
					}
				}

				// (j.jones 2014-05-01 08:36) - PLID 61837 - the new charge may
				// potentially show additional provider columns
				if (m_EntryType == 1) {
					TryShowChargeProviderColumns(m_billingItems[i], true);
				}
			}
		}

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {

				// (j.jones 2008-06-11 13:02) - PLID 28379 - track the BillingItem
				pLineItem = m_billingItems[i];

				//find the item in the list
				RPCList *list = m_billingItems[i]->RPCList;

				//DRT 6/30/03 - For the same reason as the quotes (6/16/03 note), this does
				//		not need to be added for patient resp, only insurance resp!
				long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
				if (nInsuredPartyID > 0) {

					bool bFoundResp = false;
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int j = 0;
					for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
						if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
							bFoundResp = true;
					}

					if (bFoundResp) {
						//at this point, var is the amount before tax, and varTotal is the amount with tax
						//use the insurance TaxType to determine which responsibility gets which amount
						if (TaxType == 1)
							UpdateListInsAmount(list, j, varTotal);
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							UpdateListInsAmount(list, j, var);
					}
					else {
						//we're looking at insurance, but there's nothing in our list!  we
						//need to add it
						RespPerCharge rpc;
						rpc.InsuredPartyID = nInsuredPartyID;

						if (TaxType == 1)
							rpc.InsAmount = varTotal;
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							rpc.InsAmount = var;

						// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
						rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
						rpc.RespTypeName = GetCurrentBillToRespTypeName();

						list->aryRPC.Add(rpc);
					}
				}
			}
		}

		// (a.walling 2007-09-21 14:49) - PLID 26172 - CalculateLineTotal should be called here
		m_varBoundItem = (long)iLineID;


		// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
		CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

		////////////////////////////////////////////////////
		if (m_EntryType == 1)
			FillBillList();
		else
			FillQuoteList();

		// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
		// use the row instead of the LineID
		// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
		IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
		InsertRowSorted(pRowToSort, cyTotal);

		EnableBillingScreen();

		////////////////////////////////////////////////////
		// Recalculate the bill total
		CalculateTotal();

		PostChargeAdded();

		// (j.jones 2007-11-15 13:57) - PLID 27988 - Any allocation we opened, we should be done with it now,
		// so force it to be resolved. But if it returns FALSE, don't worry about it too much here,
		// ValidateChanges will require it before closing.
		//TES 7/17/2008 - PLID 27983 - If bMassAdding is true, our caller will ForceResolveAllAllocations() once it's done adding
		// charges.
		if (!bMassAdding && !ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}

		// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
		if (bSwitchedResponsibilitySel) {
			if (nOldRespType == -1) {
				//there was no resp type, so select the blank row
				m_listBillTo->PutCurSel(-1);
			}
			else {
				m_listBillTo->SetSelByColumn(btcID, nOldRespType);
			}
			PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
		}

		return pLineItem;

	}NxCatchAll(__FUNCTION__);

	return BillingItemPtr();
}

void CBillingDlg::OnSelChosenComboQuote(long iNewRow)
{
	try {

		if (iNewRow == -1) {
			return;
		}

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return;
		}

		// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
		CMaintainFocus maintainFocus(__FUNCTION__);

		_variant_t v = m_QuotesCombo->GetValue(iNewRow, 0);
		if (v.vt == VT_I4) {
			// (j.jones 2008-06-24 14:33) - PLID 30458 - moved all of this logic to PostSelChosenComboQuote
			PostSelChosenComboQuote(VarLong(v));
		}

	}NxCatchAll("Error in CBillingDlg::OnSelChosenComboQuote");
}

// (j.jones 2008-06-24 14:31) - PLID 30458 - PostSelChosenComboQuote()
// is used to bill a quote, but separate from the OnSelChosen function
// (j.jones 2012-01-17 16:18) - PLID 47537 - added EMNID as a parameter
void CBillingDlg::PostSelChosenComboQuote(long nQuoteID, long nAppointmentID /*= -1*/, long nEMNID /*= -1*/)
{
	try {

		if (nQuoteID == -1) {
			return;
		}

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return;
		}

		// (j.jones 2012-01-19 12:40) - PLID 47653 - track the insured party ID and resp. name currently selecte
		long nCurInsuredPartyID = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcInsuredPartyID));
		CString strCurRespTypeName = VarString(m_listBillTo->GetValue(m_listBillTo->CurSel, btcRespName));

		CWaitCursor pWait;

		BOOL bDeleteQuote = FALSE;

		_RecordsetPtr rs, rsTrack, rsDtls;
		CString str;
		long DeletedQuoteType = 4;
		long AuditID = -1;

		// (j.jones 2006-10-16 16:36) - PLID 23094 - the package type and
		// payment plan ultimately become member variables, but the
		// particular quote we are billing might not be a package
		// (i.e. we can bill a package and then a normal quote, just not two packages)
		long nThisPackageType = -1;
		BOOL bThisIsAPaymentPlan = FALSE;

		// (j.jones 2007-08-10 10:49) - PLID 23769 - locally track the value of
		// m_bQuoteFromPopupWindow, but reset it to false so it is accurate after this
		// function exits
		BOOL bQuoteFromPopupWindow = m_bQuoteFromPopupWindow;
		m_bQuoteFromPopupWindow = FALSE;

		EnsureRemoteData();

		// (j.jones 2007-03-26 14:41) - PLID 25287 - potentially used if we need
		// to offset the the charge to meet the package amount
		COleCurrency cyMatchRemainingPackageAmount = COleCurrency(0, 0);
		long nMatchRemAmountToChargeID = -1;
		BOOL bWarnSplitPackageCharges = FALSE;

		/****************************************************************************************
		* Check all the items being added to make sure it fits the authorization.  This is		*
		* probably somewhat slow, but this case really should never come up, it just doesn't	*
		* make sense.																			*
		****************************************************************************************/

		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

			try {
				//we need to loop through every item being added and compare them against the items 
				//in our referral
				bool bOneFailed = false;

				//setup an array for all the items we'll need to be checking in the auth
				CArray<long, long> aryAuthIDs;
				_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
				while (!rsAuth->eof) {
					aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
					rsAuth->MoveNext();
				}
				rsAuth->Close();

				// (j.jones 2008-05-01 11:53) - PLID 28606 - do not bother checking if services match
				// if the referral has no services in it
				if (aryAuthIDs.GetSize() > 0) {

					_RecordsetPtr rsAuthCheck = CreateParamRecordset("SELECT ServiceID FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID WHERE Type = 11 AND BillID = {INT} AND Deleted = 0", nQuoteID);
					while (!rsAuthCheck->eof && !bOneFailed) {
						long nServiceID = AdoFldLong(rsAuthCheck, "ServiceID");

						bool bFound = false;
						for (int i = 0; i < aryAuthIDs.GetSize() && !bFound; i++) {
							if (aryAuthIDs.GetAt(i) == nServiceID)
								bFound = true;
						}

						if (!bFound)
							bOneFailed = true;

						rsAuthCheck->MoveNext();
					}

					if (bOneFailed) {
						if (MsgBox(MB_YESNO, "At least one item selected on this quote does not match your insurance authorization.\n"
							"Are you sure you wish to add this quote?") == IDNO) {
							return;
						}
					}
				}

			} NxCatchAll("Error determining authorization status for a quote.");
		}

		// (j.jones 2008-05-22 11:56) - PLID 28450 - added a new package charge array
		// that replaced the old service & quantity arrays
		CArray<PackageChargeObject*, PackageChargeObject*> arypPackageCharges;

		/************************************
		* Delete an existing quote          *
		*************************************/

		//this boolean will decide if we prompt to delete the quote
		BOOL prompt = TRUE;
		CString strMsg = "Would you like to delete the original quote?";

		//check to see if this quote has expired
		rs = CreateParamRecordset("SELECT UseExp, ExpDays, Date FROM BillsT WHERE ID = {INT}", nQuoteID);
		if (!rs->eof) {
			_variant_t varTmp;

			varTmp = rs->Fields->Item["UseExp"]->Value;
			if (varTmp.vt == VT_BOOL && varTmp.boolVal) {
				//this quote expires
				varTmp = rs->Fields->Item["ExpDays"]->Value;
				if (varTmp.vt == VT_I4) {
					long ExpDays = varTmp.lVal;

					//we decided that 0 and 1 will both mean it expires today
					if (ExpDays <= 0)
						ExpDays = 1;

					COleDateTime dtExp, dtNow;
					COleDateTimeSpan dtSpan;
					dtSpan.SetDateTimeSpan(ExpDays, 0, 0, 0);

					dtExp = rs->Fields->Item["Date"]->Value.date;
					dtExp += dtSpan;

					dtNow = COleDateTime::GetCurrentTime();

					//the expiration date is the quote date + days to expiration.
					if (dtExp < dtNow) {
						// (j.jones 2011-06-24 12:01) - PLID 21441 - changed to be a warning, rather than a restriction
						if (IDNO == MessageBox("This quote has expired. Are you sure you still wish to bill this expired quote?",
							"Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
							return;
						}
					}
				}
			}
		}
		rs->Close();

		//check to see if this quote is a package
		// (j.jones 2008-05-30 12:39) - PLID 28898 - ensured we ignore charges that have an outside fee with no practice fee
		rs = CreateParamRecordset("SELECT Type, CurrentAmount, TotalAmount, TotalCount, CurrentCount, PackageChargesQ.MultiUseTotalCount, PackageChargesQ.MultiUseCurrentCount "
			"FROM PackagesT "
			"LEFT JOIN "
			"	(SELECT ChargesT.BillID, Sum(Quantity) AS MultiUseTotalCount, Sum(PackageQtyRemaining) AS MultiUseCurrentCount "
			"	FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID WHERE Deleted = 0 "
			"	AND (LineItemT.Amount > Convert(money,0) OR ChargesT.OthrBillFee = Convert(money,0)) "
			"	GROUP BY BillID "
			"	) AS PackageChargesQ ON PackagesT.QuoteID = PackageChargesQ.BillID "
			"WHERE QuoteID = {INT}", nQuoteID);
		if (!rs->eof) {

			//if not eof, then it IS a package

			if (m_nPackageID != -1 && m_nPackageID != nQuoteID) {
				AfxMessageBox("A different package is already referenced on this bill. Multiple packages are not supported on one bill.");
				return;
			}

			// (j.jones 2007-08-10 10:20) - PLID 23769 - If the preference is enabled to not bill non-prepaid packages,
			// check whether the package is covered before we continue.
			// Also check the bQuoteFromPopupWindow boolean - if TRUE, then we came from the popup window that would have
			// been responsible for already running these calculations, thus we do not need to take the time to do them again.
			long nDoNotBillNonPrepaidPackages = GetRemotePropertyInt("DoNotBillNonPrepaidPackages", 0, 0, "<None>", TRUE);
			if (nDoNotBillNonPrepaidPackages > 0 && !bQuoteFromPopupWindow) {

				//logic copied largely from the Show Packages dialog

				double dblCurrentCount, dblTotalCount;

				long nType = AdoFldLong(rs, "Type", 1);

				if (nType == 1)
					dblTotalCount = (double)AdoFldLong(rs, "TotalCount", 0);
				else if (nType == 2)
					dblTotalCount = AdoFldDouble(rs, "MultiUseTotalCount", 0.0);
				else
					dblTotalCount = 0.0;

				if (nType == 1)
					dblCurrentCount = (double)AdoFldLong(rs, "CurrentCount", 0);
				else if (nType == 2)
					dblCurrentCount = AdoFldDouble(rs, "MultiUseCurrentCount", 0.0);
				else
					dblCurrentCount = 0.0;

				COleCurrency cyTotalCostNoTax = AdoFldCurrency(rs, "TotalAmount", COleCurrency(0, 0));

				COleCurrency cyUnBilledNoTax = AdoFldCurrency(rs, "CurrentAmount", COleCurrency(0, 0));

				COleCurrency cyPrePays = CalculatePrePayments(m_nPatientID, nQuoteID, GetRemotePropertyInt("IncludeAllPrePaysInPopUps", 1, 0, "<None>", TRUE) == 1);

				//just to save some work here - if we have no prepayments
				//and there is a positive unbilled amount, just give up
				//as we can't possibly cover one use
				if (cyPrePays == COleCurrency(0, 0) && cyUnBilledNoTax > COleCurrency(0, 0)) {
					//just to save some work here - if we have no prepayments
					//and there is a positive unbilled amount, just give up
					//as we can't possibly cover one use

					CString str, strType;
					if (nDoNotBillNonPrepaidPackages == 1) {
						strType = "the full unbilled balance";
					}
					else {
						strType = "one use";
					}
					str.Format("This patient does not have enough available prepayments to cover %s of this package.\n"
						"Your preferences are set to disallow billing any package without enough prepayments to cover %s.",
						strType, strType);
					AfxMessageBox(str);
					return;
				}

				BOOL bHasTax = FALSE;

				COleCurrency cyTotalCostWithTax = CalculateTotalPackageValueWithTax(nQuoteID);

				COleCurrency cyUnBilledWithTax;

				//if the balances are different, tax exists, so make sure we also grab the other amounts with tax
				if (cyTotalCostNoTax != cyTotalCostWithTax) {
					bHasTax = TRUE;
					cyUnBilledWithTax = CalculateRemainingPackageValueWithTax(nQuoteID);
				}
				else {
					cyUnBilledWithTax = cyUnBilledNoTax;
				}

				//now check if we are comparing to the unbilled amount, or one-use amount
				if (nDoNotBillNonPrepaidPackages == 1) {

					//compare to the full, unbilled amount
					if (cyPrePays < cyUnBilledWithTax) {
						AfxMessageBox("This patient does not have enough available prepayments to cover the full unbilled balance of this package.\n"
							"Your preferences are set to disallow billing any package without enough prepayments to cover the full unbilled balance.");
						return;
					}
				}
				else {
					//calculate the value of one instance of the package
					COleCurrency cyOneUse = COleCurrency(0, 0);

					if (dblCurrentCount <= 1.0)
						//if there is 1 use left, it is the remaining balance
						//if there is 0 left, then the balance is 0 anyways
						if (bHasTax) {
						cyOneUse = cyUnBilledWithTax;
						}
						else {
							cyOneUse = cyUnBilledNoTax;
						}
					else {
						//one use is the package cost / package count
						if (bHasTax) {
							cyOneUse = (cyTotalCostWithTax / dblTotalCount);
						}
						else {
							cyOneUse = (cyTotalCostNoTax / dblTotalCount);
						}
						RoundCurrency(cyOneUse);
					}

					// (j.jones 2011-07-15 15:21) - PLID 38334 - if there are uses left,
					// but the unbilled amount is zero, then one use is also zero
					if (bHasTax) {
						if (cyUnBilledWithTax <= COleCurrency(0, 0)) {
							cyOneUse = COleCurrency(0, 0);
						}
					}
					else {
						if (cyUnBilledNoTax <= COleCurrency(0, 0)) {
							cyOneUse = COleCurrency(0, 0);
						}
					}

					//ok, now we have the cyOneUse price, do we have prepayments to cover it?

					if (cyPrePays < cyOneUse) {

						//nope, not enough prepays
						AfxMessageBox("This patient does not have enough available prepayments to cover one use of this package.\n"
							"Your preferences are set to disallow billing any package without enough prepayments to cover one use.");
						return;
					}
				}

				//if we get here, we must have enough prepays, so go ahead and bill it
			}

			//1 is a repeat package, 2 is a multi-use package
			m_nPackageType = AdoFldLong(rs, "Type", 1);
			nThisPackageType = m_nPackageType;

			if (nThisPackageType == 1) {	//repeat package
				_variant_t varTmp;
				varTmp = rs->Fields->Item["CurrentCount"]->Value;
				if (varTmp.vt == VT_I4) {
					//first check to see if the package count is valid

					if ((varTmp.lVal - m_RepeatPackageUses) < 1) {
						AfxMessageBox("This package has been used up. Please go to the Quotes tab to add more uses, or delete the quote entirely.");
						return;
					}

					//don't do this until we actually save the bill!
					//decrement the package count
					//ExecuteSql("UPDATE PackagesT SET CurrentCount = %li WHERE QuoteID = %li",(varTmp.lVal - 1),QuoteID);

					//TODO: Make sure there is an option to use/not use payment plans,
					//in which case this boolean may not always be set to true

					// (j.jones 2011-06-24 16:16) - PLID 27672 - if we deleted all the charges,
					// there is no reason to give a warning
					if (m_bIsABilledPackage && m_pList->GetRowCount() > 0) {

						if (IDNO == MessageBox("The bill already references this package, do you wish to bill this package again?", "Practice", MB_ICONEXCLAMATION | MB_YESNO))
							return;

						m_RepeatPackageUses++;
					}
					else
						m_RepeatPackageUses = 1;

					//we are billing this package now, so let's set all charges to zero so we can use the payment plan
					m_bPaymentPlan = TRUE;
					bThisIsAPaymentPlan = m_bPaymentPlan;

					m_bIsABilledPackage = TRUE;

					m_nPackageID = nQuoteID;

					// Update description on parent billing module dialog
					// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
					if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
						// (j.gruber 2012-01-04 11:44) - PLID 46291
						SetBillDescriptionBasedOnResp();
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
						str = GetBillDescription();
						if (str.GetLength() == 0) {
							m_rsBill = CreateParamRecordset("SELECT Description FROM BillsT WHERE ID = {INT}", nQuoteID);
							CString strDesc = AdoFldString(m_rsBill, "Description", "");
							if (GetRemotePropertyInt("ShowPackageIterationsInBillDesc", 1, 0, "<None>", TRUE) == 1) {
								//the user wants to see the package iteration as part of the bill description
								long nPackageTotalCount = AdoFldLong(rs, "TotalCount", 0);
								long nPackageCurrentCount = AdoFldLong(rs, "CurrentCount", 0);
								str.Format(" (%li of %li)", nPackageTotalCount - nPackageCurrentCount + 1, nPackageTotalCount);
								strDesc += str;
							}
							// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
							SetBillDescription(strDesc);
							m_rsBill->Close();
						}
					}

					//if the package count is zero, then we can prompt to delete
					// (j.jones 2010-04-09 09:27) - PLID 27671 - we no longer do this
					/*
					if((varTmp.lVal - m_RepeatPackageUses) < 1) {
					prompt = TRUE;
					strMsg = "This package has now been used up. Would you like to delete the original quote?\nIf not, you will have to go to the Quotes tab to add more uses.";
					}
					else {
					prompt = FALSE;
					}
					*/
				}
			}
			else {	//multi-use package

				BOOL bPackageHasBeenBilled = FALSE;

				//first calculate any existing uses on this bill and propagate the dialog
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int i = 0;
				for (i = 0; i < (int)m_billingItems.size(); i++) {
					long nPackageChargeRefID = VarLong(m_billingItems[i]->PackageChargeRefID, -1);
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (nPackageChargeRefID != -1 && ReturnsRecordsParam("SELECT ID FROM ChargesT WHERE BillID = {INT} AND ID = {INT}", nQuoteID, nPackageChargeRefID)) {

						bPackageHasBeenBilled = TRUE;

						//okay this package has been added to this bill already
						long nChargeID = VarLong(m_billingItems[i]->ChargeID, -2);
						long nServiceID = VarLong(m_billingItems[i]->ServiceID, -1);
						double dblQuantity = VarDouble(m_billingItems[i]->Quantity, 0.0);
						if (nChargeID != -2) {
							//if it has been saved before, we can't know for sure if they haven't changed the quantity
							//so reload it and adjust accordingly
							// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
							_RecordsetPtr rsQty = CreateParamRecordset("SELECT Quantity FROM ChargesT WHERE ID = {INT}", nChargeID);
							if (!rsQty->eof) {
								double dblOldQuantity = AdoFldDouble(rsQty, "Quantity", 0.0);
								dblQuantity -= dblOldQuantity;
							}
							rsQty->Close();
						}
						if (dblQuantity != 0.0) {
							//add to the list
							BOOL bFound = FALSE;

							// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array
							// that replaced the old service & quantity arrays

							for (int j = 0; j < arypPackageCharges.GetSize(); j++) {

								PackageChargeObject *pCharge = (PackageChargeObject*)(arypPackageCharges.GetAt(j));

								if (pCharge->nPackageChargeID == nPackageChargeRefID) {
									pCharge->dblQuantity += dblQuantity;
									bFound = TRUE;
								}
							}
							if (!bFound) {
								PackageChargeObject *pNew = new PackageChargeObject;
								pNew->nPackageChargeID = nPackageChargeRefID;
								pNew->nServiceID = nServiceID;
								pNew->dblQuantity = dblQuantity;
								arypPackageCharges.Add(pNew);
							}
						}
					}
				}

				// (j.jones 2007-07-02 16:30) - PLID 25349 - do the same calculation
				// again but on deleted, previously saved charges, that way if they delete
				// a charge on accident, they don't have to close and reopen the bill to re-add it								

				for (i = 0; i < m_adwDeletedCharges.GetSize(); i++) {

					long nDeletedChargeID = (long)(m_adwDeletedCharges.GetAt(i));

					if (nDeletedChargeID > 0) {

						//have to query from data, which is annoying but we would have had
						//to do it anyways were it in memory, because we need what it was in data
						_RecordsetPtr rsDeletedCharge = CreateParamRecordset("SELECT Quantity, ServiceID, PackageChargeRefID FROM ChargesT "
							"WHERE ID = {INT} AND PackageChargeRefID Is Not Null AND PackageChargeRefID IN (SELECT ID FROM ChargesT WHERE BillID = {INT})",
							nDeletedChargeID, nQuoteID);

						if (!rsDeletedCharge->eof) {

							long nServiceID = AdoFldLong(rsDeletedCharge, "ServiceID", -1);
							double dblQuantity = -AdoFldDouble(rsDeletedCharge, "Quantity", 0.0);
							long nPackageChargeRefID = AdoFldLong(rsDeletedCharge, "PackageChargeRefID", -1);

							// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array
							// that replaced the old service & quantity arrays

							//add this service and a negative of its quantity to our list
							BOOL bFound = FALSE;
							for (int j = 0; j < arypPackageCharges.GetSize(); j++) {

								PackageChargeObject *pCharge = (PackageChargeObject*)(arypPackageCharges.GetAt(j));

								if (pCharge->nPackageChargeID == nPackageChargeRefID) {
									pCharge->dblQuantity += dblQuantity;
									bFound = TRUE;
								}
							}
							if (!bFound) {
								PackageChargeObject *pNew = new PackageChargeObject;
								pNew->nPackageChargeID = nPackageChargeRefID;
								pNew->nServiceID = nServiceID;
								pNew->dblQuantity = dblQuantity;
								arypPackageCharges.Add(pNew);
							}
						}
						rsDeletedCharge->Close();
					}
				}

				//now that we have the total amount used on this bill, if any,
				//check and see if there are any uses left on this package
				_RecordsetPtr rsCheckPackage = CreateParamRecordset("SELECT ChargesT.ID, ServiceID, PackageQtyRemaining "
					"FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"WHERE Deleted = 0 AND (LineItemT.Amount > Convert(money,0) OR ChargesT.OthrBillFee = Convert(money,0)) AND BillID = {INT} ", nQuoteID);
				BOOL bAnyUsesRemaining = FALSE;
				while (!rsCheckPackage->eof && !bAnyUsesRemaining) {

					//check the remaining quantity
					long nServiceID = AdoFldLong(rsCheckPackage, "ServiceID");
					double dblQtyRemaining = AdoFldDouble(rsCheckPackage, "PackageQtyRemaining", 0.0);
					long nPackageChargeID = AdoFldLong(rsCheckPackage, "ID");

					//if zero, then there are obviously no services remaining...
					if (dblQtyRemaining <= 0.0)
						bAnyUsesRemaining = FALSE;
					else
						bAnyUsesRemaining = TRUE;

					// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array
					// that replaced the old service & quantity arrays

					//...unless the service is in our list, in which the total may have been changed
					for (i = 0; i < arypPackageCharges.GetSize(); i++) {

						PackageChargeObject *pCharge = (PackageChargeObject*)(arypPackageCharges.GetAt(i));

						if (pCharge->nPackageChargeID == nPackageChargeID) {
							//if so, see if the total amount remaining minus the changes on this bill is still > 0
							if (dblQtyRemaining - pCharge->dblQuantity > 0.0) {
								bAnyUsesRemaining = TRUE;
							}
							else {
								bAnyUsesRemaining = FALSE;
							}
						}
					}

					rsCheckPackage->MoveNext();
				}
				rsCheckPackage->Close();

				if (!bAnyUsesRemaining) {
					AfxMessageBox("This package has been used up. Please go to the Quotes tab to add more uses, or delete the quote entirely.");

					// (j.jones 2008-05-22 12:05) - PLID 28450 - clean up our package array
					for (int i = arypPackageCharges.GetSize() - 1; i >= 0; i--) {
						delete (PackageChargeObject*)(arypPackageCharges.GetAt(i));
					}
					arypPackageCharges.RemoveAll();
					return;
				}

				//if anything is in this list at all, OR the billed quote is the quote ID, it's been billed before

				// (j.jones 2011-06-24 16:16) - PLID 27672 - if we deleted all the charges,
				// there is no reason to give a warning
				if ((bPackageHasBeenBilled || arypPackageCharges.GetSize() > 0 || m_nPackageID == nQuoteID) && m_pList->GetRowCount() > 0) {
					if (IDNO == MessageBox("The bill already references this package, do you wish to bill this package again?", "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {

						// (j.jones 2008-05-22 12:05) - PLID 28450 - clean up our package array
						for (int i = arypPackageCharges.GetSize() - 1; i >= 0; i--) {
							delete (PackageChargeObject*)(arypPackageCharges.GetAt(i));
						}
						arypPackageCharges.RemoveAll();
						return;
					}
				}

				CPackageUseSelectionDlg dlg(this);
				dlg.m_nQuoteID = nQuoteID;

				// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array
				// that replaced the old service & quantity arrays

				//propagate the lists, if we have any data already
				for (i = 0; i < arypPackageCharges.GetSize(); i++) {

					PackageChargeObject *pCharge = (PackageChargeObject*)(arypPackageCharges.GetAt(i));

					// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array
					// that replaced the old service & quantity arrays
					PackageChargeObject *pNew = new PackageChargeObject;
					pNew->nPackageChargeID = pCharge->nPackageChargeID;
					pNew->nServiceID = pCharge->nServiceID;
					pNew->dblQuantity = pCharge->dblQuantity;
					dlg.m_arypPackageCharges.Add(pNew);
				}

				// (j.jones 2008-05-22 12:05) - PLID 28450 - now empty our package array,
				// because we are going to reload it shortly
				for (i = arypPackageCharges.GetSize() - 1; i >= 0; i--) {
					delete (PackageChargeObject*)(arypPackageCharges.GetAt(i));
				}
				arypPackageCharges.RemoveAll();

				if (dlg.DoModal() == IDCANCEL) {
					//the dialog will have warned them before cancelling
					return;
				}

				for (i = 0; i < dlg.m_arypPackageCharges.GetSize(); i++) {

					// (j.jones 2008-05-22 11:49) - PLID 28450 - added a new package charge array					
					// that replaced the old service & quantity arrays

					PackageChargeObject *pCharge = (PackageChargeObject*)(dlg.m_arypPackageCharges.GetAt(i));

					PackageChargeObject *pNew = new PackageChargeObject;
					pNew->nPackageChargeID = pCharge->nPackageChargeID;
					pNew->nServiceID = pCharge->nServiceID;
					pNew->dblQuantity = pCharge->dblQuantity;
					arypPackageCharges.Add(pNew);
				}

				// (j.jones 2007-03-26 14:41) - PLID 25287 - if the package is now finished,
				// see if we are given an offset amount to match the package total
				// (j.jones 2011-02-03 09:12) - PLID 42291 - changed to calculate the package charge ID, not service ID
				if (dlg.m_nMatchRemAmountToChargeID != -1 && dlg.m_cyMatchRemainingPackageAmount != COleCurrency(0, 0)) {
					nMatchRemAmountToChargeID = dlg.m_nMatchRemAmountToChargeID;
					cyMatchRemainingPackageAmount = dlg.m_cyMatchRemainingPackageAmount;
				}

				//we are billing this package now, so let's set all charges to zero so we can use the payment plan
				m_bPaymentPlan = TRUE;
				bThisIsAPaymentPlan = m_bPaymentPlan;

				m_bIsABilledPackage = TRUE;

				m_nPackageID = nQuoteID;

				// Update description on parent billing module dialog
				// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
				if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
					// (j.gruber 2012-01-04 11:44) - PLID 46291
					SetBillDescriptionBasedOnResp();
					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
					str = GetBillDescription();
					if (str.GetLength() == 0) {
						m_rsBill = CreateParamRecordset("SELECT Description FROM BillsT WHERE ID = {INT}", nQuoteID);
						CString strDesc = AdoFldString(m_rsBill, "Description");
						/*
						if(GetRemotePropertyInt("ShowPackageIterationsInBillDesc",1,0,"<None>",TRUE) == 1) {
						//the user wants to see the package iteration as part of the bill description
						long nPackageTotalCount = AdoFldLong(rs, "TotalCount",0);
						long nPackageCurrentCount = AdoFldLong(rs, "CurrentCount",0);
						str.Format(" (%li of %li)",nPackageTotalCount-nPackageCurrentCount+1, nPackageTotalCount);
						strDesc += str;
						}
						*/
						// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
						SetBillDescription(strDesc);
						m_rsBill->Close();
					}
				}

				//if they have chosen to bill the last of the services, prompt to delete
				// (j.jones 2010-04-09 09:27) - PLID 27671 - we no longer do this
				/*
				if(dlg.m_bPackageIsUsedUp) {
				prompt = TRUE;
				strMsg = "This package has now been used up. Would you like to delete the original quote?\nIf not, you will have to go to the Quotes tab to add more uses.";
				}
				else {
				prompt = FALSE;
				}
				*/
			}
		}
		else {	//is not a package

			// (j.jones 2010-04-09 09:15) - PLID 27671 - the ability to delete a billed quote now only applies
			// to quotes, not packages, so only call this code for non-package quotes

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (ReturnsRecordsParam("SELECT ID FROM EventsT WHERE ID IN (SELECT EventID FROM EventAppliesT) AND Type = {INT} AND ItemID = {INT}", PhaseTracking::ET_QuoteCreated, nQuoteID)
				|| ReturnsRecordsParam("SELECT QuoteID FROM ProcInfoQuotesT WHERE QuoteID = {INT}", nQuoteID)
				|| ReturnsRecordsParam("SELECT ActiveQuoteID FROM ProcInfoT WHERE ActiveQuoteID = {INT}", nQuoteID)) {
				//Deleting the quote could mess up tracking, so we don't want to even give them the chance to.
				prompt = FALSE;
			}
			if (prompt) {

				int QuoteDeletionPref = GetRemotePropertyInt("QuoteDeletionPref", 0, 0, "<None>", TRUE);

				//0 = prompt, 1 = delete, 2 = do nothing
				if (QuoteDeletionPref == 1 || (QuoteDeletionPref == 0 && IDYES == MessageBox(strMsg, NULL, MB_YESNO))) {
					//it will be deleted from data later, not right away
					bDeleteQuote = TRUE;
					m_QuotesCombo->RemoveRow(m_QuotesCombo->GetCurSel());
					m_QuotesCombo->PutCurSel(-1);
				}
			}
		}
		rs->Close();

		/************************************
		* Bill the quote		            *
		*************************************/

		DisableBillingScreen();

		// (j.jones 2008-05-02 09:25) - PLID 27685 - ensure that the CPT list has been requeried
		// prior to trying to search the list, which we will do later in this function
		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}

		//Update Place Of Service on bill dialog;
		m_rsBill = CreateParamRecordset("SELECT Location, ServiceLocationID, PatCoord FROM BillsT "
			"INNER JOIN ChargesT ON BillsT.ID = ChargesT.BillID "
			"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID WHERE LineItemT.Deleted = 0 AND BillsT.ID = {INT}", nQuoteID);
		if (!m_rsBill->eof) {
			//Update Place Of Service on bill dialog;

			// (j.jones 2011-08-24 08:41) - PLID 44868 - call TryChangePlaceOfService,
			// as we might not be allowed to change the place of service
			TryChangePlaceOfService(VarLong(m_rsBill->Fields->Item["Location"]->Value, -1));

			m_DesignationCombo->SetSelByColumn(posdcID, m_rsBill->Fields->Item["ServiceLocationID"]->Value);

			//Update the Patient Coordinator
			long nPatCoordID = AdoFldLong(m_rsBill, "PatCoord", -1);
			if (nPatCoordID != -1) {
				//update the patient coordinator automatically if the current one selected is the default
				//or is empty, otherwise prompt to update
				long nCurSel = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetCurSel();
				long nSelCoordID = -1;
				if (nCurSel != -1)
					nSelCoordID = VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->GetValue(nCurSel, 0), -1);

				CString strBillPCName, strQuotePCName;
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT First + ' ' + Last AS Name FROM PersonT WHERE ID = {INT}", nSelCoordID);
				if (!rs->eof) {
					strBillPCName = AdoFldString(rs, "Name", "");
				}
				rs->Close();
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				rs = CreateParamRecordset("SELECT First + ' ' + Last AS Name FROM PersonT WHERE ID = {INT}", nPatCoordID);
				if (!rs->eof) {
					strQuotePCName = AdoFldString(rs, "Name", "");
				}
				rs->Close();

				CString strPrompt;
				strPrompt.Format("Would you like to change the bill's patient coordinator (%s) "
					"to the patient coordinator selected on the quote (%s)?", strBillPCName, strQuotePCName);

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (nSelCoordID == -1 || ReturnsRecordsParam("SELECT EmployeeID FROM PatientsT WHERE PatientsT.PersonID={INT} AND EmployeeID = {INT}", m_nPatientID, nSelCoordID)
					|| IDYES == MessageBox(strPrompt, "Practice", MB_ICONQUESTION | MB_YESNO)) {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_CoordCombo->TrySetSelByColumn(0, nPatCoordID);

					//if the patient coordinator column is not shown, auto-update all the charges to reflect the new coordinator
					if (m_bBillPatCoord) {
						UpdatePatCoordIDs(nPatCoordID);
					}

				}
			}

			//see if there are associated EMNs
			// (j.jones 2012-01-19 12:24) - PLID 47653 - we now track the insured party ID as well, but there would not
			// be one for a quote, so we have to use the currently selected one
			_RecordsetPtr rsEMR = CreateParamRecordset("SELECT EMNID FROM BilledEMNsT WHERE BillID = {INT}", nQuoteID);
			while (!rsEMR->eof) {

				long nEMNID = AdoFldLong(rsEMR, "EMNID", -1);

				//add to our list, if it's not already there
				BOOL bFound = FALSE;
				for (int i = 0; i < m_aryBilledEMNInfo.GetSize(); i++) {
					BilledEMNInfo eInfo = (BilledEMNInfo)m_aryBilledEMNInfo.GetAt(i);
					if (eInfo.nEMNID == nEMNID && eInfo.nInsuredPartyID == nCurInsuredPartyID) {
						bFound = TRUE;
					}
				}
				if (!bFound) {
					BilledEMNInfo eNewInfo;
					eNewInfo.nEMNID = nEMNID;
					eNewInfo.nInsuredPartyID = nCurInsuredPartyID;
					eNewInfo.strRespTypeName = strCurRespTypeName;
					m_aryBilledEMNInfo.Add(eNewInfo);
				}

				rsEMR->MoveNext();
			}
			rsEMR->Close();
		}
		m_rsBill->Close();

		/* Open the list of charges from the quote */

		//add to our list, if it's not already there
		BOOL bFound = FALSE;
		for (int i = 0; i < m_arypBilledQuotes.GetSize(); i++) {
			if (((BilledQuote*)m_arypBilledQuotes.GetAt(i))->nQuoteID == nQuoteID) {
				bFound = TRUE;
				//update our new deletion choice
				((BilledQuote*)m_arypBilledQuotes.GetAt(i))->bDeleteQuote = bDeleteQuote;
			}
		}
		if (!bFound) {
			BilledQuote *pQuote = new BilledQuote;
			pQuote->nQuoteID = nQuoteID;
			pQuote->bDeleteQuote = bDeleteQuote;
			m_arypBilledQuotes.Add(pQuote);
		}

		// Update description on parent billing module dialog
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				//note - if this is a package, this will have already been filled in
				m_rsBill = CreateParamRecordset("SELECT Description FROM BillsT WHERE ID = {INT}", nQuoteID);
				CString strDesc = AdoFldString(m_rsBill, "Description", "");
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDesc);
				m_rsBill->Close();
			}
		}

		//update the anesthesia and facility times on the Billing2Dlg, if the Quote had them
		// (j.jones 2011-11-01 12:04) - PLID 41558 - and assisting times
		rs = CreateParamRecordset("SELECT AnesthStartTime, AnesthEndTime, "
			"FacilityStartTime, FacilityEndTime, "
			"AnesthesiaMinutes, FacilityMinutes, "
			"AssistingStartTime, AssistingEndTime, AssistingMinutes "
			"FROM BillsT WHERE ID = {INT}", nQuoteID);
		if (!rs->eof) {
			_variant_t var;

			BOOL bAnesthChanged = FALSE;
			BOOL bFacilityChanged = FALSE;
			BOOL bAssistingChanged = FALSE;

			var = rs->Fields->Item["AnesthStartTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAnesthStart = VarDateTime(var);
				CString strAnesthStart = dtAnesthStart.Format("%H:%M:%S");
				CString strOldAnesthStart = GetAnesthStartTime();
				if (strOldAnesthStart != "" && strOldAnesthStart != strAnesthStart) {
					bAnesthChanged = TRUE;
				}
				SetAnesthStartTime(strAnesthStart, bAnesthChanged);
			}

			var = rs->Fields->Item["AnesthEndTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAnesthEnd = VarDateTime(var);
				CString strAnesthEnd = dtAnesthEnd.Format("%H:%M:%S");
				CString strOldAnesthEnd = GetAnesthEndTime();
				if (strOldAnesthEnd != "" && strOldAnesthEnd != strAnesthEnd) {
					bAnesthChanged = TRUE;
				}
				SetAnesthEndTime(strAnesthEnd, bAnesthChanged);
			}

			var = rs->Fields->Item["FacilityStartTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtFacilityStart = VarDateTime(var);
				CString strFacilityStart = dtFacilityStart.Format("%H:%M:%S");
				CString strOldFacilityStart = GetFacilityStartTime();
				if (strOldFacilityStart != "" && strOldFacilityStart != strFacilityStart) {
					bFacilityChanged = TRUE;
				}
				SetFacilityStartTime(strFacilityStart, bFacilityChanged);
			}

			var = rs->Fields->Item["FacilityEndTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtFacilityEnd = VarDateTime(var);
				CString strFacilityEnd = dtFacilityEnd.Format("%H:%M:%S");
				CString strOldFacilityEnd = GetFacilityEndTime();
				if (strOldFacilityEnd != "" && strOldFacilityEnd != strFacilityEnd) {
					bFacilityChanged = TRUE;
				}
				SetFacilityEndTime(strFacilityEnd, bFacilityChanged);
			}

			var = rs->Fields->Item["AnesthesiaMinutes"]->Value;
			if (var.vt != VT_NULL) {
				long nAnesthMinutes = VarLong(var);
				long nOldAnesthMinutes = GetAnesthMinutes();
				if (nOldAnesthMinutes != 0 && nOldAnesthMinutes != nAnesthMinutes) {
					bAnesthChanged = TRUE;
				}
				SetAnesthMinutes(nAnesthMinutes, bAnesthChanged);
			}

			var = rs->Fields->Item["FacilityMinutes"]->Value;
			if (var.vt != VT_NULL) {
				long nFacilityMinutes = VarLong(var);
				long nOldFacilityMinutes = GetFacilityMinutes();
				if (nOldFacilityMinutes != 0 && nOldFacilityMinutes != nFacilityMinutes) {
					bFacilityChanged = TRUE;
				}
				SetFacilityMinutes(nFacilityMinutes, bFacilityChanged);
			}

			var = rs->Fields->Item["AssistingStartTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAssistingStart = VarDateTime(var);
				CString strAssistingStart = dtAssistingStart.Format("%H:%M:%S");
				CString strOldAssistingStart = GetAssistingStartTime();
				if (strOldAssistingStart != "" && strOldAssistingStart != strAssistingStart) {
					bAssistingChanged = TRUE;
				}
				SetAssistingStartTime(strAssistingStart, bAssistingChanged);
			}

			var = rs->Fields->Item["AssistingEndTime"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAssistingEnd = VarDateTime(var);
				CString strAssistingEnd = dtAssistingEnd.Format("%H:%M:%S");
				CString strOldAssistingEnd = GetAssistingEndTime();
				if (strOldAssistingEnd != "" && strOldAssistingEnd != strAssistingEnd) {
					bAssistingChanged = TRUE;
				}
				SetAssistingEndTime(strAssistingEnd, bAssistingChanged);
			}

			var = rs->Fields->Item["AssistingMinutes"]->Value;
			if (var.vt != VT_NULL) {
				long nAssistingMinutes = VarLong(var);
				long nOldAssistingMinutes = GetAssistingMinutes();
				if (nOldAssistingMinutes != 0 && nOldAssistingMinutes != nAssistingMinutes) {
					bAssistingChanged = TRUE;
				}
				SetAssistingMinutes(nAssistingMinutes, bAssistingChanged);
			}

			if (bAnesthChanged || bFacilityChanged || bAssistingChanged) {
				AfxMessageBox("The details on the 'Additional Info.' tab of this bill have been replaced with the details from the quote.");
			}
		}
		rs->Close();

		// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
		//LogDetail("Adding quote to bill");

		// (j.gruber 2009-03-17 09:34) - PLID 33351 - need to add a boolean to say if this is a package or not
		BOOL bIsPackage = FALSE;
		if (!bThisIsAPaymentPlan) {
			//add a normal quote like we always have
			//DRT 4/13/2006 - PLID 11734 - Added ItemType to support the replacement of ProcCode
			// (j.gruber 2007-03-26 16:02) - PLID 24870 - add discount category information
			// (j.gruber 2007-04-05 14:17) - PLID 9796 - Adding support for Coupons
			// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID, but it is always NULL here
			// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
			// (j.gruber 2009-03-12 13:41) - PLID 33351 - take discount fields out of the query
			// (j.jones 2009-08-13 12:27) - PLID 35206 - added other drug fields
			// (j.jones 2010-04-08 11:55) - PLID 15224 - added ChargesT.IsEmergency
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			// (j.jones 2010-11-09 10:07) - PLID 31392 - added ChargesT.ClaimProviderID
			// (j.jones 2011-03-28 16:23) - PLID 42575 - ignore non-billable CPT Codes
			//TES 7/1/2011 - PLID 44192 - Added GlassesOrderServiceID
			// (j.jones 2011-08-24 09:51) - PLID 44873 - added IsVoidingCharge
			// (j.jones 2011-08-24 08:41) - PLID 44868 - added IsOriginalCharge
			// (j.jones 2012-01-17 17:18) - PLID 47537 - filled EMRChargeID based on nEMNID
			// (d.singleton 2014-03-04 12:11) - PLID 61165 - update to use new daig code data structure			
			// (j.jones 2014-04-23 10:15) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
			// (r.gonet 07/07/2014) - PLID 62572 - Added DefaultAsOnHold
			// (r.gonet 07/08/2014) - PLID 62569 - Added VoidingLineItemID, OriginalLineItemID, and IsNewChargeFromCorrection
			// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
			// (d.lange 2015-11-30 10:50) - PLID 67128 - Load the insurance company for calculating the allowable based on ChargesT.AllowableInsuredPartyID
			m_rsBill = CreateParamRecordset("SELECT ChargesT.*, "
				"PatientChargesQ.Amount AS PracBillFee, PatientChargesQ.Description AS ItemDesc, Convert(bit, CASE WHEN ProductT.ID Is Not Null THEN 1 ELSE 0 END) AS IsProduct, ServiceT.Name AS ServiceName, CPTMultiplier1, CPTMultiplier2, CPTMultiplier3, CPTMultiplier4, "
				"ChargesT.ServiceType AS [Service Type], LocationID, CASE WHEN CPTCodeT.ID IS NOT NULL THEN 1 WHEN ProductT.ID IS NOT NULL THEN 2 WHEN GCTypesT.ServiceID IS NOT NULL THEN 3 WHEN AdministrativeFeesT.ID IS NOT NULL THEN 4 END AS ItemType, "
				" ServiceT.PointCost, RewardDiscountsT.DiscountPercent, RewardDiscountsT.DiscountDollars, ChargesT.NDCCode, "
				"ChargesT.DrugUnitPrice, ChargesT.DrugUnitTypeQual, ChargesT.DrugUnitQuantity, ChargesT.PrescriptionNumber, "
				"ChargesT.IsEmergency, "
				"COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount, "
				"(CASE WHEN {INT} = -1 THEN NULL ELSE (SELECT TOP 1 EMRChargesT.ID "
				"	FROM EMRChargesT "
				"	WHERE Deleted = 0 AND EMRID = {INT} AND ServiceID = ChargesT.ServiceID "
				"	ORDER BY (CASE WHEN EMRChargesT.ID NOT IN (SELECT EMRChargeID FROM ChargesT "
				"		INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
				"		WHERE LineItemT.Type = 10 AND Deleted = 0) THEN 0 ELSE 1 END) ASC) "
				"END) AS EMRChargeID, "
				"ChargesT.AppointmentID, ChargesT.GlassesOrderServiceID, "
				"LineItemCorrections_NewChargesQ.VoidingLineItemID, LineItemCorrections_NewChargesQ.OriginalLineItemID,"
				"Convert(bit, CASE WHEN LineItemCorrections_VoidingChargesQ.VoidingLineItemID Is Null THEN 0 ELSE 1 END) AS IsVoidingCharge, "
				"Convert(bit, CASE WHEN LineItemCorrections_OriginalChargesQ.OriginalLineItemID Is Null THEN 0 ELSE 1 END) AS IsOriginalCharge, "
				"Convert(bit, CASE WHEN LineItemCorrections_NewChargesQ.NewLineItemID Is Null THEN 0 ELSE 1 END) AS IsNewChargeFromCorrection, "
				"ChargesT.ReferringProviderID, ChargesT.OrderingProviderID, ChargesT.SupervisingProviderID, CPTCodeT.DefaultAsOnHold, "
				"AllowableInsuredQ.InsuranceCoID AS AllowableInsuranceCoID "
				"FROM ((SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders, ChargesT.ClaimProviderID FROM LineItemT INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
				"WHERE (((LineItemT.PatientID)={INT}) AND ((LineItemT.Deleted)=0) AND ((LineItemT.Type)>=10)) )AS PatientChargesQ INNER JOIN BillsT ON PatientChargesQ.BillID = BillsT.ID INNER JOIN ChargesT ON PatientChargesQ.ID = ChargesT.ID) "
				"LEFT JOIN CPTCodeT ON ChargesT.ServiceID = CPTCodeT.ID "
				"LEFT JOIN ProductT ON ChargesT.ServiceID = ProductT.ID "
				"LEFT JOIN GCTypesT ON ChargesT.ServiceID = GCTypesT.ServiceID "
				"LEFT JOIN AdministrativeFeesT ON ChargesT.ServiceID = AdministrativeFeesT.ID "
				"LEFT JOIN ServiceT ON ChargesT.ServiceID = ServiceT.ID "	// (a.walling 2007-05-31 09:05) - PLID 26172
				"LEFT JOIN RewardDiscountsT ON ChargesT.ServiceID = RewardDiscountsT.ServiceID "
				"LEFT JOIN ( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount FROM ServiceMultiCategoryT Group BY ServiceID ) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ChargesT.ServiceID "
				"LEFT JOIN (SELECT VoidingLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_VoidingChargesQ ON PatientChargesQ.ID = LineItemCorrections_VoidingChargesQ.VoidingLineItemID "
				"LEFT JOIN (SELECT OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_OriginalChargesQ ON PatientChargesQ.ID = LineItemCorrections_OriginalChargesQ.OriginalLineItemID "
				"LEFT JOIN (SELECT NewLineItemID, VoidingLineItemID, OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_NewChargesQ ON PatientChargesQ.ID = LineItemCorrections_NewChargesQ.NewLineItemID "
				"LEFT JOIN ( "
				"	SELECT InsuredPartyT.PersonID, InsuranceCoT.PersonID AS InsuranceCoID "
				"	FROM InsuredPartyT "
				"	INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
				") AS AllowableInsuredQ ON ChargesT.AllowableInsuredPartyID = AllowableInsuredQ.PersonID "
				"WHERE PatientChargesQ.BillID = {INT} "
				"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
				"ORDER BY ChargesT.LineID",
				nEMNID, nEMNID, m_nPatientID, nQuoteID);
		}
		else {
			// (j.gruber 2009-03-17 09:35) - PLID 33351 it is a package
			bIsPackage = TRUE;

			if (nThisPackageType == 1) {

				//payment plan, basically means we're going to add the equivalent of (1/TotalCount) * TotalAmount

				//repeat package (uses CurrentCount and TotalCount)

				//DRT 4/13/2006 - PLID 11734 - Added ItemType to support the replacement of ProcCode
				// (j.gruber 2007-03-26 16:02) - PLID 24870 - add discount category information
				// (j.gruber 2007-04-05 14:17) - PLID 9796 - Adding support for Coupons
				// (j.jones 2007-04-23 12:36) - PLID 25735 - now calculations are made off of OriginalCurrentCount
				// and OriginalCurrentAmount
				// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID, but it is always NULL here
				// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
				// (j.gruber 2009-03-12 13:42) - PLID 33351 - take discount fields out of the query
				// (j.jones 2009-08-13 12:27) - PLID 35206 - added other drug fields
				// (j.jones 2010-04-07 17:29) - PLID 15224 - removed ChargesT.EMG, obsolete field
				// (j.jones 2010-04-08 11:55) - PLID 15224 - added ChargesT.IsEmergency
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				// (j.jones 2010-11-09 10:09) - PLID 31392 - added ChargesT.ClaimProviderID
				// (j.jones 2011-03-28 16:24) - PLID 42575 - ignore non-billable CPT codes
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				// (j.jones 2011-08-24 09:51) - PLID 44873 - added IsVoidingCharge
				// (j.jones 2011-08-24 08:41) - PLID 44868 - added IsOriginalCharge
				// (j.jones 2011-10-25 16:14) - PLID 46088 - added Calls column, Alberta only
				// (j.jones 2012-01-17 17:18) - PLID 47537 - filled EMRChargeID based on nEMNID
				// (d.singleton 2012-05-24 12:30) - PLID 48152 - added skill column alberta only
				// (d.singleton 2014-03-04 12:32) - PLID 61165 - update to use new daig code data structure
				// (j.gruber 2014-03-10 14:25) - PLID 60942 - take out whichCodes
				// (j.jones 2014-04-23 10:15) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				// (r.gonet 07/07/2014) - PLID 62572 - Added DefaultAsOnHold
				// (r.gonet 07/08/2014) - PLID 62569 - Added VoidingLineItemID, OriginalLineItemID, and IsNewChargeFromCorrection
				// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
				// (d.lange 2015-11-30 10:50) - PLID 67128 - Load the insurance company for calculating the allowable based on ChargesT.AllowableInsuredPartyID
				m_rsBill = CreateParamRecordset("SELECT (CASE WHEN CurrentCount > 1 THEN "
					//handle a zero dollar bill
					"(CASE WHEN BillNonTaxTotal = 0 THEN Round(Convert(money,(OriginalCurrentAmount/OriginalCurrentCount/NumCharges/Quantity)),2) ELSE "
					//calculate using the percentage of the total
					"Round(Convert(money,((BillTotal * ChargeNonTaxTotal / BillNonTaxTotal) /Quantity)),2) END) "
					"ELSE "
					//handle a zero dollar bill
					"(CASE WHEN BillNonTaxTotal = 0 THEN (CASE WHEN Round(Convert(money,(CurrentAmount/NumCharges)),2) * NumCharges <> CurrentAmount AND LineID = 1 THEN "
					"Round(Convert(money,(CurrentAmount - Round(Convert(money,(CurrentAmount/NumCharges)),2) * (NumCharges-1)) / Quantity),2) "
					"ELSE Round(Convert(money,(CurrentAmount/NumCharges/Quantity)),2) END) ELSE "
					//calculate using the percentage of the total
					"(CASE WHEN Round(Convert(money,(CurrentAmount * ChargeNonTaxTotal / BillNonTaxTotal)),2) * NumCharges <> CurrentAmount AND LineID = 1 THEN "
					//bad ->"Round(Convert(money,(CurrentAmount - Round(Convert(money,(CurrentAmount * ChargeNonTaxTotal / BillNonTaxTotal)),2) * (NumCharges-1)) / Quantity),2) "
					"Round(Convert(money,((CurrentAmount * ChargeNonTaxTotal / BillNonTaxTotal)/Quantity)),2)"
					"ELSE Round(Convert(money,((CurrentAmount * ChargeNonTaxTotal / BillNonTaxTotal) /Quantity)),2) END) END) END) AS PracBillFee, "
					""
					"COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount, "
					"PatientChargesQ.Description AS ItemDesc, Convert(bit, CASE WHEN ProductT.ID Is Not Null THEN 1 ELSE 0 END) AS IsProduct, ServiceT.Name AS ServiceName, "
					"ChargesT.ID, ChargesT.BillID, ChargesT.ServiceID, ItemCode, ItemSubCode, ServiceT.Category, SubCategory, CPTModifier, CPTModifier2, CPTModifier3, CPTModifier4, "
					"TaxRate, TaxRate2, ChargesT.Quantity, ChargesT.DoctorsProviders, ChargesT.ClaimProviderID, ServiceDateFrom, ServiceDateTo, ServiceLocationID, ServiceType, EPSDT, COB, 0 AS PercentOff, Convert(money,0) AS Discount, OthrBillFee, LineID, -1 AS ProductItemID, ChargesT.PatCoordID, ChargesT.Batched, "
					"CPTMultiplier1, CPTMultiplier2, CPTMultiplier3, CPTMultiplier4, ChargesT.PackageChargeRefID, "
					"ChargesT.ServiceType AS [Service Type], LocationID, CASE WHEN CPTCodeT.ID IS NOT NULL THEN 1 WHEN ProductT.ID IS NOT NULL THEN 2 WHEN GCTypesT.ServiceID IS NOT NULL THEN 3 WHEN AdministrativeFeesT.ID IS NOT NULL THEN 4 END AS ItemType, "
					/*"CASE WHEN ChargesT.DiscountCategoryID IS NULL then 0 else 1 END AS HasDiscountCategory,  "
					" ChargesT.DiscountCategoryID, ChargesT.CustomDiscountDesc, ChargesT.CouponID, "*/
					" ServiceT.PointCost, RewardDiscountsT.DiscountPercent, RewardDiscountsT.DiscountDollars, ChargesT.NDCCode, "
					"ChargesT.DrugUnitPrice, ChargesT.DrugUnitTypeQual, ChargesT.DrugUnitQuantity, ChargesT.PrescriptionNumber, "
					"ChargesT.IsEmergency, "
					"(CASE WHEN {INT} = -1 THEN NULL ELSE (SELECT TOP 1 EMRChargesT.ID "
					"	FROM EMRChargesT "
					"	WHERE Deleted = 0 AND EMRID = {INT} AND ServiceID = ChargesT.ServiceID "
					"	ORDER BY (CASE WHEN EMRChargesT.ID NOT IN (SELECT EMRChargeID FROM ChargesT "
					"		INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"		WHERE LineItemT.Type = 10 AND Deleted = 0) THEN 0 ELSE 1 END) ASC) "
					"END) AS EMRChargeID, "
					"ChargesT.AppointmentID, ChargesT.GlassesOrderServiceID, "
					"LineItemCorrections_NewChargesQ.VoidingLineItemID, LineItemCorrections_NewChargesQ.OriginalLineItemID,"
					"Convert(bit, CASE WHEN LineItemCorrections_VoidingChargesQ.VoidingLineItemID Is Null THEN 0 ELSE 1 END) AS IsVoidingCharge, "
					"Convert(bit, CASE WHEN LineItemCorrections_OriginalChargesQ.OriginalLineItemID Is Null THEN 0 ELSE 1 END) AS IsOriginalCharge, "
					"Convert(bit, CASE WHEN LineItemCorrections_NewChargesQ.NewLineItemID Is Null THEN 0 ELSE 1 END) AS IsNewChargeFromCorrection, "
					"ChargesT.Calls, ChargesT.SkillCode, "
					"ChargesT.ReferringProviderID, ChargesT.OrderingProviderID, ChargesT.SupervisingProviderID, CPTCodeT.DefaultAsOnHold, "
					"AllowableInsuredQ.InsuranceCoID AS AllowableInsuranceCoID "
					"FROM ((SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders, ChargesT.ClaimProviderID, "
					""
					//get the non tax charge total
					"Round(Convert(money,((([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN(CPTMultiplier4 Is Null) THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN((SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID) Is Null) THEN 1 ELSE ((100-Convert(float,(SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID) ))/100) END)-(CASE WHEN((SELECT Sum(Discount) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID)  Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE (SELECT Sum(Discount) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID)  END))))),2) AS ChargeNonTaxTotal "
					""
					"FROM LineItemT INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
					"WHERE (((LineItemT.PatientID)={INT}) AND ((LineItemT.Deleted)=0) AND ((LineItemT.Type)>=10)) )AS PatientChargesQ INNER JOIN ChargesT ON PatientChargesQ.ID = ChargesT.ID) "
					"INNER JOIN (SELECT PackagesT.*, OriginalCurrentAmount/OriginalCurrentCount AS BillTotal FROM PackagesT) AS PackagesT ON PatientChargesQ.BillID = PackagesT.QuoteID "
					"INNER JOIN BillsT ON PatientChargesQ.BillID = BillsT.ID "
					""
					//get the non tax bill total
					"INNER JOIN (SELECT BillsT.ID, Sum(Round(Convert(money,((([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN(CPTMultiplier4 Is Null) THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))))),2)) AS BillNonTaxTotal FROM BillsT INNER JOIN ChargesT ON BillsT.ID = ChargesT.BillID INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID LEFT JOIN (SELECT ChargeID, Sum(PercentOff) AS TotalPercentOff FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalPercentOffQ ON ChargesT.ID = TotalPercentOffQ.ChargeID LEFT JOIN (SELECT ChargeID, Sum(Discount) AS TotalDiscount FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalDiscountQ ON ChargesT.ID = TotalDiscountQ.ChargeID WHERE BillsT.Deleted = 0 AND LineItemT.Deleted = 0 GROUP BY BillsT.ID) AS BillTotalsQ ON BillsT.ID = BillTotalsQ.ID "
					""
					"INNER JOIN (SELECT Count(ChargesT.ID) AS NumCharges, ChargesT.BillID FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"GROUP BY ChargesT.BillID, Convert(int,LineItemT.Deleted) "
					"HAVING ChargesT.BillID = {INT} AND Convert(int,LineItemT.Deleted) = 0) AS CountChargesQ ON ChargesT.BillID = CountChargesQ.BillID "
					"LEFT JOIN ProvidersT ON ChargesT.DoctorsProviders = ProvidersT.PersonID "
					"LEFT JOIN CPTCodeT ON ChargesT.ServiceID = CPTCodeT.ID "
					"LEFT JOIN ProductT ON ChargesT.ServiceID = ProductT.ID "
					"LEFT JOIN GCTypesT ON ChargesT.ServiceID = GCTypesT.ServiceID "
					"LEFT JOIN ServiceT ON ChargesT.ServiceID = ServiceT.ID "	// (a.walling 2007-05-31 09:05) - PLID 26172
					"LEFT JOIN ( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount FROM ServiceMultiCategoryT Group BY ServiceID ) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ChargesT.ServiceID "
					"LEFT JOIN RewardDiscountsT ON ChargesT.ServiceID = RewardDiscountsT.ServiceID "
					"LEFT JOIN AdministrativeFeesT ON ChargesT.ServiceID = AdministrativeFeesT.ID "
					"LEFT JOIN (SELECT VoidingLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_VoidingChargesQ ON ChargesT.ID = LineItemCorrections_VoidingChargesQ.VoidingLineItemID "
					"LEFT JOIN (SELECT OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_OriginalChargesQ ON ChargesT.ID = LineItemCorrections_OriginalChargesQ.OriginalLineItemID "
					"LEFT JOIN (SELECT NewLineItemID, VoidingLineItemID, OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_NewChargesQ ON PatientChargesQ.ID = LineItemCorrections_NewChargesQ.NewLineItemID "
					"LEFT JOIN ( "
					"	SELECT InsuredPartyT.PersonID, InsuranceCoT.PersonID AS InsuranceCoID "
					"	FROM InsuredPartyT "
					"	INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
					") AS AllowableInsuredQ ON ChargesT.AllowableInsuredPartyID = AllowableInsuredQ.PersonID "

					"WHERE PatientChargesQ.BillID = {INT} "
					"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
					"ORDER BY ChargesT.LineID ", nEMNID, nEMNID, m_nPatientID, nQuoteID, nQuoteID);
			}
			else {

				//multi-use package (ignores CurrentCount and TotalCount)
				//DRT 4/13/2006 - PLID 11734 - Added ItemType to support the replacement of ProcCode
				// (j.gruber 2007-04-05 14:17) - PLID 9796 - Adding support for Coupons
				// (j.jones 2007-04-23 12:36) - PLID 25735 - now calculations are made off of OriginalCurrentAmount
				// and OriginalPackageQtyRemaining
				// (a.walling 2007-05-30 12:21) - PLID 26172 - added RewardDiscountsT
				// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID, but it is always NULL here
				// (j.jones 2008-06-24 10:36) - PLID 30457 - added AppointmentID
				// (j.gruber 2009-03-12 13:42) - PLID 33351 - take discount fields out of the query
				// (j.jones 2009-08-13 12:27) - PLID 35206 - added other drug fields
				// (j.jones 2010-04-07 17:29) - PLID 15224 - removed ChargesT.EMG, obsolete field
				// (j.jones 2010-04-08 11:55) - PLID 15224 - added ChargesT.IsEmergency
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				// (j.jones 2010-11-09 10:10) - PLID 31392 - added ChargesT.ClaimProviderID
				// (j.jones 2011-03-28 16:24) - PLID 42575 - ignore non-billable CPT codes
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				// (j.jones 2011-08-24 09:51) - PLID 44873 - added IsVoidingCharge
				// (j.jones 2011-08-24 08:41) - PLID 44868 - added IsOriginalCharge
				// (j.jones 2011-10-25 16:14) - PLID 46088 - added Calls column, Alberta only
				// (j.jones 2012-01-17 17:18) - PLID 47537 - filled EMRChargeID based on nEMNID
				// (d.singleton 2012-05-24 12:31) - PLID 48152 added skill code alberta only
				// (d.singleton 2014-03-04 12:32) - PLID 61165 - update to use new daig code data structure
				// (j.gruber 2014-03-10 14:22) - PLID 60942 - take out whichCodes
				// (j.jones 2014-04-23 10:15) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
				// (r.gonet 07/07/2014) - PLID 62572 - Added DefaultAsOnHold
				// (r.gonet 07/08/2014) - PLID 62569 - Added VoidingLineItemID, OriginalLineItemID, and IsNewChargeFromCorrection
				// (s.tullis 2015-04-02 14:50) - PLID 64975 -Category Count to determine multiple categories combo edit ability
				// (d.lange 2015-11-30 10:50) - PLID 67128 - Load the insurance company for calculating the allowable based on ChargesT.AllowableInsuredPartyID
				m_rsBill = CreateParamRecordset("SELECT "
					// (j.jones 2007-07-03 10:29) - PLID 26539 - handled divide by zero for 0-quantities
					"(CASE WHEN OriginalPackageQtyRemaining = 0 THEN Convert(money,0) ELSE "
					//handle a zero dollar bill
					"(CASE WHEN BillNonTaxTotal = 0 THEN Round(Convert(money,(OriginalCurrentAmount/NumCharges/OriginalPackageQtyRemaining)),2) ELSE "
					//calculate using the percentage of the total
					"Round(Convert(money,((BillTotal * ChargeNonTaxTotal / BillNonTaxTotal) / OriginalPackageQtyRemaining)),2) END) "
					"END) "
					"AS PracBillFee, "
					""
					"PatientChargesQ.Description AS ItemDesc, Convert(bit, CASE WHEN ProductT.ID Is Not Null THEN 1 ELSE 0 END) AS IsProduct, ServiceT.Name AS ServiceName, "
					"ChargesT.ID, ChargesT.BillID, ChargesT.ServiceID, ItemCode, ItemSubCode, ServiceT.Category, COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount , SubCategory, CPTModifier, CPTModifier2, CPTModifier3, CPTModifier4, "
					"TaxRate, TaxRate2, ChargesT.Quantity, ChargesT.DoctorsProviders, ChargesT.ClaimProviderID, ServiceDateFrom, ServiceDateTo, ServiceLocationID, ServiceType, EPSDT, COB, 0 AS PercentOff, Convert(money,0) AS Discount, OthrBillFee, LineID, -1 AS ProductItemID, ChargesT.PatCoordID, ChargesT.Batched, "
					"CPTMultiplier1, CPTMultiplier2, CPTMultiplier3, CPTMultiplier4, ChargesT.PackageChargeRefID, "
					"ChargesT.ServiceType AS [Service Type], LocationID, CASE WHEN CPTCodeT.ID IS NOT NULL THEN 1 WHEN ProductT.ID IS NOT NULL THEN 2 WHEN GCTypesT.ServiceID IS NOT NULL THEN 3 WHEN AdministrativeFeesT.ID IS NOT NULL THEN 4 END AS ItemType, "
					/*"CASE WHEN ChargesT.DiscountCategoryID IS NULL then 0 else 1 END AS HasDiscountCategory,  "
					" ChargesT.DiscountCategoryID, ChargesT.CustomDiscountDesc, ChargesT.CouponID, "*/
					" ServiceT.PointCost, RewardDiscountsT.DiscountPercent, RewardDiscountsT.DiscountDollars, ChargesT.NDCCode, "
					"ChargesT.DrugUnitPrice, ChargesT.DrugUnitTypeQual, ChargesT.DrugUnitQuantity, ChargesT.PrescriptionNumber, "
					"ChargesT.IsEmergency, "
					"(CASE WHEN {INT} = -1 THEN NULL ELSE (SELECT TOP 1 EMRChargesT.ID "
					"	FROM EMRChargesT "
					"	WHERE Deleted = 0 AND EMRID = {INT} AND ServiceID = ChargesT.ServiceID "
					"	ORDER BY (CASE WHEN EMRChargesT.ID NOT IN (SELECT EMRChargeID FROM ChargesT "
					"		INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"		WHERE LineItemT.Type = 10 AND Deleted = 0) THEN 0 ELSE 1 END) ASC) "
					"END) AS EMRChargeID, "
					"ChargesT.AppointmentID, ChargesT.GlassesOrderServiceID, "
					"LineItemCorrections_NewChargesQ.VoidingLineItemID, LineItemCorrections_NewChargesQ.OriginalLineItemID,"
					"Convert(bit, CASE WHEN LineItemCorrections_VoidingChargesQ.VoidingLineItemID Is Null THEN 0 ELSE 1 END) AS IsVoidingCharge, "
					"Convert(bit, CASE WHEN LineItemCorrections_OriginalChargesQ.OriginalLineItemID Is Null THEN 0 ELSE 1 END) AS IsOriginalCharge, "
					"Convert(bit, CASE WHEN LineItemCorrections_NewChargesQ.NewLineItemID Is Null THEN 0 ELSE 1 END) AS IsNewChargeFromCorrection, "
					"ChargesT.Calls, ChargesT.SkillCode, ChargesT.ReferringProviderID, ChargesT.OrderingProviderID, ChargesT.SupervisingProviderID, CPTCodeT.DefaultAsOnHold, "
					"AllowableInsuredQ.InsuranceCoID AS AllowableInsuranceCoID "
					"FROM ((SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders, ChargesT.ClaimProviderID, "
					""
					//get the non tax charge total
					"Round(Convert(money,((([Amount]*[OriginalPackageQtyRemaining]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN(CPTMultiplier4 Is Null) THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN((SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID) Is Null) THEN 1 ELSE ((100-Convert(float,(SELECT Sum(PercentOff) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID)))/100) END)-(CASE WHEN((SELECT Sum(Discount) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID) Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE (SELECT Sum(Discount) FROM ChargeDiscountsT WHERE DELETED = 0 AND ChargeID = ChargesT.ID) END))))),2) AS ChargeNonTaxTotal "
					""
					"FROM LineItemT INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
					"WHERE (((LineItemT.PatientID)={INT}) AND ((LineItemT.Deleted)=0) AND ((LineItemT.Type)>=10)) )AS PatientChargesQ INNER JOIN ChargesT ON PatientChargesQ.ID = ChargesT.ID) "
					"INNER JOIN (SELECT PackagesT.*, OriginalCurrentAmount AS BillTotal FROM PackagesT) AS PackagesT ON PatientChargesQ.BillID = PackagesT.QuoteID "
					"INNER JOIN BillsT ON PatientChargesQ.BillID = BillsT.ID "
					""
					//get the non tax bill total
					"INNER JOIN (SELECT BillsT.ID, Sum(Round(Convert(money,((([Amount]*[OriginalPackageQtyRemaining]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN(CPTMultiplier4 Is Null) THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))))),2)) AS BillNonTaxTotal FROM BillsT INNER JOIN ChargesT ON BillsT.ID = ChargesT.BillID INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID LEFT JOIN (SELECT ChargeID, Sum(PercentOff) AS TotalPercentOff FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalPercentOffQ ON ChargesT.ID = TotalPercentOffQ.ChargeID LEFT JOIN (SELECT ChargeID, Sum(Discount) AS TotalDiscount FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalDiscountQ ON ChargesT.ID = TotalDiscountQ.ChargeID WHERE BillsT.Deleted = 0 AND LineItemT.Deleted = 0 GROUP BY BillsT.ID) AS BillTotalsQ ON BillsT.ID = BillTotalsQ.ID "
					""
					"INNER JOIN (SELECT Count(ChargesT.ID) AS NumCharges, ChargesT.BillID FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"GROUP BY ChargesT.BillID, Convert(int,LineItemT.Deleted) "
					"HAVING ChargesT.BillID = {INT} AND Convert(int,LineItemT.Deleted) = 0) AS CountChargesQ ON ChargesT.BillID = CountChargesQ.BillID "
					"LEFT JOIN ProvidersT ON ChargesT.DoctorsProviders = ProvidersT.PersonID " // (d.singleton 2012-05-21 12:18) - PLID 48152
					"LEFT JOIN CPTCodeT ON ChargesT.ServiceID = CPTCodeT.ID "
					"LEFT JOIN (Select ServiceID, COUNT(DISTINCT ServiceMultiCategoryT.CategoryID) as CPTCategoryCount FROM ServiceMultiCategoryT Group BY ServiceID) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ChargesT.ServiceID "
					"LEFT JOIN ProductT ON ChargesT.ServiceID = ProductT.ID "
					"LEFT JOIN GCTypesT ON ChargesT.ServiceID = GCTypesT.ServiceID "
					"LEFT JOIN ServiceT ON ChargesT.ServiceID = ServiceT.ID " // (a.walling 2007-05-30 12:21) - PLID 26172
					"LEFT JOIN RewardDiscountsT ON ChargesT.ServiceID = RewardDiscountsT.ServiceID "
					"LEFT JOIN AdministrativeFeesT ON ChargesT.ServiceID = AdministrativeFeesT.ID "
					"LEFT JOIN (SELECT VoidingLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_VoidingChargesQ ON ChargesT.ID = LineItemCorrections_VoidingChargesQ.VoidingLineItemID "
					"LEFT JOIN (SELECT OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_OriginalChargesQ ON ChargesT.ID = LineItemCorrections_OriginalChargesQ.OriginalLineItemID "
					"LEFT JOIN (SELECT NewLineItemID, VoidingLineItemID, OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_NewChargesQ ON PatientChargesQ.ID = LineItemCorrections_NewChargesQ.NewLineItemID "
					"LEFT JOIN ( "
					"	SELECT InsuredPartyT.PersonID, InsuranceCoT.PersonID AS InsuranceCoID "
					"	FROM InsuredPartyT "
					"	INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
					") AS AllowableInsuredQ ON ChargesT.AllowableInsuredPartyID = AllowableInsuredQ.PersonID "
					"WHERE PatientChargesQ.BillID = {INT} "
					"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
					"ORDER BY ChargesT.LineID ", nEMNID, nEMNID, m_nPatientID, nQuoteID, nQuoteID);
			}
		}


		while (!m_rsBill->eof) {

			//to retain the sorted order from the quote
			m_bOrderChanged = TRUE;

			/* Fill with only old existing charges since this
			is only called on OnShowWindow.

			If this is a bill, there should not be any outside fees
			(this would only hold true if you're billing a previous
			quote). If that amount exists and the practice fee is $0,
			skip the charge */

			_variant_t var = m_rsBill->Fields->Item["PracBillFee"]->Value;
			if (var.vt == VT_NULL || COleCurrency(0, 0) == var.cyVal) {
				var = m_rsBill->Fields->Item["OthrBillFee"]->Value;
				if (var.vt == VT_CY && COleCurrency(0, 0) < var.cyVal) {
					m_rsBill->MoveNext();
					continue;
				}
			}

			long nChargedProductItemListID = -1;
			long nChargedAllocationDetailListID = -1;

			long nServiceID = m_rsBill->Fields->Item["ServiceID"]->Value.lVal;
			CString strServiceName = AdoFldString(m_rsBill, "ServiceName", "");
			BOOL bIsProduct = AdoFldBool(m_rsBill, "IsProduct", FALSE);
			//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
			if (m_EntryType == 1 && bIsProduct == FALSE && IsCodeSelectedBasedOnWarning(nServiceID) == FALSE)
			{
				m_rsBill->MoveNext();
				continue;
			}
			double dblQuantity = AdoFldDouble(m_rsBill, "Quantity", 1.0);

			// (j.jones 2010-09-03 08:45) - PLID 38319 - if a bill, and a product,
			// and they want to add products as patient responsibility, switch the resp. dropdown now
			BOOL bSwitchedResponsibilitySel = FALSE;
			long nOldRespType = -1;
			if (bIsProduct && m_EntryType == 1
				&& GetRemotePropertyInt("AddInventoryAsPatResp", 0, 0, GetCurrentUserName(), true) == 1) {
				//cache the current resp type and then select patient
				if (m_listBillTo->CurSel != -1) {
					nOldRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
				}

				m_listBillTo->SetSelByColumn(btcPriority, (long)0);
				PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				bSwitchedResponsibilitySel = TRUE;
			}

			long nPackageChargeRefID = -1;

			// (j.jones 2007-03-26 14:42) - PLID 25287 - used to determine whether to
			// use cyMatchRemainingPackageAmount on this charge
			BOOL bApplyMatchedRemAmountNow = FALSE;

			// (j.jones 2008-02-13 15:01) - PLID 28794 - nPackageChargeRefID should be filled
			// for all packages, not just multi-use packages
			nPackageChargeRefID = AdoFldLong(m_rsBill, "ID", -1);

			if (nThisPackageType == 2) {
				//for a multi-use package, only add the services (and quantity) the user chose to bill
				BOOL bFound = FALSE;

				// (j.jones 2008-05-22 11:56) - PLID 28450 - added a new package charge array
				// that replaced the old service & quantity arrays

				for (int i = 0; i < arypPackageCharges.GetSize() && !bFound; i++) {

					PackageChargeObject *pCharge = (PackageChargeObject*)(arypPackageCharges.GetAt(i));

					if (pCharge->nPackageChargeID == nPackageChargeRefID) {
						//we found it, which means the user wants to bill this package charge now
						bFound = TRUE;
						//get the quantity they chose to bill
						dblQuantity = pCharge->dblQuantity;

						// (j.jones 2007-03-26 14:42) - PLID 25287 - if this is the ServiceID
						// to apply the excess to, say so 
						// (j.jones 2011-02-03 09:12) - PLID 42291 - changed to calculate the package charge ID, not service ID
						if (pCharge->nPackageChargeID == nMatchRemAmountToChargeID) {
							bApplyMatchedRemAmountNow = TRUE;
						}
					}
				}
				if (!bFound) {
					//it wasn't found, which means the user chose to not bill this service at this time
					m_rsBill->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}

					continue;
				}
			}

			// (j.jones 2006-04-25 16:37) - we cached the Anesthesia, UseAnesthesiaBilling, FacilityFee, and UseFacilityBilling
			// values, so don't check for these if we already know it's irrelevant

			BOOL bCPTCodeCachedInfoLoaded = FALSE;
			BOOL bIsAnesthesia = FALSE;
			BOOL bUseAnesthesia = FALSE;
			BOOL bIsFacilityFee = FALSE;
			BOOL bUseFacilityFee = FALSE;

			// (j.jones 2008-12-15 15:07) - PLID 32431 - changed this code to call FindCPTRowInComboByServiceID,
			// which will force finding the service, incase the combo is still requerying
			//int iCPTRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, FALSE);
			int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);
			if (iCPTRow >= 0) {
				bIsAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ANESTHESIA), FALSE);
				bUseAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_ANESTH_BILLING), FALSE);
				bIsFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_FACILITY_FEE), FALSE);
				bUseFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_FACILITY_BILLING), FALSE);

				//means we can safely use the booleans
				bCPTCodeCachedInfoLoaded = TRUE;
			}

			// if bCPTCodeCachedInfoLoaded = FALSE, then we can't check the cached values, so we run based on Service ID

			//check and see if this is an anesthesia code or facility code, and already exists in the charge list
			if ((!bCPTCodeCachedInfoLoaded || (bIsAnesthesia && bUseAnesthesia) || (bIsFacilityFee && bUseFacilityFee))
				&& !CheckAllowAddAnesthesiaFacilityCharge(nServiceID)) {
				m_rsBill->MoveNext();

				// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
				if (bSwitchedResponsibilitySel) {
					if (nOldRespType == -1) {
						//there was no resp type, so select the blank row
						m_listBillTo->PutCurSel(-1);
					}
					else {
						m_listBillTo->SetSelByColumn(btcID, nOldRespType);
					}
					PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				}

				continue;
			}

			long LocationID = -1;

			if (m_LocationCombo->GetCurSel() == -1)
				LocationID = GetCurrentLocationID();
			else
				LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

			// (c.haag 2015-10-23) - PLID 67401 - The quote may have actually come from a different location.
			// When adding charges from a quote, we must use their location. This is legacy behavior.
			//
			// This block of code however makes it so the bill location changes to the quote location BEFORE the
			// first charge is added, which fixes problems with serialized product validation.
			//
			long nQuoteLineItemLocationID = AdoFldLong(m_rsBill, "LocationID");
			if (nQuoteLineItemLocationID != LocationID)
			{
				if (!TryChangeBillLocation(nQuoteLineItemLocationID))
				{
					AfxMessageBox("The quote was made in another location, and the current bill location could not be changed to it.");
					return;
				}
				else
				{
					LocationID = nQuoteLineItemLocationID;
				}
			}

			// (j.jones 2007-12-14 09:14) - PLID 27988 - removed these field calls from AddChargeToList,
			// need to pull them ahead of time - allocations may change them
			CString strDescription = AdoFldString(m_rsBill, "ItemDesc", "");
			CString strItemCode = AdoFldString(m_rsBill, "ItemCode", "");
			long nCategoryID = AdoFldLong(m_rsBill, "Category", -1);
			long nSubCategoryID = AdoFldLong(m_rsBill, "SubCategory", -1);
			// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
			long nCategoryCount = AdoFldLong(m_rsBill,"CategoryCount",0);

			if (bIsProduct) {

				// (j.jones 2007-12-13 16:12) - PLID 27988 - check to see if this product is in an allocation
				// this *can* change the nServiceID, strProductName, and dblQuantity!
				long nOldServiceID = nServiceID;
				ProductAllocationReturnValue arvRet = CheckProductAgainstAllocations(nServiceID, strServiceName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID);

				//did the user decide to cancel adding the product?
				if (arvRet == arvAbortAdding) {
					m_rsBill->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}

				//did the product ID change?
				if (nServiceID != nOldServiceID) {

					//we need to update some fields
					strDescription = strServiceName;

					//we can pull the info from the products dropdown, but it may not have been requeried yet
					if (m_bProductsCombo == FALSE) {
						// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
						RequeryProductCombo();
					}

					// (j.jones 2008-12-15 15:02) - PLID 32431 - changed this code to call FindProductRowInComboByServiceID,
					// which will force finding the product, incase the combo is still requerying
					int iProductRow = FindProductRowInComboByServiceID(nServiceID, FALSE);
					if (iProductRow < 0) {
						//this would mean the product in the allocation is not billable to this location
						//give a warning
						CString strWarn;
						strWarn.Format("The product '%s' is not billable to the currently selected location on the bill.", strServiceName);
						AfxMessageBox(strWarn);

						if (nChargedAllocationDetailListID != -1) {
							DeleteOneFromChargedAllocationDetailsArray(nChargedAllocationDetailListID);
						}
						m_rsBill->MoveNext();

						// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
						if (bSwitchedResponsibilitySel) {
							if (nOldRespType == -1) {
								//there was no resp type, so select the blank row
								m_listBillTo->PutCurSel(-1);
							}
							else {
								m_listBillTo->SetSelByColumn(btcID, nOldRespType);
							}
							PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
						}
						continue;
					}
					else {
						//update the remaining fields we need
						strItemCode = VarString(m_ProductsCombo->GetValue(iProductRow, PRODUCTS_COLUMN_INS_CODE), "");
						nCategoryID = VarLong(m_ProductsCombo->GetValue(iProductRow, PRODUCTS_COLUMN_CATEGORYID), -1);
						nSubCategoryID = 0; //turns out this is never used anyways, so default to 0
					}
				}

				// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations
				InvUtils::DoIHaveEnough(nServiceID, LocationID, -GetUnsavedQuantityCount(nServiceID) - (arvRet == arvAddNormally ? dblQuantity : 0.0), -GetUnsavedAllocationQuantityCount(nServiceID), m_EntryType == 2);

				if (m_EntryType == 1 && arvRet == arvAddNormally && nChargedProductItemListID == -1) {
					// Check and see if these products have serial numbers or exp. dates.
					CString strWhere = GetProductItemWhereClause();
					if (strWhere.GetLength() > 0)
						strWhere += " AND ";
					// (j.jones 2007-11-21 16:40) - PLID 28037 - ensure we account for allocated items
					if (!IsRecordsetEmpty("SELECT ID FROM ProductItemsT WHERE %s ProductID = %li "
						"AND ID NOT IN (SELECT ProductItemID FROM ChargedProductItemsT) "
						"AND ID NOT IN (SELECT ProductItemID FROM PatientInvAllocationDetailsT "
						"			    WHERE (Status = %li OR Status = %li) "
						"				AND ProductItemID Is Not Null) "
						"AND Deleted = 0  AND (ProductItemsT.LocationID = %li OR ProductItemsT.LocationID Is Null)",
						strWhere, nServiceID, InvUtils::iadsActive, InvUtils::iadsUsed, LocationID)) {

						BOOL bCancel = FALSE;
						BOOL bLoop = TRUE;

						//while we still need to prompt
						while (bLoop) {

							//prompt
							CProductItemsDlg dlg(this);
							dlg.m_EntryType = PI_SELECT_DATA;
							dlg.m_ProductID = nServiceID;
							dlg.m_nLocationID = LocationID;
							dlg.m_CountOfItemsNeeded = (long)dblQuantity;
							dlg.m_strWhere = GetProductItemWhereClause();

							if (IDCANCEL == dlg.DoModal()) {
								//if they cancelled, warn them!
								if (IDYES == MessageBox("You have chosen to cancel adding this product."
									"\nThe item will not be added to the list if you do not fill in the requested information."
									"\nAre you SURE you wish to cancel?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
									//if they wish to not bill the item, stop looping, cancel adding this item
									bLoop = FALSE;
									bCancel = TRUE;
								}
							}
							else {
								//if they selected an item, then stop looping
								bLoop = FALSE;
								dblQuantity = dlg.m_CountOfItemsNeeded;
								nChargedProductItemListID = NewChargedProductItemListID();
								AddToChargedProductItemsArray(-2, nChargedProductItemListID, dlg.m_adwProductItemIDs);
							}
						}
						if (bCancel) {
							//if the loop ended with a cancellation, skip this item
							m_rsBill->MoveNext();

							// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
							if (bSwitchedResponsibilitySel) {
								if (nOldRespType == -1) {
									//there was no resp type, so select the blank row
									m_listBillTo->PutCurSel(-1);
								}
								else {
									m_listBillTo->SetSelByColumn(btcID, nOldRespType);
								}
								PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
							}
							continue;
						}
					}
					else {
						//if the product doesn't have any ProductItems, see if it requires them, in which case they cannot bill it
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rs = CreateParamRecordset("SELECT Name, HasSerialNum, HasExpDate FROM ServiceT "
							"INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
							"WHERE ServiceT.ID = {INT} AND (HasSerialNum = 1 OR HasExpDate = 1)", nServiceID);
						if (!rs->eof) {
							CString strName = AdoFldString(rs, "Name", "");
							BOOL bHasSerialNum = AdoFldBool(rs, "HasSerialNum", FALSE);
							BOOL bHasExpDate = AdoFldBool(rs, "HasExpDate", FALSE);
							CString str;
							str.Format("The product '%s' requires %s%s%s, but has no items in stock.\n"
								"This product cannot be billed until there are items in stock.", strName,
								bHasSerialNum ? "a serial number" : "",
								(bHasSerialNum && bHasExpDate) ? " and " : "",
								bHasExpDate ? "an expiration date" : "");
							AfxMessageBox(str);

							//move on to the next item
							m_rsBill->MoveNext();

							// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
							if (bSwitchedResponsibilitySel) {
								if (nOldRespType == -1) {
									//there was no resp type, so select the blank row
									m_listBillTo->PutCurSel(-1);
								}
								else {
									m_listBillTo->SetSelByColumn(btcID, nOldRespType);
								}
								PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
							}
							continue;
						}
						rs->Close();
					}
				}
			}

			//found out the LineID this should be
			long nLineID;
			if ((int)m_billingItems.size() > 0) {
				int MaxLineID = 0;
				for (int z = 0; z<(int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal > MaxLineID)
						MaxLineID = m_billingItems[z]->LineID.lVal;
				}
				nLineID = MaxLineID + 1;
			}
			else
				nLineID = 1;

			// (j.jones 2007-03-26 14:42) - PLID 25287 - Now we can deal with our tracking
			// of an excess amount to match up with the package total.
			// If we have a non-zero cyMatchRemainingPackageAmount, we need to apply that to this charge,
			// however, if the quantity is > 1, then we have to split the line item into two, with the first
			// charge only having a quantity of 1
			// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
			if (bApplyMatchedRemAmountNow && dblQuantity > 1.0) {
				//add the charge twice! Once with quantity 1 and the offset amount,
				//and once with the remaining quantity and no offset
				AddChargeToList(TRUE, nServiceID, 1.0, strDescription, strItemCode, nCategoryID, nSubCategoryID, bIsPackage,nCategoryCount ,nChargedProductItemListID, nChargedAllocationDetailListID, nPackageChargeRefID, cyMatchRemainingPackageAmount);
				AddChargeToList(TRUE, nServiceID, dblQuantity - 1.0, strDescription, strItemCode, nCategoryID, nSubCategoryID, bIsPackage, nCategoryCount,nChargedProductItemListID, nChargedAllocationDetailListID, nPackageChargeRefID);

				//remember to warn the user once this operation is complete
				bWarnSplitPackageCharges = TRUE;
			}
			else if (bApplyMatchedRemAmountNow) {
				//use the offset, no quantity manipulation necessary
				AddChargeToList(TRUE, nServiceID, dblQuantity, strDescription, strItemCode, nCategoryID, nSubCategoryID, bIsPackage,nCategoryCount ,nChargedProductItemListID, nChargedAllocationDetailListID, nPackageChargeRefID, cyMatchRemainingPackageAmount, nAppointmentID);
			}
			else {
				//none of this insanity is required, so add normally
				AddChargeToList(TRUE, nServiceID, dblQuantity, strDescription, strItemCode, nCategoryID, nSubCategoryID, bIsPackage,nCategoryCount ,nChargedProductItemListID, nChargedAllocationDetailListID, nPackageChargeRefID, COleCurrency(0, 0), nAppointmentID);
			}

			//just doing this for posterity, even though the boolean is defined within this loop
			bApplyMatchedRemAmountNow = FALSE;

			// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
			if (bSwitchedResponsibilitySel) {
				if (nOldRespType == -1) {
					//there was no resp type, so select the blank row
					m_listBillTo->PutCurSel(-1);
				}
				else {
					m_listBillTo->SetSelByColumn(btcID, nOldRespType);
				}
				PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
			}

			m_rsBill->MoveNext();
		}

		m_rsBill->Close();

		// (j.jones 2008-05-22 12:05) - PLID 28450 - clean up our package array
		for (i = arypPackageCharges.GetSize() - 1; i >= 0; i--) {
			delete (PackageChargeObject*)(arypPackageCharges.GetAt(i));
		}
		arypPackageCharges.RemoveAll();

		/////////////////////////////////////////////////////////////////
		// Sort the list, requery it, and recalculate the bill total
		Requery();

		PostChargeAdded();

		EnableBillingScreen();

		// (j.jones 2007-03-26 14:43) - PLID 25287 - bWarnSplitPackageCharges will be set if
		// we had to turn one multi-quantity charge into two, so now warn since at this point
		// the two charges are visible
		if (bWarnSplitPackageCharges) {
			DontShowMeAgain(this, "One of the package charges that you have added needed to have its pricing modified\n"
				"in order to accurately match up with the balance of the package total.\n\n"
				"Because this charge had a multiple quantity, it was split up into two charges,\n"
				"with the modified price on the charge with a quantity of 1.",
				"PackagePriceMatchQuantitySplit", "Packages", FALSE, FALSE);
		}

		// (j.jones 2007-12-13 17:21) - PLID 27988 - Any allocations we opened, we should be done with them now,
		// so force them to be resolved. But if it returns FALSE, don't worry about it too much here,
		// ValidateChanges will require it before closing.
		if (!ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}

		// (j.jones 2009-09-14 15:46) - PLID 35382 - see if this quote is linked to a PIC that has a case history,
		//and if that case history is not already linked to the bill, try to link it
		if (IsSurgeryCenter(FALSE)) {
			TryLinkCaseHistoriesByQuote(nQuoteID);
		}

		return;

	}NxCatchAll("BillingDlg::PostSelChosenComboQuote");

	EnableBillingScreen();
}

void CBillingDlg::OnSelChosenComboSrgy(long iNewRow)
{
	if (iNewRow == -1)
		return;

	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return;
	}

	// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
	CMaintainFocus maintainFocus(__FUNCTION__);

	CWaitCursor pWait;

	COleVariant var, varLineTotal;
	COleCurrency cyLineTotal;
	_RecordsetPtr rs(__uuidof(Recordset));
	CString strSQL;
	int iLineID;
	BOOL boPayToPractice;
	_variant_t v;

	v = m_SrgyCombo->GetValue(iNewRow, 0);
	long SurgeryID = v.lVal;

	/****************************************************************************************
	* Check all the items being added to make sure it fits the authorization.  This is		*
	* probably somewhat slow, but this case really should rarely come up, it just doesn't	*
	* make much sense.																		*
	****************************************************************************************/

	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

		try {

			//we need to loop through every item being added and compare them against the items 
			//in our referral
			bool bOneFailed = false;

			//setup an array for all the items we'll need to be checking in the auth
			CArray<long, long> aryAuthIDs;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
			while (!rsAuth->eof) {
				aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
				rsAuth->MoveNext();
			}
			rsAuth->Close();

			// (j.jones 2008-05-01 11:53) - PLID 28606 - do not bother checking if services match
			// if the referral has no services in it
			if (aryAuthIDs.GetSize() > 0) {

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsAuthCheck = CreateParamRecordset("SELECT ServiceID FROM SurgeryDetailsT WHERE SurgeryID = {INT}", v.lVal);
				while (!rsAuthCheck->eof && !bOneFailed) {
					long nServiceID = AdoFldLong(rsAuthCheck, "ServiceID");

					bool bFound = false;
					for (int i = 0; i < aryAuthIDs.GetSize() && !bFound; i++) {
						if (aryAuthIDs.GetAt(i) == nServiceID)
							bFound = true;
					}

					if (!bFound)
						bOneFailed = true;

					rsAuthCheck->MoveNext();
				}

				if (bOneFailed) {
					if (MsgBox(MB_YESNO, "At least one item selected on this surgery does not match your insurance authorization.\n"
						"Are you sure you wish to add this surgery?") == IDNO) {
						return;
					}
				}
			}

		} NxCatchAll("Error determining authorization status for surgery.");
	}

	// Create a sql statement to use for generating our BillingItem objects below
	{
		// The base WHERE clause
		CString strWhere;
		//if a surgery has a "person", the ServiceID is null, and we don't bill that line
		// (j.jones 2011-03-28 16:24) - PLID 42575 - ignore non-billable CPT codes
		strWhere.Format("SurgeriesT.ID = %li "
			"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
			"AND SurgeryDetailsT.ServiceID Is Not Null", SurgeryID);

		// Add the "PayToPractice" field to the WHERE clause if this is a bill
		if (m_EntryType == 1) { // Is a bill
			strWhere += " AND PayToPractice = 1";
		}

		// Format the sql statement to include the WHERE clause generated above
		//// (j.gruber 2007-05-23 15:24) - PLID 24870 - implemented surgeries, which don't include coupons, so I took that out		
		// (j.gruber 2009-03-12 11:24) - PLID 33361 - take out old structure, add surgerydetailID to the query				
		// (r.gonet 07/07/2014) - PLID 62572 - Added CPTCodeT.DefaultAsOnHold, a NOT NULL field.
		// (s.tullis 2015-04-20 09:32) - PLID 64975 - Added Category Count
		// (s.tullis 2015-04-20 09:43) - PLID 64973 - Insert default category if one
		strSQL.Format(
			"SELECT SurgeryDetailsT.*, SurgeriesT.*, TypeOfService, "
			"(CASE WHEN ProductT.ID Is Not Null THEN Coalesce(ProductT.InsCode, '') ELSE Coalesce(CPTCodeT.Code,'') END) AS Code, "
			"Coalesce(SubCode, '') AS SubCode, SurgeryDetailsT.ID AS SurgeryDetailID, "
			" ServiceT.PointCost, RewardDiscountsT.DiscountPercent, RewardDiscountsT.DiscountDollars, " // (a.walling 2007-05-30 13:33) - PLID 26172
			" Convert(bit, CASE WHEN ProductT.ID Is Not Null THEN 1 ELSE 0 END) AS IsProduct, ServiceT.Name AS ServiceName, CPTCodeT.DefaultAsOnHold, "
			" ServiceT.Category, COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) as CategoryCount "
			" FROM SurgeriesT "
			" INNER JOIN SurgeryDetailsT ON SurgeriesT.ID = SurgeryDetailsT.SurgeryID "
			" LEFT JOIN CPTCodeT ON SurgeryDetailsT.ServiceID = CPTCodeT.ID "
			" LEFT JOIN ProductT ON SurgeryDetailsT.ServiceID = ProductT.ID "
			" LEFT JOIN ServiceT ON SurgeryDetailsT.ServiceID = ServiceT.ID " // (a.walling 2007-05-30 13:32) - PLID 26172
			" LEFT JOIN RewardDiscountsT ON SurgeryDetailsT.ServiceID = RewardDiscountsT.ServiceID "
			" LEFT JOIN "
			"	( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount "
			"	 FROM ServiceMultiCategoryT "
			"	 Group BY ServiceID "
			"	) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ServiceT.ID "
			" WHERE %s "
			" ORDER BY SurgeryDetailsT.LineOrder", strWhere);	//DRT 5/2/03 - Order by LineOrder instead of ID

		//disable sorting on this bill, because we're using the sorted order from the surgery
		m_bOrderChanged = TRUE;
	}

	// (j.jones 2010-01-06 16:55) - PLID 36757 - these are populated later
	BOOL bIsPackage = FALSE;
	long nPackageType = 1;
	COleCurrency cyPackageTotal = COleCurrency(0, 0);
	long nPackageCount = 1;

	bool bRecalculatePackageTotals = false;

	try {
		//DRT 3/21/03 - If we format a sql statement before using createrecordset or executesql, and it has a % in it, the
		//		strformat part of those functions will cause a silent error or crash altogether.  We need to either format
		//		in the function, or use the ...Std alternative - which does not do any string formatting
		rs = CreateRecordsetStd(strSQL, adOpenStatic, adLockReadOnly);
		BillingItemPtr pNew;

		// (j.jones 2008-05-02 09:25) - PLID 27685 - ensure that the CPT list has been requeried
		// prior to trying to search the list, which we will do later inside the while loop
		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}

		if (!rs->eof) {

			if (m_EntryType == 2) {
				// (j.jones 2010-01-06 16:42) - PLID 36757 - we now support a package surgery, for quotes only
				bIsPackage = AdoFldBool(rs, "IsPackage", FALSE);

				// (j.jones 2016-02-29 14:31) - PLID 68339 - if they are adding a package, 
				// and there are existing charges, the new package price cannot be used,
				// force a recalculation - we will warn later
				if (bIsPackage && m_pList->GetRowCount() > 0) {

					//force a recalculation when there are existing charges
					bRecalculatePackageTotals = true;
				}

				if (bIsPackage) {
					//if we're still a package, load the new data
					nPackageType = AdoFldLong(rs, "PackageType", 1);
					cyPackageTotal = AdoFldCurrency(rs, "PackageTotalAmount", COleCurrency(0, 0));
					nPackageCount = AdoFldLong(rs, "PackageTotalCount", 1);

					m_packageCheck.SetCheck(TRUE);

					// (j.jones 2010-08-19 09:48) - PLID 40150 - ensure we select the package report
					((CBillingModuleDlg*)m_pBillingModuleWnd)->SetQuoteReportDropDown(TRUE);

					m_radioRepeatPackage.ShowWindow(SW_SHOWNOACTIVATE);
					m_radioMultiUsePackage.ShowWindow(SW_SHOWNOACTIVATE);

					if (nPackageType == 1) {
						//repeat package
						m_radioRepeatPackage.SetCheck(TRUE);
						m_radioMultiUsePackage.SetCheck(FALSE);
					}
					else {
						//multi-use package
						m_radioRepeatPackage.SetCheck(FALSE);
						m_radioMultiUsePackage.SetCheck(TRUE);
					}

					OnPackageTypeChanged();

					GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_SHOWNOACTIVATE);
					GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_SHOWNOACTIVATE);

					//ensure the total labels are hidden
					GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_HIDE);
					//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts
					GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
					GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);

					SetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT, nPackageCount);
					SetDlgItemInt(IDC_PACKAGE_COUNT, nPackageCount);
					SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, nPackageCount);

					// (j.jones 2015-02-24 08:56) - PLID 57494 - cache the current totals
					m_nLastPackageTotalCount = nPackageCount;
					m_nLastPackageCount = nPackageCount;

					//technically this is meaningless as CalculateTotal will replace it,
					//and then we will apply this total at the end of this function, but
					//there's no real harm in doing it right now so we replace whatever
					//is currently in these fields
					// (j.jones 2016-02-29 14:35) - PLID 68339 - don't bother trying do do this
					// if we know we are going to recalculate later
					if (!bRecalculatePackageTotals) {
						CString	str = FormatCurrencyForInterface(cyPackageTotal);
						SetDlgItemText(IDC_PACKAGE_TOTAL_COST, str);
						SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, str);
						SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, str);
					}

					m_checkPackageShowInitialValues.SetCheck(FALSE);
					OnPackageShowInitialValues();
				}
			}

			////////////////////////////////////////////////////////////
			// Update description on parent billing module dialog
			// Only update if the description is blank,
			// OR if a quote and the preference for QuoteConcatSurgeryDesc is on, in which case append
			// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
			if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
				// (j.gruber 2012-01-04 11:44) - PLID 46291
				SetBillDescriptionBasedOnResp();
				CString str;
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
				str = GetBillDescription();
				if (str.GetLength() == 0 || (m_EntryType == 2 && GetRemotePropertyInt("QuoteConcatSurgeryDesc", 0, 0, "<None>", true) == 1)) {
					CString strDesc = AdoFldString(rs, "Name", "");
					if (str.GetLength() != 0) {
						str += ", " + strDesc;
					}
					else {
						str = strDesc;
					}
					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
					SetBillDescription(str);
				}
			}
		}

		while (!rs->eof) {

			// (a.walling 2007-05-31 14:10) - PLID 26172
			BOOL bUsingPoints = FALSE;

			CWaitCursor pWait2;
	
			pNew = BillingItem::Create();

			if (SetNewRecordDefaults(pNew, iLineID)) {
				rs->Close();
				return;
			}


			long nServiceID = AdoFldLong(rs, "ServiceID");
			CString strServiceName = AdoFldString(rs, "ServiceName", "");
			BOOL bIsProduct = AdoFldBool(rs, "IsProduct", FALSE);

			//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
			if (m_EntryType == 1 && bIsProduct == FALSE && IsCodeSelectedBasedOnWarning(nServiceID) == FALSE)
			{
				pNew.reset();
				rs->MoveNext();
				continue;
			}

			// (j.jones 2014-07-28 09:26) - PLID 56662 - do not add products that are not billable for the current location
			if (bIsProduct) {
				long iProdRow = FindProductRowInComboByServiceID(nServiceID, TRUE);
				if (iProdRow < 0) {
					MessageBox(FormatString("The product '%s' was not able to be added to the bill. Ensure the product is billable for this location.", strServiceName), "Practice", MB_ICONINFORMATION | MB_OK);
					pNew.reset();
					rs->MoveNext();

					continue;
				}
			}

			// (j.jones 2010-09-03 08:45) - PLID 38319 - if a bill, and a product,
			// and they want to add products as patient responsibility, switch the resp. dropdown now
			BOOL bSwitchedResponsibilitySel = FALSE;
			long nOldRespType = -1;
			if (bIsProduct && m_EntryType == 1
				&& GetRemotePropertyInt("AddInventoryAsPatResp", 0, 0, GetCurrentUserName(), true) == 1) {
				//cache the current resp type and then select patient
				if (m_listBillTo->CurSel != -1) {
					nOldRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
				}

				m_listBillTo->SetSelByColumn(btcPriority, (long)0);
				PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				bSwitchedResponsibilitySel = TRUE;
			}

			double dblQuantity = AdoFldDouble(rs, "Quantity", 1.0);

			//TES 7/15/2008 - PLID 27983 - First, check whether we should pull in linked products for this charge.
			if (m_EntryType == 1 && !bIsProduct) {
				//TES 7/17/2008 - PLID 27983 - Pass in true for bMassAdding
				// (j.jones 2010-11-23 16:27) - PLID 41549 - supported the surgery price and discounts
				COleCurrency cySurgeryPrice = VarCurrency(rs->Fields->Item["Amount"]->Value, COleCurrency(0, 0));
				long nSurgeryDetailID = AdoFldLong(rs, "SurgeryDetailID", -1);
				if (CheckLinkProducts(nServiceID, dblQuantity, true, &cySurgeryPrice, -1, nSurgeryDetailID, TRUE)) {
					//TES 7/15/2008 - PLID 27983 - If CheckLinkProducts() returns TRUE, that means it already added linked products
					// to the bill in lieu of this item.
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}

					continue;
				}
			}
			// (j.jones 2006-04-25 16:37) - we cached the Anesthesia, UseAnesthesiaBilling, FacilityFee, and UseFacilityBilling
			// values, so don't check for these if we already know it's irrelevant

			// (j.jones 2009-03-31 10:54) - PLID 33747 - renamed this boolean to bCPTCodeCachedInfoLoaded,
			// to reflect that we are loading more info than just anesthesia & facility fee info
			BOOL bCPTCodeCachedInfoLoaded = FALSE;
			BOOL bIsAnesthesia = FALSE;
			BOOL bUseAnesthesia = FALSE;
			BOOL bIsFacilityFee = FALSE;
			BOOL bUseFacilityFee = FALSE;
			BOOL bIsAssistingCode = FALSE;

			// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
			BOOL bOHIPPremiumCode = FALSE;

			if (!bIsProduct) {
				// (j.jones 2008-12-15 15:07) - PLID 32431 - changed this code to call FindCPTRowInComboByServiceID,
				// which will force finding the service, incase the combo is still requerying
				//int iCPTRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, FALSE);
				int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);
				if (iCPTRow >= 0) {
					bIsAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ANESTHESIA), FALSE);
					bUseAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_ANESTH_BILLING), FALSE);
					bIsFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_FACILITY_FEE), FALSE);
					bUseFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_FACILITY_BILLING), FALSE);

					// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
					bOHIPPremiumCode = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_OHIP_PREMIUM_CODE), FALSE);

					// (j.jones 2010-11-23 08:52) - PLID 39602 - cache the AssistingCode value
					bIsAssistingCode = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ASSISTING_CODE), FALSE);

					//means we can safely use the booleans
					bCPTCodeCachedInfoLoaded = TRUE;
				}

				// if bCPTCodeCachedInfoLoaded = FALSE, then we can't check the cached values, so we run based on Service ID

				//check and see if this is an anesthesia code or facility code, and already exists in the charge list
				if ((!bCPTCodeCachedInfoLoaded || (bIsAnesthesia && bUseAnesthesia) || (bIsFacilityFee && bUseFacilityFee))
					&& !CheckAllowAddAnesthesiaFacilityCharge(nServiceID)) {
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}
			}

			// (j.jones 2004-07-07 16:59) - if the current ins. resp. is set to allow 1/10th rounding, do so!
			long InsID = -1;
			InsID = GetCurrentBillToInsuranceCoID();
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			BOOL bRoundUp = !ReturnsRecordsParam("SELECT PersonID FROM InsuranceCoT WHERE AnesthesiaSetting = 1 AND PersonID = {INT}", InsID);

			BOOL bAnesthesia = FALSE;
			COleCurrency cyAnesthUnitCost = COleCurrency(0, 0);
			double dblAnesthUnits = 0.0;

			if (m_PlaceOfServiceCombo->CurSel == -1)
				m_PlaceOfServiceCombo->CurSel = 0;
			long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

			// (j.jones 2009-03-31 10:39) - PLID 33747 - if a CPT code, check if it is an OHIP Premium Code
			if (!bIsProduct && bCPTCodeCachedInfoLoaded
				&& UseOHIP() && bOHIPPremiumCode) {

				//the flat fee option will use the standard fee, not the fee from whatever object added this charge
				if (ProcessOHIPPremiumCode(nServiceID)) {
					//if the above function returns true, we will not add this charge in this function
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}
			}

			//pre-fill the start/end times, and minutes, with info from the Billing2 dlg
			long nAnesthMinutes = GetAnesthMinutes();
			CString strStartTime = GetAnesthStartTime();
			CString strEndTime = GetAnesthEndTime();

			// (j.jones 2010-01-18 13:53) - PLID 36913 - load the information from the surgery
			// if it didn't exist on the bill already
			BOOL bLoadedSurgeryAnesthTimes = FALSE;
			if (nAnesthMinutes == 0) {
				nAnesthMinutes = AdoFldLong(rs, "AnesthMinutes", 0);
				if (nAnesthMinutes != 0) {
					bLoadedSurgeryAnesthTimes = TRUE;
				}
			}
			if (strStartTime == "") {
				_variant_t var = rs->Fields->Item["AnesthStartTime"]->Value;
				if (var.vt == VT_DATE) {
					strStartTime = VarDateTime(var).Format("%H:%M:%S");
					bLoadedSurgeryAnesthTimes = TRUE;
				}
			}
			if (strEndTime == "") {
				_variant_t var = rs->Fields->Item["AnesthEndTime"]->Value;
				if (var.vt == VT_DATE) {
					strEndTime = VarDateTime(var).Format("%H:%M:%S");
					bLoadedSurgeryAnesthTimes = TRUE;
				}
			}

			// (j.jones 2004-07-07 12:09) - checks to see if this is an anesthesia code and loads the associated info.
			if (!bIsProduct && (!bCPTCodeCachedInfoLoaded || bUseAnesthesia)) {
				if (!CheckAnesthesia(nServiceID, bAnesthesia, cyAnesthUnitCost, dblAnesthUnits, nAnesthMinutes, strStartTime, strEndTime, nPlaceOfServiceID, bRoundUp, bLoadedSurgeryAnesthTimes)) {
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}
			}

			if (bAnesthesia) {
				//set the times on the Billing2 dlg
				SetAnesthMinutes(nAnesthMinutes);
				SetAnesthStartTime(strStartTime);
				SetAnesthEndTime(strEndTime);
			}

			long nFacilityMinutes = GetFacilityMinutes();
			strStartTime = GetFacilityStartTime();
			strEndTime = GetFacilityEndTime();

			// (j.jones 2010-01-18 13:53) - PLID 36913 - load the information from the surgery
			// if it didn't exist on the bill already
			BOOL bLoadedSurgeryFacilityTimes = FALSE;
			if (nFacilityMinutes == 0) {
				nFacilityMinutes = AdoFldLong(rs, "FacilityMinutes", 0);
				if (nFacilityMinutes != 0) {
					bLoadedSurgeryFacilityTimes = TRUE;
				}
			}
			if (strStartTime == "") {
				_variant_t var = rs->Fields->Item["FacilityStartTime"]->Value;
				if (var.vt == VT_DATE) {
					strStartTime = VarDateTime(var).Format("%H:%M:%S");
					bLoadedSurgeryFacilityTimes = TRUE;
				}
			}
			if (strEndTime == "") {
				_variant_t var = rs->Fields->Item["FacilityEndTime"]->Value;
				if (var.vt == VT_DATE) {
					strEndTime = VarDateTime(var).Format("%H:%M:%S");
					bLoadedSurgeryFacilityTimes = TRUE;
				}
			}

			BOOL bFacilityFee = FALSE;
			COleCurrency cyFacilityUnitCost = COleCurrency(0, 0);
			// (j.jones 2005-07-01 11:31) - checks to see if this is a facility fee code and calculates the right fee
			if (!bIsProduct && (!bCPTCodeCachedInfoLoaded || bUseFacilityFee)) {
				if (!CheckFacilityFee(nServiceID, bFacilityFee, cyFacilityUnitCost, nFacilityMinutes, strStartTime, strEndTime, nPlaceOfServiceID, bLoadedSurgeryFacilityTimes)) {
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}
			}

			if (bFacilityFee) {
				//set the times on the Billing2 dlg
				SetFacilityMinutes(nFacilityMinutes);
				SetFacilityStartTime(strStartTime);
				SetFacilityEndTime(strEndTime);
			}

			if (bAnesthesia)
				dblQuantity = dblAnesthUnits;

			// (j.jones 2010-11-23 08:58) - PLID 39602 - if OHIP, and not anesthesia, and not a facility fee,
			// check to see if it is an assisting code
			BOOL bAssistingCode = FALSE;
			COleCurrency cyAssistingCodeUnitCost = COleCurrency(0, 0);

			if (!bIsProduct && !bAnesthesia && !bFacilityFee
				&& UseOHIP()
				&& (!bCPTCodeCachedInfoLoaded || bIsAssistingCode)) {

				// (j.jones 2011-10-31 17:15) - PLID 41558 - we now store this per bill
				long nAssistingMinutes = GetAssistingMinutes();
				CString strAssistingStartTime = GetAssistingStartTime();
				CString strAssistingEndTime = GetAssistingEndTime();

				if (!CheckAssistingCode(nServiceID, bAssistingCode, cyAssistingCodeUnitCost, nAssistingMinutes, strAssistingStartTime, strAssistingEndTime)) {
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}

				if (bAssistingCode) {
					//set the times on the Billing2 dlg
					SetAssistingMinutes(nAssistingMinutes);
					SetAssistingStartTime(strAssistingStartTime);
					SetAssistingEndTime(strAssistingEndTime);
				}
			}

			// (j.gruber 2009-03-06 09:53) - PLID 33351 - take out discounts
			pNew->DiscountList = new DiscountList;

			COleCurrency cyPointCost = AdoFldCurrency(rs, "PointCost", COleCurrency(0, 0));
			COleCurrency cyRewardDiscountDollars = AdoFldCurrency(rs, "DiscountDollars", COleCurrency(0, 0));
			long nRewardDiscountPercent = AdoFldLong(rs, "DiscountPercent", 0);
			COleCurrency cyPointsUsed;
			long nSurgeryDetailID = AdoFldLong(rs, "SurgeryDetailID", -1);

			LoadDiscountList(TRUE, nSurgeryDetailID, nServiceID, pNew->DiscountList, cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent, bUsingPoints, cyPointsUsed, FALSE, TRUE);

			long LocationID = -1;

			if (m_LocationCombo->GetCurSel() == -1)
				LocationID = GetCurrentLocationID();
			else
				LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

			long nChargedProductItemListID = -1;
			long nChargedAllocationDetailListID = -1;

			ProductAllocationReturnValue arvRet = arvAddNormally;

			CString strItemCode = AdoFldString(rs, "Code");

			//first check to see if we have a product on our hands
			if (bIsProduct) {

				// (j.jones 2013-05-13 14:16) - PLID 56661 - moved this requery code earlier in the function so
				// that any time any surgery has a product, we ensure the list is requeried, as opposed
				// to checking this any time we might be pulling from the list

				//we can pull the info from the products dropdown, but it may not have been requeried yet
				if (m_bProductsCombo == FALSE) {
					// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
					RequeryProductCombo();
				}

				// (j.jones 2007-12-13 16:12) - PLID 27988 - check to see if this product is in an allocation
				// this *can* change the nServiceID, strProductName, and dblQuantity!
				long nOldServiceID = nServiceID;
				arvRet = CheckProductAgainstAllocations(nServiceID, strServiceName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID);

				//did the user decide to cancel adding the product?
				if (arvRet == arvAbortAdding) {
					pNew.reset();
					rs->MoveNext();

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					continue;
				}

				//did the product ID change?
				if (nServiceID != nOldServiceID) {

					// (j.jones 2008-12-15 15:02) - PLID 32431 - changed this code to call FindProductRowInComboByServiceID,
					// which will force finding the product, incase the combo is still requerying
					int iProductRow = FindProductRowInComboByServiceID(nServiceID, FALSE);
					if (iProductRow < 0) {
						//this would mean the product in the allocation is not billable to this location
						//give a warning
						CString strWarn;
						strWarn.Format("The product '%s' is not billable to the currently selected location on the bill.", strServiceName);
						AfxMessageBox(strWarn);

						if (nChargedAllocationDetailListID != -1) {
							DeleteOneFromChargedAllocationDetailsArray(nChargedAllocationDetailListID);
						}
						pNew.reset();
						rs->MoveNext();

						// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
						if (bSwitchedResponsibilitySel) {
							if (nOldRespType == -1) {
								//there was no resp type, so select the blank row
								m_listBillTo->PutCurSel(-1);
							}
							else {
								m_listBillTo->SetSelByColumn(btcID, nOldRespType);
							}
							PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
						}
						continue;
					}
					else {
						//update the remaining fields we need
						strItemCode = VarString(m_ProductsCombo->GetValue(iProductRow, PRODUCTS_COLUMN_INS_CODE), "");

						//this function already queries the data later for product-specific information,
						//so we don't need to load up anything else now but the ItemCode
					}
				}
			}

			if (bIsProduct) {

				// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations
				InvUtils::DoIHaveEnough(nServiceID, LocationID, -GetUnsavedQuantityCount(nServiceID) - (arvRet == arvAddNormally ? dblQuantity : 0.0), -GetUnsavedAllocationQuantityCount(nServiceID), m_EntryType == 2);

				if (m_EntryType == 1 && arvRet == arvAddNormally && nChargedProductItemListID == -1) {
					// Check and see if these products have serial numbers or exp. dates.
					CString strWhere = GetProductItemWhereClause();
					if (strWhere.GetLength() > 0)
						strWhere += " AND ";
					// (j.jones 2007-11-21 16:40) - PLID 28037 - ensure we account for allocated items
					if (!IsRecordsetEmpty("SELECT ID FROM ProductItemsT WHERE %s ProductID = %li "
						"AND ID NOT IN (SELECT ProductItemID FROM ChargedProductItemsT) "
						"AND ID NOT IN (SELECT ProductItemID FROM PatientInvAllocationDetailsT "
						"			    WHERE (Status = %li OR Status = %li) "
						"				AND ProductItemID Is Not Null) "
						"AND Deleted = 0  AND (ProductItemsT.LocationID = %li OR ProductItemsT.LocationID Is Null)",
						strWhere, nServiceID, InvUtils::iadsActive, InvUtils::iadsUsed, LocationID)) {

						BOOL bCancel = FALSE;
						BOOL bLoop = TRUE;

						//while we still need to prompt
						while (bLoop) {

							CWaitCursor pWait3;

							//prompt
							CProductItemsDlg dlg(this);
							dlg.m_EntryType = PI_SELECT_DATA;
							dlg.m_ProductID = nServiceID;
							dlg.m_nLocationID = LocationID;
							dlg.m_CountOfItemsNeeded = (long)dblQuantity;
							dlg.m_strWhere = GetProductItemWhereClause();

							if (IDCANCEL == dlg.DoModal()) {
								//if they cancelled, warn them!
								if (IDYES == MessageBox("You have chosen to cancel adding this product."
									"\nThe item will not be added to the list if you do not fill in the requested information."
									"\nAre you SURE you wish to cancel?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
									//if they wish to not bill the item, stop looping, cancel adding this item
									bLoop = FALSE;
									bCancel = TRUE;
								}
							}
							else {
								//if they selected an item, then stop looping
								bLoop = FALSE;
								dblQuantity = dlg.m_CountOfItemsNeeded;
								nChargedProductItemListID = NewChargedProductItemListID();
								AddToChargedProductItemsArray(-2, nChargedProductItemListID, dlg.m_adwProductItemIDs);
							}
						}
						if (bCancel) {
							//if the loop ended with a cancellation, skip this item
							pNew.reset();
							rs->MoveNext();

							// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
							if (bSwitchedResponsibilitySel) {
								if (nOldRespType == -1) {
									//there was no resp type, so select the blank row
									m_listBillTo->PutCurSel(-1);
								}
								else {
									m_listBillTo->SetSelByColumn(btcID, nOldRespType);
								}
								PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
							}
							continue;
						}

					}
					else {
						//if the product doesn't have any ProductItems, see if it requires them, in which case they cannot bill it
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rsProduct = CreateParamRecordset("SELECT Name, HasSerialNum, HasExpDate FROM ServiceT "
							"INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
							"WHERE ServiceT.ID = {INT} AND (HasSerialNum = 1 OR HasExpDate = 1)", nServiceID);
						if (!rsProduct->eof) {
							CString strName = AdoFldString(rsProduct, "Name", "");
							BOOL bHasSerialNum = AdoFldBool(rsProduct, "HasSerialNum", FALSE);
							BOOL bHasExpDate = AdoFldBool(rsProduct, "HasExpDate", FALSE);
							CString str;
							str.Format("The product '%s' requires %s%s%s, but has no items in stock.\n"
								"This product cannot be billed until there are items in stock.", strName,
								bHasSerialNum ? "a serial number" : "",
								(bHasSerialNum && bHasExpDate) ? " and " : "",
								bHasExpDate ? "an expiration date" : "");
							AfxMessageBox(str);

							//move on to the next item
							pNew.reset();
							rs->MoveNext();

							// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
							if (bSwitchedResponsibilitySel) {
								if (nOldRespType == -1) {
									//there was no resp type, so select the blank row
									m_listBillTo->PutCurSel(-1);
								}
								else {
									m_listBillTo->SetSelByColumn(btcID, nOldRespType);
								}
								PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
							}
							continue;
						}
						rsProduct->Close();
					}
				}
			}

			pNew->ChargedProductItemListID = nChargedProductItemListID;
			pNew->ChargedAllocationDetailListID = nChargedAllocationDetailListID;

			CWaitCursor pWait4;

			var = rs->Fields->Item["PayToPractice"]->Value;
			boPayToPractice = var.boolVal;

			//////////////////////////////////////////////////////////////////
			// Have ChargeID be a -2 so we know it's not actually a charge yet
			var.vt = VT_I4;
			var = (long)-2;
			pNew->ChargeID = var;
			//			rs.GetFieldValue("Description", var);
			//			m_pList->SetFieldValue("Description", var);

			CString str;

			var = rs->Fields->Item["TypeOfService"]->Value;
			if (var.vt != VT_NULL)
				str.Format(CString(var.bstrVal));
			if (var.vt == VT_BSTR && *(CString(var.bstrVal)) && (str != "(null)"))
				pNew->TypeOfService = var;
			else pNew->TypeOfService.vt = NULL;

			pNew->ServiceID = nServiceID;

			var = strItemCode;
			pNew->CPTCode = var;

			var = rs->Fields->Item["SubCode"]->Value;
			pNew->CPTSubCode = var;

			// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
			// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
			if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 1) {
				pNew->Provider = (long)-1;
			}
			else {
				long ProviderID = AdoFldLong(rs, "ProviderID", -1);
				if (ProviderID != -1) {
					pNew->Provider = (long)ProviderID;
				}
			}

			// (j.jones 2010-11-09 10:34) - PLID 31392 - added ClaimProvider
			pNew->ClaimProvider = m_DefaultClaimProvider;
							
			if (!bIsProduct) {

				// (j.jones 2016-06-15 13:48) - NX-100077 - all of the below service code
				// stuff is only for bills, not quotes
				if (m_EntryType == 1) {

					int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);

					if (iCPTRow >= 0) {

						// (j.jones 2012-04-12 10:00) - PLID 49609 - Add the default claim note, if it exists.
						CString strClaimNote = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_CLAIM_NOTE), "");
						strClaimNote.TrimLeft(); strClaimNote.TrimRight();
						if (strClaimNote.GetLength() > 0) {
							AddNewUnsavedChargeNote(pNew, strClaimNote, TRUE);
						}

						// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
						CString strNDCCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFCODE), "");
						double dblNDCQty = VarDouble(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFQTY), 0.0);
						COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
						CString strNDCUnitType = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITTYPE), "");

						pNew->NDCCode = strNDCCode;
						pNew->DrugUnitPrice = cyNDCUnitPrice;
						pNew->DrugUnitType = strNDCUnitType;
						pNew->DrugUnitQuantity = dblNDCQty;
					}
				}
			}
			else {

				//is a product

				// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
				long iProdRow = FindProductRowInComboByServiceID(nServiceID, TRUE);
				if (iProdRow < 0) {
					MessageBox(FormatString("The product '%s' was not able to be added. Ensure the product is billable for this location.", strServiceName), "Practice", MB_ICONINFORMATION | MB_OK);
					pNew.reset();
					rs->MoveNext();

					continue;
				}
				else if (iProdRow >= 0) {

					//bills only
					if (m_EntryType == 1) {
						// (j.dinatale 2012-06-15 10:51) - PLID 51000 - Added claim notes to inventory items
						CString strClaimNote = VarString(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_CLAIM_NOTE), "");
						strClaimNote.TrimLeft(); strClaimNote.TrimRight();
						if (strClaimNote.GetLength() > 0) {
							AddNewUnsavedChargeNote(pNew, strClaimNote, TRUE);
						}

						// (j.dinatale 2012-06-15 18:26) - PLID 50959 - NDC defaults for inventory items
						CString strNDCCode = VarString(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_NDCDEFCODE), "");
						double dblNDCQty = VarDouble(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_NDCDEFQTY), 0.0);
						COleCurrency cyNDCUnitPrice = VarCurrency(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
						CString strNDCUnitType = VarString(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_NDCDEFUNITTYPE), "");

						pNew->NDCCode = strNDCCode;
						pNew->DrugUnitPrice = cyNDCUnitPrice;
						pNew->DrugUnitType = strNDCUnitType;
						pNew->DrugUnitQuantity = dblNDCQty;
					}

					//the remaining features are for bills and quotes

					// (j.jones 2016-04-07 13:16) - NX-100077 - added RememberChargeProvider setting
					bool bRememberChargeProvider = VarBool(m_ProductsCombo->GetValue(iProdRow, PRODUCTS_COLUMN_REMEMBER_CHARGE_PROVIDER), FALSE) ? true : false;
					if (bRememberChargeProvider) {
						//this function will auto-update the provider to the last one who sold
						//the patient this product, if a prior sale exists
						UpdateChargeToMostRecentProviderSold(pNew);
					}
				}
				else {
					//don't throw an exception, we unfortunately errantly permit billing invalid products through surgeries
					ASSERT(FALSE);
				}
			}

			var = rs->Fields->Item["Amount"]->Value;
			if (bAnesthesia) {
				var = cyAnesthUnitCost;
			}
			else if (bFacilityFee) {
				var = cyFacilityUnitCost;
			}
			// (j.jones 2010-11-23 09:03) - PLID 39602 - use the assisting code cost
			else if (bAssistingCode) {
				var = cyAssistingCodeUnitCost;
			}
			varLineTotal = var;

			// (s.tullis 2015-04-20 09:43) - PLID 64973 - Insert default category if one
			pNew->CPTCategoryID = AdoFldLong(rs, "Category", 0);
			// (s.tullis 2015-04-20 09:32) - PLID 64975 - for showing/hiding category column
			pNew->CPTCategoryCount = AdoFldLong(rs, "CategoryCount", 0);

			// (j.jones 2014-04-23 08:40) - PLID 61836 - added the ReferringProviderID, OrderingProviderID, SupervisingProviderID
			pNew->ReferringProviderID = (long)-1;
			pNew->ReferringProviderIDRequired = g_cvarFalse;
			pNew->OrderingProviderID = (long)-1;
			pNew->OrderingProviderIDRequired = g_cvarFalse;
			pNew->SupervisingProviderID = (long)-1;
			pNew->SupervisingProviderIDRequired = g_cvarFalse;
			// (r.gonet 07/07/2014) - PLID 62572 - New charges on a bill can be on hold by default if the CPT code is configured as such.
			if (m_EntryType == 1 && GetBillStatusType() != EBillStatusType::OnHold) {
				pNew->OnHold = AdoFldBool(rs, "DefaultAsOnHold", FALSE) ? g_cvarTrue : g_cvarFalse;
			} else {
				// (r.gonet 07/07/2014) - PLID 62569 - Quote charges can't be on hold. And bills already on hold can't have on hold charges.
				pNew->OnHold = g_cvarFalse;
			}

			cyLineTotal = var.cyVal;

			// (j.jones 2006-09-19 11:24) - PLID 22106 - check that the Anesthesia or Facility Fees require an outside fee
			// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (boPayToPractice && bAnesthesia && m_EntryType == 2 && ReturnsRecordsParam("SELECT AnesthOutsideFee FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND AnesthOutsideFee = 1", nServiceID, nPlaceOfServiceID)) {

				//they want the anesthesia to be paid as an outside fee, but the surgery says otherwise, so prompt
				if (IDYES == MessageBox("An anesthesia fee on this surgery is set as a practice fee, "
					"but your settings for this Place Of Service state that it should be an outside fee.\n\n"
					"Do you wish to calculate the anesthesia fee as an outside fee?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

					//make it an outside fee
					boPayToPractice = FALSE;
				}
			}

			// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (boPayToPractice && bFacilityFee && m_EntryType == 2 && ReturnsRecordsParam("SELECT FacilityOutsideFee FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND FacilityOutsideFee = 1", nServiceID, nPlaceOfServiceID)) {

				//they want the facility fee to be paid as an outside fee, but the surgery says otherwise, so prompt
				if (IDYES == MessageBox("A facility fee on this surgery is set as a practice fee, "
					"but your settings for this Place Of Service state that it should be an outside fee.\n\n"
					"Do you wish to calculate the facility fee as an outside fee?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

					//make it an outside fee
					boPayToPractice = FALSE;
				}
			}

			if (boPayToPractice) {
				pNew->UnitCost = var;
				pNew->OthrUnitCost = COleCurrency(0, 0);
			}
			else {
				pNew->OthrUnitCost = var;
				pNew->UnitCost = COleCurrency(0, 0);
			}

			pNew->Quantity = (double)dblQuantity;
			pNew->PackageQtyRemaining = (double)dblQuantity;
			// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
			pNew->OriginalPackageQtyRemaining = (double)dblQuantity;

			cyLineTotal = CalculateAmtQuantity(cyLineTotal, dblQuantity);

			// (j.gruber 2009-03-06 10:11) - PLID 33351 - new discount structure
			COleCurrency cyTotalDollarDiscount;
			long nPercentOff;
			COleCurrency cyTotalLineDiscount;

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			CalculateTotalDiscount(pNew->DiscountList, cyLineTotal, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);
			pNew->TotalDiscount = cyTotalLineDiscount;

			cyLineTotal = (cyLineTotal * (100000 - nPercentOff * 1000));
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
			cyLineTotal = cyLineTotal / long(100000);
			cyLineTotal -= cyTotalDollarDiscount;

			//DRT 1/6/2005 - We need to save the line total cost before tax is applied for
			//	use at the bottom of this function.  Do not change this value.
			COleCurrency cyPreTaxLineTotal = cyLineTotal;

			pNew->Batched.vt = VT_BOOL;
			pNew->Batched.boolVal = TRUE;

			pNew->TaxRate1 = (double)0.0;
			pNew->TaxRate2 = (double)0.0;

			//get taxable status
			long TaxType = 2;

			//find the insurance company's taxable status
			TaxType = GetInsuranceCoTaxType(GetCurrentBillToInsuredPartyID());

			if (bIsProduct) {

				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				pNew->ItemType = (long)ITEM_TYPE_PRODUCT;

				_RecordsetPtr rs1(__uuidof(Recordset)), rsTax(__uuidof(Recordset));
				CString sql;

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				rs1 = CreateParamRecordset("SELECT Category, Name, Taxable1, Taxable2 FROM ServiceT LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID WHERE ServiceT.ID = {INT}", nServiceID);
				//leave category here for now, NxTools will update it
				//bad data structure makes reports too hard if this isn't updated
				pNew->CPTCategoryID = rs1->Fields->Item["Category"]->Value;
				pNew->Description = rs1->Fields->Item["Name"]->Value;
				COleVariant varTax1, varTax2;
				varTax1 = rs1->Fields->Item["Taxable1"]->Value;
				varTax2 = rs1->Fields->Item["Taxable2"]->Value;
				rs1->Close();

				COleCurrency taxTotal1 = COleCurrency(0, 0), taxTotal2 = COleCurrency(0, 0);

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				rsTax = CreateParamRecordset("SELECT TaxRate, TaxRate2 FROM LocationsT WHERE LocationsT.ID = {INT}", GetCurrentLocation());
				//if taxable
				if (!rsTax->eof) {
					var = rsTax->Fields->Item["TaxRate"]->Value;
					if (TaxType != 3 && var.vt == VT_R8 && var.dblVal != 0.0 && varTax1.vt != VT_NULL && varTax1.boolVal == -1) {
						pNew->TaxRate1 = COleVariant(m_fltPracticeTax1);

						taxTotal1 = CalculateTax(cyLineTotal, ((m_fltPracticeTax1 / 100.0) + 1.0));
					}
					var = rsTax->Fields->Item["TaxRate2"]->Value;
					if (TaxType != 3 && var.vt == VT_R8 && var.dblVal != 0.0 && varTax2.vt != VT_NULL && varTax2.boolVal == -1) {
						pNew->TaxRate2 = COleVariant(m_fltPracticeTax2);

						taxTotal2 = CalculateTax(cyLineTotal, ((m_fltPracticeTax2 / 100.0) + 1.0));
					}
				}
				cyLineTotal += taxTotal1;
				cyLineTotal += taxTotal2;
				RoundCurrency(cyLineTotal);
				rsTax->Close();
			}
			else {	//categories for CPT Codes - they can also be taxed

				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				pNew->ItemType = (long)ITEM_TYPE_CPT;

				_RecordsetPtr rsCat(__uuidof(Recordset));

				COleVariant varTax1, varTax2;

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				rsCat = CreateParamRecordset("SELECT Category, Name, Taxable1, Taxable2 FROM CPTCodeT INNER JOIN ServiceT ON CPTCodeT.ID = ServiceT.ID "
					"WHERE CPTCodeT.ID = {INT}", nServiceID);
				if (!rsCat->eof) {
					var = rsCat->Fields->Item["Category"]->Value;
					pNew->CPTCategoryID = var;
					pNew->Description = rsCat->Fields->Item["Name"]->Value;
					varTax1 = rsCat->Fields->Item["Taxable1"]->Value;
					varTax2 = rsCat->Fields->Item["Taxable2"]->Value;
				}
				rsCat->Close();

				COleCurrency taxTotal1 = COleCurrency(0, 0), taxTotal2 = COleCurrency(0, 0);

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsTax = CreateParamRecordset("SELECT TaxRate, TaxRate2 FROM LocationsT WHERE LocationsT.ID = {INT}", GetCurrentLocation());
				//if taxable
				if (!rsTax->eof) {
					var = rsTax->Fields->Item["TaxRate"]->Value;
					if (TaxType != 3 && var.vt == VT_R8 && var.dblVal != 0.0 && varTax1.vt != VT_NULL && varTax1.boolVal == -1)	{
						pNew->TaxRate1 = COleVariant(m_fltPracticeTax1);

						taxTotal1 = CalculateTax(cyLineTotal, ((m_fltPracticeTax1 / 100.0) + 1.0));
					}
					var = rsTax->Fields->Item["TaxRate2"]->Value;
					if (TaxType != 3 && var.vt == VT_R8 && var.dblVal != 0.0 && varTax2.vt != VT_NULL && varTax2.boolVal == -1)	{
						pNew->TaxRate2 = COleVariant(m_fltPracticeTax2);

						taxTotal2 = CalculateTax(cyLineTotal, ((m_fltPracticeTax2 / 100.0) + 1.0));
					}
				}
				cyLineTotal += taxTotal1;
				cyLineTotal += taxTotal2;
				RoundCurrency(cyLineTotal);
				rsTax->Close();
			}

			var = cyLineTotal;
			pNew->LineTotal = var;

			///////////////////////
			//find the item in the list

			pNew->RPCList = new RPCList;	//AddChargeToList usually does this, but that doesn't quite work in this situation
			RPCList *list = pNew->RPCList;

			//DRT 6/16/03 - This code does NOT need to be executed if we are under patient resp - that is all
			//		handled at the end of a save to figure out the patient resp from what the insurance has
			long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
			if (nInsuredPartyID > 0) {

				//DRT 1/6/2005 - PLID 15187 - This bug has existed for quite some time ... apparently the code
				//	to fill the pre-tax amount never took quantity into account.  This is just popping up now
				//	because the anesthesia minute stuff allows you to have a 0 quantity, so we noticed it.
				//This now calculates varNoTaxLineAmount as the pre-tax amount, and 'var' is still the taxed
				//	amount.
				_variant_t varNoTaxLineAmount = cyPreTaxLineTotal;	//cyPreTaxLineTotal is set above when we first calculate the line amt w/o tax.

				bool bFoundResp = false;
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int j = 0;
				for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
					if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == GetCurrentBillToInsuredPartyID())
						bFoundResp = true;
				}

				var = cyLineTotal;

				if (bFoundResp) {
					//at this point, varNoTaxLineAmount is the amount before tax, and var is the amount with tax
					//use the insurance TaxType to determine which responsibility gets which amount
					if (TaxType == 1)
						UpdateListInsAmount(list, j, varNoTaxLineAmount);
					else
						//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
						UpdateListInsAmount(list, j, var);
				}
				else {
					//we're looking at insurance, but there's nothing in our list!  we
					//need to add it
					RespPerCharge rpc;
					rpc.InsuredPartyID = GetCurrentBillToInsuredPartyID();

					if (TaxType == 1)
						rpc.InsAmount = varNoTaxLineAmount;
					else
						//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
						rpc.InsAmount = var;

					// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
					rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
					rpc.RespTypeName = GetCurrentBillToRespTypeName();

					list->aryRPC.Add(rpc);
				}

			}

			// (j.gruber 2009-10-16 11:59) - PLID 35947 - load the allowable
			LoadAllowableColumn(pNew, FALSE);

			m_billingItems.push_back(pNew);

			// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
			if (bSwitchedResponsibilitySel) {
				if (nOldRespType == -1) {
					//there was no resp type, so select the blank row
					m_listBillTo->PutCurSel(-1);
				}
				else {
					m_listBillTo->SetSelByColumn(btcID, nOldRespType);
				}
				PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
			}

			// (j.jones 2014-05-01 08:36) - PLID 61837 - the new charge may
			// potentially show additional provider columns
			if (m_EntryType == 1) {
				TryShowChargeProviderColumns(pNew, true);
			}

			rs->MoveNext();
		}

		/////////////////////////////////////////////////////////////////
		// Sort the list, requery it, and recalculate the bill total

		// (j.jones 2016-02-26 15:09) - PLID 68339 - tell the calculation if we
		// want to force a full package recalculation
		Requery(bRecalculatePackageTotals);

		PostChargeAdded();

		// (j.jones 2010-01-06 17:08) - PLID 36757 - it is likely that the above code will have
		// tried to recalculate the package total, because normally any change should do so,
		// but if we loaded a specific package total, apply it now
		if (bIsPackage) {
			// (j.jones 2016-02-26 15:08) - PLID 68339 - we now have a flag to force a recalculation,
			// so if that was set, skip this update, and tell the user what happened
			if (bRecalculatePackageTotals) {
				CString strNewPackageTotal;
				GetDlgItemText(IDC_PACKAGE_TOTAL_COST, strNewPackageTotal);
				CString strWarning;
				strWarning.Format("Because this quote already has charges on it, the selected package's total cost of %s will not be used. "
					"The Total Package Cost has been reset to %s.\n\n"
					"Please review the Total Package Cost to ensure the value is correct.", FormatCurrencyForInterface(cyPackageTotal), strNewPackageTotal);
				AfxMessageBox(strWarning);
			}
			else {
				//we really do want the new package's total
				CString	str = FormatCurrencyForInterface(cyPackageTotal);
				SetDlgItemText(IDC_PACKAGE_TOTAL_COST, str);
				SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, str);
				SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, str);
			}
		}

		// (j.jones 2007-12-13 17:21) - PLID 27988 - Any allocations we opened, we should be done with them now,
		// so force them to be resolved. But if it returns FALSE, don't worry about it too much here,
		// ValidateChanges will require it before closing.
		if (!ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}
	}
	NxCatchAll("BillingDlg::OnSelChosenComboSrgy");
}

void CBillingDlg::OnColumnClickingComboCpt(short nCol, BOOL FAR* bAllowSort)
{
	/* Save the textbox format as a user preference */
	SetRemotePropertyInt("CPTSearch", nCol, 0, GetCurrentUserName());
}

void CBillingDlg::OnColumnClickingComboProducts(short nCol, BOOL FAR* bAllowSort)
{
	/* Save the textbox format as a user preference */
	SetRemotePropertyInt("ProductSearch", nCol, 0, GetCurrentUserName());
}

void CBillingDlg::OnColumnClickingComboQuote(short nCol, BOOL FAR* bAllowSort)
{
	/* Save the textbox format as a user preference */
	//SetRemotePropertyInt("QuoteSearch", nCol, 0, GetCurrentUserName());
}

void CBillingDlg::OnColumnClickingComboSrgy(short nCol, BOOL FAR* bAllowSort)
{
	/* Save the textbox format as a user preference */
	SetRemotePropertyInt("SrgySearch", nCol, 0, GetCurrentUserName());
}

LRESULT CBillingDlg::OnBarcodeScan(WPARAM wParam, LPARAM lParam)
{
	// (a.walling 2007-05-11 10:06) - PLID 25983 - We shouldn't allow adding an item to the bill if it is disabled
	// (j.jones 2011-01-21 10:24) - PLID 42156 - you can add if you have partial access
	if (m_eHasAccess == batNoAccess) {
		DontShowMeAgain(this, "This bill is not currently editable; this scan will be ignored.", "BarcodeScanOnDisabledBill", "Barcode Scan");
		return 0;
	}

	CString str;
	// (a.walling 2007-11-08 16:28) - PLID 27476 - Need to convert this correctly from a bstr
	_bstr_t bstr = (BSTR)lParam; // We can typecast this to an ANSI string // a.walling -- ha! it was always an ANSI string to begin with!
	long row = -1;

	// (j.jones 2007-11-15 15:11) - PLID 27988 - reworked this mutex
	if (IsBarcodingDisabled()) {
		return 0;
	}

	if (m_pDiscountCategorySelectDlg && m_pDiscountCategorySelectDlg->GetSafeHwnd() != NULL) {
		// if this dialog exists, send it the message.
		return m_pDiscountCategorySelectDlg->SendMessage(WM_BARCODE_SCAN, wParam, lParam);
	} else if (m_pDiscountBillDlg && m_pDiscountBillDlg->GetSafeHwnd() != NULL) {
		// if this dialog exists, send it the message.
		return m_pDiscountBillDlg->SendMessage(WM_BARCODE_SCAN, wParam, lParam);
	}

	//temporarily disable barcodes in billing
	DisableBarcoding();

	// (a.walling 2007-11-08 16:28) - PLID 27476 - Need to convert this correctly from a bstr
	_variant_t var(bstr);
	//var.SetString((const char*)bstr);

	BOOL bProduct = TRUE;

	//JMJ - 8/5/2003 - The general algorithm needs to proceed as follows:
	//1. first check the products list for the barcode, if found, select that product in the list
	//if not found, check the CPT list, and if found then select the CPT in the list
	//2. check the BarcodeAllowQtyIncrement preference. If true, then
	//first search the bill for that product/cpt and increase its quantity.
	//if false, or the item was not found, call OnSelChosenCPT or Product to add new
	//3. (a.walling 2007-05-10 15:24) - PLID 25171 - If none of these are found, try using a coupon
	//4. (j.jones 2008-06-11 12:03) - PLID 28379 - if nothing else found, search serial numbers

	BOOL bItemFound = FALSE;

	BillingItemPtr pLineItem;

	// (z.manning, 05/04/2007) - PLID 25828 - We are eventually going to need a row index to add a charge to the 
	// bill (even if we called AddNewProductToBillByServiceID, it waits for requery as well). So we need to 
	// make sure we aren't requerying when we get this index or else we may get the wrong one.
	BOOL bHasInventoryLicense = FALSE;
	if (g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrUse)) {

		bHasInventoryLicense = TRUE;

		int sel = (m_EntryType == 1 ? ROW_BILL_A_PRODUCT : ROW_QUOTE_A_PRODUCT);
		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)sel));
		m_ProductsCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);
		//(c.copits 2010-10-01) PLID 40317 - Allow duplicate UPC codes for FramesData certification.
		row = GetBestUPCProductInventory(var);
	}

	if (row == -1) {
		//not found, now try CPTs
		bProduct = FALSE;

		int sel = (m_EntryType == 1 ? ROW_BILL_A_CPT_CODE : ROW_QUOTE_A_CPT_CODE);
		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)sel));
		m_CPTCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);
		row = m_CPTCombo->SetSelByColumn(CPT_COLUMN_BARCODE, var);
	}

	//it was found in a list
	if (row != -1) {

		// If we want to increment any existing amount of the product on a bill,
		// try doing it.
		if (GetRemotePropertyInt("BarcodeAllowQtyIncrement", 1, 0, "<None>", TRUE) == 1) {

			long ServiceID;

			if (bProduct) {
				ServiceID = m_ProductsCombo->GetValue(row, PRODUCTS_COLUMN_ID).lVal;
			}
			else {
				//now check CPT codes
				ServiceID = m_CPTCombo->GetValue(row, CPT_COLUMN_SERVICE_ID).lVal;
			}

			// (j.jones 2008-06-11 12:21) - PLID 28379 - CheckIncreaseDuplicateChargeQuantity now returns a BillingItem pointer,
			// but we do not use it for any purpose other than to check for success			
			pLineItem = CheckIncreaseDuplicateChargeQuantity(ServiceID, bProduct);
		}

		// If we did not increment an existing quantity for a product, then
		// we just add the item to the bill individually.
		if (pLineItem == NULL) {
			if (bProduct) {
				OnSelChosenComboProducts(row);
			}
			else {
				OnSelChosenComboCpt(row);
			}
		}

		bItemFound = TRUE;

	// (a.wetta 2007-05-17 09:45) - PLID 25960 - Make sure that they have the NexSpa license to scan coupons
	} else if (g_pLicense && g_pLicense->CheckForLicense(CLicense::lcNexSpa, CLicense::cflrSilent)) {
		
		
		// couldn't find any of these? perhaps it is a coupon...
		// (j.gruber 2009-03-23 17:38) - PLID 33484 - moved to the billingdlgdiscount.cpp
		bItemFound = ApplyDiscountFromBarCode(lParam);

	}

	// (j.jones 2008-06-11 12:04) - PLID 28379 - If nothing was found with the barcode,
	// search for serial numbers, they may have just scanned a serial number on its own
	// This is only supported on bills, not quotes.	
	if (!bItemFound && bHasInventoryLicense && m_EntryType == 1) {

		_bstr_t bstr = (BSTR)lParam;
		CString strSerialNum = (LPCTSTR)bstr;
		if (TryBillProductBySerialNumber(strSerialNum)) {
			//if TRUE, it was found (may or may not have successfully added), so return now
			//re-enable barcodes in billing
			EnableBarcoding();
			return 0;
		}
	}

	//re-enable barcodes in billing
	EnableBarcoding();
	return 0;
}

// (j.jones 2008-06-24 14:30) - PLID 30458 - added nAppointmentID parameter
// (j.jones 2012-01-17 16:18) - PLID 47537 - Added EMNID as a parameter, and also
// renamed from OnBillPackage as it was poorly named.
// This function actually handles billing any quote or any package.
void CBillingDlg::OnBillQuoteOrPackage(long QuoteID, long nAppointmentID /*= -1*/, long nEMNID /*= -1*/)
{
	try {

		long row = -1;

		// (j.jones 2005-05-03 09:47) - PLID 16410 - reset to patient resp before adding the charges
		m_listBillTo->PutCurSel(long(0));
		// (j.jones 2008-09-12 13:06) - PLID 4423 - changed to PostSelChosenComboBillTo
		PostSelChosenComboBillTo(m_listBillTo->CurSel);

		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)ROW_BILL_A_QUOTE));

		// (a.walling 2006-06-23 11:46) - PLID 21115 SetSelByColumn was consistently returning 0 if the quote list
		// was not full, breaking the billing ability of the package dialog (by always selecting the first quote)
		m_QuotesCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);

		//DRT 2/18/03 - Assignment statements in an if() - ugh!
		row = m_QuotesCombo->SetSelByColumn(0, (long)QuoteID);
		if (row != -1) {	//selection did not fail
			// (j.jones 2007-08-10 10:48) - PLID 23769 - tell OnSelChosenComboQuote that
			// this came from the popup window's message
			m_bQuoteFromPopupWindow = TRUE;

			// (j.jones 2008-06-24 14:46) - PLID 30458 - now we use PostSelChosenComboQuote
			long nQuoteID = VarLong(m_QuotesCombo->GetValue(row, 0));
			PostSelChosenComboQuote(nQuoteID, nAppointmentID, nEMNID);
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to break out the logic for billing an EMR
void CBillingDlg::OnBillEMR(long EMRID, long nInsuredPartyID, bool bBillEntireEMR /*= true*/)
{
	//determine the row to select based on the InsuredPartyID
	m_listBillTo->SetSelByColumn(btcInsuredPartyID, long(nInsuredPartyID));

	long nItemToBill = ROW_BILL_A_EMR;
	if (m_EntryType == 1)
		nItemToBill = ROW_BILL_A_EMR;
	else
		nItemToBill = ROW_QUOTE_A_EMR;

	OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)nItemToBill));

	// (j.dinatale 2012-01-13 17:36) - PLID 47514 - needed a way to determine if we are billing an entire emr or not
	if(bBillEntireEMR){
		IRowSettingsPtr pRow = m_EMRCombo->SetSelByColumn(0,(long)EMRID);
		if (pRow)	//selection did not fail
			OnSelChosenComboEMR(pRow);
	}else{
		BillEMR(EMRID, false);
	}
}

// (j.jones 2008-06-24 08:40) - PLID 30455 - added ability to bill from the schedule
void CBillingDlg::OnBillAppointment(long nApptID)
{
	try {

		long nItemToBill = ROW_BILL_AN_APPT;
		if (m_EntryType == 1) {
			nItemToBill = ROW_BILL_AN_APPT;
		}
		else {
			nItemToBill = ROW_QUOTE_AN_APPT;
		}

		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)nItemToBill));

		IRowSettingsPtr pRow = m_AppointmentCombo->SetSelByColumn(0, (long)nApptID);
		if (pRow) {	//selection did not fail
			// (f.dinatale 2010-10-06) - PLID 40509 - Refactored and modified the way billing an appointment is handled to allow the date 
			// to be set when an appointment is selected within the a manually created bill.
			OnSelChosenComboAppointments(pRow);
		}
		else {
			//explain why the appt. may not be billable
			// (j.gruber 2010-07-20 15:57) - PLID 39739 - added types as billable
			AfxMessageBox("This appointment is not able to be billed. Billable appointments are those that are for a procedural type "
				"(Office Procedure, Surgery, etc.) and have a purpose that has service codes or inventory items linked to it "
				"or are those that have a non-procedural appointment type and have service codes or inventory items linked to their appointment type. "
				"The appointment also must not be marked as a no-show.");
			return;
		}

	}NxCatchAll("Error in CBillingDlg::OnBillAppointment");
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragBeginList(BOOL FAR* pbShowDrag, LPDISPATCH lpRow, short nCol, long nFlags)
{
	// TODO: Add your control notification handler code here

}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragOverCellList(BOOL FAR* pbShowDrop, LPDISPATCH lpRow, short nCol, LPDISPATCH lpFromRow, short nFromCol, long nFlags)
{
	// TODO: Add your control notification handler code here

}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragEndList(LPDISPATCH lpRow, short nCol, LPDISPATCH lpFromRow, short nFromCol, long nFlags)
{
	long FromID, ToID;
	CPtrArray aryBillingTabInfoTemp;

	try {

		IRowSettingsPtr pRow(lpRow);
		IRowSettingsPtr pFromRow(lpFromRow);

		if (pFromRow == NULL) {
			return;
		}

		DisableBillingScreen();

		//this means you are dragging a row to the bottom of the list
		if (pRow == NULL) {
			//take the dragged item, make it the last in the list, and advance the rest of the list up.

			FromID = pFromRow->GetValue(COLUMN_LINE_ID).lVal;

			//make sure this ID is unaffected by the rolling changes
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			int z = 0;
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == FromID) {
					m_billingItems[z]->LineID = (long)-1;
					break;
				}
			}

			//if the ToID is not changed, then we don't want to reassign any other number
			ToID = FromID;

			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			IRowSettingsPtr pLoopRow = pFromRow->GetNextRow();
			while (pLoopRow) {

				long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
				long NewID = OldID - 1;

				pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

				//increment ToID
				ToID = NewID + 1;

				for (int j = 0; j < (int)m_billingItems.size(); j++) {
					if (m_billingItems[j]->LineID.lVal == OldID) {
						m_billingItems[j]->LineID = NewID;
						break;
					}
				}

				pLoopRow = pLoopRow->GetNextRow();
			}

			//now we know ToID is the next available number
			pFromRow->PutValue(COLUMN_LINE_ID, ToID);

			//now give the proper ID to the moved row
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == (long)-1) {
					m_billingItems[z]->LineID = ToID;
					break;
				}
			}

			m_bOrderChanged = TRUE;

			m_List->Sort();
			EnableBillingScreen();

			//save all charges
			_variant_t var;
			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			pLoopRow = m_List->GetFirstRow();
			while (pLoopRow) {
				var = pLoopRow->GetValue(COLUMN_CHARGE_ID);
				if (var.lVal != -2){
					// (j.jones 2011-08-24 08:41) - PLID 44868 - this is permitted on original/void charges
					AddToModifiedList(var.lVal, TRUE);
				}

				pLoopRow = pLoopRow->GetNextRow();
			}
			return;
		}

		FromID = pFromRow->GetValue(COLUMN_LINE_ID).lVal;
		ToID = pRow->GetValue(COLUMN_LINE_ID).lVal;

		//if you are dragging a row up
		if (FromID > ToID) {

			//make sure this ID is unaffected by the rolling changes
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			int z = 0;
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == FromID) {
					m_billingItems[z]->LineID = (long)-1;
					break;
				}
			}

			IRowSettingsPtr pLoopRow = pFromRow->GetPreviousRow();
			while (pLoopRow) {

				long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
				//only increment IDs until we reach the ToID row (counting that row)
				if (OldID >= ToID) {
					long NewID = OldID + 1;

					pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == OldID) {
							m_billingItems[j]->LineID = NewID;
							break;
						}
					}
				}

				pLoopRow = pLoopRow->GetPreviousRow();
			}

			pFromRow->PutValue(COLUMN_LINE_ID, ToID);

			//now give the proper ID to the moved row
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == (long)-1) {
					m_billingItems[z]->LineID = ToID;
					break;
				}
			}
		}
		//if you are dragging a row down
		else if (FromID < ToID) {

			//make sure this ID is unaffected by the rolling changes
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			int z = 0;
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == FromID) {
					m_billingItems[z]->LineID = (long)-1;
					break;
				}
			}

			IRowSettingsPtr pLoopRow = pFromRow->GetNextRow();
			while (pLoopRow) {

				long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
				//only increment IDs until we reach the ToID row (but not counting that row)
				if (OldID < ToID) {

					long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
					long NewID = OldID - 1;

					pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == OldID) {
							m_billingItems[j]->LineID = NewID;
							break;
						}
					}
				}

				pLoopRow = pLoopRow->GetNextRow();
			}

			//we want to insert BEFORE the row we dragged to
			ToID--;

			pFromRow->PutValue(COLUMN_LINE_ID, ToID);

			//now give the proper ID to the moved row
			for (z = 0; z < (int)m_billingItems.size(); z++) {
				if (m_billingItems[z]->LineID.lVal == (long)-1) {
					m_billingItems[z]->LineID = ToID;
					break;
				}
			}
		}

		m_bOrderChanged = TRUE;
		m_List->Sort();
		EnableBillingScreen();

		//save all charges
		_variant_t var;
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pLoopRow = m_List->GetFirstRow();
		while (pLoopRow) {
			var = pLoopRow->GetValue(COLUMN_CHARGE_ID);
			if (var.lVal != -2) {
				// (j.jones 2011-08-24 08:41) - PLID 44868 - this is permitted on original/void charges
				AddToModifiedList(var.lVal, TRUE);
			}

			pLoopRow = pLoopRow->GetNextRow();
		}
		return;

	} NxCatchAll("Error switching charge order.");

	EnableBillingScreen();
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragBeginQuoteList(BOOL FAR* pbShowDrag, LPDISPATCH lpRow, short nCol, long nFlags)
{
	// TODO: Add your control notification handler code here

}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragOverCellQuoteList(BOOL FAR* pbShowDrop, LPDISPATCH lpRow, short nCol, LPDISPATCH lpFromRow, short nFromCol, long nFlags)
{
	IRowSettingsPtr pRow(lpRow);
	IRowSettingsPtr pFromRow(lpFromRow);

	//if dragging from Practice Fee or Outside fee, only highlight those columns, to illustrate that you are intended to drag there
	if ((nFromCol == QUOTE_COLUMN_UNIT_COST || nFromCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE) &&
		(pRow != pFromRow || (nCol != QUOTE_COLUMN_UNIT_COST && nCol != QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE))) {
		*pbShowDrop = FALSE;
	}

}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnDragEndQuoteList(LPDISPATCH lpRow, short nCol, LPDISPATCH lpFromRow, short nFromCol, long nFlags)
{
	long FromID, ToID;
	CPtrArray aryBillingTabInfoTemp;

	try {

		IRowSettingsPtr pRow(lpRow);
		IRowSettingsPtr pFromRow(lpFromRow);

		if (pFromRow == NULL) {
			return;
		}

		m_QuoteList->SetRedraw(FALSE);

		if ((nFromCol == QUOTE_COLUMN_UNIT_COST || nFromCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE) &&
			pRow == pFromRow) {

			//they are dragging from unit cost to outside cost, or back

			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == pRow->GetValue(COLUMN_LINE_ID).lVal) {

					//get the current costs		
					_variant_t varPracCost, varOutsideCost;
					COleCurrency cyPracCost, cyOutsideCost;
					varPracCost = m_billingItems[i]->UnitCost;
					varOutsideCost = m_billingItems[i]->OthrUnitCost;
					if (varOutsideCost.vt == VT_EMPTY)
						varOutsideCost.vt = VT_NULL;
					cyPracCost = VarCurrency(varPracCost, COleCurrency(0, 0));
					cyOutsideCost = VarCurrency(varOutsideCost, COleCurrency(0, 0));

					//switch from practice cost to outside cost
					if (nFromCol == QUOTE_COLUMN_UNIT_COST && nCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE) {
						cyOutsideCost += cyPracCost;
						cyPracCost = COleCurrency(0, 0);
					}
					else if (nFromCol == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE && nCol == QUOTE_COLUMN_UNIT_COST) {
						cyPracCost += cyOutsideCost;
						cyOutsideCost = COleCurrency(0, 0);
					}
					varPracCost = _variant_t(cyPracCost);
					varOutsideCost = _variant_t(cyOutsideCost);

					//and now update the table and datalist				
					m_billingItems[i]->UnitCost = varPracCost;
					m_billingItems[i]->OthrUnitCost = varOutsideCost;
					pRow->PutValue(QUOTE_COLUMN_UNIT_COST, varPracCost);
					pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, varOutsideCost);
					break;
				}
			}

			// Calculate the line total
			m_varBoundItem = pRow->GetValue(COLUMN_LINE_ID);
			if (m_varBoundItem.vt == VT_EMPTY)
				return;

			_variant_t var;
			var = pRow->GetValue(COLUMN_CHARGE_ID);
			if (var.lVal != -2)
				AddToModifiedList(var.lVal);

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
		}
		else {

			//they are dragging rows up and down

			//this means you are dragging a row to the bottom of the list
			if (pRow == NULL) {
				//take the dragged item, make it the last in the list, and advance the rest of the list up.

				FromID = pFromRow->GetValue(COLUMN_LINE_ID).lVal;

				//make sure this ID is unaffected by the rolling changes
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int z = 0;
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == FromID) {
						m_billingItems[z]->LineID = (long)-1;
						break;
					}
				}

				//if the ToID is not changed, then we don't want to reassign any other number
				ToID = FromID;

				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				IRowSettingsPtr pLoopRow = pFromRow->GetNextRow();
				while (pLoopRow) {

					long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
					long NewID = OldID - 1;

					pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

					//increment ToID
					ToID = NewID + 1;

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == OldID) {
							m_billingItems[j]->LineID = NewID;
							break;
						}
					}

					pLoopRow = pLoopRow->GetNextRow();
				}

				//now we know ToID is the next available number
				pFromRow->PutValue(COLUMN_LINE_ID, ToID);

				//now give the proper ID to the moved row
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == (long)-1) {
						m_billingItems[z]->LineID = ToID;
						break;
					}
				}

				m_bOrderChanged = TRUE;

				m_QuoteList->Sort();
				m_QuoteList->SetRedraw(TRUE);

				//save all charges
				_variant_t var;
				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				pLoopRow = m_QuoteList->GetFirstRow();
				while (pLoopRow) {
					var = pLoopRow->GetValue(COLUMN_CHARGE_ID);
					if (var.lVal != -2) {
						AddToModifiedList(var.lVal);
					}

					pLoopRow = pLoopRow->GetNextRow();
				}
				return;
			}

			FromID = pFromRow->GetValue(COLUMN_LINE_ID).lVal;
			ToID = pRow->GetValue(COLUMN_LINE_ID).lVal;

			//if you are dragging a row up
			if (FromID > ToID) {

				//make sure this ID is unaffected by the rolling changes
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int z = 0;
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == FromID) {
						m_billingItems[z]->LineID = (long)-1;
						break;
					}
				}

				IRowSettingsPtr pLoopRow = pFromRow->GetPreviousRow();
				while (pLoopRow) {

					long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
					//only increment IDs until we reach the ToID row (counting that row)
					if (OldID >= ToID) {
						long NewID = OldID + 1;

						pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

						for (int j = 0; j < (int)m_billingItems.size(); j++) {
							if (m_billingItems[j]->LineID.lVal == OldID) {
								m_billingItems[j]->LineID = NewID;
								break;
							}
						}
					}

					pLoopRow = pLoopRow->GetPreviousRow();
				}

				pFromRow->PutValue(COLUMN_LINE_ID, ToID);

				//now give the proper ID to the moved row
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == (long)-1) {
						m_billingItems[z]->LineID = ToID;
						break;
					}
				}
			}
			//if you are dragging a row down
			else if (FromID < ToID) {

				//make sure this ID is unaffected by the rolling changes
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
				int z = 0;
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == FromID) {
						m_billingItems[z]->LineID = (long)-1;
						break;
					}
				}

				IRowSettingsPtr pLoopRow = pFromRow->GetNextRow();
				while (pLoopRow) {

					long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
					//only increment IDs until we reach the ToID row (but not counting that row)
					if (OldID < ToID) {

						long OldID = pLoopRow->GetValue(COLUMN_LINE_ID).lVal;
						long NewID = OldID - 1;

						pLoopRow->PutValue(COLUMN_LINE_ID, NewID);

						for (int j = 0; j < (int)m_billingItems.size(); j++) {
							if (m_billingItems[j]->LineID.lVal == OldID) {
								m_billingItems[j]->LineID = NewID;
								break;
							}
						}
					}

					pLoopRow = pLoopRow->GetNextRow();
				}

				//we want to insert BEFORE the row we dragged to
				ToID--;

				pFromRow->PutValue(COLUMN_LINE_ID, ToID);

				//now give the proper ID to the moved row
				for (z = 0; z < (int)m_billingItems.size(); z++) {
					if (m_billingItems[z]->LineID.lVal == (long)-1) {
						m_billingItems[z]->LineID = ToID;
						break;
					}
				}
			}

			m_bOrderChanged = TRUE;
			m_QuoteList->Sort();

			//save all charges
			_variant_t var;
			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			IRowSettingsPtr pLoopRow = m_QuoteList->GetFirstRow();
			while (pLoopRow) {
				var = pLoopRow->GetValue(COLUMN_CHARGE_ID);
				if (var.lVal != -2) {
					AddToModifiedList(var.lVal);
				}

				pLoopRow = pLoopRow->GetNextRow();
			}
		}

		m_QuoteList->SetRedraw(TRUE);

	} NxCatchAll("Error switching charge order.");

	m_QuoteList->SetRedraw(TRUE);
}

void CBillingDlg::SortList()
{
	//DRT 4/30/03 - Added a preference that allows people to turn off the auto-sorting on 
	//		new bills.
	// (d.thompson 2012-06-27) - PLID 51220 - Changed default to never (0)
	long nSort = GetRemotePropertyInt("SortBills", 0, 0, "<None>", true);

	if (nSort == 0 || m_bOrderChanged) {
		//sorting has been disabled by preferences
		//or they've already changed the order manually
		m_pList->Sort();	//(this doesnt really "sort", it just orders things as they should be ordered)
		return;
	}

	if (GetBillID() != -1) {
		//DRT 4/30/03 - We are on a bill that is not new, they're editing it.  As of today, we're going to 
		//		attempt the following:  Look at the way things are currently sorted.  If they are already
		//		in the correct sorted order (by total price, descending), then we'll let it pass on and add
		//		any new charges in a sorted order.  If we find that something is out of order, then we'll 
		//		leave things as is, and the new charges will go to the bottom.  This is an alternative
		//		to adding something in the data for each bill that would be a marker when the charge
		//		list has been manually re-sorted.
		//		If nothing has been changed, we don't want to bother checking the order, just return from this
		//		function (follow the old functionality).

		//this is checked when we open the dialog.  if things were OK at that point, any manual changes since then
		//would have been taken care of in the above case (m_boOrderChanged)
		if (!m_bIsInDefaultSortedOrder) {
			//DRT 5/10/2004 - PLID 12148 - This is a temporary workaround so I don't have to cause some major destablization
			//	in billing.  If you do some wierd things involving gift certificates, it's possible to get duplicate lineIDs.
			//	If you are in default sorted order, then renumberids() is called, and the problem is masked.  So I'm 
			//	forcing a call here, which then masks the problem here.  Again, this is because trying to fix it so all
			//	the deleting calls happen in the right order does not destabilize billing.  This is a very minor speed hit.
			ReNumberIDs();
			//

			m_pList->Sort();
			return;
		}
	}

	DisableBillingScreen();

	int ColumnTotal;
	if (m_EntryType == 1)
		ColumnTotal = BILL_COLUMN_LINE_TOTAL;
	else
		ColumnTotal = QUOTE_COLUMN_LINE_TOTAL;

	IColumnSettingsPtr pCol;

	pCol = m_pList->GetColumn(COLUMN_LINE_ID);
	pCol->SortPriority = -1;
	pCol = m_pList->GetColumn(ColumnTotal);
	pCol->SortPriority = 0;
	pCol->PutSortAscending(FALSE);
	m_pList->Sort();

	ReNumberIDs();

	pCol = m_pList->GetColumn(ColumnTotal);
	pCol->SortPriority = -1;
	pCol = m_pList->GetColumn(COLUMN_LINE_ID);
	pCol->SortPriority = 0;
	pCol->PutSortAscending(TRUE);
	m_pList->Sort();

	EnableBillingScreen();
}

bool CBillingDlg::IsListInDefaultSortedOrder() {
	//DRT 5/1/03 - This function operates based on the m_billingItems array.  This array is initially
	//		filled in LineID order, straight out of the data.  Once it has been loaded the first time, it
	//		is not kept in sorted order.  Therefore, this function returns false if it is called when 
	//		m_boInitialized = true.  Otherwise, it loops through the array and determines if the items are
	//		in the default sort order (line total, descending).

	if (m_boInitialized)
		return false;

	if ((int)m_billingItems.size() < 2) {
		//0 items or 1 item, it's in order
		return true;
	}

	COleCurrency cyPrev(0, 0), cyCur(0, 0);
	cyPrev = m_billingItems.front()->LineTotal;	//value of the first item

	for (int i = 1; i < (int)m_billingItems.size(); i++) {
		//the comparison is fairly simple, we loop through each row in the array, 
		//and if our current value is greater than the previous value, we return
		//false.  If we finish the loop, we must return true;
		cyCur = m_billingItems[i]->LineTotal;

		if (cyCur > cyPrev) {
			//out of order
			return false;
		}

		//these ones are ok.  move cyCur into previous before the next go-round
		cyPrev = cyCur;
		cyCur = COleCurrency(0, 0);
	}

	return true;
}

void CBillingDlg::ReNumberIDs() {
	//this function makes sorting the IDs MUCH easier than sorting a CPtrArray

	try {

		_variant_t var;
		long OldLineID, NewLineID;

		NewLineID = 0;

		//first initialize the IDs to be negative, so there are no conflicts
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			long temp = pRow->GetValue(COLUMN_LINE_ID).lVal;
			temp = -temp;
			pRow->PutValue(COLUMN_LINE_ID, temp);

			pRow = pRow->GetNextRow();
		}

		for (int x = 0; x < (int)m_billingItems.size(); x++) {
			long temp = m_billingItems[x]->LineID.lVal;
			temp = -temp;
			m_billingItems[x]->LineID = temp;
		}

		//now when we renumber, we won't run into "good" numbers being overwritten
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		pRow = m_pList->GetFirstRow();
		while (pRow) {
			var = pRow->GetValue(COLUMN_LINE_ID);
			OldLineID = var.lVal;
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			int j = 0;
			for (j = 0; j < (int)m_billingItems.size(); j++) {
				if (m_billingItems[j]->LineID.lVal == OldLineID) {
					break;
				}
			}
			//we could use i, but this makes it more understandable
			NewLineID++;
			m_billingItems[j]->LineID = NewLineID;
			pRow->PutValue(COLUMN_LINE_ID, NewLineID);

			var = pRow->GetValue(COLUMN_CHARGE_ID);
			//(e.lally 2008-06-23) PLID 30464 - make sure the (negative) old ID and new ID are now different before
			//saying this charge has been modified.
			if (var.lVal != -2 && (-OldLineID) != NewLineID) {
				// (j.jones 2011-08-24 08:41) - PLID 44868 - this is permitted on original and void charges
				AddToModifiedList(var.lVal, TRUE);
			}

			pRow = pRow->GetNextRow();
		}

	} NxCatchAll("Error in ReNumberIDs");
}

//use these functions to cleanly redraw the screen, like the financial tab
void CBillingDlg::DisableBillingScreen() {

	m_DisableRefCount++;

	if (!m_bIsScreenEnabled)
		return;
	else {

		m_pList->SetRedraw(FALSE);
		m_bIsScreenEnabled = FALSE;
	}
}

void CBillingDlg::EnableBillingScreen() {

	m_DisableRefCount--;

	if (m_DisableRefCount > 0 || m_bIsScreenEnabled) {
		return;
	}
	else {

		m_pList->SetRedraw(TRUE);

		m_bIsScreenEnabled = TRUE;
	}
}

// (j.jones 2006-12-20 09:24) - PLID 23338 - converted parameter iLineID to the more accurate iRowIndex
// (j.jones 2011-10-04 11:40) - PLID 45799 - now takes in a DL2 row
void CBillingDlg::InsertRowSorted(NXDATALIST2Lib::IRowSettingsPtr pRowIndex, COleCurrency cyTotal) {

	try {

		if (pRowIndex == NULL) {
			return;
		}

		//SortList will take care of this if the order is unchanged and the bill is new
		if (!m_bOrderChanged && GetBillID() == -1)
			return;

		// (j.jones 2006-10-09 14:36) - PLID 22924 - if they aren't sorting by amount, don't try to move the charge
		// (d.thompson 2012-06-27) - PLID 51220 - Changed default to never (0)
		if (GetRemotePropertyInt("SortBills", 0, 0, "<None>", true) == 0)
			return;

		int ColumnTotal;
		if (m_EntryType == 1)
			ColumnTotal = BILL_COLUMN_LINE_TOTAL;
		else
			ColumnTotal = QUOTE_COLUMN_LINE_TOTAL;

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			COleCurrency tmpCy = pRow->GetValue(ColumnTotal).cyVal;
			if (tmpCy < cyTotal) {
				if (m_EntryType == 1)
					OnDragEndList(pRow, ColumnTotal, pRowIndex, ColumnTotal, 0);
				else
					OnDragEndQuoteList(pRow, ColumnTotal, pRowIndex, ColumnTotal, 0);
				return;
			}

			pRow = pRow->GetNextRow();
		}

	} NxCatchAll("Error in InsertSorted");

}


// (j.politis 2015-06-26 12:11) - PLID 65949 - Getting error when try to open edit a bill has  active location but not managed !
//if you edit any bill for that loaction(Dr.John Vine)  will give you the error .
void CBillingDlg::ChangeLocationComboSelection(long nLocationID, BOOL bIsCalledInternally) {

	try {

		// (j.jones 2007-12-14 11:47) - PLID 27988 - we disallow changing locations
		// if we have any allocations currently in use on this bill
		if (m_paryAllocationInfo.GetSize() > 0 || HasChargesLinkedToAllocations()) {
			//this function should not have been called if we have tracked allocations or charged allocations
			ASSERT(FALSE);
			return;
		}

		//Try to set the selection.
		//If it fails, then just set the name in the location dropdown and set current location to the id we were given.
		if (m_LocationCombo->TrySetSelByColumn(0, nLocationID) == -1) {
			//Must be inactive.
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsLocName = CreateParamRecordset("SELECT Name FROM LocationsT WHERE ID = {INT}", nLocationID);
			if (!rsLocName->eof) {
				m_LocationCombo->PutComboBoxText(_bstr_t(AdoFldString(rsLocName, "Name")));
				m_nCurLocationID = nLocationID;
			}

			return;
		}

		// (j.gruber 2007-08-16 09:59) - PLID 25191 - see if they have permission
		if (m_EntryType == 1 && GetBillID() == -1) {

			if (nLocationID != GetCurrentLocationID()) {

				//only output message boxes if this is called externally
				if (bIsCalledInternally) {

					if (!(GetCurrentUserPermissions(bioChargeLocation) & (SPT___W_______))) {

						if (!(GetCurrentUserPermissions(bioChargeLocation) & (SPT___W________ANDPASS))) {

							//they don't have permission, so always make the selection the currently logged in one
							m_LocationCombo->SetSelByColumn(0, GetCurrentLocationID());
							//TES 2/10/2015 - PLID 64841 - Don't return here, there's still a lot of logic to execute in this function. Just set the nLocationID variable
							nLocationID = GetCurrentLocationID();
						}
						else {

							//we are assuming that they have the password if we are changing it internally and they have write with pass
						}
					}
				}
				else {
					if (!(CheckCurrentUserPermissions(bioChargeLocation, sptWrite))) {

						m_LocationCombo->SetSelByColumn(0, GetCurrentLocationID());
						//TES 2/10/2015 - PLID 64841 - Don't return here, there's still a lot of logic to execute in this function. Just set the nLocationID variable
						nLocationID = GetCurrentLocationID();
					}
				}
			}
		}


		//if they didn't change the selection, then don't bother doing anything
		if (nLocationID == m_nCurLocationID)
			return;

		// (j.jones 2007-11-15 15:31) - PLID 27988 - disallow changing locations
		// if we have any active allocations currently in use on this bill

		//only output message boxes if this is called externally
		if (!bIsCalledInternally) {
			if (m_paryAllocationInfo.GetSize() > 0) {
				MsgBox("You may not change the bill location while there are unsaved allocations tied to this bill.\n"
					"You must cancel the changes to this bill if you wish to change the location.\n\n"
					"Alternatively you may save the bill, which will complete the linked allocations, and reopen\n"
					"the bill and change the location. If you do this, however, you may not be able to use the\n"
					"same products that were in stock at the originally allocated location.");
				m_LocationCombo->SetSelByColumn(0, m_nCurLocationID);
				return;
			}
			else {
				//even if there aren't tracked allocations, see if any charge uses an allocation,
				//in which case they still can't change it
				if (HasChargesLinkedToAllocations()) {
					MsgBox("You may not change the bill location while there charges linked to inventory allocations.\n"
						"You must delete any charges created from inventory allocations if you wish to change the location.");
					m_LocationCombo->SetSelByColumn(0, m_nCurLocationID);
					return;
				}
			}

			//TES 7/25/2014 - PLID 63048 - Changing the location could potentially result in deleting chargeback charges
			if (DoesChargeHaveChargeback(CSqlFragment("ChargesT.BillID = {INT}", GetBillID()))) {
				MsgBox("Locations on bills with associated Chargebacks cannot be changed. In order to change the location, you must first expand the bill "
					"on the Billing tab, right-click on the associated Chargeback, and select 'Undo Chargeback.'");
				return;
			}

			// (j.jones 2011-01-25 14:58) - PLID 42156 - check historical permissions
			if (m_EntryType == 1 && GetBillID() != -1
				&& !CanChangeHistoricFinancial("Bill", GetBillID(), bioBill, sptWrite)) {

				m_LocationCombo->SetSelByColumn(0, m_nCurLocationID);
				return;
			}
		}

		_variant_t var;
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			var = pRow->GetValue(COLUMN_CHARGE_ID);
			if (var.lVal != -2) {
				AddToModifiedList(var.lVal);
			}

			pRow = pRow->GetNextRow();
		}

		//make sure we display items that are billable at this location
		CString strWhere;
		m_nCurLocationID = nLocationID;

		//no point in requerying it if it has yet to be requeried
		if (m_bProductsCombo) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo(m_nCurLocationID);
		}

		/////////////////////////////////////////////////////
		// Get the practice tax rate - reflect the rax rate of the NEW location

		if (GetRemotePropertyInt("DefaultTaxSource", 1, 0, "<None>", TRUE) == 1) {

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rs = CreateParamRecordset("SELECT TaxRate, TaxRate2 FROM LocationsT WHERE ID = {INT}", m_nCurLocationID);
			if (!rs->eof) {
				_variant_t var;
				var = rs->Fields->Item["TaxRate"]->Value;
				m_fltPracticeTax1 = ((var.dblVal - 1) * 100);
				var = rs->Fields->Item["TaxRate2"]->Value;
				m_fltPracticeTax2 = ((var.dblVal - 1) * 100);

				PromptUpdateTaxRates(FALSE);
			}
			else {
				m_fltPracticeTax1 = 0.0;
				m_fltPracticeTax2 = 0.0;
			}
			rs->Close();
		}

		PromptInventoryLocationChanged(m_nCurLocationID);
		// (s.tullis 2016-02-24 14:57) - PLID 68319 - Location Changed Update our claim form selection
		((CBillingModuleDlg*)m_pBillingModuleWnd)->UpdateClaimFormSelection();
		//check to see if any charges need to be updated
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr pItem = m_billingItems[i];

			// (j.gruber 2009-10-16 12:47) - PLID 35947 - check if the allowable changed
			LoadAllowableColumn(pItem, TRUE);

			// (j.jones 2014-04-30 15:25) - PLID 61837 - the new location may
			// potentially show additional provider columns
			if (m_EntryType == 1) {
				TryShowChargeProviderColumns(pItem, false);
			}
		}

	}NxCatchAll("Error in ChangeLocationComboSelection");

}

void CBillingDlg::OnSelChosenComboLocation(long nRow)
{
	// (j.politis 2015-07-06 11:36) - PLID 65949 - Getting error when try to open edit a bill has  active location but not managed !
	// if you edit any bill for that loaction ( Dr.John Vine )  will give you the error .
	try{
		if (m_LocationCombo->GetRowCount() > 0)
		{
			ChangeLocationComboSelection(VarLong(m_LocationCombo->GetValue((nRow > 0 ? nRow : 0), 0)), FALSE);
		}
	}NxCatchAll("Error in OnSelChosenComboLocation");
}

void CBillingDlg::AddPaymentPlanCharge(COleCurrency cyAmount)
{
	try {

		CWaitCursor pWait;

		CString strCPTCode, strCPTSubCode, strDescription, strTypeOfService, strSQL;
		COleCurrency cyUnitCost;
		COleVariant var;
		double dblTax1, dblTax2;

		DisableBillingScreen();

		// Add a new charge to the temporary list and
		// set its details to default values
		int iLineID = AppendChargeToList()->LineID.lVal;

		long ServiceID = -1;

		strCPTCode = "Package";

		strCPTSubCode = " ";

		strDescription = "Package Installment Fee";

		strTypeOfService = " ";

		dblTax1 = 0.0;

		dblTax2 = 0.0;

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->ChargeID = (long)-2;
				m_billingItems[i]->Quantity = (double)1.0;
				m_billingItems[i]->PackageQtyRemaining = (double)1.0;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
				m_billingItems[i]->OriginalPackageQtyRemaining = (double)1.0;
				m_billingItems[i]->ServiceID = ServiceID;
				m_billingItems[i]->CPTCode = _bstr_t(strCPTCode);
				BillingItemPtr billitem = m_billingItems[i];
				_variant_t var = m_billingItems[i]->CPTCode;
				m_billingItems[i]->CPTSubCode = _bstr_t(strCPTSubCode);
				m_billingItems[i]->Description = _bstr_t(strDescription);
				m_billingItems[i]->TypeOfService = _bstr_t(strTypeOfService);
				m_billingItems[i]->TaxRate1 = (double)dblTax1;
				m_billingItems[i]->TaxRate2 = (double)dblTax2;
			}
		}

		//now set the charge total
		RoundCurrency(cyAmount);

		var = cyAmount;

		/////////////////////////////////////////////////////////////////
		// If no insurance, always set the total to the unit cost,
		// even if a quote.

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID){
				//LogDetail("#$# Setting Ins1Resp to %s billingdlg line 4537", FormatCurrency(VarCurrency(var)));
				SetListInsAmount(i, GetCurrentBillToInsuredPartyID(), var);
			}
		}

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {

				m_billingItems[i]->UnitCost = var;
				m_billingItems[i]->LineTotal = var;
			}
		}

		if (m_EntryType == 1)
			FillBillList();
		else
			FillQuoteList();

		// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
		// use the row instead of the LineID
		// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
		IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
		InsertRowSorted(pRowToSort, var);

		EnableBillingScreen();

		/* Recalculate the bill total */
		CalculateTotal();

	}NxCatchAll("Error in AddPaymentPlanCharge");
}

void CBillingDlg::OnPackageCheck()
{
	try {
		if (m_packageCheck.GetCheck()) {

			// (j.gruber 2007-11-20 12:16) - PLID 28061 - change the way the quote report is pulled
			((CBillingModuleDlg*)m_pBillingModuleWnd)->SetQuoteReportDropDown(TRUE);

			m_radioRepeatPackage.ShowWindow(SW_SHOWNOACTIVATE);
			m_radioMultiUsePackage.ShowWindow(SW_SHOWNOACTIVATE);

			//if neither are checked, check the repeat package
			if (!m_radioRepeatPackage.GetCheck() && !m_radioMultiUsePackage.GetCheck())
				m_radioRepeatPackage.SetCheck(TRUE);

			OnPackageTypeChanged();

			GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_SHOWNOACTIVATE);
			// (j.jones 2009-12-22 14:32) - PLID 32587 - show the original amount fields
			GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_SHOWNOACTIVATE);
			OnPackageShowInitialValues();

			// (j.jones 2009-12-31 09:58) - PLID 18765 - ensure the total labels are hidden
			GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_HIDE);
			//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(SW_HIDE);

			//if any of the charges have tax, warn the user
			BOOL bWarn = FALSE;
			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			IRowSettingsPtr pRow = m_QuoteList->GetFirstRow();
			while (pRow != NULL && !bWarn) {
				_variant_t varTax1 = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_1);
				_variant_t varTax2 = pRow->GetValue(QUOTE_COLUMN_TAX_RATE_2);
				if ((varTax1.vt == VT_R8 && VarDouble(varTax1) > 0.0) ||
					(varTax2.vt == VT_R8 && VarDouble(varTax2) > 0.0)) {
					bWarn = TRUE;
				}

				pRow = pRow->GetNextRow();
			}

			// (j.jones 2016-02-29 14:48) - PLID 68339 - force a recalculation of the quote total as package total
			CalculateTotal(true);

			if (bWarn)
				WarnTaxedPackage();
		}
		else {
			if (GetBillID() != -1) {
				//this is an existing quote, see if package info exists
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (ReturnsRecordsParam("SELECT QuoteID FROM PackagesT WHERE QuoteID = {INT}", GetBillID())) {
					//it does
					if (IDNO == MessageBox("You have already saved this quote as a package. "
						"Are you sure you wish to remove this data?", "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
						m_packageCheck.SetCheck(TRUE);
						return;
					}
				}
			}

			// (j.gruber 2007-11-20 12:16) - PLID 28061 - change the way the quote report is pulled
			((CBillingModuleDlg*)m_pBillingModuleWnd)->SetQuoteReportDropDown(FALSE);

			m_radioRepeatPackage.ShowWindow(SW_HIDE);
			m_radioMultiUsePackage.ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COST_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COST)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_CURRENT_BALANCE)->ShowWindow(SW_HIDE);
			// (j.jones 2009-12-22 14:32) - PLID 32587 - hide the original amount fields
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_SHOW_INITIAL_VALUES)->ShowWindow(SW_HIDE);

			// (j.jones 2009-12-31 09:58) - PLID 18765 - ensure the total labels are shown
			GetDlgItem(IDC_PATIENT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_TOTAL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_TOTAL_OUTSIDE)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PAID_OUTSIDE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_DISCOUNT_TOTAL_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_LABEL_DISCOUNTS)->ShowWindow(SW_SHOWNOACTIVATE);
			//(e.lally 2010-10-22) PLID 30253 - Hide the outside discounts unless it is in use
			if (m_bHasOutsideDiscount){
				//Ensure we have the right totals
				CalculateTotal();
			}
			GetDlgItem(IDC_OUTSIDE_DISCOUNT_TOTAL_LABEL)->ShowWindow(m_bHasOutsideDiscount ? SW_SHOWNOACTIVATE : SW_HIDE);
			GetDlgItem(IDC_LABEL_OUTSIDE_DISCOUNTS)->ShowWindow(m_bHasOutsideDiscount ? SW_SHOWNOACTIVATE : SW_HIDE);

			ResizeColumns();
		}
	}NxCatchAll("Error in OnPackageCheck");
}

void CBillingDlg::OnKillfocusPackageCount()
{
	try {

		// (j.jones 2015-02-24 09:05) - PLID 57494 - only proceed if the number actually changed
		long nCurPackageCount = GetDlgItemInt(IDC_PACKAGE_COUNT);
		bool bPackageCountChanged = false;
		if (m_nLastPackageCount != nCurPackageCount) {
			bPackageCountChanged = true;
			m_nLastPackageCount = nCurPackageCount;
		}
		else {
			return;
		}

		long count = GetDlgItemInt(IDC_PACKAGE_COUNT);
		if (count < 0) {
			count = 0;
			SetDlgItemInt(IDC_PACKAGE_COUNT, count);
		}
		//if the number was huge, or negative, this will re-set it
		SetDlgItemInt(IDC_PACKAGE_COUNT, count);

		// (j.jones 2015-02-24 08:56) - PLID 57494 - re-cache the current value
		m_nLastPackageCount = count;

		long totCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
		if (count > totCount) {
			count = totCount;
			AfxMessageBox("You cannot have more remaining uses than there are total uses.\n"
				"Please update the 'Total Uses' field first.");
			SetDlgItemInt(IDC_PACKAGE_COUNT, count);

			// (j.jones 2015-02-24 08:56) - PLID 57494 - re-cache the current value
			m_nLastPackageCount = count;
		}

		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			// (j.jones 2009-12-23 11:57) - PLID 32587 - if new/unbilled, set the original count to match this count
			SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, count);

			// (j.jones 2015-02-24 08:56) - PLID 57494 - re-cache the current value
			m_nLastPackageCount = count;

			//if this does not match the total, show the initial value fields
			if (count != totCount) {
				m_checkPackageShowInitialValues.SetCheck(TRUE);
				OnPackageShowInitialValues();
			}
		}

	}NxCatchAll("Error changing remaining package count");
}

void CBillingDlg::OnKillfocusPackageTotalCount()
{
	try {

		// (j.jones 2015-02-24 09:05) - PLID 57494 - only proceed if the number actually changed
		long nCurPackageTotalCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
		bool bPackageTotalCountChanged = false;
		if (m_nLastPackageTotalCount != nCurPackageTotalCount) {
			bPackageTotalCountChanged = true;
			m_nLastPackageTotalCount = nCurPackageTotalCount;
		}
		else {
			return;
		}

		long count = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
		if (count < 0) {
			count = 0;
		}

		long nInitCount = GetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT);

		//if the number was huge, or negative, this will re-set it
		SetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT, count);

		// (j.jones 2015-02-24 08:56) - PLID 57494 - re-cache the current value
		m_nLastPackageTotalCount = count;

		// (j.jones 2008-04-30 10:36) - PLID 29846 - package were changed to allow updates
		// so long as the quote has not been billed, not only if the quote is new
		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			//only update if new
			SetDlgItemInt(IDC_PACKAGE_COUNT, count);
			// (j.jones 2009-12-23 11:57) - PLID 32587 - also set the original count
			SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, count);

			// (j.jones 2015-02-24 08:56) - PLID 57494 - re-cache the current value
			m_nLastPackageCount = count;

			// (j.jones 2005-06-10 10:16) - PLID 14992 - CalculateTotal will properly fill
			// the Package totals with the non-taxed quote total
			// (j.jones 2015-02-24 09:09) - PLID 57494 - pass in bPackageTotalCountChanged
			CalculateTotal(bPackageTotalCountChanged);
		}
		else if (count < nInitCount){
			// (j.jones 2009-12-23 11:57) - PLID 32587 - set the original count if the total is lower
			SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, count);
			// (j.jones 2015-02-24 09:09) - PLID 57494 - pass in bPackageTotalCountChanged
			CalculateTotal(bPackageTotalCountChanged);
		}

	}NxCatchAll("Error changing total package count");
}

void CBillingDlg::OnKillfocusPackageCurrentBalance()
{
	CString str;
	GetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, str);
	COleCurrency cy = ParseCurrencyFromInterface(str);

	CString strTotalCost;
	GetDlgItemText(IDC_PACKAGE_TOTAL_COST, strTotalCost);
	COleCurrency cyTotalCost = ParseCurrencyFromInterface(strTotalCost);

	if (cy.GetStatus() == COleCurrency::invalid) {
		AfxMessageBox("The value you entered is not a valid amount, please enter in a dollar amount.");
		// (j.jones 2008-04-30 10:36) - PLID 29846 - package were changed to allow updates
		// so long as the quote has not been billed, not only if the quote is new
		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			// (j.jones 2005-06-10 10:16) - PLID 14992 - CalculateTotal will properly fill
			// the Package totals with the non-taxed quote total
			CalculateTotal();
		}
	}
	else {
		SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, FormatCurrencyForInterface(cy));

		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			// (j.jones 2009-12-23 12:57) - PLID 32587 - if new/unbilled, set the original amount to match this amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cy));

			//if this does not match the total, show the initial value fields
			if (cy != cyTotalCost) {
				m_checkPackageShowInitialValues.SetCheck(TRUE);
				OnPackageShowInitialValues();
			}
		}
	}
}

void CBillingDlg::OnKillfocusPackageTotalCost()
{
	CString str;
	GetDlgItemText(IDC_PACKAGE_TOTAL_COST, str);
	COleCurrency cy = ParseCurrencyFromInterface(str);

	CString strInitCost;
	GetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, strInitCost);
	COleCurrency cyInitCost = ParseCurrencyFromInterface(strInitCost);

	if (cy.GetStatus() == COleCurrency::invalid) {
		AfxMessageBox("The value you entered is not a valid amount, please enter in a dollar amount.");
		// (j.jones 2008-04-30 10:37) - PLID 29846 - package were changed to allow updates
		// so long as the quote has not been billed, not only if the quote is new
		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			//only update if new
			// (j.jones 2005-06-10 10:16) - PLID 14992 - CalculateTotal will properly fill
			// the Package totals with the non-taxed quote total
			CalculateTotal();
		}
	}
	else {
		SetDlgItemText(IDC_PACKAGE_TOTAL_COST, FormatCurrencyForInterface(cy));
		// (j.jones 2008-04-30 10:37) - PLID 29846 - package were changed to allow updates
		// so long as the quote has not been billed, not only if the quote is new
		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			//only update if new
			SetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, FormatCurrencyForInterface(cy));
			// (j.jones 2009-12-23 11:45) - PLID 32587- also set the original amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cy));
		}
		else if (cy < cyInitCost){
			// (j.jones 2009-12-23 11:57) - PLID 32587 - set the original amount if the total is lower
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cy));
		}
	}

}

void CBillingDlg::OnChangePackageCount()
{
	// (j.jones 2015-02-24 09:03) - PLID 57494 - no longer used
	//m_bPackageCountChanged = TRUE;
}

void CBillingDlg::OnChangePackageTotalCount()
{
	// (j.jones 2015-02-24 09:03) - PLID 57494 - no longer used
	//m_bPackageTotalCountChanged = TRUE;
}

void CBillingDlg::OnQuoteUseExpCheck()
{
	try {
		if (m_quoteExpCheck.GetCheck()) {
			GetDlgItem(IDC_QUOTE_EXP_DAY_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_QUOTE_EXP_DAYS)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE)->ShowWindow(SW_SHOWNOACTIVATE);
			if (GetDlgItemInt(IDC_QUOTE_EXP_DAYS) == 0) {
				SetDlgItemInt(IDC_QUOTE_EXP_DAYS, GetRemotePropertyInt("QuoteDefExpDays", 30, 0, "<None>", true));
				CalcExpireDate();
			}
		}
		else {
			GetDlgItem(IDC_QUOTE_EXP_DAY_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXP_DAYS)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_QUOTE_EXPIRE_DATE)->ShowWindow(SW_HIDE);
		}
	}NxCatchAll("Error in OnQuoteUseExpCheck");
}

double CBillingDlg::GetUnsavedQuantityCount(long nServiceID)
{
	// (j.jones 2007-12-18 12:31) - PLID 28037 - Note, this function was not altered to
	// be more streamlined (due to the multi-recordset access, I just made it a param
	// recordset for now). All I changed was making the code ignore allocation charges.
	// There is a slight inaccuracy though - if you bill an allocation, then change the
	// quantity to be greater than the allocation, then that excess quantity will decrement
	// from inventory, but this code won't catch it. We're not going to bother with it right
	// now for the impending release, but maybe one day we will correct it. It is
	// non-critical though.

	double dblCount = 0.0;

	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		if (VarLong(m_billingItems[i]->ServiceID) == nServiceID) /* Has same service ID */ {

			long nChargeID = VarLong(m_billingItems[i]->ChargeID);
			BOOL bAllocated = VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1) > 0;

			if (bAllocated) {
				//ignore charges from allocations
				continue;
			}
			// (s.dhole 2012-06-12 011:58) - PLID 48597  We should check IsOffTheShelf <> 1
			BOOL bExcludeFromCount = FALSE;
			long nGlassesOrderServiceID = VarLong(m_billingItems[i]->GlassesOrderServiceID, -1);
			_RecordsetPtr rsGs = CreateParamRecordset("SELECT Quantity FROM GlassesOrderServiceT WHERE IsOffTheShelf =0 AND ID = {INT}", nGlassesOrderServiceID);
			if (!rsGs->eof) {
				bExcludeFromCount = TRUE;
			}
			rsGs->Close();
			if (nChargeID == -2   /* Is a new charge */ && bExcludeFromCount == FALSE) {
				dblCount += VarDouble(m_billingItems[i]->Quantity);
			}
			else if (bExcludeFromCount == FALSE){
				//get the difference between the current amount and saved amount
				_RecordsetPtr rs = CreateParamRecordset("SELECT Quantity FROM ChargesT WHERE ID = {INT}", nChargeID);
				if (!rs->eof) {
					double dblQty = AdoFldDouble(rs, "Quantity", 1.0);
					dblCount += (VarDouble(m_billingItems[i]->Quantity) - dblQty);
				}
				rs->Close();
			}
			else
			{
				// nothing
			}
		}
	}

	//this function now only calculates the quantity on unsaved non-allocation charges,
	//but if we have any unsaved allocations, include those too
	dblCount += GetUnsavedAllocationQuantityCount(nServiceID);

	return dblCount;
}

// (j.jones 2007-12-18 13:39) - PLID 28037 - searches tracked allocations
// for quantities marked used, such that we can predict what the new
// in stock amount will be
double CBillingDlg::GetUnsavedAllocationQuantityCount(long nServiceID)
{
	double dblCount = 0.0;

	//the array is only populated with allocations we have opened in this session
	//and need to save, that is provided they aren't already completed
	for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {

		InvUtils::AllocationMasterInfo *pInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
		//only check this allocation if it is active, which means it has not previously
		//been marked completed, but will when we save the bill
		if (pInfo && pInfo->iasStatus == InvUtils::iasActive) {
			for (int j = 0; j < pInfo->paryAllocationDetailInfo.GetSize(); j++) {
				InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pInfo->paryAllocationDetailInfo.GetAt(j));
				if (pDetail && pDetail->nProductID == nServiceID && pDetail->iadsCurrentStatus == InvUtils::iadsUsed) {
					//this detail is for this product and is marked used, so grab its quantity
					dblCount += pDetail->dblCurQuantity;
				}
			}
		}
	}

	return dblCount;
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - Added boolean for
// bSaveEvenIfCorrected, which should only be TRUE if the charge
// we added to the modified list is permitted to save changes
// even if it is "Original" or "Void", which is typically read-only.
void CBillingDlg::SaveAllCharges(BOOL bSaveEvenIfCorrected)
{
	// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {
		long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);

		if (nChargeID == -2) {
			pRow = pRow->GetNextRow();
			continue;
		}

		// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges,
		// unless told that we want to save those too
		if (!bSaveEvenIfCorrected) {
			if (IsOriginalOrVoidCharge(nChargeID)) {

				//This is an original or a void charge, and shouldn't have
				//SaveAllCharges() called on it unless bSaveEvenIfCorrected is TRUE.

				//If you hit this assertion, your calling code needs to ensure that it
				//is not trying to modify an original/void charge. Ideally, SaveAllCharges()
				//should not even be called without bSaveEvenIfCorrected set to TRUE.
				//If it might affect A/R, we can't change this data.

				//***When in doubt, changing these charges is NOT permitted!***
				ASSERT(FALSE);

				pRow = pRow->GetNextRow();
				continue;
			}
		}

		AddToModifiedList(nChargeID, bSaveEvenIfCorrected);

		pRow = pRow->GetNextRow();
	}
}

void CBillingDlg::TrySaveListColumnWidths()
{
	try {
		CString strWidths; // Output widths for writing to ConfigRT
		CString strColWidths; // Current column widths in ConfigRT

		// (d.thompson 2012-08-01) - PLID 51898 - Changed default to 1
		if (!GetRemotePropertyInt("RememberBillingColumnWidths", 1, 0, GetCurrentUserName(), TRUE))
			return;

		// (c.haag 2004-01-28 09:34) - If you change any of these defaults, don't forget to
		// change them in the preferences DLL too.
		if (m_EntryType == 2) {
			// (j.jones 2009-12-23 09:19) - PLID 32587 - added bShowInitialValue
			strColWidths = GetRemotePropertyText("DefaultQuoteColumnSizes", GetDefaultQuoteColumnWidths(GetIsMultiUsePackage(), m_checkPackageShowInitialValues.GetCheck()), 0, GetCurrentUserName(), false);
		}
		else {
			strColWidths = GetRemotePropertyText("DefaultBillColumnSizes", GetDefaultBillingColumnWidths(), 0, GetCurrentUserName(), false);
		}

		// (c.haag 2004-01-28 09:03) - There's a trick here -- zero-length columns could be
		// zero length for reasons aside from the user manually sizing it to zero (This
		// wouldn't have been an issue if the csVisible style was used, and if the csVisible
		// style actually preserved data!!!). So, the rule is: If a column should be zero-length
		// because A. The user defined it to be invisible from the administrator module
		// or B. Because of the state of the Bill To dropdown, we will NOT preserve any
		// width changes.
		if (m_EntryType == 1) {
			// (s.dhole 2011-05-23 12:37) - PLID 33666  new version
			//strWidths += "V2,";
			for (short i = 0; i < m_List->ColumnCount; i++)
			{

				IColumnSettingsPtr pCol = m_List->GetColumn(i);
				long nStoredWidth = (long)pCol->StoredWidth;
				CString str;

				if(i == COLUMN_BATCHED) {
					nStoredWidth = 0;	//do not store the width of this column
				} else if (i == BILL_COLUMN_ON_HOLD) {
					nStoredWidth = 0;
				}

				// nStoredWith is the current width of the column, but we don't know
				// if the column is supposed to be hidden by the system or not. Lets find
				// out.
				BOOL bSystemShow;
				if (m_mapSysHiddenBillCols.Lookup(i, bSystemShow))
				{
					if (!bSystemShow)
					{
						// It's system hidden. Pull the width we memorized from last time.
						nStoredWidth = GetColumnWidth(strColWidths, i);
					}
				}

				// Ok, so the user preference says the column is visible...but...
				// what about the Bill To combo?

				// (j.jones 2010-08-31 09:18) - PLID 39218 - we can default to no resp. chosen, for display purposes
				// treat this as though they selected patient
				long nRespType = 0;
				if (m_listBillTo->CurSel != -1) {
					nRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
				}


				switch (nRespType)
				{
					case 0: // Patient responsibility
						//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
						if (i == COLUMN_ITEM_TYPE || i == COLUMN_INS_RESP || i == COLUMN_INS_PARTY_ID)
							nStoredWidth = GetColumnWidth(strColWidths, i);
						break;
					default:
						//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
						if (i == COLUMN_TAX_RATE_1 || i == COLUMN_TAX_RATE_2 || i == COLUMN_ITEM_TYPE || i == COLUMN_INS_PARTY_ID)
							nStoredWidth = GetColumnWidth(strColWidths, i);
						break;
				}

				if (i == 0)
					str.Format("%d", nStoredWidth);
				else
					str.Format(",%d", nStoredWidth);
				// (s.dhole 2011-05-23 13:16) - PLID 33666 We will skip visibale false calum of BILL_COLUMN_WHICH_CODES /BILL_COLUMN_WHICH_CODES_EXT
				if (((ShouldShowDiagExt() && i == BILL_COLUMN_WHICH_CODES) || (!ShouldShowDiagExt() && i == BILL_COLUMN_WHICH_CODES_EXT)) == FALSE)
					strWidths += str;
			}
			SetRemotePropertyText("DefaultBillColumnSizes", strWidths, 0, GetCurrentUserName());
		}
		else {
			for (short i = 0; i < m_QuoteList->ColumnCount; i++)
			{
				IColumnSettingsPtr pCol = m_QuoteList->GetColumn(i);
				long nStoredWidth = (long)pCol->StoredWidth;
				CString str;

				// nStoredWith is the current width of the column, but we don't know
				// if the column is supposed to be hidden by the system or not. Lets find
				// out.
				BOOL bSystemShow;
				if (m_mapSysHiddenQuoteCols.Lookup(i, bSystemShow))
				{
					if (!bSystemShow)
					{
						// It's system hidden. Pull the width we memorized from last time.
						nStoredWidth = GetColumnWidth(strColWidths, i);
					}
				}

				// (b.savon 2012-05-31 16:30) - PLID 50570 - We need to handle special columns that are conditional
				// on MultiUse Packages and the Original Qty count (which is dependent on the former).  These columns
				// are special in that they only appear when you click 'Is Package' and select 'MultiUse' (and 'Show Original'). Instead of
				// making the user expand the columns to see them, were going to always use the default size (or user defined) so that,
				// when they do make these selections, the columns always auto-expand so that the user can see them
				// in the datalist.  When we save, we want to always get the default or user defined column size.
				// Previously, these were overwritten if the user creates a quote that IS NOT a PACKAGE (MU and Orig) since
				// these columns are only necessary for MutiUse package quotes and would be hidden (0 width).  Using the 
				// old column widths (strColWidths) makes sure we do just that.
				if (i == QUOTE_COLUMN_PACKAGE_QTY_REM || i == QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM)
				{
					nStoredWidth = GetColumnWidth(strColWidths, i);
				}

				if (i == 0)
					str.Format("%d", nStoredWidth);
				else
					str.Format(",%d", nStoredWidth);

				strWidths += str;
			}
			SetRemotePropertyText("DefaultQuoteColumnSizes", strWidths, 0, GetCurrentUserName());
		}
	}
	NxCatchAll("Error saving column widths");
}

void CBillingDlg::OnSelChosenComboCaseHistory(long nRow)
{
	//m_CaseHistoryCombo
	if (nRow == -1)
		return;

	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return;
	}

	// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
	CMaintainFocus maintainFocus(__FUNCTION__);

	CWaitCursor pWait;

	_RecordsetPtr rs, rsTrack, rsDtls;
	CString str;
	long AuditID = -1;
	_variant_t var = m_CaseHistoryCombo->GetValue(nRow, CASE_HISTORY_COLUMN_ID);

	// (j.jones 2009-08-12 16:11) - PLID 35179 - track for auditing
	CString strCaseHistoryName = VarString(m_CaseHistoryCombo->GetValue(nRow, CASE_HISTORY_COLUMN_NAME));
	COleDateTime dtSurgeryDate = VarDateTime(m_CaseHistoryCombo->GetValue(nRow, CASE_HISTORY_COLUMN_DATE));

	long CaseHistoryID = var.lVal;

	EnsureRemoteData();


	/****************************************************************************************
	* Check all the items being added to make sure it fits the authorization.  This is		*
	* probably somewhat slow, but this case really should rarely come up, it just doesn't	*
	* make much sense.																		*
	****************************************************************************************/

	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

		try {

			//we need to loop through every item being added and compare them against the items 
			//in our referral
			bool bOneFailed = false;

			//setup an array for all the items we'll need to be checking in the auth
			CArray<long, long> aryAuthIDs;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
			while (!rsAuth->eof) {
				aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
				rsAuth->MoveNext();
			}
			rsAuth->Close();

			// (j.jones 2008-05-01 11:53) - PLID 28606 - do not bother checking if services match
			// if the referral has no services in it
			if (aryAuthIDs.GetSize() > 0) {

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsAuthCheck = CreateParamRecordset("SELECT ItemID FROM CaseHistoryDetailsT WHERE CaseHistoryID = {INT} AND ItemType <> -3", CaseHistoryID);
				while (!rsAuthCheck->eof && !bOneFailed) {
					long nServiceID = AdoFldLong(rsAuthCheck, "ItemID");

					bool bFound = false;
					for (int i = 0; i < aryAuthIDs.GetSize() && !bFound; i++) {
						if (aryAuthIDs.GetAt(i) == nServiceID)
							bFound = true;
					}

					if (!bFound)
						bOneFailed = true;

					rsAuthCheck->MoveNext();
				}

				if (bOneFailed) {
					if (MsgBox(MB_YESNO, "At least one item selected on this case history does not match your insurance authorization.\n"
						"Are you sure you wish to add this case history?") == IDNO) {
						return;
					}
				}
			}

		} NxCatchAll("Error determining authorization status for case history.");
	}



	/************************************
	* Bill the case history		        *
	*************************************/

	try {

		/* Open the list of services from the case history */

		// (j.jones 2009-08-06 10:29) - PLID 35120 - supported multiple case histories per bill

		//before we continue, check to see if the case has previously been billed, and warn if it has
		//(doesn't matter if it was on this bill or another bill)
		_RecordsetPtr rs = CreateParamRecordset("SELECT ID FROM BillsT "
			"INNER JOIN BilledCaseHistoriesT ON BillsT.ID = BilledCaseHistoriesT.BillID "
			"WHERE CaseHistoryID = {INT} AND BillsT.EntryType = 1 AND Deleted = 0", CaseHistoryID);
		if (!rs->eof) {
			CString str = "The selected Case History has already been billed, are you sure you wish to bill it again?";
			if (m_EntryType == 2) {
				str.Replace("bill it", "quote it");
			}
			if (IDNO == MessageBox(str, "Practice", MB_ICONQUESTION | MB_YESNO)) {
				return;
			}
		}
		rs->Close();

		if (CaseHistoryID != -1) {
			//add to our list, if it's not already there

			// (j.jones 2009-08-12 15:32) - PLID 35179 - this is now an array of pointers
			BOOL bFound = FALSE;
			for (int i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {

				CaseHistoryInfo *pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);

				if (pCase->nCaseHistoryID == CaseHistoryID) {
					bFound = TRUE;
				}
			}
			if (!bFound) {
				CaseHistoryInfo *pNewCase = new CaseHistoryInfo;
				pNewCase->nCaseHistoryID = CaseHistoryID;
				pNewCase->strCaseHistoryName = strCaseHistoryName;
				pNewCase->dtSurgeryDate = dtSurgeryDate;
				m_arypBilledCaseHistories.Add(pNewCase);
			}
		}

		//Update description on parent billing module dialog
		//update the anesthesia and facility times on the Billing2Dlg, if the Case History had them
		rs = CreateParamRecordset("SELECT Name, LogAnesthesiaIn, LogAnesthesiaOut, "
			"LogFacilityIn, LogFacilityOut, "
			"AnesthMinutes, FacilityMinutes "
			"FROM CaseHistoryT WHERE ID = {INT}", CaseHistoryID);
		if (!rs->eof) {

			//Update description on parent billing module dialog
			// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
			if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
				// (j.gruber 2012-01-04 11:44) - PLID 46291
				SetBillDescriptionBasedOnResp();
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
				str = GetBillDescription();
				if (str.GetLength() == 0) {
					str = AdoFldString(rs, "Name", "");
					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
					SetBillDescription(str);
				}
			}

			_variant_t var;

			BOOL bAnesthChanged = FALSE;
			BOOL bFacilityChanged = FALSE;

			var = rs->Fields->Item["LogAnesthesiaIn"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAnesthStart = VarDateTime(var);
				CString strAnesthStart = dtAnesthStart.Format("%H:%M:%S");
				CString strOldAnesthStart = GetAnesthStartTime();
				if (strOldAnesthStart != "" && strOldAnesthStart != strAnesthStart) {
					bAnesthChanged = TRUE;
				}
				SetAnesthStartTime(strAnesthStart, bAnesthChanged);
			}

			var = rs->Fields->Item["LogAnesthesiaOut"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtAnesthEnd = VarDateTime(var);
				CString strAnesthEnd = dtAnesthEnd.Format("%H:%M:%S");
				CString strOldAnesthEnd = GetAnesthEndTime();
				if (strOldAnesthEnd != "" && strOldAnesthEnd != strAnesthEnd) {
					bAnesthChanged = TRUE;
				}
				SetAnesthEndTime(strAnesthEnd, bAnesthChanged);
			}

			var = rs->Fields->Item["LogFacilityIn"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtFacilityStart = VarDateTime(var);
				CString strFacilityStart = dtFacilityStart.Format("%H:%M:%S");
				CString strOldFacilityStart = GetFacilityStartTime();
				if (strOldFacilityStart != "" && strOldFacilityStart != strFacilityStart) {
					bFacilityChanged = TRUE;
				}
				SetFacilityStartTime(strFacilityStart, bFacilityChanged);
			}

			var = rs->Fields->Item["LogFacilityOut"]->Value;
			if (var.vt != VT_NULL) {
				COleDateTime dtFacilityEnd = VarDateTime(var);
				CString strFacilityEnd = dtFacilityEnd.Format("%H:%M:%S");
				CString strOldFacilityEnd = GetFacilityEndTime();
				if (strOldFacilityEnd != "" && strOldFacilityEnd != strFacilityEnd) {
					bFacilityChanged = TRUE;
				}
				SetFacilityEndTime(strFacilityEnd, bFacilityChanged);
			}

			var = rs->Fields->Item["AnesthMinutes"]->Value;
			if (var.vt != VT_NULL) {
				long nAnesthMinutes = VarLong(var);
				long nOldAnesthMinutes = GetAnesthMinutes();
				if (nOldAnesthMinutes != 0 && nOldAnesthMinutes != nAnesthMinutes) {
					bAnesthChanged = TRUE;
				}
				SetAnesthMinutes(nAnesthMinutes, bAnesthChanged);
			}

			var = rs->Fields->Item["FacilityMinutes"]->Value;
			if (var.vt != VT_NULL) {
				long nFacilityMinutes = VarLong(var);
				long nOldFacilityMinutes = GetFacilityMinutes();
				if (nOldFacilityMinutes != 0 && nOldFacilityMinutes != nFacilityMinutes) {
					bFacilityChanged = TRUE;
				}
				SetFacilityMinutes(nFacilityMinutes, bFacilityChanged);
			}

			if (bAnesthChanged || bFacilityChanged) {
				AfxMessageBox("The details on the 'Additional Info.' tab of this bill have been replaced with the details from the Case History.");
			}
		}
		rs->Close();

		// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
		//LogDetail("Adding case history to bill");

		//TODO: if the CaseHistory become location-specific, use that location
		long LocationID = -1;

		if (m_LocationCombo->GetCurSel() == -1)
			LocationID = GetCurrentLocationID();
		else {
			var = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0);
			if (var.vt == VT_I4)
				LocationID = var.lVal;
			else
				LocationID = GetCurrentLocationID();
		}

		// (j.jones 2009-03-31 15:45) - PLID 33747 - OHIP Premium Codes are always loaded last
		CString strOrderBy, strSql;
		if (UseOHIP()) {
			strOrderBy = "ORDER BY (CASE WHEN CPTCodeT.OHIPPremiumCode = 1 THEN 1 ELSE 0 END) ";
		}

		// (j.jones 2009-08-19 15:30) - PLID 35124 - removed PayToPractice
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.jones 2011-03-28 16:25) - PLID 42575 - ignore non-billable CPT codes
		// (j.gruber 2014-03-21 13:02) - PLID 61493 - handle ICD-10 for case histories
		m_rsBill = CreateParamRecordset(FormatString("SELECT CaseHistoryT.*, CaseHistoryDetailsT.*, ServiceT.Name AS ServiceName, "
			"CaseHistoryDetailsT.ID AS DetailID, "
			"ICD91T.CodeNumber as ICD9Code1, ICD91T.CodeDesc as ICD9Desc1, "
			"ICD101T.CodeNumber as ICD10Code1, ICD101T.CodeDesc as ICD10Desc1, "
			"ICD92T.CodeNumber as ICD9Code2, ICD92T.CodeDesc as ICD9Desc2, "
			"ICD102T.CodeNumber as ICD10Code2, ICD102T.CodeDesc as ICD10Desc2, "
			"ICD93T.CodeNumber as ICD9Code3, ICD93T.CodeDesc as ICD9Desc3, "
			"ICD103T.CodeNumber as ICD10Code3, ICD103T.CodeDesc as ICD10Desc3, "
			"ICD94T.CodeNumber as ICD9Code4, ICD94T.CodeDesc as ICD9Desc4, "
			"ICD104T.CodeNumber as ICD10Code4, ICD104T.CodeDesc as ICD10Desc4 "
			" FROM CaseHistoryT "
			"INNER JOIN CaseHistoryDetailsT ON CaseHistoryT.ID = CaseHistoryDetailsT.CaseHistoryID "
			"LEFT JOIN ServiceT ON CaseHistoryDetailsT.ItemID = ServiceT.ID "
			"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
			"LEFT JOIN DiagCodes ICD91T ON CaseHistoryT.PostOpDx1 = ICD91T.ID "
			"LEFT JOIN DiagCodes ICD101T ON CaseHistoryT.PostOpDx1ICD10 = ICD101T.ID "
			"LEFT JOIN DiagCodes ICD92T ON CaseHistoryT.PostOpDx2 = ICD92T.ID "
			"LEFT JOIN DiagCodes ICD102T ON CaseHistoryT.PostOpDx2ICD10 = ICD102T.ID "
			"LEFT JOIN DiagCodes ICD93T ON CaseHistoryT.PostOpDx3 = ICD93T.ID "
			"LEFT JOIN DiagCodes ICD103T ON CaseHistoryT.PostOpDx3ICD10 = ICD103T.ID "
			"LEFT JOIN DiagCodes ICD94T ON CaseHistoryT.PostOpDx4 = ICD94T.ID "
			"LEFT JOIN DiagCodes ICD104T ON CaseHistoryT.PostOpDx4ICD10 = ICD104T.ID "
			"WHERE (ItemType = -1 OR ItemType = -2) AND CaseHistoryDetailsT.Billable = 1 "
			"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
			"AND PersonID = {INT} AND CaseHistoryT.ID = {INT} AND CompletedDate Is Not Null "
			"%s", strOrderBy),
			m_nPatientID, CaseHistoryID);

		//Update Place Of Service on bill dialog;

		// (j.jones 2011-08-24 08:41) - PLID 44868 - call TryChangePlaceOfService,
		// as we might not be allowed to change the place of service
		TryChangePlaceOfService(VarLong(m_rsBill->Fields->Item["PlaceOfServiceID"]->Value, -1));

		// (j.gruber 2008-07-09 17:42) - PLID 30644 - load diag codes
		if (!m_rsBill->eof) {
			//only clear once so we don't keep clearing what we've already set
			BOOL bCleared = FALSE;
			// (j.gruber 2014-03-21 13:02) - PLID 61493 - update for ICD-10
			long nDiag9ID = AdoFldLong(m_rsBill, "PostOpDx1", -1);
			long nDiag10ID = AdoFldLong(m_rsBill, "PostOpDx1ICD10", -1);
			CString strDiag9Code = AdoFldString(m_rsBill, "ICD9Code1", "");
			CString strDiag10Code = AdoFldString(m_rsBill, "ICD10Code1", "");
			CString strDiag9Desc = AdoFldString(m_rsBill, "ICD9Desc1", "");
			CString strDiag10Desc = AdoFldString(m_rsBill, "ICD10Desc1", "");
			if (nDiag9ID != -1 || nDiag10ID != -1) {
				if (!bCleared) {
					// (j.jones 2009-03-20 09:43) - PLID 9729 - clear the extra diag codes
					ClearDiagCodesList();
					// (d.singleton 2014-02-26 12:21) - PLID 60974 - reflect cleared diag code array to our UI
					ReflectDiagCodeArrayToInterface();

					bCleared = TRUE;
				}

				AddDiagCode(nDiag9ID, nDiag10ID, strDiag9Code, strDiag10Code, strDiag9Desc, strDiag10Desc);
			}

			// (j.gruber 2014-03-21 13:05) - PLID 61493 - update for ICD-10
			nDiag9ID = AdoFldLong(m_rsBill, "PostOpDx2", -1);
			nDiag10ID = AdoFldLong(m_rsBill, "PostOpDx2ICD10", -1);
			strDiag9Code = AdoFldString(m_rsBill, "ICD9Code2", "");
			strDiag10Code = AdoFldString(m_rsBill, "ICD10Code2", "");
			strDiag9Desc = AdoFldString(m_rsBill, "ICD9Desc2", "");
			strDiag10Desc = AdoFldString(m_rsBill, "ICD10Desc2", "");
			if (nDiag9ID != -1 || nDiag10ID != -1) {

				if (!bCleared) {
					// (j.jones 2009-03-20 09:43) - PLID 9729 - clear the extra diag codes
					ClearDiagCodesList();
					// (d.singleton 2014-02-26 12:21) - PLID 60974 - reflect cleared diag code array to our UI
					ReflectDiagCodeArrayToInterface();

					bCleared = TRUE;
				}

				AddDiagCode(nDiag9ID, nDiag10ID, strDiag9Code, strDiag10Code, strDiag9Desc, strDiag10Desc);
			}

			// (j.gruber 2014-03-21 13:06) - PLID 61493 - update for ICD-10
			nDiag9ID = AdoFldLong(m_rsBill, "PostOpDx3", -1);
			nDiag10ID = AdoFldLong(m_rsBill, "PostOpDx3ICD10", -1);
			strDiag9Code = AdoFldString(m_rsBill, "ICD9Code3", "");
			strDiag10Code = AdoFldString(m_rsBill, "ICD10Code3", "");
			strDiag9Desc = AdoFldString(m_rsBill, "ICD9Desc3", "");
			strDiag10Desc = AdoFldString(m_rsBill, "ICD10Desc3", "");
			if (nDiag9ID != -1 || nDiag10ID != -1) {
				if (!bCleared) {
					// (j.jones 2009-03-20 09:43) - PLID 9729 - clear the extra diag codes
					ClearDiagCodesList();
					// (d.singleton 2014-02-26 12:21) - PLID 60974 - reflect cleared diag code array to our UI
					ReflectDiagCodeArrayToInterface();

					bCleared = TRUE;
				}

				AddDiagCode(nDiag9ID, nDiag10ID, strDiag9Code, strDiag10Code, strDiag9Desc, strDiag10Desc);
			}

			// (j.gruber 2014-03-21 13:08) - PLID 61493 - update for ICD-10
			nDiag9ID = AdoFldLong(m_rsBill, "PostOpDx4", -1);
			nDiag10ID = AdoFldLong(m_rsBill, "PostOpDx4ICD10", -1);
			strDiag9Code = AdoFldString(m_rsBill, "ICD9Code4", "");
			strDiag10Code = AdoFldString(m_rsBill, "ICD10Code4", "");
			strDiag9Desc = AdoFldString(m_rsBill, "ICD9Desc4", "");
			strDiag10Desc = AdoFldString(m_rsBill, "ICD10Desc4", "");
			if (nDiag9ID != -1 || nDiag10ID != -1) {

				if (!bCleared) {
					// (j.jones 2009-03-20 09:43) - PLID 9729 - clear the extra diag codes
					ClearDiagCodesList();
					// (d.singleton 2014-02-26 12:21) - PLID 60974 - reflect cleared diag code array to our UI
					ReflectDiagCodeArrayToInterface();

					bCleared = TRUE;
				}

				AddDiagCode(nDiag9ID, nDiag10ID, strDiag9Code, strDiag10Code, strDiag9Desc, strDiag10Desc);
			}
		}

		while (!m_rsBill->eof) {

			//TODO: We currently call the cpt and product saving code.
			//Should we implement the code in these functions here? Should we make shared code for these functions?

			long ServiceID, ItemType, CaseHistoryDetailID, nProviderID;

			ServiceID = AdoFldLong(m_rsBill, "ItemID", -1);
			ItemType = AdoFldLong(m_rsBill, "ItemType", 0);

			CaseHistoryDetailID = AdoFldLong(m_rsBill, "DetailID", -1);

			nProviderID = AdoFldLong(m_rsBill, "ProviderID", -1);
			if (nProviderID != -1)
				m_DefaultProvider = nProviderID;

			//this should never happen
			if (ServiceID == -1 || (ItemType != -1 && ItemType != -2)) {
				AfxMessageBox("An invalid item was included in this case history. Please contact NexTech for assistance.");
				m_rsBill->MoveNext();
				continue;
			}
			//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
			if (m_EntryType == 1 && ItemType == -2 && IsCodeSelectedBasedOnWarning(ServiceID) == FALSE)
			{
				m_rsBill->MoveNext();
				continue;
			}


			if (ItemType == -1) {
				//Product

				CString strProductName = AdoFldString(m_rsBill, "ServiceName", "");

				if (!AddNewExternalProduct(CaseHistoryDetailID, EXT_CASE_HISTORY, ServiceID, strProductName, AdoFldDouble(m_rsBill, "Quantity", 1.0), AdoFldCurrency(m_rsBill, "Amount", COleCurrency(0, 0)))) {

					CString strName;

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT Name FROM ServiceT WHERE ID = {INT}", ServiceID);

					if (!rs->eof) {
						strName = AdoFldString(rs, "Name", "");
					}
					rs->Close();

					CString str;
					str.Format("The product '%s' was not able to be billed.\n"
						"If you did not manually cancel this item, please ensure that this product\n"
						"is able to be billed to the selected location, is in stock,\n"
						"and that the product has not been made inactive.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}
			else if (ItemType == -2) {
				//CPT Code

				if (!AddNewExternalCpt(CaseHistoryDetailID, EXT_CASE_HISTORY)) {

					CString strName;

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					// (j.jones 2011-03-28 16:25) - PLID 42575 - ignore non-billable CPT codes
					_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description "
						"FROM ServiceT "
						"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
						"WHERE ServiceT.ID = {INT} "
						"AND CPTCodeT.Billable = 1", ServiceID);

					if (!rs->eof) {
						strName = AdoFldString(rs, "Description", "");
					}
					rs->Close();

					CString str;
					str.Format("The Service Code '%s' was not able to be billed.\n"
						"Please ensure that the Code has not been made inactive or non-billable.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}



			m_rsBill->MoveNext();
		}

		m_rsBill->Close();

		/////////////////////////////////////////////////////////////////
		// Sort the list, requery it, and recalculate the bill total
		Requery();

		PostChargeAdded();

		// (j.jones 2007-12-13 17:21) - PLID 27988 - Any allocations we opened, we should be done with them now,
		// so force them to be resolved. But if it returns FALSE, don't worry about it too much here,
		// ValidateChanges will require it before closing.
		if (!ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}
	}
	NxCatchAll("BillingDlg::OnSelChosenComboCaseHistory");
}

// (j.dinatale 2012-06-05 11:11) - PLID 49713 - add an external InsuredPartyID for optical orders
BOOL CBillingDlg::AddNewExternalCpt(long ExternalID, long ExternalType, long nExtInsuredPartyID /*= -1*/, CString strInsCoName /*= ""*/, CString strRespTypeName /*= ""*/)
{
	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return FALSE;
	}

	CWaitCursor pWait;

	CString strCPTCode, strCPTSubCode, strDescription, strTypeOfService, strSQL;
	COleCurrency cyUnitCost;
	COleVariant var;
	double dblTax1, dblTax2;
	_variant_t v;

	long CPTID = -1;
	if (ExternalType == EXT_CASE_HISTORY) {
		CPTID = AdoFldLong(m_rsBill, "ItemID", -1);
	}
	else if (ExternalType == EXT_EMR || ExternalType == EXT_APPOINTMENT || ExternalType == EXT_GLASSES_ORDER) {
		CPTID = AdoFldLong(m_rsBill, "ServiceID", -1);
	}
	else {
		if (ExternalType == EXT_ALLOCATION) {
			//this type should never be billing a CPT code
			ASSERT(FALSE);
		}
		return FALSE;
	}

	// (j.jones 2008-05-02 09:25) - PLID 27685 - ensure that the CPT list has been requeried
	// prior to trying to search the list
	if (m_bCPTCombo == FALSE) {
		//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
		m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
		m_CPTCombo->Requery();
		m_bCPTCombo = TRUE;
	}

	double dblQuantity = AdoFldDouble(m_rsBill, "Quantity", 1.0);

	//TES 7/15/2008 - PLID 27983 - First, check whether we should pull in linked products for this charge.
	if (m_EntryType == 1) {
		//TES 7/17/2008 - PLID 27983 - Pass in true for bMassAdding, this is called from places like "Bill a EMN" or
		// "Bill a Previous Case History" that add a bunch of charges at once.
		// (j.jones 2010-11-23 16:27) - PLID 41549 - supported the external price

		if (ExternalType == EXT_CASE_HISTORY) {
			var = m_rsBill->Fields->Item["Amount"]->Value;
		}
		else if (ExternalType == EXT_EMR || ExternalType == EXT_APPOINTMENT) {
			var = m_rsBill->Fields->Item["UnitCost"]->Value;
		}
		else if (ExternalType == EXT_GLASSES_ORDER) {
			var = m_rsBill->Fields->Item["Price"]->Value;
		}
		COleCurrency cyExternalPrice = VarCurrency(var);

		if (CheckLinkProducts(CPTID, dblQuantity, true, &cyExternalPrice, -1, -1, FALSE)) {
			//TES 7/15/2008 - PLID 27983 - If CheckLinkProducts() returns TRUE, that means it already added linked products
			// to the bill in lieu of this item.
			return TRUE;
		}
	}

	long iNewRow = m_CPTCombo->SetSelByColumn(CPT_COLUMN_SERVICE_ID, CPTID);

	if (iNewRow == -1)
		return FALSE;

	long ServiceID;
	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_SERVICE_ID);
	if (v.vt != VT_NULL && v.vt != VT_EMPTY)
		ServiceID = v.lVal;
	else
		ServiceID = -1;

	// (j.jones 2006-04-25 16:37) - we cached the Anesthesia, UseAnesthesiaBilling, FacilityFee, and UseFacilityBilling
	// values, so don't check for these if we already know it's irrelevant
	BOOL bIsAnesthesia = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_ANESTHESIA), FALSE);
	BOOL bUseAnesthesia = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_USE_ANESTH_BILLING), FALSE);
	BOOL bIsFacilityFee = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_FACILITY_FEE), FALSE);
	BOOL bUseFacilityFee = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_USE_FACILITY_BILLING), FALSE);
	// (j.jones 2010-11-23 08:52) - PLID 39602 - cache the AssistingCode value
	BOOL bIsAssistingCode = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_ASSISTING_CODE), FALSE);

	// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
	BOOL bOHIPPremiumCode = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_OHIP_PREMIUM_CODE), FALSE);

	// (j.jones 2009-03-31 10:39) - PLID 33747 - if a CPT code, check if it is an OHIP Premium Code
	if (UseOHIP() && bOHIPPremiumCode) {
		//the flat fee option will use the standard fee, not the fee from whatever object added this charge
		if (ProcessOHIPPremiumCode(ServiceID)) {
			//if the above function returns true, we will not add this charge in this function,
			//but return TRUE since it processed normally
			return TRUE;
		}
	}

	//check and see if this is an anesthesia code or facility code, and already exists in the charge list
	if (((bIsAnesthesia && bUseAnesthesia) || (bIsFacilityFee && bUseFacilityFee))
		&& !CheckAllowAddAnesthesiaFacilityCharge(ServiceID)) {
		return TRUE;
	}

	// (j.jones 2004-07-07 16:59) - if the current ins. resp. is set to allow 1/10th rounding, do so!
	long InsID = -1;
	InsID = GetCurrentBillToInsuranceCoID();
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	BOOL bRoundUp = !ReturnsRecordsParam("SELECT PersonID FROM InsuranceCoT WHERE AnesthesiaSetting = 1 AND PersonID = {INT}", InsID);

	BOOL bAnesthesia = FALSE;
	COleCurrency cyAnesthUnitCost = COleCurrency(0, 0);
	double dblAnesthUnits = 0.0;
	long nAnesthMinutes = GetAnesthMinutes();

	BOOL bFacilityFee = FALSE;
	COleCurrency cyFacilityUnitCost = COleCurrency(0, 0);
	long nFacilityMinutes = GetFacilityMinutes();

	BOOL bAssistingCode = FALSE;
	COleCurrency cyAssistingCodeUnitCost = COleCurrency(0, 0);

	if (m_PlaceOfServiceCombo->CurSel == -1)
		m_PlaceOfServiceCombo->CurSel = 0;
	long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

	//// (j.jones 2004-07-07 13:52) - a case history would have already done these calculations
	if (ExternalType != EXT_CASE_HISTORY) {

		//pre-fill the start/end times, and minutes, with info from the Billing2 dlg
		CString strStartTime = GetAnesthStartTime();
		CString strEndTime = GetAnesthEndTime();

		// (j.jones 2004-07-07 12:09) - checks to see if this is an anesthesia code and loads the associated info.
		if (bIsAnesthesia && bUseAnesthesia && !CheckAnesthesia(ServiceID, bAnesthesia, cyAnesthUnitCost, dblAnesthUnits, nAnesthMinutes, strStartTime, strEndTime, nPlaceOfServiceID, bRoundUp))
			return FALSE;

		if (bAnesthesia) {
			//set the times on the Billing2 dlg
			SetAnesthMinutes(nAnesthMinutes);
			SetAnesthStartTime(strStartTime);
			SetAnesthEndTime(strEndTime);
		}

		strStartTime = GetFacilityStartTime();
		strEndTime = GetFacilityEndTime();

		// (j.jones 2005-07-01 11:31) - checks to see if this is a facility fee code and calculates the right fee
		if (bIsFacilityFee && bUseFacilityFee && !CheckFacilityFee(ServiceID, bFacilityFee, cyFacilityUnitCost, nFacilityMinutes, strStartTime, strEndTime, nPlaceOfServiceID)) {
			return FALSE;
		}

		if (bFacilityFee) {
			//set the times on the Billing2 dlg
			SetFacilityMinutes(nFacilityMinutes);
			SetFacilityStartTime(strStartTime);
			SetFacilityEndTime(strEndTime);
		}

		// (j.jones 2011-10-31 17:15) - PLID 41558 - we now store this per bill
		long nAssistingMinutes = GetAssistingMinutes();
		CString strAssistingStartTime = GetAssistingStartTime();
		CString strAssistingEndTime = GetAssistingEndTime();

		// (j.jones 2010-11-23 08:58) - PLID 39602 - if OHIP, and not anesthesia, and not a facility fee,
		// check to see if it is an assisting code
		if (!bAnesthesia && !bFacilityFee && UseOHIP()) {
			if (!CheckAssistingCode(ServiceID, bAssistingCode, cyAssistingCodeUnitCost, nAssistingMinutes, strAssistingStartTime, strAssistingEndTime)) {
				return FALSE;
			}

			if (bAssistingCode) {
				//set the times on the Billing2 dlg
				SetAssistingMinutes(nAssistingMinutes);
				SetAssistingStartTime(strAssistingStartTime);
				SetAssistingEndTime(strAssistingEndTime);
			}
		}
	}


	DiscountList *pDiscountList = new DiscountList;
	COleCurrency cyPointsUsed;
	BOOL bUsingPoints = FALSE;

	COleCurrency cyRewardDiscountDollars = VarCurrency(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_DISCOUNTDOLLARS), COleCurrency(0, 0));
	long nRewardDiscountPercent = VarLong(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_DISCOUNTPERCENT), 0);
	COleCurrency cyPointCost = VarCurrency(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_POINTCOST), COleCurrency(0, 0));

	//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
	// (j.dinatale 2012-04-11 09:41) - PLID 49519 - we need to pass in glasses order service ID to load discount list, so moved up, pass along the service ID if this is for a glasses order
	long nGlassesOrderServiceID = -1;
	BOOL bLoadDiscountsFromGlasses = FALSE;
	if (ExternalType == EXT_GLASSES_ORDER) {
		nGlassesOrderServiceID = ExternalID;
		bLoadDiscountsFromGlasses = TRUE;
	}

	LoadDiscountList(TRUE, (bLoadDiscountsFromGlasses ? nGlassesOrderServiceID : -1), ServiceID, pDiscountList,
		cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent,
		bUsingPoints, cyPointsUsed, FALSE, FALSE, bLoadDiscountsFromGlasses);

	// Add a new charge to the temporary list and
	// set its details to default values
	long nDefaultProviderID = -1;
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
	_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
		"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
		"FROM ServiceT "
		"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", ServiceID);
	if (!rs->eof) {
		nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
	}
	rs->Close();

	// (j.dinatale 2012-05-09 14:12) - PLID 50135 - handle optical orders differently, the provider on a glasses order will be the claim provider
	//		and the optician will be the normal provider on each charge if its filled in, otherwise go with the default behavior
	long nClaimProviderID = -1;
	if (ExternalType == EXT_GLASSES_ORDER){
		_RecordsetPtr rsProv = CreateParamRecordset("SELECT "
			"CASE WHEN ProvidersQ.Archived = 0 "
			"THEN GlassesOrderT.ProviderID "
			"ELSE NULL END AS ProviderID, "
			"CASE WHEN OpticiansQ.Archived = 0 "
			"THEN GlassesOrderT.OpticianID "
			"ELSE NULL END AS OpticianID "
			"FROM GlassesOrderServiceT "
			"LEFT JOIN GlassesOrderT ON GlassesOrderServiceT.GlassesOrderID = GlassesOrderT.ID "
			"LEFT JOIN PersonT ProvidersQ ON GlassesOrderT.ProviderID = ProvidersQ.ID "
			"LEFT JOIN PersonT OpticiansQ ON GlassesOrderT.OpticianID = OpticiansQ.ID "
			"WHERE GlassesOrderServiceT.ID = {INT}", nGlassesOrderServiceID);
		if (!rsProv->eof) {
			long nOpticianID = AdoFldLong(rsProv, "OpticianID", -1);
			if (nOpticianID != -1){
				nDefaultProviderID = nOpticianID;
			}

			nClaimProviderID = AdoFldLong(rsProv, "ProviderID", -1);
		}
		rsProv->Close();
	}

	// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Keep a reference to the item so we can use its date
	BillingItemPtr pNewBillingItem = AppendChargeToList(nDefaultProviderID);
	int iLineID = pNewBillingItem->LineID.lVal;

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_CODE);
	if (v.vt != VT_NULL && v.vt != VT_EMPTY)
		strCPTCode = CString(v.bstrVal);

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_SUBCODE);
	if (v.vt != VT_NULL && v.vt != VT_EMPTY)
		strCPTSubCode = CString(v.bstrVal);

	// (j.jones 2015-03-18 15:17) - PLID 64974 - Category and SubCategory are now nullable
	_variant_t varCategoryID = g_cvarNull;
	_variant_t varSubCategoryID = g_cvarNull;

	
	
	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_CATEGORY);
	if (v.vt == VT_I4 && VarLong(v) > 0) {
		varCategoryID = v;
	}
	// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
	_variant_t varCategoryCount =(long) 0;
	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_CATEGORY_COUNT);
	if (v.vt == VT_I4 && VarLong(v) > 0) {
		varCategoryCount = v;
	}

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_NAME);
	if (v.vt != VT_NULL || v.vt == VT_EMPTY) {
		strDescription = CString(v.bstrVal);
	}

	if (ExternalType == EXT_EMR) {
		strDescription = AdoFldString(m_rsBill, "Description", strDescription);
	}

	// Update description on parent billing module dialog
	CString str;
	// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
	if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
		// (j.gruber 2012-01-04 11:44) - PLID 46291
		SetBillDescriptionBasedOnResp();
		// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
		str = GetBillDescription();
		if (str.GetLength() == 0) {
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
			SetBillDescription(strDescription);
		}
	}

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_TOS);
	if (v.vt != VT_NULL)
		strTypeOfService = CString(v.bstrVal);

	if (strTypeOfService.GetLength() == 0)
		strTypeOfService = " ";

	////////////////////////////////////////////////////
	// Get Taxable status

	long TaxType = 2;

	//find the insurance company's taxable status
	long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
	if (nInsuredPartyID > 0)
		TaxType = GetInsuranceCoTaxType(nInsuredPartyID);

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_TAXABLE1);
	if (v.boolVal == 0) {
		dblTax1 = 1.0;
	}
	else {
		dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
	}

	double dblTaxCalc1 = dblTax1;

	dblTax1 -= 1.0;
	dblTax1 *= 100.0;

	v = m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_TAXABLE2);
	if (v.boolVal == 0) {
		dblTax2 = 1.0;
	}
	else {
		dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
	}

	double dblTaxCalc2 = dblTax2;

	dblTax2 -= 1.0;
	dblTax2 *= 100.0;

	if (bAnesthesia) {
		dblQuantity = dblAnesthUnits;
	}

	// Diagnosis codes
	//DRT 1/16/2007 - PLID 24177 - Previously, if you billed an EMR with 4 diagnosis codes, 
	//	all your charges were automatically slapped with all 4 in the WhichCodes column.  We
	//	now provide the ability for the user to specify which codes are in use in the EMR itself, 
	//	so we throw away this old behavior and will copy the data from the EMR.
	CString strDiagCodes;

	// (j.jones 2010-08-30 11:02) - PLID 40196 - this code does NOT get disabled by the BillDoNotAutoFillDiagCs preference

	//Only need to query if there are some diag codes selected, and if we're on an EMR type
	// (j.gruber 2014-02-19 10:54) - PLID 60878
	CChargeWhichCodesMapPtr pWhichCodes;
	pWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);

	if (ExternalType == EXT_EMR) {
		long nCntCodes = AdoFldLong(m_rsBill, "DiagCount", 0);
		LoadEMRWhichCodes(pWhichCodes, nCntCodes, ExternalID);
	}
	else {
		LoadDefaultWhichCodes(pWhichCodes);
	}

	// (j.jones 2008-06-04 15:08) - PLID 30256 - added EMRChargeID, only tracked on quotes
	// (j.jones 2012-01-17 14:46) - PLID 47537 - now this is tracked on bills as well, though it is saved differently later
	long nEMRChargeID = -1;
	if (ExternalType == EXT_EMR) {
		nEMRChargeID = ExternalID;
	}

	// (j.jones 2008-06-24 10:42) - PLID 30457 - added AppointmentID
	long nAppointmentID = -1;
	if (ExternalType == EXT_APPOINTMENT) {
		nAppointmentID = ExternalID;
	}

	//CPTModifiers
	CString strModifier1 = "";
	CString strModifier2 = "";
	CString strModifier3 = "";
	CString strModifier4 = "";
	// (d.thompson 2009-07-09) - PLID 34821 - Don't forget multipliers!
	double dblMultiplier1 = 1.0, dblMultiplier2 = 1.0, dblMultiplier3 = 1.0, dblMultiplier4 = 1.0;

	// (j.jones 2009-08-10 12:56) - PLID 34841 - properly initialized these variables
	BOOL bHasAllowable = FALSE;
	COleCurrency cyAllowable = COleCurrency(0, 0);

	//Only the EMR will have CPT Modifiers
	// (s.tullis 2015-04-02 13:52) - PLID 64978 -  Added Category for Emr charges
	if (ExternalType == EXT_EMR) {
		varCategoryID = AdoFldLong(m_rsBill, "Category", -1);
		varCategoryCount = AdoFldLong(m_rsBill, "CategoryCount", 0);
		strModifier1 = AdoFldString(m_rsBill, "CPTModifier1", "");
		strModifier2 = AdoFldString(m_rsBill, "CPTModifier2", "");
		strModifier3 = AdoFldString(m_rsBill, "CPTModifier3", "");
		strModifier4 = AdoFldString(m_rsBill, "CPTModifier4", "");
		dblMultiplier1 = AdoFldDouble(m_rsBill, "Multiplier1", 1.0);
		dblMultiplier2 = AdoFldDouble(m_rsBill, "Multiplier2", 1.0);
		dblMultiplier3 = AdoFldDouble(m_rsBill, "Multiplier3", 1.0);
		dblMultiplier4 = AdoFldDouble(m_rsBill, "Multiplier4", 1.0);
	}

	try {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->ChargeID = (long)-2;
				m_billingItems[i]->Quantity = dblQuantity;
				m_billingItems[i]->PackageQtyRemaining = dblQuantity;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
				m_billingItems[i]->OriginalPackageQtyRemaining = dblQuantity;
				m_billingItems[i]->ServiceID = CPTID;
				m_billingItems[i]->CPTCode = _bstr_t(strCPTCode);
				BillingItemPtr billitem = m_billingItems[i];
				_variant_t var = m_billingItems[i]->CPTCode;
				m_billingItems[i]->CPTSubCode = _bstr_t(strCPTSubCode);
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category and SubCategory are now nullable
				m_billingItems[i]->CPTCategoryID = varCategoryID;
				m_billingItems[i]->CPTSubCategoryID = varSubCategoryID;
				// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
				m_billingItems[i]->CPTCategoryCount = varCategoryCount;
				m_billingItems[i]->Description = _bstr_t(strDescription);
				m_billingItems[i]->TypeOfService = _bstr_t(strTypeOfService);
				// (d.thompson 2009-07-09) - PLID 34821 - Include multipliers too!
				if (!strModifier1.IsEmpty()) {
					m_billingItems[i]->Modifier1 = _bstr_t(strModifier1);
					m_billingItems[i]->Multiplier1 = (double)dblMultiplier1;
				}
				if (!strModifier2.IsEmpty()) {
					m_billingItems[i]->Modifier2 = _bstr_t(strModifier2);
					m_billingItems[i]->Multiplier2 = (double)dblMultiplier2;
				}
				if (!strModifier3.IsEmpty()) {
					m_billingItems[i]->Modifier3 = _bstr_t(strModifier3);
					m_billingItems[i]->Multiplier3 = (double)dblMultiplier3;
				}
				if (!strModifier4.IsEmpty()) {
					m_billingItems[i]->Modifier4 = _bstr_t(strModifier4);
					m_billingItems[i]->Multiplier4 = (double)dblMultiplier4;
				}

				// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
				m_billingItems[i]->Calls = (double)0.0;

				// (d.singleton 2012-05-21 12:28) - PLID 48152 added the skill column alberta only
				m_billingItems[i]->Skill = (LPCTSTR)"";

				// (d.singleton 2012-03-07 17:32) - PLID 49100 new column
				m_billingItems[i]->ValidationStatus = g_cvarNull;

				// (d.singleton 2012-03-22 16:36) - PLID 49136 notes column
				m_billingItems[i]->Notes = _variant_t((long)m_hIconNotes);

				// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes
				m_billingItems[i]->NDCCode = g_cvarNull;

				// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
				m_billingItems[i]->IsEmergency = (long)cietUseDefault;

				// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
				m_billingItems[i]->DrugUnitPrice = COleCurrency(0, 0);
				m_billingItems[i]->DrugUnitType = (LPCTSTR)"";
				m_billingItems[i]->DrugUnitQuantity = (double)0.0;
				m_billingItems[i]->PrescriptionNumber = (LPCTSTR)"";

				// (j.dinatale 2012-05-09 17:54) - PLID 50135 - provider for an optical order is going to be the claim provider on the bill
				m_billingItems[i]->ClaimProvider = nClaimProviderID;

				// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID
				m_billingItems[i]->EMRChargeID = (long)nEMRChargeID;
				// (j.jones 2008-06-24 10:42) - PLID 30457 - added AppointmentID
				m_billingItems[i]->AppointmentID = (long)nAppointmentID;
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				m_billingItems[i]->GlassesOrderServiceID = nGlassesOrderServiceID;
				// (j.gruber 2009-03-06 10:44) - PLID 33351 - take out discount fields
				m_billingItems[i]->DiscountList = pDiscountList;
				//m_billingItems[i]->PercentOff = (long)nPercentOff;
				// (a.walling 2007-05-30 13:40) - PLID 26172 - Save the points used
				m_billingItems[i]->PointsUsed = bUsingPoints ? cyPointsUsed : COleCurrency(0, 0);
				// (a.wetta 2007-05-08 10:39) - PLID 25959 - Also set the discount
				//m_billingItems[i]->Discount = cyDiscount;
				m_billingItems[i]->TaxRate1 = (double)dblTax1;
				m_billingItems[i]->TaxRate2 = (double)dblTax2;
				// (j.gruber 2014-02-19 10:52) - PLID 60878 - new whichCode structure
				m_billingItems[i]->whichCodes = pWhichCodes;

				// (j.gruber 2009-10-16 12:04) - PLID 35947 - load the allowable
				LoadAllowableColumn(m_billingItems[i], FALSE);

				if (m_EntryType == 1 && iNewRow >= 0) {
					// (j.jones 2012-04-12 10:00) - PLID 49609 - add the default claim note, if it exists
					CString strClaimNote = VarString(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_CLAIM_NOTE), "");
					strClaimNote.TrimLeft(); strClaimNote.TrimRight();
					if (strClaimNote.GetLength() > 0) {
						AddNewUnsavedChargeNote(m_billingItems[i], strClaimNote, TRUE);
					}

					// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
					CString strNDCCode = VarString(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_NDCDEFCODE), "");
					double dblNDCQty = VarDouble(m_CPTCombo->GetValue(iNewRow,CPT_COLUMN_NDCDEFQTY), 0.0);
					COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(iNewRow,CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
					CString strNDCUnitType = VarString(m_CPTCombo->GetValue(iNewRow,CPT_COLUMN_NDCDEFUNITTYPE), "");
					// (r.gonet 07/07/2014) - PLID 62572 - Set the On Hold state if the CPT Code is configured to defalt the charge as on hold
					BOOL bOnHold;
					if (GetBillStatusType() != EBillStatusType::OnHold) {
						bOnHold = VarBool(m_CPTCombo->GetValue(iNewRow, CPT_COLUMN_DEFAULTASONHOLD), FALSE);
					} else {
						// Bills already on hold can't have on hold charges.
						bOnHold = FALSE;
					}

					m_billingItems[i]->NDCCode = strNDCCode;
					m_billingItems[i]->DrugUnitPrice = cyNDCUnitPrice;
					m_billingItems[i]->DrugUnitType = strNDCUnitType;
					m_billingItems[i]->DrugUnitQuantity = dblNDCQty;
					// (r.gonet 07/07/2014) - PLID 62569
					m_billingItems[i]->OnHold = bOnHold ? g_cvarTrue : g_cvarFalse;
				}

				// (j.jones 2014-05-01 08:36) - PLID 61837 - the new service code may
				// potentially show additional provider columns
				if (m_EntryType == 1) {
					TryShowChargeProviderColumns(m_billingItems[i], true);
				}
			}
		}
	}
	NxCatchAll("BillingDlg::AddNewExternalCpt");

	_variant_t varOutsideFee = _variant_t(COleCurrency(0, 0));

	if (!bAnesthesia && !bFacilityFee && !bAssistingCode) {
		if (m_EntryType == 1) {
			//////////////////////////////////////////////////////////////////
			// Get the fee from the Multi-Fee Scheduling table. If there is none,
			// set it to the default CPT unit cost.
			// (For a bill only)

			BOOL boMultiFeeExists = FALSE;
			BOOL boWarn = TRUE;
			CString strSQLIns;
			_RecordsetPtr nxrs(__uuidof(Recordset));

			long LocationID = -1;

			if (m_LocationCombo->GetCurSel() == -1)
				LocationID = GetCurrentLocationID();
			else
				LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

			// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
			long nPOSID = -1;
			if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
				nPOSID = GetCurrentLocationID();
			}
			else {
				nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
			}

			CString text;

			if (nInsuredPartyID > 0) {
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				// (d.lange 2015-12-01 12:14) - PLID 67127 - Determine the most-primary insurance based on the insurance
				// category for the given insured party
				nxrs = GetMostPrimaryInsCoIDForInsuredPartyRecordset(nInsuredPartyID);
				if (!nxrs->eof) {
					long InsID = nxrs->Fields->Item["InsuranceCoID"]->Value.lVal;
					nxrs->Close();
					// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
					cyUnitCost = GetMultiFee(ServiceID, (m_DefaultProvider == -1 ? m_Main_Physician : m_DefaultProvider), InsID, LocationID, nPOSID, pNewBillingItem->Date, boMultiFeeExists, boWarn, text, bHasAllowable, cyAllowable);
				}
				else nxrs->Close();
			}
			else {
				// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
				cyUnitCost = GetMultiFee(ServiceID, (m_DefaultProvider == -1 ? m_Main_Physician : m_DefaultProvider), -1, LocationID, nPOSID, pNewBillingItem->Date, boMultiFeeExists, boWarn, text, bHasAllowable, cyAllowable);
			}

			// (m.hancock 2006-05-19 11:35) - PLID 20688 - Do not remove the check for !boMultiFeeExists below or else
			// it will cause EMRs to be billed incorrectly.
			if (!boMultiFeeExists || (boMultiFeeExists && boWarn && IDNO == MessageBox(text, "NexTech", MB_YESNO))) {
				// Allow the user to ignore the multi-fee unit cost and
				// use the standard unit cost for this charge
				if (ExternalType == EXT_CASE_HISTORY) {
					var = m_rsBill->Fields->Item["Amount"]->Value;
				}
				else if (ExternalType == EXT_EMR || ExternalType == EXT_APPOINTMENT) {
					var = m_rsBill->Fields->Item["UnitCost"]->Value;
				}
				else if (ExternalType == EXT_GLASSES_ORDER) {
					var = m_rsBill->Fields->Item["Price"]->Value;
				}
				cyUnitCost = var;
			}

			// (j.gruber 2007-08-21 10:49) - PLID 25846 - check the allowable
			//this is outside the above because they can have an allowable without a multifee
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {

					m_billingItems[i]->UnitAllowable = _variant_t(cyAllowable);

					if (bHasAllowable) {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_TRUE, VT_BOOL);

						// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is multiplied by quantity & modifiers
						COleCurrency cyAllowableTotal = cyAllowable;
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

						RoundCurrency(cyAllowableTotal);

						m_billingItems[i]->TotalAllowable = _variant_t(cyAllowableTotal);
					}
					else {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
						// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL
						m_billingItems[i]->TotalAllowable = g_cvarNull;
					}
				}
			}

			var = cyUnitCost;
		}
		else {
			if (ExternalType == EXT_CASE_HISTORY) {
				var = m_rsBill->Fields->Item["Amount"]->Value;
			}
			else if (ExternalType == EXT_EMR || ExternalType == EXT_APPOINTMENT) {
				var = m_rsBill->Fields->Item["UnitCost"]->Value;
			}
			else if (ExternalType == EXT_GLASSES_ORDER) {
				var = m_rsBill->Fields->Item["Price"]->Value;
			}
		}
	}
	else {
		if (bAnesthesia) {
			// (j.jones 2004-07-07 12:39) - use the anesthesia cost

			// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (m_EntryType == 2 && ReturnsRecordsParam("SELECT AnesthOutsideFee FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND AnesthOutsideFee = 1", CPTID, nPlaceOfServiceID)) {
				var = COleCurrency(0, 0);
				varOutsideFee = cyAnesthUnitCost;
			}
			else {
				var = cyAnesthUnitCost;
				varOutsideFee = COleCurrency(0, 0);
			}
		}
		else if (bFacilityFee) {
			// (j.jones 2005-07-01 13:28) - use the facility cost

			// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (m_EntryType == 2 && ReturnsRecordsParam("SELECT FacilityOutsideFee FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND FacilityOutsideFee = 1", CPTID, nPlaceOfServiceID)) {
				var = COleCurrency(0, 0);
				varOutsideFee = cyFacilityUnitCost;
			}
			else {
				var = cyFacilityUnitCost;
				varOutsideFee = COleCurrency(0, 0);
			}
		}
		// (j.jones 2010-11-23 09:06) - PLID 39602 - supported assisting codes
		else if (bAssistingCode) {
			var = cyAssistingCodeUnitCost;
			varOutsideFee = COleCurrency(0, 0);
		}
	}

	// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
	// the unit cost based on the modifier we just chose
	if (UseAlbertaHLINK()) {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->UnitCost = var;
				// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
				// price unless there are modifiers
				UpdateChargePriceWithAlbertaModifiers(m_billingItems[i], FALSE);
				//get the new price, as it could have changed
				var = m_billingItems[i]->UnitCost;
				break;
			}
		}
	}

	_variant_t varUnit, varTotal;
	COleCurrency cyTotal, cyTotalTax1, cyTotalTax2;
	COleCurrency cyAllowableTotal = COleCurrency(0, 0);

	//quotes calculate the total as both the fees put together
	if (m_EntryType == 2) {
		cyTotal = VarCurrency(var, COleCurrency(0, 0)) + VarCurrency(varOutsideFee, COleCurrency(0, 0));
	}
	else {
		cyTotal = VarCurrency(var, COleCurrency(0, 0));
	}

	cyTotal = CalculateAmtQuantity(cyTotal, dblQuantity);

	// (d.thompson 2009-07-09) - PLID 34821 - If modifiers are included, we must apply their multipliers to the total
	//	as well.  This is done before the discounts are applied.  If we're not on EMR or they aren't in use, these 
	//	will just be 1.0.
	cyTotal = CalculateAmtQuantity(cyTotal, dblMultiplier1);
	cyTotal = CalculateAmtQuantity(cyTotal, dblMultiplier2);
	cyTotal = CalculateAmtQuantity(cyTotal, dblMultiplier3);
	cyTotal = CalculateAmtQuantity(cyTotal, dblMultiplier4);

	// (j.gruber 2009-03-06 10:49) - PLID  33351 - calculate the total discount
	long nPercentOff;
	COleCurrency cyTotalDollarDiscount, cyTotalLineDiscount;

	COleCurrency cyInvalid;
	cyInvalid.SetStatus(COleCurrency::invalid);

	CalculateTotalDiscount(pDiscountList, cyTotal, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);

	cyTotal = (cyTotal * (100000 - nPercentOff * 1000));
	// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
	cyTotal = cyTotal / long(100000);

	// (a.wetta 2007-05-08 11:17) - PLID 25959 - Subtract the discount from the total
	cyTotal -= cyTotalDollarDiscount;

	//store this for the insurance calculation
	varUnit = var;
	var = cyTotal;

	cyTotalTax1 = CalculateTax(cyTotal, dblTaxCalc1);
	cyTotalTax2 = CalculateTax(cyTotal, dblTaxCalc2);

	cyTotal += cyTotalTax1;
	cyTotal += cyTotalTax2;

	RoundCurrency(cyTotal);

	varTotal = cyTotal;

	/////////////////////////////////////////////////////////////////
	// If no insurance, always set the total to the unit cost,
	// even if a quote.
	int i;

	// (j.dinatale 2012-04-16 11:33) - PLID 49690 - added handling for the optical orders, these orders have a vision and pat resp defined 
	//	for each charge
	if (nInsuredPartyID > 0 || ExternalType == EXT_GLASSES_ORDER) {
		//we are looking at some sort of insurance
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				//find the item in the list
				RPCList *list = m_billingItems[i]->RPCList;

				if (ExternalType != EXT_GLASSES_ORDER){
					bool bFoundResp = false;
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int j = 0;
					for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
						if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
							bFoundResp = true;
					}

					if (bFoundResp) {
						//at this point, var is the amount before tax, and varTotal is the amount with tax
						//use the insurance TaxType to determine which responsibility gets which amount
						if (TaxType == 1)
							UpdateListInsAmount(list, j, varTotal);
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							UpdateListInsAmount(list, j, var);
					}
					else {
						//we're looking at insurance, but there's nothing in our list!  we
						//need to add it
						RespPerCharge rpc;
						rpc.InsuredPartyID = nInsuredPartyID;

						if (TaxType == 1)
							rpc.InsAmount = varTotal;
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							rpc.InsAmount = var;

						// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
						rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
						rpc.RespTypeName = GetCurrentBillToRespTypeName();

						list->aryRPC.Add(rpc);
					}
				}else{
					// (j.dinatale 2012-04-25 11:01) - PLID 49690 - can optimize this so we dont keep checking for primary vision
					// (j.dinatale 2012-06-05 11:11) - PLID 49713 - add an external InsuredPartyID for optical orders
					if(nExtInsuredPartyID > 0){
						// grab the vision resp amount for this service, and the primary vision insurance
						_RecordsetPtr rsRespAmounts = CreateParamRecordset(
							"SELECT VisionRespAmt FROM GlassesOrderServiceT WHERE ID = {INT}; ", ExternalID);

						if (!rsRespAmounts->eof){
							// if we were able to retrieve the vision resp amount...
							COleCurrency cyVisionResp = AdoFldCurrency(rsRespAmounts, "VisionRespAmt", g_ccyZero);

							if (cyVisionResp != g_ccyZero){
								// and that amount is not zero...
								RespPerCharge rpc;
								rpc.InsuredPartyID = nExtInsuredPartyID;
								rpc.InsAmount = _variant_t(cyVisionResp);
								rpc.InsuranceCoName = strInsCoName;
								rpc.RespTypeName = strRespTypeName;

								list->aryRPC.Add(rpc);
							}
						}
					}
				}
			}
		}
	}

	for (i = 0; i < (int)m_billingItems.size(); i++) {
		if (m_billingItems[i]->LineID.lVal == iLineID) {

			// (j.gruber 2009-03-09 10:27) - PLID 33351 - add Total Discount here
			m_billingItems[i]->TotalDiscount = cyTotalLineDiscount;

			m_billingItems[i]->UnitCost = varUnit;
			m_billingItems[i]->OthrUnitCost = varOutsideFee;
			m_billingItems[i]->LineTotal = varTotal;
		}
	}

	m_varBoundItem = (long)iLineID;


	// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
	CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

	DisableBillingScreen();

	if (m_EntryType == 1)
		FillBillList();
	else
		FillQuoteList();

	// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
	// use the row instead of the LineID
	// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
	IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
	InsertRowSorted(pRowToSort, varTotal);

	EnableBillingScreen();

	/* Recalculate the bill total */
	CalculateTotal();

	return TRUE;
}

// (j.jones 2007-12-14 13:41) - PLID 27988 - AddNewExternalProduct can now be called from
// the end of an allocation - it should take in parameters and not be dependent on m_rsBill
// (j.dinatale 2012-06-05 11:11) - PLID 49713 - add an external InsuredPartyID for optical orders
// (j.dinatale 2013-02-20 10:03) - PLID 54698 - need to determine if we should skip the "Do I Have Enough" prompting
// (j.jones 2013-04-12 13:30) - PLID 56250 - renamed cyUnitCost to cyExternalPrice cost to clarify that it's the cost passed in by the called
BOOL CBillingDlg::AddNewExternalProduct(long ExternalID, long ExternalType, long nProductID, CString strProductName, double dblQuantity, COleCurrency cyExternalPrice, long nDiagCount /*= -1*/, long nChargedProductItemListID /*= -1*/, long nChargedAllocationDetailListID /*= -1*/, long nExtInsuredPartyID /*= -1*/, CString strInsCoName /*= ""*/, CString strRespTypeName /*= ""*/, bool bSkipInvCountCheck /*= false*/)
{
	CWaitCursor pWait;

	try {

		COleVariant var;
		// (j.jones 2008-04-16 13:15) - PLID 29681 - this code tried to redefine a passed-in parameter!
		//COleCurrency cyUnitCost;
		CString strCPTCode, strCPTSubCode, strDescription, strUnitCost, strLineTotal, strCPTCategory, strSQL;
		double dblTax1, dblTax2;

		if (ExternalType != EXT_CASE_HISTORY && ExternalType != EXT_EMR && ExternalType != EXT_ALLOCATION && ExternalType != EXT_APPOINTMENT && ExternalType != EXT_GLASSES_ORDER) {
			//invalid type
			ASSERT(FALSE);
			return FALSE;
		}

		// (j.jones 2008-05-02 09:25) - PLID 27685 - ensure that the product list has been requeried
		// prior to trying to use the list
		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}

		// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
		long iNewRow = FindProductRowInComboByServiceID(nProductID, TRUE);

		if (iNewRow == -1) {
			return FALSE;
		}

		// (j.jones 2010-09-03 08:45) - PLID 38319 - if a bill, and a product,
		// and they want to add products as patient responsibility, switch the resp. dropdown now
		BOOL bSwitchedResponsibilitySel = FALSE;
		long nOldRespType = -1;
		if (m_EntryType == 1
			&& GetRemotePropertyInt("AddInventoryAsPatResp", 0, 0, GetCurrentUserName(), true) == 1) {
			//cache the current resp type and then select patient
			if (m_listBillTo->CurSel != -1) {
				nOldRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
			}
			m_listBillTo->SetSelByColumn(btcPriority, (long)0);
			PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
			bSwitchedResponsibilitySel = TRUE;
		}

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return FALSE;
		}

		long LocationID = -1;

		if (m_LocationCombo->GetCurSel() == -1) {
			LocationID = GetCurrentLocationID();
		}
		else {
			LocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
		}

		ProductAllocationReturnValue arvRet = arvAddNormally;

		//we may have already been given a nChargedAllocationDetailListID
		//do not check for allocations when billing a case history
		if (nChargedAllocationDetailListID == -1 && ExternalType != EXT_CASE_HISTORY) {
			// (j.jones 2007-12-13 16:12) - PLID 27988 - check to see if this product is in an allocation
			// this *can* change the nProductID, strProductName, and dblQuantity!
			long nOldProductID = nProductID;
			arvRet = CheckProductAgainstAllocations(nProductID, strProductName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID);

			//did the user decide to cancel adding the product?
			if (arvRet == arvAbortAdding) {

				// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
				if (bSwitchedResponsibilitySel) {
					if (nOldRespType == -1) {
						//there was no resp type, so select the blank row
						m_listBillTo->PutCurSel(-1);
					}
					else {
						m_listBillTo->SetSelByColumn(btcID, nOldRespType);
					}
					PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
				}
				return FALSE;
			}

			//did the product ID change?
			if (nProductID != nOldProductID) {
				//make sure we re-select the product row
				// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
				iNewRow = FindProductRowInComboByServiceID(nProductID, TRUE);
				if (iNewRow == -1) {
					//this would mean the product in the allocation is not billable to this location
					//give a warning
					CString strWarn;
					strWarn.Format("The product '%s' is not billable to the currently selected location on the bill.", strProductName);
					AfxMessageBox(strWarn);

					if (nChargedAllocationDetailListID != -1) {
						DeleteOneFromChargedAllocationDetailsArray(nChargedAllocationDetailListID);
					}

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					return FALSE;
				}
			}
		}

		//JJ - Billed case histories do not decrement, therefore it doesn't need to be checked for a case history
		if (ExternalType != EXT_CASE_HISTORY) {
			// (s.dhole 2012-03-26 12:05) - PLID 48597 Exclude Glasses order item qnt if mark as Off the shelf  
			BOOL bExcludeQntity = FALSE;
			if (ExternalType == EXT_GLASSES_ORDER)
			{
				// (s.dhole 2012-04-24 08:58) - PLID 48597  We should check IsOffTheShelf <> 1
				if (ReturnsRecordsParam("SELECT * FROM GlassesOrderServiceT  WHERE IsDefaultProduct = 1 AND IsOffTheShelf =0 AND ID = {INT}", ExternalID)){
					bExcludeQntity = TRUE;
				}
			}
			double dblTempQuantity = 0.0;
			if (ExternalType == EXT_GLASSES_ORDER && bExcludeQntity){
				dblTempQuantity = -GetUnsavedQuantityCount(nProductID);
				// if total is -0 then change to  0.0
				if (dblTempQuantity == 0.00) {
					dblTempQuantity = 0.00;
				}
			}
			else if (ExternalType != EXT_ALLOCATION){
				dblTempQuantity = -GetUnsavedQuantityCount(nProductID) - (ExternalType != EXT_ALLOCATION ? dblQuantity : 0.0);
			}


			// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations
			//InvUtils::DoIHaveEnough(nProductID, LocationID, -GetUnsavedQuantityCount(nProductID) - (ExternalType != EXT_ALLOCATION ? dblQuantity : 0.0), -GetUnsavedAllocationQuantityCount(nProductID), m_EntryType == 2);

			// (j.dinatale 2013-02-20 10:08) - PLID 54698 - do we want to skip the prompt?
			if (!bSkipInvCountCheck){
				InvUtils::DoIHaveEnough(nProductID, LocationID, dblTempQuantity, -GetUnsavedAllocationQuantityCount(nProductID), m_EntryType == 2);
			}
			//InvUtils::DoIHaveEnough(nProductID, LocationID, -GetUnsavedQuantityCount(nProductID) - dblTempQuantity , -GetUnsavedAllocationQuantityCount(nProductID), m_EntryType == 2);


		}

		//JJ - The Case History itself takes care of this, the charge should not do it again for case histories

		// Check and see if these products have serial numbers or exp. dates.	
		if (ExternalType != EXT_CASE_HISTORY && m_EntryType == 1 && arvRet == arvAddNormally && nChargedProductItemListID == -1) {
			CString strWhere = GetProductItemWhereClause();
			if (strWhere.GetLength() > 0)
				strWhere += " AND ";
			// (j.jones 2007-11-21 16:40) - PLID 28037 - ensure we account for allocated items
			if (!IsRecordsetEmpty("SELECT ID FROM ProductItemsT WHERE %s ProductID = %li "
				"AND ID NOT IN (SELECT ProductItemID FROM ChargedProductItemsT) "
				"AND ID NOT IN (SELECT ProductItemID FROM PatientInvAllocationDetailsT "
				"			    WHERE (Status = %li OR Status = %li) "
				"				AND ProductItemID Is Not Null) "
				"AND Deleted = 0  AND (ProductItemsT.LocationID = %li OR ProductItemsT.LocationID Is Null)",
				strWhere, nProductID, InvUtils::iadsActive, InvUtils::iadsUsed, LocationID)) {

				BOOL bCancel = FALSE;
				BOOL bLoop = TRUE;

				//while we still need to prompt
				while (bLoop) {

					//prompt
					CProductItemsDlg dlg(this);
					dlg.m_EntryType = PI_SELECT_DATA;
					dlg.m_ProductID = nProductID;
					dlg.m_nLocationID = LocationID;
					dlg.m_CountOfItemsNeeded = (long)dblQuantity;
					dlg.m_strWhere = GetProductItemWhereClause();
					//we will only allow the auto-qty-grow when selecting an individual product
					// (r.farnworth 2014-07-07 15:25) - PLID 59570 - We no longer want to allow the quantity to change when being called from an EMN.
					dlg.m_bAllowQtyGrow = FALSE;

					if (IDCANCEL == dlg.DoModal()) {
						//if they cancelled, warn them!
						if (IDYES == MessageBox("You have chosen to cancel adding this product."
							"\nThe item will not be added to the list if you do not fill in the requested information."
							"\nAre you SURE you wish to cancel?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
							//if they wish to not bill the item, stop looping, cancel adding this item
							bLoop = FALSE;
							bCancel = TRUE;
						}
					}
					else {
						//if they selected an item, then stop looping
						bLoop = FALSE;
						dblQuantity = dlg.m_CountOfItemsNeeded;
						nChargedProductItemListID = NewChargedProductItemListID();
						AddToChargedProductItemsArray(-2, nChargedProductItemListID, dlg.m_adwProductItemIDs);
					}
				}
				if (bCancel) {
					//if the loop ended with a cancellation, quit

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					return FALSE;
				}
			}
			else {
				//if the product doesn't have any ProductItems, see if it requires them, in which case they cannot bill it
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Name, HasSerialNum, HasExpDate FROM ServiceT "
					"INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
					"WHERE ServiceT.ID = {INT} AND (HasSerialNum = 1 OR HasExpDate = 1)", nProductID);
				if (!rs->eof) {
					CString strName = AdoFldString(rs, "Name", "");
					BOOL bHasSerialNum = AdoFldBool(rs, "HasSerialNum", FALSE);
					BOOL bHasExpDate = AdoFldBool(rs, "HasExpDate", FALSE);
					CString str;
					str.Format("The product '%s' requires %s%s%s, but has no items in stock.\n"
						"This product cannot be billed until there are items in stock.", strName,
						bHasSerialNum ? "a serial number" : "",
						(bHasSerialNum && bHasExpDate) ? " and " : "",
						bHasExpDate ? "an expiration date" : "");
					AfxMessageBox(str);

					// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
					if (bSwitchedResponsibilitySel) {
						if (nOldRespType == -1) {
							//there was no resp type, so select the blank row
							m_listBillTo->PutCurSel(-1);
						}
						else {
							m_listBillTo->SetSelByColumn(btcID, nOldRespType);
						}
						PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
					}
					return FALSE;
				}
				rs->Close();
			}
		}

		DisableBillingScreen();

		// (j.gruber 2009-03-06 10:52) - PLID 33351 - take out existing discounts
		DiscountList *pDiscountList = new DiscountList;
		COleCurrency cyPointsUsed;
		BOOL bUsingPoints = FALSE;

		COleCurrency cyRewardDiscountDollars = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_DISCOUNTDOLLARS), COleCurrency(0, 0));
		long nRewardDiscountPercent = VarLong(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_DISCOUNTPERCENT), 0);
		COleCurrency cyPointCost = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_POINTCOST), COleCurrency(0, 0));

		LoadDiscountList(TRUE, (ExternalType == EXT_GLASSES_ORDER ? ExternalID : -1), nProductID, pDiscountList,
			cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent,
			bUsingPoints, cyPointsUsed, FALSE, FALSE, (ExternalType == EXT_GLASSES_ORDER));

		// (j.dinatale 2012-05-10 09:40) - PLID 50135 - move this up here, we need it for the claim provider query
		//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
		long nGlassesOrderServiceID = -1;
		if (ExternalType == EXT_GLASSES_ORDER) {
			nGlassesOrderServiceID = ExternalID;
		}

		// Add a new charge to the temporary list and
		// set its details to default values
		long nDefaultProviderID = -1;
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
		_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
			"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
			"FROM ServiceT "
			"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", nProductID);
		if (!rs->eof) {
			nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
		}
		rs->Close();

		// (j.dinatale 2012-05-09 14:12) - PLID 50135 - handle optical orders differently, the provider on a glasses order will be the claim provider
		//		and the optician will be the normal provider on each charge if its filled in, otherwise go with the default behavior
		long nClaimProviderID = -1;
		if (ExternalType == EXT_GLASSES_ORDER){
			_RecordsetPtr rsProv = CreateParamRecordset("SELECT "
				"CASE WHEN ProvidersQ.Archived = 0 "
				"THEN GlassesOrderT.ProviderID "
				"ELSE NULL END AS ProviderID, "
				"CASE WHEN OpticiansQ.Archived = 0 "
				"THEN GlassesOrderT.OpticianID "
				"ELSE NULL END AS OpticianID "
				"FROM GlassesOrderServiceT "
				"LEFT JOIN GlassesOrderT ON GlassesOrderServiceT.GlassesOrderID = GlassesOrderT.ID "
				"LEFT JOIN PersonT ProvidersQ ON GlassesOrderT.ProviderID = ProvidersQ.ID "
				"LEFT JOIN PersonT OpticiansQ ON GlassesOrderT.OpticianID = OpticiansQ.ID "
				"WHERE GlassesOrderServiceT.ID = {INT}", nGlassesOrderServiceID);
			if (!rsProv->eof) {
				long nOpticianID = AdoFldLong(rsProv, "OpticianID", -1);
				if (nOpticianID != -1){
					nDefaultProviderID = nOpticianID;
				}

				nClaimProviderID = AdoFldLong(rsProv, "ProviderID", -1);
			}
			rsProv->Close();
		}

		// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Keep a reference to the item so we can use its date
		BillingItemPtr pNewBillingItem = AppendChargeToList(nDefaultProviderID);
		int iLineID = pNewBillingItem->LineID.lVal;

		// CPT code (should be set to InsCode from ProductT table)
		_variant_t v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_INS_CODE);

		if (v.vt != VT_NULL) {
			strCPTCode = CString(v.bstrVal);
		}

		// Description (Name from ServiceT table)
		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NAME);
		if (v.vt != VT_NULL)
			strDescription = CString(v.bstrVal);

		/* Update description on parent billing module dialog */
		CString str;
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDescription);
			}
		}

		// (j.jones 2015-03-18 15:17) - PLID 64974 - Category is now nullable
		_variant_t varCategoryID = g_cvarNull;
		var = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CATEGORYID);
		if (var.vt == VT_I4 && VarLong(var) > 0) {
			varCategoryID = var;
		}
		// (s.tullis 2015-04-02 13:54) - PLID 64975- Hide the category column if there is not multiple catagories
		_variant_t varCategoryCount = (long)0;
		var = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CATEGORY_COUNT);
		if (var.vt == VT_I4 && VarLong(var) > 0) {
			varCategoryCount = var;
		}

		long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
		// (d.lange 2015-12-01 10:49) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
		long nInsuranceCoID = GetCurrentBillToMostPriInsCoIDForCategory();

		long nPOSID = -1;
		if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
			nPOSID = GetCurrentLocationID();
		}
		else {
			nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
		}

		// Get unit price
		COleCurrency cyUnitCost = cyExternalPrice;

		// (j.jones 2013-04-12 14:02) - PLID 56250 - check for multi-fees (bills only)
		if (m_EntryType == 1) {
			BOOL bMultiFeeExists = FALSE;
			BOOL bWarn = TRUE;
			CString strWarn;
			BOOL bHasAllowable = FALSE;
			COleCurrency cyAllowable = COleCurrency(0, 0);

			// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
			cyUnitCost = GetMultiFee(nProductID, (m_DefaultProvider == -1 ? m_Main_Physician : m_DefaultProvider), (nInsuranceCoID > 0) ? nInsuranceCoID : -1, LocationID, nPOSID, pNewBillingItem->Date, bMultiFeeExists, bWarn, strWarn, bHasAllowable, cyAllowable);

			//if there is no multi-fee or they decline to use it, revert to the provided external price
			if (!bMultiFeeExists || (bMultiFeeExists && bWarn && IDNO == MessageBox(strWarn, "NexTech", MB_YESNO))) {
				cyUnitCost = cyExternalPrice;
			}

			// (j.jones 2013-04-12 14:02) - PLID 56250 - check for allowables
			//this is outside the above because they can have an allowable without a multifee
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {

					m_billingItems[i]->UnitAllowable = _variant_t(cyAllowable);

					if (bHasAllowable) {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_TRUE, VT_BOOL);

						//products don't have modifiers by default
						COleCurrency cyAllowableTotal = cyAllowable;
						cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

						RoundCurrency(cyAllowableTotal);

						m_billingItems[i]->TotalAllowable = _variant_t(cyAllowableTotal);
					}
					else {
						m_billingItems[i]->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
						m_billingItems[i]->TotalAllowable = g_cvarNull;
					}
				}
			}
		}

		// (j.jones 2013-04-12 13:42) - PLID 56250 - This code used to just build up
		// cyUnitCost and use it as a total. I properly named the variable cyTotal
		// so it's clearer that's what it is really used for.
		COleCurrency cyTotal = cyUnitCost;

		COleCurrency cyOthrUnit = COleCurrency(0, 0);

		//if a quote, our total will include the outside fee
		if (m_EntryType == 2)
			cyTotal += cyOthrUnit;

		cyTotal = CalculateAmtQuantity(cyTotal, dblQuantity);

		// (j.gruber 2009-03-06 10:56) - PLID 33351 - Calculate the total discount amount
		COleCurrency cyTotalDollarDiscount, cyTotalLineDiscount;
		long nPercentOff;

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		CalculateTotalDiscount(pDiscountList, cyTotal, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);

		cyTotal = (cyTotal * (100000 - nPercentOff * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cyTotal = cyTotal / long(100000);

		// (a.wetta 2007-05-08 11:17) - PLID 25959 - Subtract the discount from the total
		cyTotal -= cyTotalDollarDiscount;

		////////////////////////////////////////////////////
		// Get Taxable status
		COleCurrency taxTotal1, taxTotal2;

		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_1);
		if (v.boolVal == 0) {
			dblTax1 = 1.0;
		}
		else {
			dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
		}

		taxTotal1 = CalculateTax(cyTotal, dblTax1);

		dblTax1 -= 1.0;
		dblTax1 *= 100.0;

		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_2);
		if (v.boolVal == 0) {
			dblTax2 = 1.0;
		}
		else {
			dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
		}

		taxTotal2 = CalculateTax(cyTotal, dblTax2);

		dblTax2 -= 1.0;
		dblTax2 *= 100.0;

		var = cyTotal;
		cyTotal += taxTotal1;
		cyTotal += taxTotal2;

		RoundCurrency(cyTotal);
		_variant_t varTotal = cyTotal;

		// Diagnosis codes
		//DRT 1/16/2007 - PLID 24177 - Previously, if you billed an EMR with 4 diagnosis codes, 
		//	all your charges were automatically slapped with all 4 in the WhichCodes column.  We
		//	now provide the ability for the user to specify which codes are in use in the EMR itself, 
		//	so we throw away this old behavior and will copy the data from the EMR.
		CString strDiagCodes;

		// (j.jones 2010-08-30 11:02) - PLID 40196 - this code does NOT get disabled by the BillDoNotAutoFillDiagCs preference

		//Only need to query if there are some diag codes selected, and if we're on an EMR type
		// (j.gruber 2014-02-19 12:59) - PLID 60878 - new structure
		CChargeWhichCodesMapPtr pWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		if (ExternalType == EXT_EMR) {
			LoadEMRWhichCodes(pWhichCodes, nDiagCount, ExternalID);
		}
		else {
			LoadDefaultWhichCodes(pWhichCodes);
		}

		// (j.jones 2008-06-04 15:08) - PLID 30256 - added EMRChargeID, only tracked on quotes
		// (j.jones 2012-01-17 14:46) - PLID 47537 - now this is tracked on bills as well, though it is saved differently later
		long nEMRChargeID = -1;
		if (ExternalType == EXT_EMR) {
			nEMRChargeID = ExternalID;
		}

		// (j.jones 2008-06-24 10:42) - PLID 30457 - added AppointmentID
		long nAppointmentID = -1;
		if (ExternalType == EXT_APPOINTMENT) {
			nAppointmentID = ExternalID;
		}

		// (z.manning 2014-11-11 14:41) - PLID 34832 - Need to include modifiers for EMR charges
		CString strModifier1, strModifier2, strModifier3, strModifier4;
		double dblMultiplier1 = 1.0, dblMultiplier2 = 1.0, dblMultiplier3 = 1.0, dblMultiplier4 = 1.0;
		// (s.tullis 2015-04-02 13:52) - PLID 64978 - Support EMR charges categories show hide
		if (ExternalType == EXT_EMR) {
			varCategoryID = AdoFldLong(m_rsBill, "Category", -1);
			varCategoryCount = AdoFldLong(m_rsBill, "CategoryCount", 0);
			strModifier1 = AdoFldString(m_rsBill, "CPTModifier1", "");
			strModifier2 = AdoFldString(m_rsBill, "CPTModifier2", "");
			strModifier3 = AdoFldString(m_rsBill, "CPTModifier3", "");
			strModifier4 = AdoFldString(m_rsBill, "CPTModifier4", "");
			dblMultiplier1 = AdoFldDouble(m_rsBill, "Multiplier1", 1.0);
			dblMultiplier2 = AdoFldDouble(m_rsBill, "Multiplier2", 1.0);
			dblMultiplier3 = AdoFldDouble(m_rsBill, "Multiplier3", 1.0);
			dblMultiplier4 = AdoFldDouble(m_rsBill, "Multiplier4", 1.0);
		}

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->ChargeID = (long)-2;
				m_billingItems[i]->Quantity = (double)dblQuantity;
				m_billingItems[i]->PackageQtyRemaining = (double)dblQuantity;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
				m_billingItems[i]->OriginalPackageQtyRemaining = (double)dblQuantity;
				m_billingItems[i]->ServiceID = (long)nProductID;
				m_billingItems[i]->CPTCode = _bstr_t(strCPTCode);
				m_billingItems[i]->CPTSubCode = _bstr_t("0");
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
				m_billingItems[i]->CPTCategoryID = varCategoryID;
				// (s.tullis 2015-04-02 13:54) - PLID 64975 
				m_billingItems[i]->CPTCategoryCount = varCategoryCount;
				m_billingItems[i]->Description = _bstr_t(strDescription);
				m_billingItems[i]->UnitCost = cyUnitCost;
				m_billingItems[i]->OthrUnitCost = cyOthrUnit;
				// (j.gruber 2009-03-06 10:51) - PLID 33351 - take out existing discount fields
				m_billingItems[i]->DiscountList = pDiscountList;
				m_billingItems[i]->TotalDiscount = cyTotalLineDiscount;
				//m_billingItems[i]->PercentOff = (long)nPercentOff;
				// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes
				// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
				m_billingItems[i]->Calls = (double)0.0;
				// (d.singleton 2012-05-21 12:31) - PLID 48152 added skill alberta only
				m_billingItems[i]->Skill = (LPCTSTR)"";

				// (z.manning 2014-11-11 14:43) - PLID 34832 - Handle modifiers
				if (!strModifier1.IsEmpty()) {
					m_billingItems[i]->Modifier1 = _bstr_t(strModifier1);
					m_billingItems[i]->Multiplier1 = (double)dblMultiplier1;
				}
				if (!strModifier2.IsEmpty()) {
					m_billingItems[i]->Modifier2 = _bstr_t(strModifier2);
					m_billingItems[i]->Multiplier2 = (double)dblMultiplier2;
				}
				if (!strModifier3.IsEmpty()) {
					m_billingItems[i]->Modifier3 = _bstr_t(strModifier3);
					m_billingItems[i]->Multiplier3 = (double)dblMultiplier3;
				}
				if (!strModifier4.IsEmpty()) {
					m_billingItems[i]->Modifier4 = _bstr_t(strModifier4);
					m_billingItems[i]->Multiplier4 = (double)dblMultiplier4;
				}

				// (d.singleton 2012-03-07 17:38) - PLID 49100 new column
				m_billingItems[i]->ValidationStatus = g_cvarNull;

				// (d.singleton 2012-03-22 16:36) - PLID 49136 notes column
				m_billingItems[i]->Notes = _variant_t((long)m_hIconNotes);

				// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
				m_billingItems[i]->IsEmergency = (long)cietUseDefault;
				// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields

				// (j.jones 2013-04-12 14:54) - PLID 56250 - load allowables for products
				LoadAllowableColumn(m_billingItems[i], FALSE);

				// (j.dinatale 2012-06-13 13:34) - PLID 50959 - NDC defaults values
				if (iNewRow >= 0) {

					//bills only
					if (m_EntryType == 1) {
						// (j.dinatale 2012-06-15 10:51) - PLID 51000 - Added claim notes to inventory items
						CString strClaimNote = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_CLAIM_NOTE), "");
						strClaimNote.TrimLeft(); strClaimNote.TrimRight();
						if (strClaimNote.GetLength() > 0) {
							AddNewUnsavedChargeNote(m_billingItems[i], strClaimNote, TRUE);
						}

						CString strNDCCode = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFCODE), "");
						double dblNDCQty = VarDouble(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFQTY), 0.0);
						COleCurrency cyNDCUnitPrice = VarCurrency(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
						CString strNDCUnitType = VarString(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_NDCDEFUNITTYPE), "");

						m_billingItems[i]->NDCCode = strNDCCode;
						m_billingItems[i]->DrugUnitPrice = cyNDCUnitPrice;
						m_billingItems[i]->DrugUnitType = strNDCUnitType;
						m_billingItems[i]->DrugUnitQuantity = dblNDCQty;
					}

					//the remaining features are for bills and quotes

					// (j.jones 2016-04-07 13:16) - NX-100077 - added RememberChargeProvider setting
					bool bRememberChargeProvider = VarBool(m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_REMEMBER_CHARGE_PROVIDER), FALSE) ? true : false;
					if (bRememberChargeProvider) {
						//this function will auto-update the provider to the last one who sold
						//the patient this product, if a prior sale exists
						UpdateChargeToMostRecentProviderSold(m_billingItems[i]);
					}
				}

				m_billingItems[i]->PrescriptionNumber = (LPCTSTR)"";

				// (j.dinatale 2012-05-09 17:54) - PLID 50135 - provider for an optical order is going to be the claim provider on the bill
				m_billingItems[i]->ClaimProvider = nClaimProviderID;

				// (j.jones 2008-06-04 15:03) - PLID 30256 - added EMRChargeID
				m_billingItems[i]->EMRChargeID = (long)nEMRChargeID;
				// (j.jones 2008-06-24 10:42) - PLID 30457 - added AppointmentID
				m_billingItems[i]->AppointmentID = (long)nAppointmentID;
				//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
				m_billingItems[i]->GlassesOrderServiceID = (long)nGlassesOrderServiceID;
				// (a.wetta 2007-05-08 10:39) - PLID 25959 - Also set the discount
				//m_billingItems[i]->Discount = cyDiscount;
				m_billingItems[i]->TaxRate1 = (double)dblTax1;
				m_billingItems[i]->TaxRate2 = (double)dblTax2;
				m_billingItems[i]->LineTotal = cyTotal;
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				m_billingItems[i]->ItemType = (long)ITEM_TYPE_PRODUCT;
				m_billingItems[i]->Batched.vt = VT_BOOL;
				m_billingItems[i]->Batched.boolVal = TRUE;
				m_billingItems[i]->ChargedProductItemListID = nChargedProductItemListID;
				m_billingItems[i]->ChargedAllocationDetailListID = nChargedAllocationDetailListID;
				// (a.walling 2007-05-30 13:40) - PLID 26172 - Save the points used			
				m_billingItems[i]->PointsUsed = bUsingPoints ? cyPointsUsed : COleCurrency(0, 0);
				// (j.gruber 2014-02-19 13:00) - PLID 60878
				m_billingItems[i]->whichCodes = pWhichCodes;

				// (j.jones 2014-05-01 08:36) - PLID 61837 - the new charge may
				// potentially show additional provider columns
				if (m_EntryType == 1) {
					TryShowChargeProviderColumns(m_billingItems[i], true);
				}
			}
		}

		long TaxType = GetInsuranceCoTaxType(nInsuredPartyID);

		// (j.dinatale 2012-04-16 11:33) - PLID 49690 - added handling for the optical orders, these orders have a vision and pat resp defined 
		//	for each charge
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {

				//find the item in the list
				RPCList *list = m_billingItems[i]->RPCList;

				if (ExternalType != EXT_GLASSES_ORDER){
					//DRT 6/30/03 - For the same reason as the quotes (6/16/03 note), this does
					//		not need to be added for patient resp, only insurance resp!
					if (nInsuredPartyID > 0) {

						bool bFoundResp = false;
						// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
						int j = 0;
						for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
							if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
								bFoundResp = true;
						}

						if (bFoundResp) {
							//at this point, var is the amount before tax, and varTotal is the amount with tax
							//use the insurance TaxType to determine which responsibility gets which amount
							if (TaxType == 1)
								UpdateListInsAmount(list, j, varTotal);
							else
								//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
								UpdateListInsAmount(list, j, var);
						}
						else {
							//we're looking at insurance, but there's nothing in our list!  we
							//need to add it
							RespPerCharge rpc;
							rpc.InsuredPartyID = nInsuredPartyID;

							if (TaxType == 1)
								rpc.InsAmount = varTotal;
							else
								//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
								rpc.InsAmount = var;

							// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
							rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
							rpc.RespTypeName = GetCurrentBillToRespTypeName();

						list->aryRPC.Add(rpc);
					}
				}
			}else{
				// (j.dinatale 2012-04-25 11:01) - PLID 49690 - can optimize this so we dont keep checking for primary vision
				// (j.dinatale 2012-06-05 11:14) - PLID 49713 - now passing in an insured party ID that would should use
				if(nExtInsuredPartyID > 0){
						// grab the vision resp amount for this service, and the primary vision insurance
						_RecordsetPtr rsRespAmounts = CreateParamRecordset(
							"SELECT VisionRespAmt FROM GlassesOrderServiceT WHERE ID = {INT}; ", ExternalID);

						if (!rsRespAmounts->eof){
							// if we were able to retrieve the vision resp amount...
							COleCurrency cyVisionResp = AdoFldCurrency(rsRespAmounts, "VisionRespAmt", g_ccyZero);

							if (cyVisionResp != g_ccyZero){
								// and that amount is not zero...
								RespPerCharge rpc;
								rpc.InsuredPartyID = nExtInsuredPartyID;
								rpc.InsAmount = _variant_t(cyVisionResp);
								rpc.InsuranceCoName = strInsCoName;
								rpc.RespTypeName = strRespTypeName;

								list->aryRPC.Add(rpc);
							}
						}
					}
				}
			}
		}

		m_varBoundItem = (long)iLineID;


		// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
		CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

		////////////////////////////////////////////////////
		if (m_EntryType == 1)
			FillBillList();
		else
			FillQuoteList();

		// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
		// use the row instead of the LineID
		// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
		IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
		InsertRowSorted(pRowToSort, cyTotal);

		// (j.jones 2010-09-03 08:50) - PLID 38319 - reset the last resp. selected
		if (bSwitchedResponsibilitySel) {
			if (nOldRespType == -1) {
				//there was no resp type, so select the blank row
				m_listBillTo->PutCurSel(-1);
			}
			else {
				m_listBillTo->SetSelByColumn(btcID, nOldRespType);
			}
			PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
		}

	}NxCatchAll("Error in AddNewExternalProduct");

	EnableBillingScreen();

	////////////////////////////////////////////////////
	// Recalculate the bill total
	CalculateTotal();

	return TRUE;
}

long CBillingDlg::NewChargedProductItemListID() {

	long Max = -1;
	if (m_aryChargedProductItems.GetSize() == 0)
		return 1;
	else {
		for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
			long ID = m_aryChargedProductItems.GetAt(i)->ID;
			if (ID > Max)
				Max = ID;
		}
		Max++;
		return Max;
	}
}

void CBillingDlg::AddToChargedProductItemsArray(long ChargeID, long ChargedProductItemListID, CDWordArray &adwProductItemIDs) {

	try {

		//initialize the CPI list
		ChargedProductItemList *newCPI;

		BOOL bFound = FALSE;

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < m_aryChargedProductItems.GetSize() && !bFound; i++) {
			if (m_aryChargedProductItems.GetAt(i)->ID == ChargedProductItemListID) {
				bFound = TRUE;
				newCPI = m_aryChargedProductItems.GetAt(i);
			}
		}

		if (!bFound) {
			newCPI = new (ChargedProductItemList);
			newCPI->ChargeID = ChargeID;
			newCPI->ID = ChargedProductItemListID;
		}

		//now add the product items
		for (i = 0; i < adwProductItemIDs.GetSize(); i++) {
			ProductItems *newProdItem = new (ProductItems);
			newProdItem->ProductItemID = (long)adwProductItemIDs.GetAt(i);
			newProdItem->SaveStatus = CPI_SAVENEW;
			newCPI->ProductItemAry.Add(newProdItem);
		}

		if (!bFound)
			m_aryChargedProductItems.Add(newCPI);

	}NxCatchAll("Error linking selected products to the charge.");
}

long CBillingDlg::LoadIntoChargedProductItemsArray(long ChargeID) {

	try {

		long ChargedProductItemListID = -1;

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rs = CreateParamRecordset("SELECT ProductItemID FROM ChargedProductItemsT WHERE ChargeID = {INT}", ChargeID);

		if (!rs->eof) {

			//initialize the CPI list
			ChargedProductItemList *newCPI = new (ChargedProductItemList);
			newCPI->ChargeID = ChargeID;
			ChargedProductItemListID = NewChargedProductItemListID();
			newCPI->ID = ChargedProductItemListID;

			//now add the product items
			while (!rs->eof) {
				long ProductItemID = AdoFldLong(rs, "ProductItemID");
				ProductItems *newProdItem = new (ProductItems);
				newProdItem->ProductItemID = ProductItemID;
				newProdItem->SaveStatus = CPI_NONE;
				newCPI->ProductItemAry.Add(newProdItem);

				rs->MoveNext();
			}

			m_aryChargedProductItems.Add(newCPI);
		}
		rs->Close();

		return ChargedProductItemListID;

	}NxCatchAll("Error loading products associated with a charge.");

	return -1;
}

void CBillingDlg::DeleteOneFromChargedProductItemsArray(long ChargedProductItemListID) {

	try {

		for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
			ChargedProductItemList *delCPI = m_aryChargedProductItems.GetAt(i);
			if (delCPI->ID == ChargedProductItemListID) {

				for (int q = delCPI->ProductItemAry.GetSize() - 1; q >= 0; q--) {
					delete delCPI->ProductItemAry.GetAt(q);
				}

				delCPI->ProductItemAry.RemoveAll();

				delete delCPI;
				m_aryChargedProductItems.RemoveAt(i);

				break;
			}
		}

	}NxCatchAll("Error removing linked product from the charge.");
}

void CBillingDlg::DeleteAllFromChargedProductItemsArray() {

	try {

		for (int i = m_aryChargedProductItems.GetSize() - 1; i >= 0; i--) {
			ChargedProductItemList *delCPI = m_aryChargedProductItems.GetAt(i);

			for (int q = delCPI->ProductItemAry.GetSize() - 1; q >= 0; q--) {
				delete delCPI->ProductItemAry.GetAt(q);
			}
			delCPI->ProductItemAry.RemoveAll();

			delete delCPI;
			m_aryChargedProductItems.RemoveAt(i);
		}

	}NxCatchAll("Error removing linked products from the charge.");
}

void CBillingDlg::SaveChargedProductItemsArray(long ChargeID, long ChargedProductItemListID) {

	//NOTE: this function is called within a transaction, so do not have a try/catch here
	//and do not have a messagebox!	

	for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
		ChargedProductItemList *cpiList = (ChargedProductItemList*)m_aryChargedProductItems.GetAt(i);
		if (cpiList->ID == ChargedProductItemListID) {
			//found it, now save

			for (int j = 0; j < cpiList->ProductItemAry.GetSize(); j++) {
				ProductItems *prodItem = cpiList->ProductItemAry.GetAt(j);
				if (prodItem->SaveStatus == CPI_SAVENEW) {
					//save this item - always an insert
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("INSERT INTO ChargedProductItemsT (ChargeID,ProductItemID) VALUES ({INT},{INT})", ChargeID, prodItem->ProductItemID);

					//TES 6/23/2008 - PLID 26152 - Now that this product has been billed, it shouldn't be flagged as 
					// To Be Returned any more.
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("UPDATE ProductItemsT SET ToBeReturned = 0 WHERE ID = {INT}", prodItem->ProductItemID);

					//update so we don't try to save it twice
					prodItem->SaveStatus = CPI_NONE;

					//Audit
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT ServiceT.Name + ' (' + (CASE WHEN HasSerialNum = 1 THEN (CASE WHEN SerialNum IS NULL THEN '' ELSE SerialNum END) ELSE '' END) + "
						"(CASE WHEN HasSerialNum = 1 AND HasExpDate = 1 THEN ' - ' ELSE '' END) + (CASE WHEN HasExpDate = 1 THEN (CASE WHEN ExpDate IS NULL THEN '' ELSE Convert(nvarchar,ExpDate,1) END)  ELSE '' END) + ')' AS Name "
						"FROM ProductItemsT INNER JOIN ServiceT ON ProductItemsT.ProductID = ServiceT.ID INNER JOIN ProductT ON ServiceT.ID = ProductT.ID WHERE ProductItemsT.ID = {INT}", prodItem->ProductItemID);
					if (!rs->eof) {
						_variant_t var = rs->Fields->Item["Name"]->Value;
						if (var.vt == VT_BSTR) {
							long AuditID = BeginNewAuditEvent();
							AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiAddChargeProductItem, ChargeID, "", CString(var.bstrVal), aepMedium, aetCreated);
						}
					}
				}
				else if (prodItem->SaveStatus == CPI_DELETE) {
					//delete this item

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					ExecuteParamSql("DELETE FROM ChargedProductItemsT WHERE ChargeID = {INT} AND ProductItemID = {INT}", ChargeID, prodItem->ProductItemID);

					//Audit
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT ServiceT.Name + ' (' + (CASE WHEN HasSerialNum = 1 THEN (CASE WHEN SerialNum IS NULL THEN '' ELSE SerialNum END) ELSE '' END) + "
						"(CASE WHEN HasSerialNum = 1 AND HasExpDate = 1 THEN ' - ' ELSE '' END) + (CASE WHEN HasExpDate = 1 THEN (CASE WHEN ExpDate IS NULL THEN '' ELSE Convert(nvarchar,ExpDate,1) END)  ELSE '' END) + ')' AS Name "
						"FROM ProductItemsT INNER JOIN ServiceT ON ProductItemsT.ProductID = ServiceT.ID INNER JOIN ProductT ON ServiceT.ID = ProductT.ID WHERE ProductItemsT.ID = {INT}", prodItem->ProductItemID);
					if (!rs->eof) {
						_variant_t var = rs->Fields->Item["Name"]->Value;
						long AuditID = BeginNewAuditEvent();
						AuditEvent(m_nPatientID, GetBillPatientName(), AuditID, aeiDeleteChargeProductItem, ChargeID, CString(var.bstrVal), "", aepMedium, aetDeleted);
					}
				}
				else if (prodItem->SaveStatus == CPI_NONE) {
					//do nothing, this item doesn't need to be saved or deleted
				}
			}

			//now, if we deleted any, remove from the list
			for (int q = cpiList->ProductItemAry.GetSize() - 1; q >= 0; q--) {
				ProductItems *prodItem = cpiList->ProductItemAry.GetAt(q);
				if (prodItem->SaveStatus == CPI_DELETE) {
					delete cpiList->ProductItemAry.GetAt(q);
					cpiList->ProductItemAry.RemoveAt(q);
				}
			}

			//last, update the charge ID to use the new charge ID
			cpiList->ChargeID = ChargeID;
		}


	}
}

CString CBillingDlg::GetProductItemWhereClause() {

	//returns a query of AND statements so unsaved assigned ProductItems aren't in the list

	try {

		CString strWhere = "";

		for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
			ChargedProductItemList *CPIlist = m_aryChargedProductItems.GetAt(i);

			for (int j = 0; j < CPIlist->ProductItemAry.GetSize(); j++) {
				CString str;
				if (CPIlist->ProductItemAry.GetAt(j)->SaveStatus != CPI_DELETE) {
					str.Format("ProductItemsT.ID <> %li", CPIlist->ProductItemAry.GetAt(j)->ProductItemID);
					strWhere += str + " AND ";
				}
			}
		}

		strWhere.TrimRight("AND ");

		return strWhere;

	}NxCatchAll("Error determining list of unsaved products.");

	return "";
}

BOOL CBillingDlg::ChangeProductItems(double &dblQuantity) {

	//we're editing the serialized item list for the charge

	try {

		IRowSettingsPtr pCurSel = m_pList->GetCurSel();
		if (pCurSel == NULL)
			return FALSE;

		long ChargeID = -2;
		long ChargedProductItemListID = -1;
		long ProductID = -1;
		long nChargedAllocationDetailListID = -1;

		long LineID = pCurSel->GetValue(0).lVal;
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == LineID) {
				ChargeID = m_billingItems[i]->ChargeID.lVal;
				ChargedProductItemListID = m_billingItems[i]->ChargedProductItemListID.lVal;
				ProductID = m_billingItems[i]->ServiceID.lVal;
				nChargedAllocationDetailListID = VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1);
				break;
			}
		}

		// (j.jones 2007-12-14 11:20) - PLID 27988 - if this charge has product items and they are also allocated items,
		// disallow the change and tell them this is not permitted
		if (nChargedAllocationDetailListID != -1) {
			CString strWarn;
			if (ChargeID == -2) { //new charge
				strWarn = "This charge is associated with an allocation, and its serialized items cannot be changed.\n"
					"You must delete and re-add this charge if you wish to change the items it is using.";
			}
			else {
				//If it's an existing charge, let them know in advance that if they do delete it,
				//they have to save the changes for the allocation and product items to be made
				//available again. Following TPOLT ("Tom's Principle Of Least Taunting"), we
				//should warn them of this requirement.
				strWarn = "This charge is associated with an allocation, and its serialized items cannot be changed.\n"
					"You must delete and re-add this charge if you wish to change the items it is using.\n\n"
					"If you intend to re-use a portion of the same allocation or serialized items, you must save the bill\n"
					"in order to release the items from the deleted charge.";
			}
			AfxMessageBox(strWarn);
			return FALSE;
		}

		long LocationID = -1;

		if (m_LocationCombo->GetCurSel() == -1)
			LocationID = GetCurrentLocationID();
		else
			LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

		//first loop up until the ChargedProductItem list in question
		for (int j = 0; j < m_aryChargedProductItems.GetSize(); j++) {
			ChargedProductItemList *CPIlist = m_aryChargedProductItems.GetAt(j);
			if (CPIlist->ID == ChargedProductItemListID) {

				CProductItemsDlg dlg(this);
				dlg.m_EntryType = PI_SELECT_DATA;
				dlg.m_ProductID = ProductID;
				dlg.m_nLocationID = LocationID;
				dlg.m_CountOfItemsNeeded = (long)dblQuantity;
				dlg.m_strWhere = GetProductItemWhereClause();
				//fill in the existing values
				for (int z = 0; z < CPIlist->ProductItemAry.GetSize(); z++) {
					long ProductItemID = CPIlist->ProductItemAry.GetAt(z)->ProductItemID;
					if (CPIlist->ProductItemAry.GetAt(z)->SaveStatus != CPI_DELETE)
						dlg.m_adwProductItemIDs.Add(ProductItemID);
				}

				if (dlg.DoModal() != IDCANCEL) {
					//in this case, they can cancel, and we only make changes if they did not

					dblQuantity = dlg.m_CountOfItemsNeeded;

					//now loop through each item and see if we removed anything
					for (int i = 0; i < CPIlist->ProductItemAry.GetSize(); i++) {
						long ProductItemID = CPIlist->ProductItemAry.GetAt(i)->ProductItemID;
						BOOL bFound = FALSE;
						for (int x = 0; x < dlg.m_adwProductItemIDs.GetSize(); x++) {
							if (ProductItemID == (long)dlg.m_adwProductItemIDs.GetAt(x)) {
								bFound = TRUE;
								break;
							}
						}
						if (!bFound)
							CPIlist->ProductItemAry.GetAt(i)->SaveStatus = CPI_DELETE;
					}

					//now loop to see if we added anything
					//now loop through each item and compare
					for (int q = 0; q < dlg.m_adwProductItemIDs.GetSize(); q++) {
						long ProductItemID = (long)dlg.m_adwProductItemIDs.GetAt(q);
						BOOL bFound = FALSE;
						for (int x = 0; x < CPIlist->ProductItemAry.GetSize(); x++) {
							if (ProductItemID == CPIlist->ProductItemAry.GetAt(x)->ProductItemID) {
								bFound = TRUE;
								break;
							}
						}
						if (!bFound) {
							//add the item new
							ProductItems *newProdItem = new (ProductItems);
							newProdItem->ProductItemID = ProductItemID;
							newProdItem->SaveStatus = CPI_SAVENEW;
							CPIlist->ProductItemAry.Add(newProdItem);
						}
					}

					//make sure this charge gets saved
					if (ChargeID != -2)
						AddToModifiedList(ChargeID);

					return TRUE;
				}
				else
					return FALSE;
			}
		}

	}NxCatchAll("Error changing the products attached to the selected charge.");

	return FALSE;
}

void CBillingDlg::OnRequeryFinishedComboSrgy(short nFlags)
{

}

// (z.manning 2008-09-30 17:27) - PLID 31126 - Now returns a BillingItem pointer
//TES 10/21/2008 - PLID 21432 - Added a nDefaultProviderID parameter, will override any other settings.
// (j.gruber 2014-02-19 13:02) - PLID 60878 - changed WhichCodes parameter
// (r.farnworth 2014-12-11 11:07) - PLID 64163 - Added cyAmount paramater
// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
BillingItemPtr CBillingDlg::AddNewChargeToBill(long nServiceID, COleCurrency cyAmount /*= g_ccyInvalid*/, double dblQuantity /*= -1.0*/, CChargeWhichCodesMapPtr pWhichCodes /*= NULL*/,
	const CString &strMod1 /*= ""*/, const CString &strMod2 /*= ""*/, const CString &strMod3 /*= ""*/, const CString &strMod4 /*= ""*/,
	COleDateTime *pdtService /*= NULL*/, long nDefaultProviderID /*= -1*/, BOOL bHL7Bill /*= FALSE */, long nOrdProvider /*= -1*/)
{
	BillingItemPtr pNew;

	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return BillingItemPtr();
	}

	//DRT 5/6/03 - Used primarily to add charges to a bill when you are not inside the BillingDialog itself
	//		(like being in the BillingModuleDlg).  This function just simulates the activity of dropping 
	//		down the list, clicking a row, and having it be entered.

	// (j.jones 2008-05-02 09:25) - PLID 27685 - ensure that the CPT list has been requeried
	// prior to trying to search the list
	if (m_bCPTCombo == FALSE) {
		//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
		m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
		m_CPTCombo->Requery();
		m_bCPTCombo = TRUE;
	}

	//TES 7/15/2008 - PLID 27983 - First, check whether we should pull in linked products for this charge.
	if (m_EntryType == 1) {
		//TES 7/17/2008 - PLID 27983 - Pass in false for bMassAdding, this charge is being added individually.
		if (CheckLinkProducts(nServiceID, dblQuantity, false, NULL, -1, -1, FALSE)) {
			//TES 7/15/2008 - PLID 27983 - If CheckLinkProducts() returns TRUE, that means it already added linked products
			// to the bill in lieu of this item.
			return BillingItemPtr();
		}
	}

	//find the service id
	// (j.jones 2008-12-15 15:07) - PLID 32431 - changed this code to call FindCPTRowInComboByServiceID,
	// which will force finding the service, incase the combo is still requerying
	//int nRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, FALSE);
	int nRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);

	if (nRow < 0) {
		//unfound
		MsgBox("This item was not able to be added to the bill.  Ensure the item still exists and is not inactivated or deleted.");
		return BillingItemPtr();
	}
	//Found it, let's get adding.
	try {

		m_CPTCombo->PutCurSel(nRow);

		//TES 7/16/2008 - PLID 27983 - Check if this code is linked to products.
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		if (ReturnsRecordsParam("SELECT CptID FROM ServiceToProductLinkT WHERE CptID = {INT}", nServiceID)) {
			if (m_EntryType == 2) {
				//TES 7/16/2008 - PLID 27983 - Let the user know that this is a placeholder, and what that means.
				DontShowMeAgain(this, "This Service Code is linked to products.  When this quote is billed, you will be prompted to choose which of "
					"the products linked to this service to add to the bill.  This Service Code itself will never be added to a bill.", "QuoteLinkedCpt");
			}
			else {
				//TES 7/16/2008 - PLID 27983 - It should never be possible to add a "placeholder" service code to a bill.
				ASSERT(FALSE);
				MsgBox("The Service Code you selected is linked to products, and cannot be billed directly.");
				return BillingItemPtr();
			}
		}

		CString strCPTCode, strCPTSubCode, strDescription, strTypeOfService, strSQL;
		COleCurrency cyUnitCost;
		COleVariant var;
		double dblTax1, dblTax2;
		_variant_t v;


		if (GetRemotePropertyInt("ChargeAllowQtyIncrement", 0, 0, "<None>", TRUE) == 1) {

			// (j.jones 2008-06-11 12:21) - PLID 28379 - CheckIncreaseDuplicateChargeQuantity now returns a BillingItem pointer,
			// but we do not use it for any purpose other than to check for success
			BillingItemPtr pLineItem = CheckIncreaseDuplicateChargeQuantity(nServiceID, FALSE, dblQuantity == -1.0 ? 1.0 : dblQuantity);
			if (pLineItem) {
				return BillingItemPtr();
			}
		}

		//DRT 5/6/03 - When adding a cpt code, if they have chosen an ins. auth number, we
		//		need to make sure this warns them if the code we just chose doesn't fit into
		//		that auth.
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {
			long nAuthID = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID;

			// (j.jones 2008-05-01 11:59) - PLID 28606 - don't warn if there are no services
			// on the referral, so instead let's just see if the linked referral has services,
			// but just not ours
			_RecordsetPtr rsReferralCheck = CreateParamRecordset("SELECT "
				"Count(ServiceID) AS TotalServices, "
				"Sum(CASE WHEN ServiceID = {INT} THEN 1 ELSE 0 END) AS CountOfOurService "
				"FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", nServiceID, nAuthID);
			if (!rsReferralCheck->eof) {

				long nTotalServices = AdoFldLong(rsReferralCheck, "TotalServices", 0);
				long nCountOfOurService = AdoFldLong(rsReferralCheck, "CountOfOurService", 0);

				if (nTotalServices > 0 && nCountOfOurService == 0) {

					//the referral has services, but does not have this one, so warn					

					if (MsgBox(MB_YESNO, "The chosen Service Code does not exist in your chosen insurance authorization.  Are you sure you wish to select this code?") == IDNO) {
						return BillingItemPtr();
					}
				}
			}
			rsReferralCheck->Close();
		}

		// (j.jones 2004-07-07 16:59) - if the current ins. resp. is set to allow 1/10th rounding, do so!
		long InsID = -1;
		// (d.lange 2015-12-01 10:49) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
		InsID = GetCurrentBillToMostPriInsCoIDForCategory();
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		BOOL bRoundUp = !ReturnsRecordsParam("SELECT PersonID FROM InsuranceCoT WHERE AnesthesiaSetting = 1 AND PersonID = {INT}", InsID);

		//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
		if (IsCodeSelectedBasedOnWarning(nServiceID) == FALSE)
		{
			return BillingItemPtr();
		}
		else
		{
			// Nothing
		}
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized

		/*_RecordsetPtr rsNote = CreateParamRecordset("SELECT Notes FROM CptInsNotesT WHERE CptCodeID = {INT} AND InsuranceCoID = {INT}", nServiceID, InsID);
		if (!rsNote->eof) {
			CString strNote = AdoFldString(rsNote, "Notes", "");
			if (!strNote.IsEmpty()) {
				if (MsgBox(MB_YESNO, "This Service Code/Insurance Company combination has the following warning:\r\n\r\n%s\r\n\r\nAre you sure you wish to select this code?", strNote) == IDNO)
					return BillingItemPtr();
			}
		}
		rsNote->Close();*/

		// (j.jones 2006-04-25 16:37) - we cached the Anesthesia, UseAnesthesiaBilling, FacilityFee, and UseFacilityBilling
		// values, so don't check for these if we already know it's irrelevant

		BOOL bCPTCodeCachedInfoLoaded = FALSE;
		BOOL bIsAnesthesia = FALSE;
		BOOL bUseAnesthesia = FALSE;
		BOOL bIsFacilityFee = FALSE;
		BOOL bUseFacilityFee = FALSE;
		BOOL bIsAssistingCode = FALSE;

		// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
		BOOL bOHIPPremiumCode = FALSE;

		// (j.jones 2008-12-15 15:07) - PLID 32431 - changed this code to call FindCPTRowInComboByServiceID,
		// which will force finding the service, incase the combo is still requerying
		//int iCPTRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, FALSE);
		int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);
		if (iCPTRow >= 0) {
			bIsAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ANESTHESIA), FALSE);
			bUseAnesthesia = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_ANESTH_BILLING), FALSE);
			bIsFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_FACILITY_FEE), FALSE);
			bUseFacilityFee = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_USE_FACILITY_BILLING), FALSE);

			// (j.jones 2009-03-31 11:01) - PLID 33747 - cache the OHIP Premium Code setting
			bOHIPPremiumCode = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_OHIP_PREMIUM_CODE), FALSE);

			// (j.jones 2010-11-23 08:52) - PLID 39602 - cache the AssistingCode value
			bIsAssistingCode = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_ASSISTING_CODE), FALSE);

			//means we can safely use the booleans
			bCPTCodeCachedInfoLoaded = TRUE;
		}

		BOOL bAnesthesia = FALSE;
		COleCurrency cyAnesthUnitCost = COleCurrency(0, 0);
		double dblAnesthUnits = 0.0;

		if (m_PlaceOfServiceCombo->CurSel == -1)
			m_PlaceOfServiceCombo->CurSel = 0;
		long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

		// (j.jones 2009-03-31 10:39) - PLID 33747 - if a CPT code, check if it is an OHIP Premium Code
		//bCPTCodeCachedInfoLoaded would be FALSE if the service ID was not a CPT Code
		if (bCPTCodeCachedInfoLoaded && UseOHIP() && bOHIPPremiumCode) {
			//the flat fee option will use the standard fee, not the fee from whatever object added this charge
			if (ProcessOHIPPremiumCode(nServiceID)) {
				//if the above function returns true, we will not add this charge in this function
				return BillingItemPtr();
			}
		}

		//pre-fill the start/end times, and minutes, with info from the Billing2 dlg
		long nAnesthMinutes = GetAnesthMinutes();
		CString strStartTime = GetAnesthStartTime();
		CString strEndTime = GetAnesthEndTime();

		// (j.jones 2004-07-07 12:09) - checks to see if this is an anesthesia code and loads the associated info.
		if (!bCPTCodeCachedInfoLoaded || bUseAnesthesia) {
			if (!CheckAnesthesia(nServiceID, bAnesthesia, cyAnesthUnitCost, dblAnesthUnits, nAnesthMinutes, strStartTime, strEndTime, nPlaceOfServiceID, bRoundUp))
				return BillingItemPtr();
		}

		if (bAnesthesia) {
			//set the times on the Billing2 dlg
			SetAnesthMinutes(nAnesthMinutes);
			SetAnesthStartTime(strStartTime);
			SetAnesthEndTime(strEndTime);

			dblQuantity = dblAnesthUnits;
		}

		long nFacilityMinutes = GetFacilityMinutes();
		strStartTime = GetFacilityStartTime();
		strEndTime = GetFacilityEndTime();

		BOOL bFacilityFee = FALSE;
		COleCurrency cyFacilityUnitCost = COleCurrency(0, 0);
		// (j.jones 2005-07-01 11:31) - checks to see if this is a facility fee code and calculates the right fee
		if (!bCPTCodeCachedInfoLoaded || bUseFacilityFee) {
			if (!CheckFacilityFee(nServiceID, bFacilityFee, cyFacilityUnitCost, nFacilityMinutes, strStartTime, strEndTime, nPlaceOfServiceID)) {
				return BillingItemPtr();
			}
		}

		if (bFacilityFee) {
			//set the times on the Billing2 dlg
			SetFacilityMinutes(nFacilityMinutes);
			SetFacilityStartTime(strStartTime);
			SetFacilityEndTime(strEndTime);
		}

		// (j.jones 2010-11-23 08:58) - PLID 39602 - if OHIP, and not anesthesia, and not a facility fee,
		// check to see if it is an assisting code
		BOOL bAssistingCode = FALSE;
		COleCurrency cyAssistingCodeUnitCost = COleCurrency(0, 0);

		if (!bAnesthesia && !bFacilityFee
			&& UseOHIP()
			&& (!bCPTCodeCachedInfoLoaded || bIsAssistingCode)) {

			// (j.jones 2011-10-31 17:15) - PLID 41558 - we now store this per bill
			long nAssistingMinutes = GetAssistingMinutes();
			CString strAssistingStartTime = GetAssistingStartTime();
			CString strAssistingEndTime = GetAssistingEndTime();

			if (!CheckAssistingCode(nServiceID, bAssistingCode, cyAssistingCodeUnitCost, nAssistingMinutes, strAssistingStartTime, strAssistingEndTime)) {
				return BillingItemPtr();
			}

			if (bAssistingCode) {
				//set the times on the Billing2 dlg
				SetAssistingMinutes(nAssistingMinutes);
				SetAssistingStartTime(strAssistingStartTime);
				SetAssistingEndTime(strAssistingEndTime);
			}
		}

		// (j.gruber 2009-03-06 10:58) - PLID 33351 - take out discount fields
		DiscountList *pDiscountList = new DiscountList;
		COleCurrency cyPointsUsed;
		BOOL bUsingPoints;

		COleCurrency cyRewardDiscountDollars = VarCurrency(m_CPTCombo->GetValue(nRow, CPT_COLUMN_DISCOUNTDOLLARS), COleCurrency(0, 0));
		long nRewardDiscountPercent = VarLong(m_CPTCombo->GetValue(nRow, CPT_COLUMN_DISCOUNTPERCENT), 0);
		COleCurrency cyPointCost = VarCurrency(m_CPTCombo->GetValue(nRow, CPT_COLUMN_POINTCOST), COleCurrency(0, 0));

		LoadDiscountList(TRUE, -1, nServiceID, pDiscountList,
			cyPointCost, cyRewardDiscountDollars, nRewardDiscountPercent,
			bUsingPoints, cyPointsUsed);

		// Add a new charge to the temporary list and
		// set its details to default values

		//TES 10/21/2008 - PLID 21432 - If we were given a default provider ID, then just use it, otherwise check
		// the service code.
		if (nDefaultProviderID == -1) {
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
			_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
				"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
				"FROM ServiceT "
				"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", nServiceID);
			if (!rs->eof) {
				nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
			}
			rs->Close();
		}

		// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
		pNew = AppendChargeToList(nDefaultProviderID, bHL7Bill, nOrdProvider);
		int iLineID = pNew->LineID.lVal;

		// (d.singleton 2012-05-24 16:47) - PLID 50744 added skill code alberta only,  need to load taxonomy code when there is a default provider
		CString strSkillCode = "";
		if (UseAlbertaHLINK()) {
			if (nDefaultProviderID > -1) {
				//get the taxonomy code
				_RecordsetPtr rs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", nDefaultProviderID);
				if (!rs->eof) {
					strSkillCode = AdoFldString(rs, "TaxonomyCode", "");
				}
			}
			else {
				strSkillCode = VarString(pNew->Skill, "");
			}
			if (strSkillCode.GetLength() > 4) {
				strSkillCode = "";
			}
		}



		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_CODE);
		if (v.vt != VT_NULL && v.vt != VT_EMPTY)
			strCPTCode = CString(v.bstrVal);

		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_SUBCODE);
		if (v.vt != VT_NULL && v.vt != VT_EMPTY)
			strCPTSubCode = CString(v.bstrVal);

		// (j.jones 2015-03-18 15:17) - PLID 64974 - Category and SubCategory are now nullable
		_variant_t varCategoryID = g_cvarNull;
		_variant_t varSubCategoryID = g_cvarNull;
		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_CATEGORY);
		if (v.vt == VT_I4 && VarLong(v) > 0) {
			varCategoryID = v;
		}
		// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling category column later
		_variant_t varCategoryCount = (long) 0;
		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_CATEGORY_COUNT);
		if (v.vt == VT_I4 && VarLong(v) > 0) {
			varCategoryCount = v;
		}

		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_NAME);
		if (v.vt != VT_NULL || v.vt == VT_EMPTY)
			strDescription = CString(v.bstrVal);

		// Update description on parent billing module dialog
		CString str;
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDescription);
			}
		}

		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_TOS);
		if (v.vt != VT_NULL)
			strTypeOfService = CString(v.bstrVal);

		if (strTypeOfService.GetLength() == 0)
			strTypeOfService = " ";

		////////////////////////////////////////////////////
		// Get Taxable status

		long TaxType = 2;

		//find the insurance company's taxable status
		long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
		if (nInsuredPartyID > 0)
			TaxType = GetInsuranceCoTaxType(nInsuredPartyID);

		//now load the default taxrate for this CPT code
		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_TAXABLE1);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
			dblTax1 = 1.0;
		}
		else {
			dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
		}

		double dblTaxCalc1 = dblTax1;

		dblTax1 -= 1.0;
		dblTax1 *= 100.0;

		v = m_CPTCombo->GetValue(nRow, CPT_COLUMN_TAXABLE2);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
			dblTax2 = 1.0;
		}
		else {
			dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
		}

		double dblTaxCalc2 = dblTax2;

		dblTax2 -= 1.0;
		dblTax2 *= 100.0;

		if (dblQuantity == -1.0)
			dblQuantity = 1.0;

		try {
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {
					m_billingItems[i]->ChargeID = (long)-2;
					m_billingItems[i]->Quantity = dblQuantity;
					m_billingItems[i]->PackageQtyRemaining = dblQuantity;
					// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
					m_billingItems[i]->OriginalPackageQtyRemaining = (double)dblQuantity;
					m_billingItems[i]->ServiceID = nServiceID;
					m_billingItems[i]->CPTCode = _bstr_t(strCPTCode);
					BillingItemPtr billitem = m_billingItems[i];
					_variant_t var = m_billingItems[i]->CPTCode;
					m_billingItems[i]->CPTSubCode = _bstr_t(strCPTSubCode);
					// (j.jones 2015-03-18 14:24) - PLID 64974 - Category and SubCategory are now nullable
					m_billingItems[i]->CPTCategoryID = varCategoryID;
					m_billingItems[i]->CPTSubCategoryID = varSubCategoryID;
					// (s.tullis 2015-04-07 16:54) - PLID 64975 - Added Category Count for Showing/Hiding/ Disabling the category column later
					m_billingItems[i]->CPTCategoryCount = varCategoryCount;
					m_billingItems[i]->Description = _bstr_t(strDescription);
					m_billingItems[i]->TypeOfService = _bstr_t(strTypeOfService);
					// (j.gruber 2009-03-06 11:00) - PLID 33351 - take out percent fields
					m_billingItems[i]->DiscountList = pDiscountList;
					//m_billingItems[i]->PercentOff = (long)nPercentOff;
					// (a.walling 2007-05-30 13:40) - PLID 26172 - Save the points used
					m_billingItems[i]->PointsUsed = bUsingPoints ? cyPointsUsed : COleCurrency(0, 0);
					// (a.wetta 2007-05-08 10:39) - PLID 25959 - Also set the discount
					//m_billingItems[i]->Discount = cyDiscount;
					m_billingItems[i]->TaxRate1 = (double)dblTax1;
					m_billingItems[i]->TaxRate2 = (double)dblTax2;
					//The default WhichCodes were already set in AppendChargeToList, so only override if we've been asked to.
					// (j.gruber 2014-02-19 13:03) - PLID 60878 - new structure
					if (pWhichCodes != NULL) {
						m_billingItems[i]->whichCodes = pWhichCodes;
					}

					if (strMod1 != "") {
						m_billingItems[i]->Modifier1 = _bstr_t(strMod1);
					}
					if (strMod2 != "") {
						m_billingItems[i]->Modifier2 = _bstr_t(strMod2);
					}
					if (strMod3 != "") {
						m_billingItems[i]->Modifier3 = _bstr_t(strMod3);
					}
					if (strMod4 != "") {
						m_billingItems[i]->Modifier4 = _bstr_t(strMod4);
					}

					// (j.jones 2011-10-25 09:31) - PLID 46088 - added Calls column, Alberta only
					m_billingItems[i]->Calls = (double)0.0;

					// (d.singleton 2012-05-21 12:32) - PLID 48152 added skill column alberta only
					m_billingItems[i]->Skill = _bstr_t(strSkillCode);

					// (d.singleton 2012-03-07 17:38) - PLID 49100 new column
					m_billingItems[i]->ValidationStatus = g_cvarNull;

					// (d.singleton 2012-03-22 16:41) - PLID 49136 notes column
					m_billingItems[i]->Notes = _variant_t((long)m_hIconNotes);

					// (j.jones 2008-05-28 11:28) - PLID 28782 - added NDC Codes
					m_billingItems[i]->NDCCode = g_cvarNull;

					// (j.jones 2010-04-08 11:51) - PLID 15224 - added IsEmergency
					m_billingItems[i]->IsEmergency = (long)cietUseDefault;

					// (j.jones 2009-08-12 18:15) - PLID 35206 - added more drug fields
					m_billingItems[i]->DrugUnitPrice = COleCurrency(0, 0);
					m_billingItems[i]->DrugUnitType = (LPCTSTR)"";
					m_billingItems[i]->DrugUnitQuantity = (double)0.0;
					m_billingItems[i]->PrescriptionNumber = (LPCTSTR)"";

					// (j.jones 2008-06-04 15:08) - PLID 30256 - added EMRChargeID
					m_billingItems[i]->EMRChargeID = g_cvarNull;

					// (j.jones 2008-06-24 10:42) - PLID 30457 - added AppointmentID
					m_billingItems[i]->AppointmentID = g_cvarNull;

					//TES 6/29/2011 - PLID 44192 - Added GlassesOrderServiceID
					m_billingItems[i]->GlassesOrderServiceID = g_cvarNull;

					//Likewise the date.
					if (pdtService) {
						m_billingItems[i]->Date = *pdtService;
						m_billingItems[i]->ServiceDateTo = *pdtService;
					}

					// (j.gruber 2009-10-16 12:02) - PLID 35947 - load the allowable
					LoadAllowableColumn(m_billingItems[i], FALSE);

					if (m_EntryType == 1) {
						// (j.jones 2012-04-12 10:00) - PLID 49609 - Add the default claim note, if it exists.
						CString strClaimNote = VarString(m_CPTCombo->GetValue(nRow, CPT_COLUMN_CLAIM_NOTE), "");
						strClaimNote.TrimLeft(); strClaimNote.TrimRight();
						if (strClaimNote.GetLength() > 0) {
							AddNewUnsavedChargeNote(m_billingItems[i], strClaimNote, TRUE);
						}

						// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
						CString strNDCCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFCODE), "");
						double dblNDCQty = VarDouble(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFQTY), 0.0);
						COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
						CString strNDCUnitType = VarString(m_CPTCombo->GetValue(iCPTRow,CPT_COLUMN_NDCDEFUNITTYPE), "");
						// (r.gonet 07/07/2014) - PLID 62572 - Set the On Hold state if the CPT Code is configured to defalt the charge as on hold
						BOOL bOnHold;
						if (GetBillStatusType() != EBillStatusType::OnHold) {
							bOnHold = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_DEFAULTASONHOLD), FALSE);
						} else {
							// Bills already on hold can't have on hold charges
							bOnHold = FALSE;
						}

						m_billingItems[i]->NDCCode = strNDCCode;
						m_billingItems[i]->DrugUnitPrice = cyNDCUnitPrice;
						m_billingItems[i]->DrugUnitType = strNDCUnitType;
						m_billingItems[i]->DrugUnitQuantity = dblNDCQty;
						// (r.gonet 07/07/2014) - PLID 62569
						m_billingItems[i]->OnHold = bOnHold ? g_cvarTrue : g_cvarFalse;
					}

					// (j.jones 2014-05-01 08:36) - PLID 61837 - the new charge may
					// potentially show additional provider columns
					if (m_EntryType == 1) {
						TryShowChargeProviderColumns(m_billingItems[i], true);
					}
				}
			}
		}
		NxCatchAll("BillingDlg::OnSelectionChangeComboCPT");

		_variant_t varOutsideFee = _variant_t(COleCurrency(0, 0));

		// (r.farnworth 2014-12-11 09:20) - PLID 64163 - If valid currency passed in, use that instead of doing all this
		if (cyAmount.GetStatus() != COleCurrency::invalid) {
			var = cyAmount;
		}
		else {
			if (!bAnesthesia && !bFacilityFee && !bAssistingCode) {
				if (m_EntryType == 1) {
					//////////////////////////////////////////////////////////////////
					// Get the fee from the Multi-Fee Scheduling table. If there is none,
					// set it to the default CPT unit cost.
					// (For a bill only)

					BOOL boMultiFeeExists = FALSE;
					BOOL boWarn = TRUE;
					long InsID = -1;

					// (d.lange 2015-11-20 11:41) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
					InsID = GetCurrentBillToMostPriInsCoIDForCategory();

					long LocationID = -1;

					if (m_LocationCombo->GetCurSel() == -1)
						LocationID = GetCurrentLocationID();
					else
						LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

					// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
					long nPOSID = -1;
					if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
						nPOSID = GetCurrentLocationID();
					}
					else {
						nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
					}

					CString text;

					// (j.jones 2009-08-10 12:56) - PLID 34841 - properly initialized these variables
					BOOL bHasAllowable = FALSE;
					COleCurrency cyAllowable = COleCurrency(0, 0);

					// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
					cyUnitCost = GetMultiFee(nServiceID, nDefaultProviderID != -1 ? nDefaultProviderID : (m_DefaultProvider == -1 ? m_Main_Physician : m_DefaultProvider), InsID, LocationID, nPOSID, pNew->Date, boMultiFeeExists, boWarn, text, bHasAllowable, cyAllowable);

					////////////////////////////

					if (boMultiFeeExists && boWarn && IDNO == MessageBox(text, "NexTech", MB_YESNO)) {
						_RecordsetPtr rsLocal;
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						rsLocal = CreateParamRecordset("SELECT Price FROM CPTCodeT INNER JOIN ServiceT ON CPTCodeT.ID = ServiceT.ID WHERE ServiceT.ID = {INT}", nServiceID);
						if (rsLocal->eof)
							HandleException(NULL, "An error occurred: please be sure this service code still exists",
							__LINE__, __FILE__);
						var = rsLocal->Fields->Item["Price"]->Value;
						cyUnitCost = var;
						rsLocal->Close();
					}

					for (int i = 0; i < (int)m_billingItems.size(); i++) {
						if (m_billingItems[i]->LineID.lVal == iLineID) {

							m_billingItems[i]->UnitAllowable = _variant_t(cyAllowable);

							if (bHasAllowable) {
								m_billingItems[i]->HasAllowable = variant_t(VARIANT_TRUE, VT_BOOL);

								// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is multiplied by quantity & modifiers
								COleCurrency cyAllowableTotal = cyAllowable;

								double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
								dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

								BillingItemPtr pItem = m_billingItems[i];

								if (pItem->Quantity.vt == VT_R8) {
									dblQuantity = VarDouble(pItem->Quantity, 1.0);
								}
								if (pItem->Multiplier1.vt == VT_R8) {
									dblMultiplier1 = VarDouble(pItem->Multiplier1, 1.0);
								}
								if (pItem->Multiplier2.vt == VT_R8) {
									dblMultiplier2 = VarDouble(pItem->Multiplier2, 1.0);
								}
								if (pItem->Multiplier3.vt == VT_R8) {
									dblMultiplier3 = VarDouble(pItem->Multiplier3, 1.0);
								}
								if (pItem->Multiplier4.vt == VT_R8) {
									dblMultiplier4 = VarDouble(pItem->Multiplier4, 1.0);
								}

								cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

								cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
								cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
								cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
								cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

								RoundCurrency(cyAllowableTotal);

								pItem->TotalAllowable = _variant_t(cyAllowableTotal);
							}
							else {
								m_billingItems[i]->HasAllowable = variant_t(VARIANT_FALSE, VT_BOOL);
								// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL for now, calculated later
								m_billingItems[i]->TotalAllowable = g_cvarNull;
							}
						}
					}


					///////////////////////////

					var = cyUnitCost;
				}
				else {
					var = m_CPTCombo->GetValue(nRow, CPT_COLUMN_PRICE);
				}
			}
			else {
				if (bAnesthesia) {
					// (j.jones 2004-07-07 12:39) - use the anesthesia cost

					// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (m_EntryType == 2 && ReturnsRecordsParam("SELECT AnesthOutsideFee FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND AnesthOutsideFee = 1", nServiceID, nPlaceOfServiceID)) {
						var = COleCurrency(0, 0);
						varOutsideFee = cyAnesthUnitCost;
					}
					else {
						var = cyAnesthUnitCost;
						varOutsideFee = COleCurrency(0, 0);
					}
				}
				else if (bFacilityFee) {
					// (j.jones 2005-07-01 13:28) - use the facility cost

					// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (m_EntryType == 2 && ReturnsRecordsParam("SELECT FacilityOutsideFee FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND FacilityOutsideFee = 1", nServiceID, nPlaceOfServiceID)) {
						var = COleCurrency(0, 0);
						varOutsideFee = cyFacilityUnitCost;
					}
					else {
						var = cyFacilityUnitCost;
						varOutsideFee = COleCurrency(0, 0);
					}
				}
				// (j.jones 2010-11-23 09:06) - PLID 39602 - supported assisting codes
				else if (bAssistingCode) {
					var = cyAssistingCodeUnitCost;
					varOutsideFee = COleCurrency(0, 0);
				}
			}
		}

		// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
		// the unit cost based on the modifier we just chose
		if (UseAlbertaHLINK()) {
			for (int i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {
					//fill the totals first in the BillingItem object
					m_billingItems[i]->UnitCost = var;
					m_billingItems[i]->OthrUnitCost = varOutsideFee;

					// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
					// price unless there are modifiers
					UpdateChargePriceWithAlbertaModifiers(m_billingItems[i], FALSE);
					//get the new price, as it could have changed
					var = m_billingItems[i]->UnitCost;
					break;
				}
			}
		}

		_variant_t varTotal, varAmtQty;
		COleCurrency cyTotal, cyTotalTax1, cyTotalTax2;

		//quotes calculate the total as both the fees put together
		if (m_EntryType == 2) {
			cyTotal = VarCurrency(var, COleCurrency(0, 0)) + VarCurrency(varOutsideFee, COleCurrency(0, 0));
		}
		else {
			cyTotal = VarCurrency(var, COleCurrency(0, 0));
		}

		cyTotal = CalculateAmtQuantity(cyTotal, dblQuantity);

		// (j.gruber 2009-03-06 11:20) - PLID 33351 - calculate discounts
		long nPercentOff = 1;
		COleCurrency cyTotalDollarDiscount, cyTotalLineDiscount;

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		CalculateTotalDiscount(pDiscountList, cyTotal, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);

		cyTotal = (cyTotal * (100000 - nPercentOff * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cyTotal = cyTotal / long(100000);

		// (a.wetta 2007-05-08 11:17) - PLID 25959 - Subtract the discount from the total
		cyTotal -= cyTotalDollarDiscount;

		varAmtQty = cyTotal;

		cyTotalTax1 = CalculateTax(cyTotal, dblTaxCalc1);
		cyTotalTax2 = CalculateTax(cyTotal, dblTaxCalc2);

		cyTotal += cyTotalTax1;
		cyTotal += cyTotalTax2;

		RoundCurrency(cyTotal);

		varTotal = cyTotal;

		/////////////////////////////////////////////////////////////////
		// If no insurance, always set the total to the unit cost,
		// even if a quote.
		int i;

		if (nInsuredPartyID > 0) {
			//we are looking at some sort of insurance
			for (i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {
					//find the item in the list
					RPCList *list = m_billingItems[i]->RPCList;

					bool bFoundResp = false;
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int j = 0;
					for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
						if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
							bFoundResp = true;
					}

					if (bFoundResp) {
						//at this point, var is the amount before tax, and varTotal is the amount with tax
						//use the insurance TaxType to determine which responsibility gets which amount
						if (TaxType == 1)
							UpdateListInsAmount(list, j, varTotal);
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							UpdateListInsAmount(list, j, varAmtQty);
					}
					else {
						//we're looking at insurance, but there's nothing in our list!  we
						//need to add it
						RespPerCharge rpc;
						rpc.InsuredPartyID = nInsuredPartyID;

						if (TaxType == 1)
							rpc.InsAmount = varTotal;
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							rpc.InsAmount = varAmtQty;

						// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
						rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
						rpc.RespTypeName = GetCurrentBillToRespTypeName();

						list->aryRPC.Add(rpc);
					}
				}
			}
		}

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {

				// (j.gruber 2009-03-09 09:26) - PLID 33351 - adding total discount field
				m_billingItems[i]->TotalDiscount = _variant_t(cyTotalLineDiscount);
				m_billingItems[i]->UnitCost = var;
				m_billingItems[i]->OthrUnitCost = varOutsideFee;
				m_billingItems[i]->LineTotal = varTotal;
			}
		}

		// (a.walling 2007-09-21 14:50) - PLID 26172 - CalculateLineTotal should be called here
		m_varBoundItem = (long)iLineID;


		// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
		CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

		DisableBillingScreen();

		if (m_EntryType == 1)
			FillBillList();
		else
			FillQuoteList();

		// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
		// use the row instead of the LineID
		// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
		IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
		InsertRowSorted(pRowToSort, varTotal);

		EnableBillingScreen();

		/* Recalculate the bill total */
		CalculateTotal();

	} NxCatchAll("Error in OnSelChosenComboCPT()");

	return pNew;
}

long CBillingDlg::GetCurrentBillToRespID() {
	//DRT 5/8/03 - Gets the current RespTypeID out of the BillTo combo

	if (m_EntryType == 1)
		//Bill
		return VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
	else
		//Quote
		return 0;	//Patient resp
}

long CBillingDlg::GetCurrentBillToInsuredPartyID() {
	//gets the InsuredPartyID by looking at the BillTo combo

	if (m_EntryType == 1 && m_listBillTo->CurSel != -1)
		//Bill
		return VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcInsuredPartyID));
	else
		//Quote
		return -1;	//Patient resp
}

long CBillingDlg::GetCurrentBillToInsuranceCoID() {
	//gets the InsuredPartyID by looking at the BillTo combo

	if (m_EntryType == 1 && m_listBillTo->CurSel != -1)
		//Bill
		return VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcInsuranceCoID));
	else
		//Quote
		return -1;	//Patient resp
}

// (j.jones 2007-02-28 08:46) - PLID 24844 - added to simplify auditing
CString CBillingDlg::GetCurrentBillToRespTypeName() {
	//gets the RespTypeName by looking at the BillTo combo

	if (m_EntryType == 1 && m_listBillTo->CurSel != -1)
		//Bill
		return VarString(m_listBillTo->GetValue(m_listBillTo->CurSel, btcRespName), "");
	else
		//Quote
		return "Patient";	//Patient resp
}

// (j.jones 2007-02-28 08:46) - PLID 24844 - added to simplify auditing
CString CBillingDlg::GetCurrentBillToInsuranceCoName() {
	//gets the Insurance Co. Name by looking at the BillTo combo

	if (m_EntryType == 1 && m_listBillTo->CurSel != -1)
		//Bill
		return VarString(m_listBillTo->GetValue(m_listBillTo->CurSel, btcInsuranceCoName), "");
	else
		//Quote
		return "";	//Patient resp
}

// (j.jones 2010-08-17 10:47) - PLID 40135 - added to get the current resp type category
RespCategoryType CBillingDlg::GetCurrentBillToRespTypeCategoryID() {
	//gets the InsuredPartyID by looking at the BillTo combo

	if (m_EntryType == 1 && m_listBillTo->CurSel != -1)
		//Bill
		return (RespCategoryType)VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcCategoryTypeID), rctInvalidRespCategory);
	else
		//Quote
		return rctInvalidRespCategory;	//Patient resp
}

// (d.lange 2015-12-01 12:28) - PLID 67127 - Returns the _RecordsetPtr for determining the most-primary insurance
// based on the given insured party
ADODB::_RecordsetPtr CBillingDlg::GetMostPrimaryInsCoIDForInsuredPartyRecordset(long nInsuredPartyID)
{
	return CreateParamRecordset("SELECT TOP 1 L.InsuranceCoID "
								"FROM InsuredPartyT "
								"INNER JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
								"LEFT JOIN ( "
								"	SELECT Q.PersonID, Q.InsuranceCoID, Q.Priority, Q.EffectiveCategoryType, Q.RowNum "
								"	FROM ( "
								"		SELECT I.PersonID, T.Priority "
								"			, (CASE WHEN T.ID <> -1 THEN T.CategoryType ELSE(-1 * I.PersonID) END) AS EffectiveCategoryType "
								"			, (ROW_NUMBER() OVER(PARTITION BY I.PatientID, (CASE WHEN T.ID <> -1 THEN T.CategoryType ELSE(-1 * I.PersonID) END) ORDER BY T.Priority ASC, (CASE WHEN I.RespTypeID = -1 THEN 2147483647 ELSE I.RespTypeID END) ASC, I.PersonID)) AS RowNum "
								"			, C.PersonID AS InsuranceCoID "
								"		FROM dbo.InsuredPartyT I "
								"		INNER JOIN InsuranceCoT C ON I.InsuranceCoID = C.PersonID "
								"		INNER JOIN dbo.RespTypeT T ON I.RespTypeID = T.ID "
								"		WHERE I.PatientID = {INT} "
								"	) Q WHERE Q.RowNum = 1 "
								") L ON(CASE WHEN RespTypeT.ID <> -1 THEN RespTypeT.CategoryType ELSE(-1 * InsuredPartyT.PersonID) END) = L.EffectiveCategoryType "
								"WHERE InsuredPartyT.PersonID = {INT} "
								"ORDER BY(CASE WHEN L.Priority = -1 THEN 2147483647 ELSE L.Priority END) ASC, (CASE WHEN L.EffectiveCategoryType > 0 THEN L.EffectiveCategoryType ELSE 2147483647 END) ASC "
		,m_nPatientID, nInsuredPartyID);
}

// (d.lange 2015-11-19 14:32) - PLID 67127 - Returns the insurance company ID for the most-primary insurance
// based on the selected insurance category
long CBillingDlg::GetCurrentBillToMostPriInsCoIDForCategory()
{
	// Retrieve the selected insured party from the Bill To dropdown
	long nInsuredPartyID = GetCurrentBillToInsuredPartyID();

	// Retrieve the most-primary insurance company based on the selected insured party
	_RecordsetPtr rs = GetMostPrimaryInsCoIDForInsuredPartyRecordset(nInsuredPartyID);
	if (!rs->eof) {
		return AdoFldLong(rs, "InsuranceCoID", -1);
	}

	// Patient Responsibility
	return -1;
}

void CBillingDlg::OnSelChosenComboBillTo(long nRow)
{
	try {

		if (nRow == -1) {
			//if unselected, try to select patient
			nRow = 0;
			m_listBillTo->PutCurSel(0);
			//make sure that the list isn't empty, in which case we have to return
			//(though something would be seriously wrong)
			nRow = m_listBillTo->GetCurSel();
			if (nRow == -1) {
				return;
			}
		}

		long nRespTypeID = VarLong(m_listBillTo->GetValue(nRow, btcID), 0);

		// (j.jones 2008-09-12 12:20) - PLID 4423 - if they picked an inactive responsibility,
		// give a don't show me again warning explaining that they must correct the dates
		if (m_EntryType == 1 && nRespTypeID == -1) {
			//it's inactive, so warn
			DontShowMeAgain(this, "Any new charges made for an inactive insurance responsibility cannot have a date of service after the expiration date of the insured party.\n"
				"You will not be allowed to save the bill if any new charges have service dates outside of this range.",
				"BillInactiveInsurance", "Billing Inactive Insurance", FALSE, FALSE);
		}

		// (j.jones 2008-09-12 13:07) - PLID 4423 - moved the contents of this function to PostSelChosenComboBillTo
		PostSelChosenComboBillTo(nRow);

	} NxCatchAll("Error in OnSelChosenComboBillTo()");
}

void CBillingDlg::SetFocusToBillToCombo() {
	//sets the focus to the m_listBillTo datalist
	//this is really only needed because the billingmoduledlg
	//tries to setfocus sometimes, and this is easier.

	GetDlgItem(IDC_COMBO_BILL_TO)->SetFocus();
}

bool CBillingDlg::FindRPCInList(RPCList *list, long nInsuredPartyID, RespPerCharge &rpc) {
	//DRT 5/8/03 - Looks up a RespPerCharge in the given list with the given type id 
	//		and returns through the paramter.  True is returned if we find it, false
	//		otherwise.

	for (int i = 0; i < list->aryRPC.GetSize(); i++) {
		if (VarLong(list->aryRPC.GetAt(i).InsuredPartyID) == nInsuredPartyID) {
			rpc = list->aryRPC.GetAt(i);
			return true;
		}
	}

	//not found
	return false;
}

bool CBillingDlg::SetListInsAmount(long nIndex, long nInsuredPartyID, COleVariant varAmount) {
	//DRT 5/9/03 - Sets the insurance amount given the index in the m_billingItems structure, 
	//the nInsuredPartyID, and the amount to set.

	//find the item in the list
	RPCList *list = m_billingItems[nIndex]->RPCList;

	for (int j = 0; j < list->aryRPC.GetSize(); j++) {
		if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID) {
			UpdateListInsAmount(list, j, varAmount);
			return true;
		}
	}

	return false;
}

void CBillingDlg::UpdateListInsAmount(RPCList *list, long nAryIndex, COleVariant varAmount) {
	//Since we have to SetAt() to update the amounts, it's easier if we stick the small
	//amount of code in this function

	RespPerCharge rpc;
	rpc = list->aryRPC.GetAt(nAryIndex);
	rpc.InsAmount = varAmount;
	list->aryRPC.SetAt(nAryIndex, rpc);
}

void CBillingDlg::OnTrySetSelFinishedComboPlaceofservice(long nRowEnum, long nFlags)
{
	if (nFlags == dlTrySetSelFinishedFailure) {
		//OK, they must have an inactive location selected.
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rsLocation = CreateParamRecordset("SELECT Name FROM LocationsT WHERE ID = (SELECT Location FROM BillsT WHERE ID = {INT})", GetBillID());
		if (!rsLocation->eof) {
			m_PlaceOfServiceCombo->PutComboBoxText(_bstr_t(AdoFldString(rsLocation, "Name", "")));
		}
	}
}

void CBillingDlg::OnTrySetSelFinishedComboLocation(long nRowEnum, long nFlags)
{
	if (nFlags == dlTrySetSelFinishedFailure) {
		//OK, they must have an inactive location selected.
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rsLocation = CreateParamRecordset("SELECT Name FROM LocationsT WHERE ID = (SELECT Location FROM LineItemT WHERE ID IN (SELECT ID FROM ChargesT WHERE BillID = {INT}))", GetBillID());
		if (!rsLocation->eof) {
			m_LocationCombo->PutComboBoxText(_bstr_t(AdoFldString(rsLocation, "Name", "")));
		}
	}
}

// (j.jones 2010-02-05 17:28) - PLID 37251 - added bBillDateChanged
BOOL CBillingDlg::ValidateChanges(BOOL bBillDateChanged)
{
	try {

		BOOL bWarnedAboutPackageQty = FALSE;
		BOOL bWarnedAboutPackageDiscounts = FALSE;
		BOOL bWarnedAboutBillableItems = FALSE;
		BOOL bWarnedAboutICD9Codes = FALSE;
		BOOL bWarnedAboutFutureDates = FALSE;
		BOOL bWarnedAboutMismatchedDates = FALSE;
		BOOL bWarnedAboutOutsideFeesOnPackages = FALSE;
		BOOL bWarnedAboutInactiveInsuranceCharges = FALSE;
		// (s.tullis 2015-03-27 14:23) - PLID 64976 -Need to warn if they have multiple category configured but none assigned to the charge
		BOOL bWarnedAboutMultiCategoryCPT = FALSE;

		if (m_pList->GetRowCount() == 0) {
			MsgBox("You must have at least one charge before saving.");
			return FALSE;
		}

		if (m_PlaceOfServiceCombo->CurSel == -1 && CString((LPCTSTR)m_PlaceOfServiceCombo->ComboBoxText) == "") {
			MsgBox("You must select a place of service for this bill.");
			return FALSE;
		}
		if (m_LocationCombo->CurSel == -1 && CString((LPCTSTR)m_LocationCombo->ComboBoxText) == "") {
			MsgBox("You must select a location for this bill.");
			return FALSE;
		}

		// (j.jones 2007-11-15 14:54) - PLID 27988 - if at this point there are any
		// unresolved allocations, we MUST require them to allocate them
		if (m_EntryType == 1 && !ForceResolveAllAllocations()) {
			MsgBox("You may not save this bill until all open allocations have been used up or released to general stock.");
			return FALSE;
		}

		// (j.jones 2010-08-30 10:20) - PLID 32788 - warn if the description is empty
		// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
		CString strBillDesc = GetBillDescription();
		strBillDesc.TrimLeft();
		strBillDesc.TrimRight();
		if (strBillDesc.IsEmpty()) {
			// (r.gonet 07/02/2014) - PLID 62567 - Make the warning about empty description a bit different if they have an ON HOLD: prefix,
			// because the description isn't totally empty in that case, just meaningfully empty.
			CString strBillDescWithPrefix = GetBillDescriptionWithPrefix();
			strBillDescWithPrefix.TrimLeft();
			strBillDescWithPrefix.TrimRight();
			if (!strBillDescWithPrefix.IsEmpty()) {
				MsgBox("You must enter in a description (in addition to the pre-filled status prefix) before saving.");
			} else {
				MsgBox("You must enter in a description before saving.");
			}
			return FALSE;
		}

		// (j.jones 2010-08-17 11:40) - PLID 40135 - Check to see if they selected two insured parties
		// on the insurance tab that have different categories (ie. one is Medical, one is Vision).
		// This function will warn the user and ask if they wish to continue. It returns FALSE if they said no.
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()
			&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.CheckWarnMismatchedInsuranceCategories() == FALSE) {
			//they would already have been warned
			return FALSE;
		}

		if (m_EntryType == 2 && GetIsAnyPackage()) {

			//Validate Package Information
			CString strTotalAmount;
			CString strCurrentAmount;
			CString strInitialAmount;
			GetDlgItemText(IDC_PACKAGE_TOTAL_COST, strTotalAmount);
			GetDlgItemText(IDC_PACKAGE_CURRENT_BALANCE, strCurrentAmount);
			GetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, strInitialAmount);

			COleCurrency cyTotal, cyCurrent, cyInitial;
			if (!cyTotal.ParseCurrency(strTotalAmount) || cyTotal < COleCurrency(0, 0)) {
				AfxMessageBox("Please enter a valid amount in the 'Total Package Cost' field.");
				return FALSE;
			}
			if (!cyCurrent.ParseCurrency(strCurrentAmount) || cyCurrent < COleCurrency(0, 0)) {
				AfxMessageBox("Please enter a valid amount in the 'Unbilled Amount' field.");
				return FALSE;
			}
			// (j.jones 2009-12-23 12:20) - PLID 32587 - validate the initial value
			if (!cyInitial.ParseCurrency(strInitialAmount) || cyInitial < COleCurrency(0, 0)) {
				AfxMessageBox("Please enter a valid amount in the 'Initial Value' field.");

				//make sure the field is displayed
				m_checkPackageShowInitialValues.SetCheck(TRUE);
				OnPackageShowInitialValues();
				return FALSE;
			}
			if (cyTotal < cyInitial) {
				AfxMessageBox("Please ensure that the 'Initial Value' field is not less than the 'Total Package Cost'.");

				//make sure the field is displayed
				m_checkPackageShowInitialValues.SetCheck(TRUE);
				OnPackageShowInitialValues();
				return FALSE;
			}

			// (j.jones 2009-12-23 14:19) - PLID 32587 - disallow the total cost from being less than the balance
			if (cyTotal < cyCurrent) {
				AfxMessageBox("Please ensure that the 'Total Package Cost' field is not less than the 'Unbilled Amount'.");
				return FALSE;
			}
			// (j.jones 2009-12-23 14:19) - PLID 32587 - disallow initial quantity from being less than the balance
			else if (cyInitial < cyCurrent) {
				AfxMessageBox("Please ensure that the 'Initial Value' field is not less than the 'Unbilled Amount'.");
				//make sure the field is displayed
				m_checkPackageShowInitialValues.SetCheck(TRUE);
				OnPackageShowInitialValues();
				return FALSE;
			}

			// (j.jones 2009-12-23 14:19) - PLID 32587 - if repeatable, disallow the total count from being less than the balance
			if (!GetIsMultiUsePackage()) {

				long nTotalCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
				long nCurrentCount = GetDlgItemInt(IDC_PACKAGE_COUNT);
				long nInitCount = GetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT);

				if (nTotalCount < nCurrentCount) {
					AfxMessageBox("Please ensure that the 'Total Uses' field is not less than the 'Uses Remaining'.");
					return FALSE;
				}
				// (j.jones 2009-12-23 14:19) - PLID 32587 - disallow initial count from being less than the balance
				else if (nInitCount < nCurrentCount) {
					AfxMessageBox("Please ensure that the 'Initial Uses' field is not less than the 'Uses Remaining'.");
					//make sure the field is displayed
					m_checkPackageShowInitialValues.SetCheck(TRUE);
					OnPackageShowInitialValues();
					return FALSE;
				}
			}
		}

		if (m_EntryType == 1 && GetRemotePropertyInt("WarnBillDateInFuture", 1, 0, "<None>", TRUE) == 1) {
			if (GetBillID() == -1 && VarDateTime(m_peditBillDate->GetValue()) > COleDateTime::GetCurrentTime()) {
				if (IDNO == MessageBox("You are saving a bill with a date in the future.\n"
					"Are you sure you want to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return FALSE;
				}
				bWarnedAboutFutureDates = TRUE;
			}
		}

		// (j.jones 2010-05-07 15:51) - PLID 37695 - track whether the user can bill out of stock products
		BOOL bCanBillOutOfStock = (GetCurrentUserPermissions(bioBill) & sptDynamic1) > 0 ? TRUE : FALSE;
		BOOL bCanBillOutOfStockWithPass = (GetCurrentUserPermissions(bioBill) & sptDynamic1WithPass) > 0 ? TRUE : FALSE;

		CStringArray strOutOfStockArray;
		CArray<double, double> aryOutOfStockOnHandQty;
		CArray<double, double> aryOutOfStockAllocatedQty;

		// (c.haag 2009-03-10 16:17) - PLID 32433 - Fail if the user is trying to backdate an existing bill or charge more days than is
		// acceptable. Because users are allowed to backdate existing items they entered in the same day, there's no point in checking
		// this for new items, or items entered on the same day.
		//
		// I want to note that if a user simply opens a bill and clicks OK, they will get this warning. In a perfect world, we would
		// have to go through every field in the entire bill (all tabs) and charge list; see if anything changed, and if so, then fire
		// this code. However, it's not a perfect world; and to do this would take a lot of work. It would pretty much be its own project.
		// For now, if a user with limited permissions opens a bill, they will have to use the Cancel button if they don't want to get the
		// you-can't-save message.
		//
		// (c.haag 2009-05-18 11:46) - PLID 34273 - We used to not check for backdating authorization for new bills or bills edited on
		// the same day. Now we always check. Furthermore, we only do this with bills, not quotes.
		//		
		// (j.jones 2010-02-05 17:23) - PLID 37251 - These assessments were flawed. If you open a bill in the past, change nothing at all,
		// and then try to preview the bill, or merge to word, etc., you would be told you cannot do it, because the bill saves first.
		// Chris was right in that it would be a huge project to detect all changes, but if you never changed the bill date, then you should
		// not get this prompt at all.


		if (m_EntryType == 1)
		{
			COleDateTime dtToday = COleDateTime::GetCurrentTime();
			dtToday.SetDate(dtToday.GetYear(), dtToday.GetMonth(), dtToday.GetDay());
			COleDateTime dtBill = VarDateTime(m_peditBillDate->GetValue());
			COleDateTime dtEarliestCharge = g_cdtInvalid;
			COleDateTime dtEarliestChargeInput = g_cdtInvalid;
			const int nBillID = GetBillID();
			const CString strType = (m_EntryType == 2) ? "Quote" : "Bill";

			// Get the earliest date of all charges.
			// Run a loop through all charges, see which ones were added or modified, and find the
			// earliest charge date in that subset
			BOOL bAtLeastOneChargeChanged = FALSE;
			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			IRowSettingsPtr pRow = m_pList->GetFirstRow();
			while (pRow) {
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				COleDateTime dtCharge = pRow->GetValue(BILL_COLUMN_DATE);
				COleDateTime dtChargeInput = pRow->GetValue(COLUMN_INPUT_DATE);

				// (j.jones 2010-02-05 17:36) - PLID 37251 - do not check the charge date unless
				// it is new, or we changed it
				BOOL bIsModified = FALSE;
				if (nChargeID < 0) {
					bIsModified = TRUE;
					bAtLeastOneChargeChanged = TRUE;
				}
				for (int j = 0; j < m_adwEditedCharges.GetSize() && !bIsModified; j++) {
					long nChargeToCheck = (long)m_adwEditedCharges.GetAt(j);
					if (nChargeToCheck == nChargeID) {
						//this charge has been modified
						bIsModified = TRUE;
						bAtLeastOneChargeChanged = TRUE;
					}
				}

				if (bIsModified) {
					if (dtEarliestCharge.m_status == COleDateTime::invalid ||
						dtCharge < dtEarliestCharge) {

						dtEarliestCharge = dtCharge;
					}

					// (j.jones 2010-12-28 11:09) - PLID 41852 - get the earliest charge input date as well
					if (dtEarliestChargeInput.m_status == COleDateTime::invalid ||
						dtChargeInput < dtEarliestChargeInput) {

						dtEarliestChargeInput = dtChargeInput;
					}

					// (j.jones 2010-05-07 15:51) - PLID 37695 - if there is a restriction on billing out of stock products,
					// check each product
					BOOL bCanBillOutOfStock = (GetCurrentUserPermissions(bioBill) & sptDynamic1) > 0 ? TRUE : FALSE;
					if (!bCanBillOutOfStock) {
						//is this a product?
						if (ITEM_TYPE_PRODUCT == VarLong(pRow->GetValue(COLUMN_ITEM_TYPE))) {
							long nServiceID = VarLong(pRow->GetValue(COLUMN_SERVICE_ID), -1);
							long nLocationID = -1;
							if (m_LocationCombo->GetCurSel() != -1) { //should not be possible to be unselected
								nLocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
							}

							double dblQuantity = 0.0;
							double dblAllocated = 0.0;

							// (j.jones 2010-08-13 17:03) - PLID 37695 - only warn if they are billing less than zero, not actual zero
							if (InvUtils::CalcAmtOnHand(nServiceID, nLocationID, dblQuantity, dblAllocated, -GetUnsavedQuantityCount(nServiceID), 0.0) && dblQuantity - dblAllocated < 0.0) {
								//out of stock
								BOOL bFound = FALSE;
								CString strName = "";
								_RecordsetPtr rsProdName = CreateParamRecordset("SELECT Name FROM ServiceT WHERE ID = {INT}", nServiceID);
								if (!rsProdName->eof) {
									strName = AdoFldString(rsProdName, "Name");
								}
								rsProdName->Close();
								for (int j = 0; j < strOutOfStockArray.GetSize() && !bFound; j++) {
									if (strOutOfStockArray.GetAt(j) == strName) {
										bFound = TRUE;
									}
								}
								if (!bFound) {
									strOutOfStockArray.Add(strName);
									aryOutOfStockOnHandQty.Add(dblQuantity);
									aryOutOfStockAllocatedQty.Add(dblAllocated);
								}
							}
						}
					}
				}

				pRow = pRow->GetNextRow();
			}

			// (j.jones 2010-05-07 16:49) - PLID 37695 - now enforce the out-of-stock permission
			if (!bCanBillOutOfStock && strOutOfStockArray.GetSize() > 0) {

				CString strWarning, strOutOfStockWarning;

				if (strOutOfStockArray.GetSize() > 0) {
					for (int i = 0; i < strOutOfStockArray.GetSize() && i < 11; i++) {
						if (i == 10) {
							//stop after the 10th item
							CString strOutOfStock;
							strOutOfStock.Format("    <More...>\n");
							strOutOfStockWarning += strOutOfStock;
						}
						else {
							CString strAllocatedWarning = "";
							if (aryOutOfStockAllocatedQty.GetAt(i) > 0.0) {
								strAllocatedWarning.Format(", %g allocated to patients", aryOutOfStockAllocatedQty.GetAt(i));
							}
							CString strOutOfStock;
							strOutOfStock.Format("    %s (%g in stock%s)\n", strOutOfStockArray.GetAt(i), aryOutOfStockOnHandQty.GetAt(i), strAllocatedWarning);
							strOutOfStockWarning += strOutOfStock;
						}
					}
					strOutOfStockWarning.TrimRight("\n");
				}

				strWarning.Format("The following products are out of stock:\n\n%s", strOutOfStockWarning);
				strWarning.TrimRight("\n");

				if (bCanBillOutOfStockWithPass) {
					//they have password access, so warn them why they are about to be prompted
					strWarning += "\n\nYou must enter your password to bill products that are out of stock.\n"
						"Do you wish to continue saving this bill?";
					if (IDNO == MessageBox(strWarning, "Practice", MB_YESNO | MB_ICONEXCLAMATION)
						|| !CheckCurrentUserPassword()) {
						return FALSE;
					}
				}
				else {
					//no password access, goodbye
					strWarning += "\n\nYou do not have permission to bill products that are out of stock. Please correct these charges.";
					AfxMessageBox(strWarning);
					return FALSE;
				}
			}

			// Now make absolutely sure we have no time in the datetime
			if (dtEarliestCharge.m_status == COleDateTime::valid) {
				dtEarliestCharge.SetDate(dtEarliestCharge.GetYear(), dtEarliestCharge.GetMonth(), dtEarliestCharge.GetDay());
			}

			// Now see what we need to validate.
			// If the bill date changed, and the bill date is now in the past, then we need to make sure it can be saved
			BOOL bValidateHistoricBillDate = (dtBill < dtToday) ? TRUE : FALSE;
			// If dtEarliestCharge is a valid datetime before today,  then we need to make sure it can be saved
			BOOL bValidateHistoricChargeDate = (dtEarliestCharge.m_status == COleDateTime::valid && dtEarliestCharge < dtToday) ? TRUE : FALSE;

			if (bValidateHistoricBillDate || bValidateHistoricChargeDate)
			{
				// (j.jones 2010-02-05 17:32) - PLID 37251 - do not check the bill date if it did not change
				if (bValidateHistoricBillDate && bBillDateChanged) {
					if (!CanChangeHistoricFinancial_ByServiceDate("Bill", dtBill, TRUE)) {
						// The user cannot save the bill as is, and they've already been prompted about it.
						return FALSE;
					}
				}
				// (j.jones 2010-02-05 17:32) - PLID 37251 - do not check the charge date none changed
				if (bValidateHistoricChargeDate && bAtLeastOneChargeChanged) {
					if (!CanChangeHistoricFinancial_ByServiceDate("Charge", dtEarliestCharge, TRUE)) {
						// The user cannot save the bill as is, and they've already been prompted about it.
						return FALSE;
					}
				}
			} else {
				// The bill does not require validation because everything is either for today or the future
			}

			// (j.jones 2010-08-30 12:02) - PLID 40293 - if any charge changed, we will warn if there
			// are diagnosis codes on the bill not linked to any charge on the bill
			if (bAtLeastOneChargeChanged) {
				// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
				if (GetRemotePropertyInt("BillWarnUnlinkedDiagnosis", 1, 0, "<None>", true) == 1) {
					//this function will check for unlinked diag codes, warn, and return false if we warned
					if (!CheckWarnUnlinkedDiagnosisCodes()) {
						return FALSE;
					}
				}
			}

		} // if (m_EntryType==1)
		else {
			// Must be a quote. We don't do backdate checking with quotes.
		}

		// (j.jones 2009-09-28 16:09) - PLID 35686 - warn if the POS is 21, but no hosp. dates are entered
		if (m_EntryType == 1 && (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pHospFrom->GetStatus() == 3 /*empty*/
			|| ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pHospTo->GetStatus() == 3 /*empty*/) &&
			GetRemotePropertyInt("CheckBillHospDatesWhenPOS21", 1, 0, "<None>", TRUE) == 1) {

			//This is a bill, we are missing at least one hospitalization date, and the preference is enabled,
			//so check and see if our Place Of Service code is 21.

			if (m_DesignationCombo->CurSel != -1) {
				CString strCode = VarString(m_DesignationCombo->GetValue(m_DesignationCombo->GetCurSel(), posdcCode));
				strCode.TrimLeft();
				strCode.TrimRight();
				if (strCode == "21") {
					if (MessageBox("The Place Of Service Designation on this bill is 21, indicating an inpatient hospital stay, however the "
						"hospitalization dates are not filled out completely in the insurance tab.\n\n"
						"Do you still wish to continue saving this bill?", "Practice", MB_YESNO | MB_ICONQUESTION) == IDNO) {

						return FALSE;
					}
				}
			}
		}

		// (j.jones 2014-07-17 12:45) - PLID 62930 - Added a warning if you have 439 - Accident selected, and a date,
		// but did not select the Auto or Other accident type. To annoy people less, we'll warn for this first,
		// and if they ignore it, we'll skip the next warning, which is similar.
		bool bWarnedAboutAccidentRadio = false;
		if (m_EntryType == 1
			&& !bWarnedAboutAccidentRadio) {

			// (r.gonet 2016-04-07) - NX-100072 - Use the ClaimDates structure.
			ConditionDateType cdtConditionDateType = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates.eConditionDateType;

			if (cdtConditionDateType == ConditionDateType::cdtAccident439
				&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_claimDates.GetFirstConditionDate().GetStatus() == COleDateTime::valid
				&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_autoAccidentRadio.GetCheck() != BST_CHECKED
				&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_otherAccidentRadio.GetCheck() != BST_CHECKED) {

				if (IDNO == MessageBox("The 'Accident Date' date type has been selected, however a Condition Relation type of Auto Accident or Other has not been selected. "
					"This may cause claims to reject.\r\n\r\n"
					"Do you still wish to continue saving this bill?", "Practice", MB_YESNO | MB_ICONQUESTION)) {
					return FALSE;
				}

				//track that we warned about this radio button so we don't warn again later
				bWarnedAboutAccidentRadio = true;
			}
		}

		// (a.wilson 2013-03-28 12:32) - PLID 55888 - warn if the current accident date is filled in but no accident type is selected.
		// (j.jones 2013-08-16 09:19) - PLID 58063 - this field is no longer controlled by the dropdown
		// (j.jones 2014-07-17 12:47) - PLID 62930 - suppress this warning if we already warned about the accident type
		// with respect to the 439 - Accident selection
		if (m_EntryType == 1
			&& !bWarnedAboutAccidentRadio
			&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAccident->GetStatus() == 1
			&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_noAccidentRadio.GetCheck() == BST_CHECKED) {

			if (IDNO == MessageBox("A 'Date of Current Illness / Injury' has been added, however a Condition Relation has not been selected.\r\n\r\n"
				"Do you still wish to continue saving this bill?", "Practice", MB_YESNO | MB_ICONQUESTION)) {
				return FALSE;
			}

			//track that we warned about this radio button, although currently nothing else checks it
			bWarnedAboutAccidentRadio = true;
		}


		// (j.jones 2010-06-14 13:43) - PLID 38507 - NeedWarnHCFABox13 will return TRUE
		// if the Box 13 override is not "use default" and this is a new bill or we
		// changed it on an existing bill. Since they could presumably change it, change
		// the form type, then later change back to a HCFA, just always warn even if we
		// are not currently on the HCFA form type.
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			HCFABox13Over hb13Value = hb13_UseDefault;
			if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.NeedWarnHCFABox13(hb13Value)
				&& hb13Value != hb13_UseDefault) {

				// (j.jones 2010-07-27 11:00) - PLID 39858 - reworded these warnings to reflect
				// that this setting also affects UB claims

				CString strWarn;
				if (hb13Value == hb13_No) {
					//force blank
					strWarn = "You have changed your Assignment of Benefits (HCFA Box 13 / UB Box 53) setting to:\n"
						"Do Not Assign Benefits To Provider\n\n"
						"This will tell the insurance company to pay the patient instead of the provider.\n"
						"Are you SURE you wish to change this setting for this bill?";
				}
				else {
					//force filled
					strWarn = "You have changed your Assignment of Benefits (HCFA Box 13 / UB Box 53) setting to:\n"
						"Assign Benefits To Provider\n\n"
						"This will tell the insurance company to pay the provider instead of the patient.\n"
						"Are you SURE you wish to change this setting for this bill?";
				}

				if (IDNO == MessageBox(strWarn, "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return FALSE;
				}
			}
		}

		// (j.jones 2008-05-14 17:16) - PLID 30044 - warn if the test result option is enabled
		// and the user does not have qualifying codes, but only if they are saving using the HCFA form
		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()
			&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetFormTypeID() == 1) {

			BOOL bTestResultEnabled = FALSE;
			BOOL bTestResultValid = TRUE;

			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.CheckTestResultFields(bTestResultEnabled, bTestResultValid);

			if (bTestResultEnabled && !bTestResultValid) {
				AfxMessageBox("The 'Send Test Result' option cannot be enabled without entering information in the Identifier, Type, and Result fields.\n"
					"Please fill in these fields, or uncheck the 'Send Test Result' box.");
				return FALSE;
			}

			if (bTestResultEnabled) {

				//warn if the bill does not have any of the five test result codes in use

				CStringArray aryCodes;
				aryCodes.Add("J0881");
				aryCodes.Add("J0882");
				aryCodes.Add("J0885");
				aryCodes.Add("J0886");
				aryCodes.Add("Q4081");

				ASSERT(m_pBillingModuleWnd);

				BOOL bHasCodes = DoesBillHaveMatchingServiceCode(aryCodes);

				if (!bHasCodes) {

					//they do not have the codes on the bill, warn them

					if (MessageBox("The 'Send Test Result' option is currently enabled, but test result information is only sent for codes J0881, J0882, J0885, J0886, and Q4081.\n"
						"Your bill does not currently have a charge for any of these codes. If you continue, no test result information will be sent on your ANSI claim.\n\n"
						"Do you still wish to continue saving this bill?", "Practice", MB_YESNO | MB_ICONQUESTION) == IDNO) {

						return FALSE;
					}
				}
			}
		}

		BOOL bAreAllBatched = TRUE;
		BOOL bAreAnyBatched = FALSE;

		BOOL bCheckAndWarnCredentials = GetRemotePropertyInt("CredentialWarnBills", 0, 0, "<None>", true) == 1;
		BOOL bCheckAndWarnLicensing = GetRemotePropertyInt("ExpLicenseWarnBills", bCheckAndWarnCredentials ? 1 : 0, 0, "<None>", true) == 1;
		BOOL bWarnCredentialingTOS2 = GetRemotePropertyInt("CredentialWarningOnlyTOS2", 0, 0, "<None>", true) == 1;
		ECredentialWarning eCredToWarn = ePassedAll;
		ECredentialWarning eLicenseToWarn = ePassedAll;
		long nProviderToWarnCred = -1;
		long nProviderToWarnLicense = -1;
		// (s.tullis 2015-03-27 14:23) - PLID 64976 -Need to warn if they have multiple category configured but none assigned to the charge
		BOOL bWarnAboutNoCPTCategorySel = FALSE;
		std::vector<CString> arrNoCPTCatSelCharges;

		// (j.dinatale 2012-06-22 15:50) - PLID 51138 - NDC warnings
		bool bWarnAboutNoNDC = false;
		bool bWarnAboutNoNDCPreference = (GetRemotePropertyInt("WarnNoNDCOnNOCCode", 1, 0, "<None>", true) == 1);

		// (j.jones 2012-07-25 14:08) - PLID 50487 - office visit global period warnings
		BOOL bAlreadyWarnedOfficeVisitGlobalPeriod = FALSE;
		BOOL bWarnOfficeVisitGlobalPeriod = (GetRemotePropertyInt("GlobalPeriod_WarnOfficeVisits", 1, 0, "<None>", true) == 1);

		// (j.jones 2012-12-06 11:31) - PLID 52637 - surgical code global period warnings
		BOOL bAlreadyWarnedSurgicalCodeGlobalPeriod = FALSE;
		BOOL bWarnSurgicalCodeGlobalPeriod = (GetRemotePropertyInt("GlobalPeriod_WarnSurgicalCodes", 1, 0, "<None>", true) == 1);

		//for each charge
		for (int i = 0; i < (int)m_billingItems.size(); i++) {

			BillingItemPtr bi = m_billingItems[i];
			long nChargeID = VarLong(bi->ChargeID, -2);
			COleCurrency cyUnit = VarCurrency(bi->UnitCost);
			COleCurrency cyTotal = VarCurrency(bi->LineTotal);
			double dblQty = VarDouble(bi->Quantity);
			double dblPackageQtyRemaining = VarDouble(bi->PackageQtyRemaining);
			double dblOriginalPackageQtyRemaining = VarDouble(bi->OriginalPackageQtyRemaining);
			// (j.gruber 2009-03-06 11:32) - PLID 33351 get the total percentage and discounts 
			long nTotalPercentOff;
			COleCurrency cyTotalDollarDiscount, cyTotalLineDiscount;

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			CalculateTotalDiscount(bi->DiscountList, cyTotal, cyInvalid, nTotalPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);
			//long nPercentOff = (bi->PercentOff.vt == VT_EMPTY) ? 0 : VarLong(bi->PercentOff,0);
			//COleCurrency cyDiscount = (bi->Discount.vt == VT_EMPTY) ? COleCurrency(0,0) : VarCurrency(bi->Discount, COleCurrency(0,0));

			// (j.jones 2008-09-12 12:30) - PLID 4423 - I needed this for inactive insurance
			// validation, I'm sure other validation code can use it too.
			BOOL bIsModified = FALSE;
			if (nChargeID == -2) {
				bIsModified = TRUE;
			}
			else {
				for (int j = 0; j<m_adwEditedCharges.GetSize() && !bIsModified; j++) {
					long nChargeToCheck = (long)m_adwEditedCharges.GetAt(j);
					if (nChargeToCheck == nChargeID) {
						//this charge has been modified
						bIsModified = TRUE;
					}
				}
			}

			//make sure no unit cost is above $100,000,000.00
			if (cyUnit > COleCurrency(100000000, 0)) {
				CString str;
				str.Format("You cannot have any charges greater than %s.", FormatCurrencyForInterface(COleCurrency(100000000, 0), TRUE, TRUE));
				MsgBox(str);
				return FALSE;
			}
			// (s.tullis 2015-03-27 14:23) - PLID 64976 - if the charge has multiple categories and none assigned
			// set to warn to be true and get the charge name for later
			if (bIsModified && VarLong(bi->CPTCategoryCount, -1) > 1 && VarLong(bi->CPTCategoryID, -1) == -1)
			{
				bWarnAboutNoCPTCategorySel = TRUE;
				arrNoCPTCatSelCharges.push_back(VarString(bi->Description));
			}
		
		
			//make sure no charge total is negative
			// (j.jones 2011-08-24 09:51) - PLID 44873 - the only charge that is permitted to be negative
			// is a voiding charge, so skip this check only when IsVoidingCharge is true
			if (!VarBool(bi->IsVoidingCharge, FALSE)) {
				if (cyTotal < COleCurrency(0, 0)) {
					if (cyUnit < COleCurrency(0, 0) || dblQty < 0 || cyTotal.m_cur.Hi == -1) {
						MsgBox("You cannot have any negative charges. Please make sure no charges are less than zero.");
					}
					else {
						MsgBox("You have a charge with an invalid charge amount that is unsupported by Practice.\n"
							"(It will appear as a negative charge until it is repaired.)\n"
							"You must fix this charge before saving.");
					}
					return FALSE;
				}
			}

			//check the Batched status
			if (m_EntryType == 1) {
				BOOL bBatched = VarBool(bi->Batched, TRUE);

				//on any bill, make sure all the charges are marked as being batched
				if (bBatched)
					bAreAnyBatched = TRUE;
				else
					bAreAllBatched = FALSE;
			}

			// (j.jones 2007-03-26 14:43) - PLID 25287 - disallow a quantity less than 1
			// on a multi-use package
			if (m_EntryType == 2 && GetIsMultiUsePackage()) {
				if (dblQty < 1.0) {
					MsgBox("You cannot save a multi-use package charge with a quantity less than 1.\n"
						"Please correct this before saving.");
					return FALSE;
				}
				// (j.jones 2009-12-23 12:25) - PLID 32587 - also disallow on initial quantity
				else if (dblOriginalPackageQtyRemaining < 1.0) {
					MsgBox("You cannot save a multi-use package charge with an initial quantity less than 1.\n"
						"Please correct this before saving.");
					//make sure the field is displayed
					m_checkPackageShowInitialValues.SetCheck(TRUE);
					OnPackageShowInitialValues();
					return FALSE;
				}
				// (j.jones 2009-12-23 14:19) - PLID 32587 - disallow quantity from being less than the balance
				else if (dblOriginalPackageQtyRemaining < dblPackageQtyRemaining) {
					MsgBox("You cannot save a multi-use package charge with quantity less than the package qty. remaining.\n"
						"Please correct this before saving.");
					return FALSE;
				}
				// (j.jones 2009-12-23 14:19) - PLID 32587 - disallow initial quantity from being less than the balance
				else if (dblOriginalPackageQtyRemaining < dblPackageQtyRemaining) {
					MsgBox("You cannot save a multi-use package charge with an initial quantity less than the package qty. remaining.\n"
						"Please correct this before saving.");
					//make sure the field is displayed
					m_checkPackageShowInitialValues.SetCheck(TRUE);
					OnPackageShowInitialValues();
					return FALSE;
				}
			}


			// (j.jones 2008-09-12 12:26) - PLID 4423 - Disallow saving new or modified charges
			// where there is insurance responsibility, and the date of service is after the 
			// insurance's expiration date. The insurance does not have to currently be inactive
			// to get this warning.
			// (j.jones 2009-12-28 14:54) - PLID 36324 - we will now warn only once if it is an existing,
			// modified charge, and continue to disallow new, but that does not affect this if statement
			if (m_EntryType == 1 && (nChargeID == -2 || (bIsModified && !bWarnedAboutInactiveInsuranceCharges))) {
				//This is a new charge on a bill, or a modified charge,
				//so check and see if it has insurance responsibility,
				//then check that its service date (from or to!) is after
				//the expire date of the insurance, regardless of whether
				//the insurance is currently active.

				COleDateTime dtInvalid;
				dtInvalid.SetStatus(COleDateTime::invalid);

				//get our service dates
				COleDateTime dtFromDate = VarDateTime(bi->Date, dtInvalid);
				COleDateTime dtToDate = VarDateTime(bi->ServiceDateTo, dtInvalid);

				for (int j = 0; j < bi->RPCList->aryRPC.GetSize(); j++) {
					RespPerCharge rpc = bi->RPCList->aryRPC.GetAt(j);

					if (rpc.InsAmount.vt == VT_CY && VarCurrency(rpc.InsAmount) != COleCurrency(0, 0)) {
						//they have an insurance resp, now check the information via the dropdown list
						//rather than running a recordset
						long nRespRow = m_listBillTo->FindByColumn(btcInsuredPartyID, rpc.InsuredPartyID, 0, FALSE);
						if (nRespRow != -1) {
							//found it, now grab it's date and insco name/type
							COleDateTime dtInactiveDate = VarDateTime(m_listBillTo->GetValue(nRespRow, btcInactiveDate), dtInvalid);

							//only perform this check if the insurance has an inactive date
							if (dtInactiveDate.GetStatus() != COleDateTime::invalid) {

								CString strInsuranceCoName = VarString(m_listBillTo->GetValue(nRespRow, btcInsuranceCoName), "");
								CString strRespTypeName = VarString(m_listBillTo->GetValue(nRespRow, btcRespName), "");
								long nRespTypeID = VarLong(m_listBillTo->GetValue(nRespRow, btcID), -1);

								//is either date invalid?
								dtFromDate.SetDateTime(dtFromDate.GetYear(), dtFromDate.GetMonth(), dtFromDate.GetDay(), 0, 0, 0);
								dtToDate.SetDateTime(dtToDate.GetYear(), dtToDate.GetMonth(), dtToDate.GetDay(), 0, 0, 0);
								dtInactiveDate.SetDateTime(dtInactiveDate.GetYear(), dtInactiveDate.GetMonth(), dtInactiveDate.GetDay(), 0, 0, 0);

								CString str;
								BOOL bInvalid = FALSE;
								if (dtInactiveDate < dtFromDate) {
									str.Format("has responsibility for %s (%s) "
										"which expire%s on %s, and the charge's service date is %s.",
										strInsuranceCoName, strRespTypeName, dtInactiveDate < COleDateTime::GetCurrentTime() ? "d" : "s",
										FormatDateTimeForInterface(dtInactiveDate, NULL, dtoDate),
										FormatDateTimeForInterface(dtFromDate, NULL, dtoDate));
									bInvalid = TRUE;
								}
								else if (dtInactiveDate < dtToDate) {
									str.Format("has responsibility for %s (%s) "
										"which expire%s on %s, and the charge's 'service date to' is %s.",
										strInsuranceCoName, strRespTypeName, dtInactiveDate < COleDateTime::GetCurrentTime() ? "d" : "s",
										FormatDateTimeForInterface(dtInactiveDate, NULL, dtoDate),
										FormatDateTimeForInterface(dtToDate, NULL, dtoDate));
									bInvalid = TRUE;
								}

								if (bInvalid) {
									// (j.jones 2009-12-28 14:54) - PLID 36324 - disallow new charges like this,
									// but warn and permit saving existing charges
									if (nChargeID == -2) {
										//new charge
										CString strWarn;
										strWarn.Format("At least one new charge on this bill %s\n\n"
											"This new charge cannot be saved, please correct this before saving the bill.", str);
										MsgBox(strWarn);
										return FALSE;
									}
									else if (bIsModified && !bWarnedAboutInactiveInsuranceCharges) {
										CString strWarn;
										strWarn.Format("At least one existing charge on this bill %s\n\n"
											"This charge should be corrected before saving the bill.\n"
											"Do you want to continue saving this bill?", str);
										if (IDNO == MessageBox(strWarn, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
											return FALSE;
										}

										//if they said yes, flag that we warned once, so we don't do it again
										bWarnedAboutInactiveInsuranceCharges = TRUE;
									}
								}
							}
						}
						else {
							//shouldn't this be impossible?
							ASSERT(FALSE);
						}
					}
				}
			}


			

			
			//if creating a package quote, warn them of the dangers of billing multiple quantities
			if (GetBillID() == -1 && m_EntryType == 2 && GetIsRepeatPackage() && dblQty != 1.0 && !bWarnedAboutPackageQty) {
				if (DontShowMeAgain(this, "Warning: Creating a repeat package with a quantity other than 1 on any charge may cause "
					"the total amount billed to not match up with the Practice total.\n"
					"(ie. The total amount billed may be a few cents less than the "
					"quoted total package amount.)\n\n"
					"Are you sure you wish to continue saving this package?", "PackageQuantity", "Packages", FALSE, TRUE) == IDNO) {
					return FALSE;
				}
				bWarnedAboutPackageQty = TRUE;
			}

			//if creating a package quote, warn them of the dangers of billing multiple quantities
			if (GetBillID() == -1 && m_EntryType == 2 && GetIsAnyPackage() && (nTotalPercentOff > 0 || cyTotalDollarDiscount > COleCurrency(0, 0)) && !bWarnedAboutPackageDiscounts) {
				if (DontShowMeAgain(this, "Warning: Creating a package with a discount or percent off will not pull "
					"the discount/percent off values into any bill created from this package.\n"
					"The discount and percent off fields are only used in packages for the purposes of "
					"calculating the initial package cost.\n"
					"Billing any package creates charges that are automatically reduced in value "
					"in order to add up to the total package cost you determine on this screen.\n\n"
					"Are you sure you wish to continue saving this package?", "PackageDiscounts", "Packages", FALSE, TRUE) == IDNO) {
					return FALSE;
				}
				bWarnedAboutPackageDiscounts = TRUE;
			}

			if (m_EntryType == 1 && IsSurgeryCenter(FALSE) && (bCheckAndWarnCredentials || bCheckAndWarnLicensing)) {
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				if ((VarLong(bi->ItemType) == ITEM_TYPE_CPT) && (eCredToWarn == ePassedAll || eLicenseToWarn == ePassedAll) &&
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					(nChargeID == -2 || !ReturnsRecordsParam("SELECT ID FROM ChargesT WHERE ID = {INT} AND DoctorsProviders = {INT}", nChargeID, VarLong(bi->Provider, -1)))) {
					if (bi->Provider.vt == VT_I4 && bi->ServiceID.vt == VT_I4) {
						long ProviderID = VarLong(bi->Provider);
						long CPTCodeID = VarLong(bi->ServiceID);
						_variant_t varGiftID = bi->GiftID;
						//DRT 4/7/2006 - PLID 11734 - Commented out this if/else... we're now only going to hit this code for CPT Codes, not gift certificates
						//TODO:  This is a workaround for the ProcCode situation at the moment.  When we get rid of the ProcCode field, we can
						//	fix this.
						//if(varGiftID.vt == VT_I4)m_bshow {
						//this is a gift certificate, so don't prompt
						//}
						//else 
						if (ProviderID != -1) {

							if (bCheckAndWarnCredentials) {

								ECredentialWarning eCredWarning = CheckServiceCodeCredential(ProviderID, CPTCodeID);

								if (eCredWarning != ePassedAll) {

									//it's not credentialed. Check the TOS status before we warn though.
									BOOL bWarn = TRUE;
									// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
									if (bWarnCredentialingTOS2 && !ReturnsRecordsParam("SELECT ID FROM CPTCodeT WHERE TypeOfService = '2' AND ID = {INT}", CPTCodeID))
										bWarn = FALSE;

									if (bWarn) {

										//we will warn the user about the most severe problem
										if (eCredWarning > eCredToWarn) {
											eCredToWarn = eCredWarning;
											nProviderToWarnCred = ProviderID;
										}
									}
								}
							}

							if (bCheckAndWarnLicensing) {

								ECredentialWarning eWarning = CheckPersonCertifications(ProviderID);

								if (eWarning != ePassedAll) {

									//it's not licensed
									eLicenseToWarn = eWarning;
									nProviderToWarnLicense = ProviderID;
								}
							}
						}
					}
				}
			}

			if (m_LocationCombo->GetCurSel() != -1) {
				long nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

				BOOL bValidateInvItem = FALSE;
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (nChargeID == -2 || !ReturnsRecordsParam("SELECT LocationID FROM LineItemT WHERE ID = {INT} AND LocationID = {INT}", nChargeID, nLocationID))
					bValidateInvItem = TRUE;
				//we want to warn if it's a new charge or if the location has changed while we edited this bill,
				//but we will not warn if it is an existing bill that has not been changed

				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (bValidateInvItem && (VarLong(bi->ItemType) == ITEM_TYPE_PRODUCT) && !ReturnsRecordsParam("SELECT ProductID FROM ProductLocationInfoT WHERE ProductID = {INT} AND LocationID = {INT} AND Billable = 1", VarLong(bi->ServiceID), nLocationID)
					&& !bWarnedAboutBillableItems) {
					if (IDNO == MessageBox("You have billed an inventory item that is not marked as billable for your selected location.\n"
						"Are you sure you want to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
					bWarnedAboutBillableItems = TRUE;
				}
			}


			// (j.gruber 2014-02-19 13:04) - PLID 60898 - use new whichcodes structure
			if (m_EntryType == 1 && GetRemotePropertyInt("WarnNoICD9OnBill", 0, 0, "<None>", TRUE) == 1) {
				if (nChargeID == -2 && (bi->whichCodes == NULL || bi->whichCodes->size() == 0)
					&& !bWarnedAboutICD9Codes) {
					if (IDNO == MessageBox("You have charges without any diagnosis codes assigned to them in the 'DiagCs' column.\n"
						"Are you sure you want to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
					bWarnedAboutICD9Codes = TRUE;
				}
			}

			if (m_EntryType == 1 && GetRemotePropertyInt("WarnBillDateInFuture", 1, 0, "<None>", TRUE) == 1) {
				if (nChargeID == -2 &&
					(VarDateTime(bi->Date, COleDateTime::GetCurrentTime()) > COleDateTime::GetCurrentTime()
					|| VarDateTime(bi->ServiceDateTo, COleDateTime::GetCurrentTime()) > COleDateTime::GetCurrentTime())
					&& !bWarnedAboutFutureDates) {
					if (IDNO == MessageBox("You have at least one charge with a date in the future.\n"
						"Are you sure you want to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
					bWarnedAboutFutureDates = TRUE;
				}
			}

			if (m_EntryType == 1 && nChargeID == -2 &&
				VarDateTime(bi->Date, COleDateTime::GetCurrentTime()) >
				VarDateTime(bi->ServiceDateTo, COleDateTime::GetCurrentTime())
				&& !bWarnedAboutMismatchedDates) {
				if (IDNO == MessageBox("You have at least one charge with a 'Service Date From' that is after the 'Service Date To'.\n"
					"Are you sure you want to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return FALSE;
				}
				bWarnedAboutMismatchedDates = TRUE;
			}
			
			
			// (j.jones 2008-05-30 11:33) - PLID 28898 - warn if they are saving outside fees on a package
			if (!bWarnedAboutOutsideFeesOnPackages
				&& m_EntryType == 2 && GetIsAnyPackage() && nChargeID == -2
				&& bi->OthrUnitCost.vt == VT_CY && VarCurrency(bi->OthrUnitCost) > COleCurrency(0, 0)
				&& bi->UnitCost.vt == VT_CY && VarCurrency(bi->UnitCost) == COleCurrency(0, 0)) {

				if (IDNO == MessageBox("You have at least one charge with an Outside Fee and no Pay To Practice fee.\n"
					"Outside Fee charges are ignored when a package is billed, and will not be treated as part of this package.\n\n"
					"Are you sure you want to continue saving this package?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return FALSE;
				}

				bWarnedAboutOutsideFeesOnPackages = TRUE;
			}

			// (j.jones 2012-07-23 14:37) - PLID 51698 - pull the pay group category from the CPT dropdown,
			// if the code isn't found we have to query the data
			// (j.jones 2012-07-25 14:10) - PLID 50487 - added office visit warnings, don't need to go into
			// this code unless that warning is enabled, and we haven't already warned on this save.
			// (j.jones 2012-12-06 11:35) - PLID 52637 - added surgical code warnings
			BOOL bNeedWarnOfficeVisitGlobalPeriod = !bAlreadyWarnedOfficeVisitGlobalPeriod && bWarnOfficeVisitGlobalPeriod;
			BOOL bNeedWarnSurgicalCodeGlobalPeriod = !bAlreadyWarnedSurgicalCodeGlobalPeriod && bWarnSurgicalCodeGlobalPeriod;
			if (m_EntryType == 1 && VarLong(bi->ItemType) == ITEM_TYPE_CPT
				&& (bNeedWarnOfficeVisitGlobalPeriod || bNeedWarnSurgicalCodeGlobalPeriod)) {

				long nServiceID = VarLong(bi->ServiceID, -1);
				if (nServiceID > 0){
					long iCptRow = FindCPTRowInComboByServiceID(nServiceID, false);
					PayGroupCategory::Category ePayGroupCategory = PayGroupCategory::NoCategory;
					if (iCptRow >= 0) {
						ePayGroupCategory = (PayGroupCategory::Category)VarLong(m_CPTCombo->GetValue(iCptRow, CPT_COLUMN_PAY_GROUP_CATEGORY), (long)PayGroupCategory::NoCategory);
					}
					else {
						//the CPT code isn't in the dropdown, possibly it is no longer active or billable
						_RecordsetPtr rsPayCat = CreateParamRecordset("SELECT ServicePayGroupsT.Category FROM ServiceT "
							"INNER JOIN ServicePayGroupsT ON ServiceT.PayGroupID = ServicePayGroupsT.ID "
							"WHERE ServiceT.ID = {INT}", nServiceID);
						if (!rsPayCat->eof) {
							ePayGroupCategory = (PayGroupCategory::Category)VarLong(rsPayCat->Fields->Item["Category"]->Value, (long)PayGroupCategory::NoCategory);
						}
						rsPayCat->Close();
					}

					// (j.jones 2012-07-25 14:02) - PLID 50487 - If this is an office visit code, see if the patient is
					// under an existing global period for this date of service, and if so, warn... UNLESS the 24
					// modifier is in use, in which case you do not need to warn at all.
					// (j.jones 2013-06-18 15:26) - PLID 57147 - modifiers 25 and 57 also disable the warning
					BOOL bWarnOfficeVisit = bNeedWarnOfficeVisitGlobalPeriod && ePayGroupCategory == PayGroupCategory::OfficeVisit
						&& !ContainsModifier("24", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""))
						&& !ContainsModifier("25", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""))
						&& !ContainsModifier("57", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""));

					// (j.jones 2012-12-06 11:35) - PLID 52637 - added surgical code warnings
					BOOL bWarnSurgicalCode = bNeedWarnSurgicalCodeGlobalPeriod && ePayGroupCategory == PayGroupCategory::SurgicalCode
						&& !ContainsModifier("58", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""))
						&& !ContainsModifier("78", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""))
						&& !ContainsModifier("79", VarString(bi->Modifier1, ""), VarString(bi->Modifier2, ""), VarString(bi->Modifier3, ""), VarString(bi->Modifier4, ""));

					if (bWarnOfficeVisit || bWarnSurgicalCode) {

						//At this point we know this is either an office visit, and the 24, 25, or 57 modifier is not in use,
						//or it is a surgical code an 58, 78, or 79 is not in use.

						//Now, is there a global period active?

						CString order = "ASC";
						if (GetRemotePropertyInt("GlobalPeriodSort", 0, 0, "<None>", TRUE) == 1) {
							order = "DESC";
						}

						//have to respect the preference to only warn about global periods for surgical codes
						long nSurgicalCodesOnly = GetRemotePropertyInt("GlobalPeriod_OnlySurgicalCodes", 1, 0, "<None>", true);

						// (j.jones 2012-07-26 12:15) - PLID 50489 - added another preference to NOT track global periods
						// if the charge uses modifier 78
						long nIgnoreModifier78 = GetRemotePropertyInt("GlobalPeriod_IgnoreModifier78", 1, 0, "<None>", true);

						//This is almost the same logic as used in CheckWarnGlobalPeriod(), except that
						//if the global period started on the same date as the charge we're checking, we
						//won't warn if this charge was input first. This will avoid warning in cases where
						//they entered an office visit on one bill and then added a global period-starting
						//charge on the same or successive bill with the same service date.
						_RecordsetPtr rsGlobalPeriod = CreateParamRecordset(FormatString("SELECT CPTCodeT.Code, "
							"ServiceT.Name, LineItemT.Date, CPTCodeT.GlobalPeriod, "
							"DATEADD(day,GlobalPeriod,LineItemT.Date) AS ExpDate "
							"FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
							"INNER JOIN CPTCodeT ON ChargesT.ServiceID = CPTCodeT.ID "
							"INNER JOIN ServiceT ON CPTCodeT.ID = ServiceT.ID "
							"LEFT JOIN ServicePayGroupsT ON ServiceT.PayGroupID = ServicePayGroupsT.ID "
							"LEFT JOIN (SELECT OriginalLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_OriginalLineItemsQ ON LineItemT.ID = LineItemCorrections_OriginalLineItemsQ.OriginalLineItemID "
							"LEFT JOIN (SELECT VoidingLineItemID FROM LineItemCorrectionsT) AS LineItemCorrections_VoidingLineItemsQ ON LineItemT.ID = LineItemCorrections_VoidingLineItemsQ.VoidingLineItemID "
							"WHERE LineItemT.Deleted = 0 AND LineItemT.Type = 10 AND GlobalPeriod Is Not Null AND CPTCodeT.GlobalPeriod <> 0 AND "
							//look to see if the global period's date ends after this service date
							"dbo.AsDateNoTime(DATEADD(day,GlobalPeriod,LineItemT.Date)) > dbo.AsDateNoTime({OLEDATETIME}) "
							//then look to see if the global period's date starts before this service date
							"AND (dbo.AsDateNoTime(LineItemT.Date) < dbo.AsDateNoTime({OLEDATETIME}) OR "
							//or, in the case where the global period started on the same date,
							//look to see if the input date is prior to this charge (not needed if the charge is new)
							"	(dbo.AsDateNoTime(LineItemT.Date) = dbo.AsDateNoTime({OLEDATETIME}) AND ({INT} = -2 OR LineItemT.InputDate < {OLEDATETIME}))) "
							"AND LineItemT.PatientID = {INT} "
							"AND LineItemCorrections_OriginalLineItemsQ.OriginalLineItemID Is Null "
							"AND LineItemCorrections_VoidingLineItemsQ.VoidingLineItemID Is Null "
							"AND ({INT} <> 1 OR ServicePayGroupsT.Category = {CONST}) "
							"AND ({INT} <> 1 OR (Coalesce(ChargesT.CPTModifier, '') <> '78' AND Coalesce(ChargesT.CPTModifier2, '') <> '78' AND Coalesce(ChargesT.CPTModifier3, '') <> '78' AND Coalesce(ChargesT.CPTModifier4, '') <> '78')) "
							"ORDER BY DATEADD(day,GlobalPeriod,LineItemT.Date) %s", order),
							VarDateTime(bi->Date), VarDateTime(bi->Date), VarDateTime(bi->Date),
							VarLong(bi->ChargeID, -1), VarDateTime(bi->InputDate, COleDateTime::GetCurrentTime()),
							m_nPatientID, nSurgicalCodesOnly, PayGroupCategory::SurgicalCode, nIgnoreModifier78);
						CString strGlobals = "";
						while (!rsGlobalPeriod->eof) {

							CString strCPTCode = AdoFldString(rsGlobalPeriod, "Code", "");
							CString strCPTDesc = AdoFldString(rsGlobalPeriod, "Name", "");
							long nGlobalPeriod = AdoFldLong(rsGlobalPeriod, "GlobalPeriod");
							COleDateTime dtServiceDate = AdoFldDateTime(rsGlobalPeriod, "Date");
							COleDateTime dtExpDate = AdoFldDateTime(rsGlobalPeriod, "ExpDate");

							CString strServiceDate = FormatDateTimeForInterface(dtServiceDate);
							CString strExpDate = FormatDateTimeForInterface(dtExpDate);

							CString str;
							str.Format("\n\nService Code: (%s) %s, Service Date: %s, Global Period: %li days, Expires: %s",
								strCPTCode, strCPTDesc, strServiceDate, nGlobalPeriod, strExpDate);

							strGlobals += str;

							rsGlobalPeriod->MoveNext();
						}
						rsGlobalPeriod->Close();

						if (!strGlobals.IsEmpty()) {

							CString strCode = VarString(bi->CPTCode, "");
							CString strChargeDesc = VarString(bi->Description, "");
							CString strChargeInfo = strCode;
							if (!strChargeInfo.IsEmpty() && !strChargeDesc.IsEmpty()) {
								strChargeInfo += " - ";
							}
							strChargeInfo += strChargeDesc;

							if (bWarnOfficeVisit) {

								bAlreadyWarnedOfficeVisitGlobalPeriod = TRUE;

								// (j.jones 2013-06-18 15:26) - PLID 57147 - modifiers 25 and 57 also disable the warning
								CString strWarning;
								strWarning.Format("This patient is still under the global period for:"
									"%s\n\n"
									"The charge for %s is an office visit code and should not be billed within a global period "
									"unless modifier 24, 25, or 57 is used.\n\n"
									"Are you sure you wish to save this charge?", strGlobals, strChargeInfo);
								if (IDNO == MessageBox(strWarning, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
									return FALSE;
								}
							}
							// (j.jones 2012-12-06 11:35) - PLID 52637 - added surgical code warnings
							else if (bWarnSurgicalCode) {

								bAlreadyWarnedSurgicalCodeGlobalPeriod = TRUE;

								CString strWarning;
								strWarning.Format("This patient is still under the global period for:"
									"%s\n\n"
									"The charge for %s is a surgical code and should not be billed within a global period "
									"unless modifiers 58, 78, or 79 are used.\n\n"
									"Are you sure you wish to save this charge?", strGlobals, strChargeInfo);
								if (IDNO == MessageBox(strWarning, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
									return FALSE;
								}
							}
						}
					}
				}
			}

			// (j.dinatale 2012-06-22 14:00) - PLID 51138 - need to check for NOC codes and ensure they have an NDC code associated
			if (bWarnAboutNoNDCPreference && !bWarnAboutNoNDC && m_EntryType == 1 && VarLong(bi->ItemType) == ITEM_TYPE_CPT){
				long nServiceID = VarLong(bi->ServiceID, -1);
				if (nServiceID > 0){
					long iCptRow = FindCPTRowInComboByServiceID(nServiceID, false);
					if (iCptRow >= 0){
						BOOL bNOCCode = VarBool(m_CPTCombo->GetValue(iCptRow, CPT_COLUMN_ISNOC), FALSE);
						CString strNDCCode = VarString(bi->NDCCode, "");
						strNDCCode.Trim();
						if (strNDCCode.IsEmpty() && bNOCCode){
							bWarnAboutNoNDC = true;
						}
					}
				}
			}
		}
		
		// (s.tullis 2015-03-27 14:23) - PLID 64976 - Tell the user they need to fix their category assignments
		if (bWarnAboutNoCPTCategorySel){
			CString strWarningMessage = GetMultCategoryCPTWarning(arrNoCPTCatSelCharges);
			MessageBox(strWarningMessage, "Practice", MB_ICONEXCLAMATION);
			return FALSE;
		}

		// (j.dinatale 2012-06-22 16:09) - PLID 51138 - show the warning box! and if we aren't read only show the additional charge 
		if (bWarnAboutNoNDC){
			CString strNDCWarningMessage =
				"A 'Not Otherwise Classified' (NOC) code has been billed with no NDC code specified. "
				"This could cause problems when submitting claims. "
				"Are you sure you want to continue saving this bill?";
			if (IDNO == MsgBox(MB_YESNO, strNDCWarningMessage)){
				if (m_eHasAccess != batNoAccess){
					this->PostMessage(WM_SHOW_ADD_CHARGES);
				}
				return FALSE;
			}
		}

		//now warn about credentialing
		CString str;

		if (bCheckAndWarnCredentials && eCredToWarn == eFailedCredential) {

			str.Format("You have at least one Service code that your provider is not credentialed for.\n"
				"Are you sure you want to continue saving this bill?");

			if (eCredToWarn != ePassedAll && IDNO == MsgBox(MB_YESNO, str)) {
				return FALSE;
			}
		}

		if (bCheckAndWarnLicensing && eLicenseToWarn != ePassedAll) {

			if (eLicenseToWarn == eFailedLicenseExpired) {

				CString strLicenses;
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs2 = CreateParamRecordset("SELECT '''' + Name + ''' - Expired: ' + Convert(nvarchar,ExpDate,1) AS ExpiredLicense FROM PersonCertificationsT "
					"WHERE PersonID = {INT} AND ExpDate < Convert(datetime,(Convert(nvarchar,GetDate(),1)))", nProviderToWarnLicense);
				while (!rs2->eof) {
					strLicenses += AdoFldString(rs2, "ExpiredLicense", "");
					strLicenses += "\n";
					rs2->MoveNext();
				}
				rs2->Close();

				str.Format("The selected provider has the following expired licenses:\n\n%s\n"
					"Do you still wish to save this bill?", strLicenses);
			}
			else if (eLicenseToWarn == eFailedLicenseExpiringSoon) {

				//check if a license will expire within the given day range
				long nLicenseWarnDayRange = GetRemotePropertyInt("DefaultASCLicenseWarnDayRange", 30, 0, "<None>", true);

				CString strLicenses;
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs2 = CreateParamRecordset("SELECT '''' + Name + ''' - Expires on: ' + Convert(nvarchar,ExpDate,1) AS ExpiredLicense FROM PersonCertificationsT "
					"WHERE PersonID = {INT} AND ExpDate < DateAdd(day,{INT},Convert(datetime,(Convert(nvarchar,GetDate(),1))))", nProviderToWarnLicense, nLicenseWarnDayRange);
				while (!rs2->eof) {
					strLicenses += AdoFldString(rs2, "ExpiredLicense", "");
					strLicenses += "\n";
					rs2->MoveNext();
				}
				rs2->Close();

				str.Format("The following licenses are about to expire for the selected provider:\n\n%s\n"
					"Do you still wish to save this bill?", strLicenses);
			}

			if (eLicenseToWarn != ePassedAll && IDNO == MsgBox(MB_YESNO, str)) {
				return FALSE;
			}
		}

		if (m_EntryType == 1) {

			// (j.jones 2008-02-12 12:01) - PLID 28848 - we now can have cases where practice auto-unchecked
			// the batched status on charges, and in turn allows bills to be fully unbatched
			BOOL bHidePatientChargesOnClaims = (GetRemotePropertyInt("DisallowBatchingPatientClaims", 0, 0, "<None>", TRUE) == 1 &&
				GetRemotePropertyInt("HidePatientChargesOnClaims", 0, 0, "<None>", TRUE) == 1);

			//skip validating the batched status if these preferences are enabled
			if (!bHidePatientChargesOnClaims) {

				//If no charges are marked as batched, do NOT allow saving of the bill
				if (!bAreAnyBatched) {
					MsgBox("None of the charges on this bill are marked as Batched.\n"
						"At least one charge must be marked as Batched before the bill can be saved.");
					return FALSE;
				}

				//on new bills, warn the user if any charges are not marked as being batched
				if (GetBillID() == -1 && !bAreAllBatched) {
					if (IDNO == MessageBox("You have at least one charge marked as being not Batched.\n"
						"This charge will not be included on any claim forms.\n\n"
						"Are you sure you wish to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
				}
			}
		}

		// (j.jones 2005-11-02 13:44) - PLID 18180 - warn if there is no appointment on the same date as the bill
		if (m_EntryType == 1 && GetRemotePropertyInt("WarnNoApptOnBillDate", 0, 0, "<None>", TRUE) == 1) {

			// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
			COleDateTime dtBillDate = (m_peditBillDate->GetValue());

			//only warn on new bills, or if the date has changed
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (GetBillID() == -1 || !ReturnsRecordsParam("SELECT ID FROM BillsT WHERE ID = {INT} AND Date = {OLEDATETIME}", GetBillID(), AsDateNoTime(dtBillDate))) {

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (!ReturnsRecordsParam("SELECT ID FROM AppointmentsT WHERE Status <> 4 AND ShowState <> 3 "
					"AND PatientID = {INT} AND Date = {OLEDATETIME}", m_nPatientID, AsDateNoTime(dtBillDate))) {
					if (IDNO == MessageBox("This patient has no appointments on the same date as the bill.\n"
						"Are you sure you wish to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
				}
			}
		}

		//DRT 5/23/03 - Make sure there is no insurance total > the charge total, that doesn't make sense!
		if (m_EntryType == 1) {
			//DRT 6/10/03 - only do this for bills
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			int i = 0;
			for (i = 0; i < (int)m_billingItems.size(); i++) {
				BillingItemPtr bi = m_billingItems[i];
				long nChargeID = VarLong(bi->ChargeID, -2);

				// (j.jones 2011-08-24 09:51) - PLID 44873 - a void charge is negative, and throws
				// off this calculation, so skip this check only when IsVoidingCharge is true
				if (VarBool(bi->IsVoidingCharge, FALSE)) {
					continue;
				}

				COleCurrency cyTotal = VarCurrency(bi->LineTotal);
				COleCurrency cyCnt = COleCurrency(0, 0);
				for (int j = 0; j < bi->RPCList->aryRPC.GetSize(); j++) {
					RespPerCharge rpc = bi->RPCList->aryRPC.GetAt(j);

					if (rpc.InsAmount.vt == VT_CY && VarCurrency(rpc.InsAmount) > cyTotal && VarCurrency(rpc.InsAmount) != COleCurrency(0, 0)) {
						//DRT 6/10/03 - must be non-zero insurance to bother checking as well
						MsgBox("You have an insurance amount which is greater than its line total.  Please fix this and attempt saving again.");
						return FALSE;
					}

					//add this resp into our count
					if (rpc.InsAmount.vt == VT_CY)
						cyCnt += VarCurrency(rpc.InsAmount);

					//check to see that there are not more applies than the new amount, for insurance only
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT Sum(Amount) AS ApplyTotal FROM AppliesT INNER JOIN PaymentsT ON AppliesT.SourceID = PaymentsT.ID "
						"INNER JOIN InsuredPartyT ON PaymentsT.InsuredPartyID = InsuredPartyT.PersonID "
						"WHERE DestID = {INT} AND InsuredPartyT.PersonID = {INT}", nChargeID, VarLong(rpc.InsuredPartyID, -1));
					if (!rs->eof) {
						COleCurrency cyApplied = AdoFldCurrency(rs, "ApplyTotal", COleCurrency(0, 0));
						COleCurrency cyTotal = VarCurrency(rpc.InsAmount, COleCurrency(0, 0));
						if (cyApplied > cyTotal) {
							MsgBox("You have a charge with an insurance total less than the amount of applied payments for that responsibility.\n"
								"Please fix this amount before saving.");
							return FALSE;
						}
					}
				}

				//if we haven't got an error, make sure that the total of all insurance for this charge (cyCnt) is not > the total (cyTotal)
				if (cyCnt > cyTotal) {
					MsgBox("You have a charge where the total of all insurance responsibility is greater than the line total.  Please fix this and attempt saving again.");
					return FALSE;
				}
			}

			//check charges in a separate loop, because we only want to ask once
			for (i = 0; i < (int)m_billingItems.size(); i++) {
				BillingItemPtr bi = m_billingItems[i];
				long nChargeID = VarLong(bi->ChargeID, -2);
				//on only new charges, check the doctor ID
				long nProviderID = -1;
				if (bi->Provider.vt == VT_I4)
					nProviderID = VarLong(bi->Provider);
				if (nChargeID == -2 && nProviderID == -1) {
					// (j.jones 2011-07-08 17:36) - PLID 32067 - added pref. to force selection of a provider
					if (GetRemotePropertyInt("RequireProviderOnCharges", 1, 0, "<None>", true) == 1) {
						MessageBox("You have at least one charge without a provider. All new charges must have providers selected.", "Practice", MB_ICONEXCLAMATION | MB_OK);
						return FALSE;
					}
					else if (IDNO == MessageBox("You have at least one charge without a provider. Are you sure you wish to continue saving this bill?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
						return FALSE;
					}
					break;
				}

				//check to see that there are not more applies than the new amount, for patients only		
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Sum(Amount) AS ApplyTotal FROM AppliesT INNER JOIN PaymentsT ON AppliesT.SourceID = PaymentsT.ID "
					"WHERE DestID = {INT} AND (PaymentsT.InsuredPartyID = -1 OR PaymentsT.InsuredPartyID Is Null)", nChargeID);
				if (!rs->eof) {
					COleCurrency cyApplied = AdoFldCurrency(rs, "ApplyTotal", COleCurrency(0, 0));

					//calculate the patient total
					COleCurrency cyPatientTotal = (bi->LineTotal.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(bi->LineTotal, COleCurrency(0, 0));
					RPCList* list = bi->RPCList;
					for (int j = 0; j < list->aryRPC.GetSize(); j++) {
						RespPerCharge rpc = list->aryRPC.GetAt(j);
						cyPatientTotal -= (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));
					}

					if (cyApplied > cyPatientTotal) {
						MsgBox("You have a charge with a patient total less than the amount of applied patient payments.\n"
							"Please fix this amount before saving.");
						return FALSE;
					}
				}
			}
		}

		// (j.jones 2013-07-12 09:35) - PLID 57148 - warn about invalid invoice numbers
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
			if (!((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.ValidateInvoiceNumber(true)) {
				return FALSE;
			}
		}


		return TRUE;

	}NxCatchAll("Error in ValidateChanges()");

	return FALSE;
}

void CBillingDlg::SetAllChargesToBeUnsaved()
{
	// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
	int i = 0;

	// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {
		pRow->PutValue(1, (long)-2);

		pRow = pRow->GetNextRow();
	}

	for (i = 0; i < (int)m_billingItems.size(); i++) {
		m_billingItems[i]->ChargeID = (long)-2;
	}

	m_adwEditedCharges.RemoveAll();
}

void CBillingDlg::CalcExpireDate() {

	COleDateTime dt = (COleDateTime)m_peditBillDate->GetValue();
	COleDateTimeSpan dtSpan;
	dtSpan.SetDateTimeSpan(GetDlgItemInt(IDC_QUOTE_EXP_DAYS), 0, 0, 0);

	dt += dtSpan;

	CString strDate = FormatDateTimeForInterface(dt, NULL, dtoDate);
	SetDlgItemText(IDC_QUOTE_EXPIRE_DATE, strDate);
}

void CBillingDlg::OnKillfocusQuoteExpDays()
{
	CalcExpireDate();
}

void CBillingDlg::OnEditCPT()
{
	//DRT 4/4/03 - Removed the requirement for accessing the admin module - really they may not want permission
	//		to the admin module, but still do want permissions to access the cpt codes.
	//if (!UserPermission(AdministratorModuleItem) || !CheckCurrentUserPermissions(bioAdminBilling,sptRead))
	if (!CheckCurrentUserPermissions(bioAdminBilling, sptRead))
		return;

	CCPTCodes cpt(this);
	//(e.lally 2006-10-23) PLID 22936 - We need to set this modal flag so that the loading code get executed
	//in the initialization.
	cpt.m_IsModal = TRUE;
	CNxModalParentDlg dlg(this, &cpt, CString("Billing Codes"));
	dlg.DoModal();

	try {

		if (m_CPTCodeChecker.Changed()) {

			//don't bother requerying if it hasn't been loaded the first time yet
			if (m_bCPTCombo) {
				//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
				m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
				m_CPTCombo->Requery();
				m_bCPTCombo = TRUE;
			}

			// (j.jones 2006-11-06 16:33) - PLID 22534 - also reload the cpt list on the insurance tab
			if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
				long nCurSel = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->GetCurSel();
				long nBox44ID = -1;
				CString strText = "";
				if (nCurSel != -1) {
					nBox44ID = VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->GetValue(nCurSel, 0), -1);
				}
				else if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->IsComboBoxTextInUse) {
					strText = AsString(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->GetComboBoxText());
				}

				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->Requery();

				NXDATALISTLib::IRowSettingsPtr pRow;
				pRow = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->GetRow(-1);
				pRow->PutValue(0, (long)-1);
				pRow->PutValue(1, "<None>");
				pRow->PutValue(2, "");
				pRow->PutValue(3, "<No Code Selected>");
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->InsertRow(pRow, 0);

				if (nBox44ID != -1) {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_nPendingUB92Box44ID = nBox44ID;
					if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->TrySetSelByColumn(0, nBox44ID) == -1) {
						//they may have an inactive code
						((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->PutCurSel(sriNoRow);
						// Now go ahead and set the combo box text to the name of the desired selection.
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rsCPT = CreateParamRecordset("SELECT Code FROM CPTCodeT WHERE ID = {INT}", nBox44ID);
						if (!rsCPT->eof) {
							((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->PutComboBoxText(_bstr_t(AdoFldString(rsCPT, "Code", "")));
						}
						rsCPT->Close();
					}
				}
				else if (!strText.IsEmpty()) {
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pUB92Box44List->PutComboBoxText(_bstr_t(strText));
				}
			}
		}

		if (m_ModiferChecker.Changed())
		{

			// (j.jones 2011-10-06 11:11) - PLID 44941 - we need to reload our modifier lists,
			// which work completely differently for Alberta billing than for regular US billing
			if (UseAlbertaHLINK()) {

				//clear the existing map
				m_mapAlbertaServiceIDToModifierComboSource.RemoveAll();

				//this should NOT update existing charges, they would need to change the modifiers to alter the cost
			}
			else {
				//normal US billing

				// (j.jones 2011-10-06 10:23) - PLID 44941 - recreate the stored m_pfsCPTModifierComboSource
				RefreshCPTModifierComboSource();

				//any rows pointing to this source should auto-requery when the source is changed
			}

			// (j.jones 2007-07-03 16:31) - PLID 26098 - clear out the linked array and rebuild from data
			PopulateServiceModifierLinkArray();
		}

		// (j.jones 2008-05-01 13:48) - PLID 29868 - quotes don't have diag codes,
		// so ignore the tablechecker if on a quote
#pragma TODO("update below to use new diag code controls")
		if (m_DiagCodeChecker.Changed() && m_EntryType == 1) {
			// (b.spivey, February 27, 2014) - PLID 61081 - Update the interface and array
			UpdateDiagnosisCodesReflectDatabase();
			BuildWhichCodesCombo();
		}
	}NxCatchAll("Error refreshing diag codes.");

	//ResizeColumns();
}

void CBillingDlg::OnEditInventory()
{
	if (!CheckCurrentUserPermissions(bioInvItem, sptView))
		return;

	CInvEditDlg inv(this);
	inv.m_bPopup = true;
	CNxModalParentDlg dlg(this, &inv, CString("Inventory Items"), CRect(0, 0, 1024, 600)); // (r.goldschmidt 2014-06-23 17:24) - PLID 47280 - make dialog wider
	dlg.DoModal();

	try {
		_variant_t var, diag1, diag2, diag3, diag4;

		//don't bother requerying if it hasn't been loaded the first time yet
		if (m_ProductChecker.Changed()) {

			if (m_bProductsCombo) {
				// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
				RequeryProductCombo();
			}

			// (j.jones 2008-01-08 09:14) - PLID 28479 - reload allocations *only*
			// if we haven't started using any on this bill
			if (m_paryAllocationInfo.GetSize() == 0) {
				PopulateProductToAllocationArray();
			}
		}

	}NxCatchAll("Error refreshing inventory items.");
}

void CBillingDlg::SetChargeComboFocus()
{
	CString strSelItem;

	CWaitCursor wait;

	if (m_WhatToAddCombo->GetCurSel() == -1)
		return;

	long sel = VarLong(m_WhatToAddCombo->GetValue(m_WhatToAddCombo->CurSel, 0), 0);
	if ((m_EntryType == 1 && sel == ROW_BILL_A_CPT_CODE) || (m_EntryType == 2 && sel == ROW_QUOTE_A_CPT_CODE)) {
		GetDlgItem(IDC_COMBO_CPT)->SetFocus();
	}
	// (j.jones 2010-01-06 15:48) - PLID 36757 - we now have a separate quote option for packages
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_SURGERY) ||
		(m_EntryType == 2 && (sel == ROW_QUOTE_A_SURGERY || sel == ROW_QUOTE_A_PACKAGE))) {
		GetDlgItem(IDC_COMBO_SRGY)->SetFocus();
	}
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_PRODUCT) || (m_EntryType == 2 && sel == ROW_QUOTE_A_PRODUCT)) {
		GetDlgItem(IDC_COMBO_PRODUCTS)->SetFocus();
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_QUOTE) {
		GetDlgItem(IDC_COMBO_QUOTE)->SetFocus();
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_CASE) {
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->SetFocus();
	}
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_EMR) || (m_EntryType == 2 && sel == ROW_QUOTE_A_EMR)) {
		GetDlgItem(IDC_COMBO_EMR)->SetFocus();
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_GIFT) {
		GetDlgItem(IDC_COMBO_GIFT)->SetFocus();
	}
	// (j.jones 2008-06-20 10:40) - PLID 26153 - added appointments
	else if ((m_EntryType == 1 && sel == ROW_BILL_AN_APPT) || (m_EntryType == 2 && sel == ROW_QUOTE_AN_APPT)) {
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->SetFocus();
	}
	//TES 4/13/2011 - PLID 43249 - Added Glasses Orders
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_GLASSES_ORDER)) {
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->SetFocus();
	}
}

// (j.jones 2008-06-11 12:19) - PLID 28379 - now returns a BillingItem pointer for the row we modified
BillingItemPtr CBillingDlg::CheckIncreaseDuplicateChargeQuantity(long ServiceID, BOOL bProduct, double dblAmountToIncrease /*= 1.0*/, BOOL bAutoAddingSerialNum /*= FALSE*/)
{
	//if they get warned about being unable to increase the product items,
	//keep looping to see if there is a charge they CAN increase, but only warn them one time
	BOOL bWarned = FALSE;

	//DRT 5/5/2004 - PLID 12207 - We should be able to do the same for quotes as well!  We have to specify a 
	//	list of variables for the columns, since they can be different depending what list you are in
	int nServiceColumn = -1, nQtyColumn = -1, nProdItemID = -1, nLineID = -1, nChargeID = -1;
	if (m_EntryType == 1) {
		nServiceColumn = COLUMN_SERVICE_ID;
		nQtyColumn = BILL_COLUMN_QUANTITY;
		nProdItemID = COLUMN_PRODUCT_ITEM_ID;
		nLineID = COLUMN_LINE_ID;
		nChargeID = COLUMN_CHARGE_ID;
	}
	else if (m_EntryType == 2) {
		nServiceColumn = QUOTE_COLUMN_SERVICE_ID;
		nQtyColumn = QUOTE_COLUMN_QUANTITY;
		nProdItemID = -1;
		nLineID = COLUMN_LINE_ID;
		nChargeID = COLUMN_CHARGE_ID;
	}
	else
		return BillingItemPtr();	//??

	// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {
		if (pRow->GetValue(nServiceColumn).lVal == ServiceID)
		{
			m_pList->CurSel = pRow;

			// (j.jones 2011-01-25 14:58) - PLID 42156 - check permissions, if they can't edit the charge,
			// leave, and just add the charge new (in the unlikely event that the same product exists more
			// than once, they'll just have to deal with it, since the alternative is multiple permission
			// prompts)
			// (j.jones 2011-08-24 08:41) - PLID 44868 - you cannot edit original and void charges
			if (m_EntryType == 1) {
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				if (nChargeID != -2) {
					if (IsOriginalOrVoidCharge(nChargeID) ||
						!CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
						return BillingItemPtr();
					}
				}
			}

			// We found the inventory item in the list! Increment the quantity
			double dblOldQty = VarDouble(pRow->GetValue(nQtyColumn));
			double dblNewQty = dblOldQty + dblAmountToIncrease;

			// (j.jones 2008-06-11 17:58) - PLID 28379 - skip this code if we're auto-adding a serial number
			if (m_EntryType == 1 && bProduct && !bAutoAddingSerialNum) {
				//if there are charged product items
				if (VarLong(pRow->GetValue(nProdItemID), -1) != -1) {
					//then change them
					if (!ChangeProductItems(dblNewQty))
						dblNewQty = dblOldQty;
				}
				else {
					//if they are increasing the quantity but now it needs serialized information, yell at them.
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (!bWarned && ReturnsRecordsParam("SELECT ID FROM ProductT WHERE (HasSerialNum = 1 OR HasExpDate = 1) "
						"AND ID = {INT}", ServiceID)
						&& dblOldQty < dblNewQty) {

						BOOL bSkip = FALSE;

						//quickly check and see if there is any other charge on this bill that it will auto-update successfully
						// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
						IRowSettingsPtr pLoopRow = pRow;
						while (pLoopRow) {
							if (pLoopRow->GetValue(nServiceColumn).lVal == ServiceID
								&& VarLong(pLoopRow->GetValue(nProdItemID), -1) != -1) {

								//there is another... Skywalker... I mean, a charge that we can legitimately increase
								bSkip = TRUE;
							}

							pLoopRow = pLoopRow->GetNextRow();
						}

						if (!bSkip) {
							AfxMessageBox("The product you are adding exists on this bill, but has been set up to use a serial number or expiration date, after the original charge was created.\n"
								"The existing charge on this bill is not using a serial number or expiration date, but any changes to the quantity would require that information.\n\n"
								"Practice requires you to make a new charge for this product if you wish to change the quantity. This new charge will be created automatically.");
							bWarned = TRUE;
						}
						continue;
					}
				}
			}

			pRow->PutValue(nQtyColumn, dblNewQty);

			BillingItemPtr pLineItem;

			for (int j = 0; j < (int)m_billingItems.size(); j++) {
				if (m_billingItems[j]->LineID.lVal == pRow->GetValue(nLineID).lVal) {
					m_billingItems[j]->Quantity = (double)dblNewQty;

					if ((GetIsMultiUsePackage() && (GetBillID() == -1 || (!m_bQuoteHasBeenBilled && m_boInitialized)))
						|| !GetIsMultiUsePackage()) {
						//if a multi-use package, only update if new/unbilled, otherwise update at all times (it won't be used anyways)
						m_billingItems[j]->PackageQtyRemaining = (double)dblNewQty;

						// (j.jones 2009-12-22 16:53) - PLID 32587 - also update the original qty. rem. column
						m_billingItems[j]->OriginalPackageQtyRemaining = (double)dblNewQty;
					}

					// (j.jones 2008-06-11 12:24) - PLID 28379 - track this line item
					pLineItem = m_billingItems[j];
				}
			}

			if (bProduct) {
				long LocationID = -1;
				if (m_LocationCombo->GetCurSel() == -1)
					LocationID = GetCurrentLocationID();
				else
					LocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

				// (j.jones 2007-12-18 12:01) - PLID 28037 - DoIHaveEnough changed to support allocations,
				InvUtils::DoIHaveEnough(
					ServiceID,
					LocationID,
					-GetUnsavedQuantityCount(ServiceID),
					-GetUnsavedAllocationQuantityCount(ServiceID),
					m_EntryType == 2);
			}

			// Calculate the line total

			m_varBoundItem = pRow->GetValue(nLineID);

			// CAH
			COleVariant varChargeID = pRow->GetValue(nChargeID);
			if (varChargeID.lVal != -2)
			{
				AddToModifiedList(varChargeID.lVal);
			}

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);
			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			return pLineItem;
		}

		pRow = pRow->GetNextRow();
	}

	return BillingItemPtr();
}

void CBillingDlg::OnEditCPTInsNotes()
{
	CCPTCodeInsNotesDlg dlg(this);
	//try to use the patient's primary insurance
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rs = CreateParamRecordset("SELECT InsuranceCoID FROM InsuredPartyT WHERE PersonID = {INT}", m_GuarantorID1);
	if (!rs->eof) {
		dlg.m_nInsCoID = AdoFldLong(rs, "InsuranceCoID", -1);
	}
	rs->Close();
	dlg.DoModal();
}

// (d.thompson 2012-09-25) - PLID 52822 - In PLID 33666, we stopped saving the size of the whichcodes column.  This means that
//	no longer is the calculated & saved column string array the same as what's in the interface.  There's also been no way 
//	to know what the size should be.  This function solves that, unfortunately by just hardcoded documentation of the fact.  If
//	anyone ever adds another un-saved column (and I beg you not to do this again), then just increase the count here.
long CBillingDlg::GetSaveableColumnCount()
{
	if (m_EntryType == 1)
	{
		//-1 for the unsaved whichcodes column
		return m_List->GetColumnCount() - 1;
	}
	else
	{
		//Quote has no unsaved columns, return the real size
		return m_QuoteList->GetColumnCount();
	}
}

// (d.thompson 2012-09-24) - PLID 52822 - Goes along with the below GetColumnWidth() function -- give a string of stored
//	columns widths, in a csv format, count how many there are.
long CBillingDlg::GetColumnCount(const CString& strColWidths)
{
	if (strColWidths.IsEmpty())
	{
		return 0;
	}

	CArray<long, long> cols;
	ParseDelimitedStringToLongArray(strColWidths, ",", cols);
	return cols.GetSize();
}

long CBillingDlg::GetColumnWidth(const CString& strColWidths, short nColumnVal)
{
	CString str;
	int nIndex = 0, nEndIndex = 0;
	short nColumn = 0;

	// (b.savon 2012-05-31 16:07) - PLID 50570 - ONLY DO THIS IF WE ARE IN THE "Billing" DIALOG - m_EntryType == 1 is Billing, 2 is Quotes
	// (s.dhole 2011-05-23 13:57) - PLID 33666 if colun value >BILL_COLUMN_WHICH_CODES then add offset -1 to support old structure
	if (nColumnVal > BILL_COLUMN_WHICH_CODES && m_EntryType == 1)
		nColumn = nColumnVal - 1;
	else
		nColumn = nColumnVal;
	for (short i = 0; i < nColumn && nIndex != -1; i++)
	{
		nIndex = strColWidths.Find(',', nIndex + 1);
	}
	if (nIndex == -1)
		return -1;
	nEndIndex = strColWidths.Find(',', nIndex + 1);
	if (nEndIndex == -1)
		nEndIndex = strColWidths.GetLength();
	str = strColWidths.Mid(nIndex == 0 ? 0 : (nIndex + 1), nEndIndex - (nIndex == 0 ? 0 : nIndex + 1));
	long nWidth = atoi(str);

	// (z.manning 2008-06-10 17:02) - PLID 27392 - There used to be a bug where the insurance resp
	// amount column would make itself bigger on its own, so just in case anyone has a remembered
	// column width for this column that's needlessly large, we'll resize it down to the default.
	// This will also make it impossible to make this column larger than 300 pixels, but that is way
	// larger than this column would ever practically need to be anyway.
	if (nColumnVal == COLUMN_INS_RESP && nWidth > 300) {
		nWidth = 74;
	}

	return nWidth;
}
void CBillingDlg::OnBtnEditPosCodes()
{
	try {

		_variant_t var;
		if (m_DesignationCombo->CurSel != -1) {
			var = m_DesignationCombo->GetValue(m_DesignationCombo->GetCurSel(), posdcID);
		}

		CPlaceCodeDlg dlg(this);
		dlg.DoModal();

		m_DesignationCombo->Requery();

		if (var.vt != VT_NULL)
			m_DesignationCombo->SetSelByColumn(posdcID, var);

	}NxCatchAll("Error setting POS Designation.");
}

// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to break out the logic for billing an EMR
void CBillingDlg::BillEMR(long EMRID, bool bBillEntireEMR)
{
	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return;
	}

	// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
	CMaintainFocus maintainFocus(__FUNCTION__);

	CWaitCursor pWait;

	EnsureRemoteData();

	_RecordsetPtr rs, rsTrack, rsDtls;
	CString str;
	long AuditID = -1;

	//TODO: Determine data structure and figure out if the charges have been billed before
	long nInsuredPartyID = -1;
	CString strRespTypeName = "Patient";
	if (m_EntryType == 1) {
		NXDATALISTLib::IRowSettingsPtr pRespRow = m_listBillTo->GetRow(m_listBillTo->CurSel);
		nInsuredPartyID = pRespRow->GetValue(btcInsuredPartyID);
		strRespTypeName = VarString(pRespRow->GetValue(btcRespName));
	}

	// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to handle billing partial EMRs
	CSqlFragment sqlEmrChargeRespT, sqlInsPartyFilter;
	if (!bBillEntireEMR){
		sqlEmrChargeRespT.Create("INNER JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID ");
		if (nInsuredPartyID == -1){
			sqlInsPartyFilter.Create("AND EMRChargeRespT.InsuredPartyID IS NULL ");
			}else{
			sqlInsPartyFilter.Create("AND EMRChargeRespT.InsuredPartyID = {INT} ", nInsuredPartyID);
		}
	}

	// (j.dinatale 2012-01-25 10:34) - PLID 47741 - reworked how we determine if an EMN has been billed
	if (bBillEntireEMR){
		ADODB::_RecordsetPtr rsInsInfo = CreateParamRecordset(
			"SELECT DISTINCT EMRChargeRespT.InsuredPartyID, CONVERT(BIT, CASE WHEN EXISTS ( "
			"SELECT TOP 1 1 FROM "
			"( "
			"	SELECT EMRChargesT.ID, EMRChargesT.EMRID, EMRChargeRespT.InsuredPartyID FROM "
			"	EMRChargesT "
			"	LEFT JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID "
			"	LEFT JOIN CPTCodeT ON EMRChargesT.ServiceID = CPTCodeT.ID "
			"	LEFT JOIN "
			"	( "
			"		SELECT BillsT.Deleted, BilledEMNsT.* FROM BilledEMNsT "
			"		LEFT JOIN BillsT ON BilledEMNsT.BillID = BillsT.ID "
			"		LEFT JOIN BillCorrectionsT ON BillsT.ID = BillCorrectionsT.OriginalBillID "
			"		WHERE BillCorrectionsT.OriginalBillID IS NULL AND BillsT.Deleted = 0 AND BillsT.EntryType = 1 "
			"	) BilledEMNsSubQ ON BilledEMNsSubQ.EMNID = EMRChargesT.EMRID "
			"		AND (EMRChargeRespT.EMRChargeID Is Null OR COALESCE(EMRChargeRespT.InsuredPartyID, -1) = COALESCE(BilledEMNsSubQ.InsuredPartyID, -1)) "
			"	WHERE (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) AND BilledEMNsSubQ.BillID IS NULL "
			") UnbilledEMNsSubQ WHERE UnbilledEMNsSubQ.EMRID = EMRChargesT.EMRID "
			"		AND (EMRChargeRespT.EMRChargeID Is Null OR COALESCE(EMRChargeRespT.InsuredPartyID, -1) = COALESCE(UnbilledEMNsSubQ.InsuredPartyID, -1)) "
			") THEN 0 ELSE 1 END) AS BeenBilled "
			"FROM EMRChargesT "
			"INNER JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID "
			"LEFT JOIN CPTCodeT ON EMRChargesT.ServiceID = CPTCodeT.ID "
			"WHERE EMRChargesT.EMRID = {INT} AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) ", EMRID);

		if (!rsInsInfo->eof){
			BOOL bHasUnbilledInsParty = FALSE;
			BOOL bHasBilledInsParty = FALSE;
			int nCount = 0;

			while (!rsInsInfo->eof){
				if (AdoFldBool(rsInsInfo, "BeenBilled", FALSE)){
					bHasBilledInsParty = TRUE;
					}else{
					bHasUnbilledInsParty = TRUE;
				}

				nCount++;

				if (bHasBilledInsParty && bHasUnbilledInsParty){
					break;
				}

				rsInsInfo->MoveNext();
			}

			if (bHasBilledInsParty){
				CString str;
				if (bHasUnbilledInsParty && nCount > 1){
					str = "The selected EMR has already been partially billed, are you sure you wish to bill it again?";
					}else{
					str = "The selected EMR has already been billed, are you sure you wish to bill it again?";
				}

				if (m_EntryType == 2)
					str.Replace("bill it", "quote it");
				if (IDNO == MessageBox(str, "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return;
				}
			}
			}else{
			// (j.dinatale 2012-01-27 18:45) - PLID 47741 - need to catch the case where its been fully billed but doesnt have
			// any entries in EMRChargeRespT
			rsInsInfo->Close();

			if (ReturnsRecordsParam(
				"SELECT TOP 1 1 FROM BilledEMNsT "
				"LEFT JOIN "
				"( "
				"	SELECT BillsT.Deleted, BilledEMNsT.* FROM BilledEMNsT "
				"	LEFT JOIN BillsT ON BilledEMNsT.BillID = BillsT.ID "
				"	LEFT JOIN BillCorrectionsT ON BillsT.ID = BillCorrectionsT.OriginalBillID "
				"	WHERE BillCorrectionsT.OriginalBillID IS NULL AND BillsT.Deleted = 0 AND BillsT.EntryType = 1 "
				") BilledEMNsSubQ ON BilledEMNsSubQ.EMNID = BilledEMNsT.EMNID "
				"WHERE BilledEMNsT.BillID IS NOT NULL AND BilledEMNsT.EMNID = {INT}", EMRID)){
				CString str = "The selected EMR has already been billed, are you sure you wish to bill it again?";

				if (m_EntryType == 2)
					str.Replace("bill it", "quote it");
				if (IDNO == MessageBox(str, "Practice", MB_ICONQUESTION | MB_YESNO)) {
					return;
				}
			}
		}
	}

	// (j.dinatale 2012-01-25 10:35) - PLID 47741 - keep this here just in case, for reference, this is the old way of determining
	//	if an EMN has been billed
	//before we continue, check to see if the EMR has previously been billed, and warn if it has
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	/*if(ReturnsRecordsParam("SELECT EMNID FROM BilledEMNsT WHERE BillID IN (SELECT ID FROM BillsT WHERE Deleted = 0 AND EntryType = 1) "
		"AND EMNID = {INT}", EMRID)) {
		CString str= "The selected EMR has already been billed, are you sure you wish to bill it again?";
		if(m_EntryType == 2)
		str.Replace("bill it", "quote it");
		if(IDNO == MessageBox(str,"Practice",MB_ICONQUESTION|MB_YESNO)) {
		return;
		}
		}*/

	if (EMRID != -1) {
		//add to our list, if it's not already there
		BOOL bFound = FALSE;
		// (j.jones 2012-01-19 12:24) - PLID 47653 - this now tracks the EMNID, the insured party ID
		// that the EMN was *originally* added to the bill under, and the resp. name
		for (int i = 0; i < m_aryBilledEMNInfo.GetSize(); i++) {
			BilledEMNInfo eInfo = (BilledEMNInfo)m_aryBilledEMNInfo.GetAt(i);
			if (eInfo.nEMNID == EMRID && eInfo.nInsuredPartyID == nInsuredPartyID) {
				bFound = TRUE;
			}
		}
		if (!bFound) {
			BilledEMNInfo eNewInfo;
			eNewInfo.nEMNID = EMRID;
			eNewInfo.nInsuredPartyID = nInsuredPartyID;
			eNewInfo.strRespTypeName = strRespTypeName;
			m_aryBilledEMNInfo.Add(eNewInfo);
		}
	}

	/****************************************************************************************
	* Check all the items being added to make sure it fits the authorization.  This is		*
	* probably somewhat slow, but this case really should rarely come up, it just doesn't	*
	* make much sense.																		*
	****************************************************************************************/

	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

		try {

			//we need to loop through every item being added and compare them against the items 
			//in our referral
			bool bOneFailed = false;

			//setup an array for all the items we'll need to be checking in the auth
			CArray<long, long> aryAuthIDs;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
			while (!rsAuth->eof) {
				aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
				rsAuth->MoveNext();
			}
			rsAuth->Close();

			// (j.jones 2008-05-01 11:53) - PLID 28606 - do not bother checking if services match
			// if the referral has no services in it
			if (aryAuthIDs.GetSize() > 0) {

				// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to handle billing partial EMRs
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsAuthCheck;
				rsAuthCheck = CreateParamRecordset("SELECT ServiceID FROM EMRChargesT {SQL} WHERE Deleted = 0 AND EMRID = {INT} {SQL}",
					sqlEmrChargeRespT, EMRID, sqlInsPartyFilter);


				while (!rsAuthCheck->eof && !bOneFailed) {
					long nServiceID = AdoFldLong(rsAuthCheck, "ServiceID");

					bool bFound = false;
					for (int i = 0; i < aryAuthIDs.GetSize() && !bFound; i++) {
						if (aryAuthIDs.GetAt(i) == nServiceID)
							bFound = true;
					}

					if (!bFound)
						bOneFailed = true;

					rsAuthCheck->MoveNext();
				}

				if (bOneFailed) {
					if (MsgBox(MB_YESNO, "At least one item selected on this EMR does not match your insurance authorization.\n"
						"Are you sure you wish to add this EMR?") == IDNO) {
						return;
					}
				}
			}

		} NxCatchAll("Error determining authorization status for the EMR.");
	}


	/************************************
	* Bill the EMR				        *
	*************************************/

	// (j.jones 2007-01-23 15:43) - PLID 19857 - now see if there are any active, unbilled quotes,
	// either any at all or any that match a code in the EMN (per the preference)
	// If so, open the EMN Quote Selection dialog.

	long nLinkedToQuoteID = -1;
	BOOL bLinkedQuoteIsPackage = FALSE;
	BOOL bDeleteLinkedQuoteID = FALSE;
	ELinkedQuoteBillType nLinkedQuoteBillType = elqbtQuoteAndEMN;

	if (m_EntryType == 1) {

		long nEMNLinkToQuote = GetRemotePropertyInt("EMNLinkToQuote", 0, 0, "<None>", TRUE);
		//0 - filtered, 1 - all unbilled quotes

		// (j.dinatale 2012-01-13 17:36) - PLID 47514 - need to handle billing partial EMRs
		// (a.walling 2011-01-28 15:29) - PLID 40965 - Use a fragment
		CSqlFragment fragmentEMNChargeFilter;
		if (nEMNLinkToQuote == 0) {
			// (j.jones 2012-01-17 17:05) - PLID 47600 - fixed bug where it didn't ignore deleted EMR charges
			fragmentEMNChargeFilter.Create(" AND ChargesT.ServiceID IN (SELECT ServiceID FROM EMRChargesT {SQL} WHERE EMRID = {INT} AND Deleted = 0 {SQL}) ",
				sqlEmrChargeRespT, EMRID, sqlInsPartyFilter);
		}

		//check to see if there are any unbilled quotes or unfinished packages
		//(copied and modified from the quote dropdown)

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		if (ReturnsRecordsParam("SELECT [PatientBillsQ].ID "
			"FROM (SELECT BillsT.*, "
			"		(SELECT TOP 1 ID FROM BilledQuotesT "
			"		WHERE BilledQuotesT.QuoteID = BillsT.ID "
			"		AND BilledQuotesT.BillID IN (SELECT ID FROM BillsT WHERE Deleted = 0 AND EntryType = 1) "
			"		) AS HasBeenBilled "
			"	FROM BillsT "
			"	WHERE BillsT.PatientID = {INT} AND BillsT.Deleted = 0 "
			"	AND BillsT.Active = 1 "
			"	) AS PatientBillsQ "
			"INNER JOIN "
			"	(SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders "
			"	FROM LineItemT "
			"	INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
			"	WHERE LineItemT.PatientID = {INT} AND LineItemT.Deleted=0 "
			"	AND LineItemT.Type >= 10 "
			"	AND (ChargesT.OthrBillFee = 0 OR LineItemT.Amount > 0) "
			"	{SQL} "
			"	) AS PatientChargesQ ON [PatientBillsQ].ID = [PatientChargesQ].BillID "
			"INNER JOIN ChargesT ON [PatientChargesQ].ID = ChargesT.ID "
			"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
			"LEFT JOIN PackagesT ON PatientBillsQ.ID = PackagesT.QuoteID "
			"WHERE [PatientBillsQ].EntryType = 2 "
			"AND LineItemT.Deleted = 0 "
			"AND (CASE WHEN PackagesT.QuoteID Is Not Null THEN (CASE WHEN CurrentCount > 0 THEN 0 ELSE 1 END) ELSE Coalesce(HasBeenBilled,0) END) = 0 "
			"GROUP BY [PatientBillsQ].ID, [PatientBillsQ].Date, [PatientBillsQ].Description, "
			"CASE WHEN PackagesT.QuoteID Is Not Null THEN (CASE WHEN CurrentCount > 0 THEN 0 ELSE 1 END) ELSE Coalesce(HasBeenBilled,0) END, "
			"PackagesT.QuoteID, PackagesT.CurrentAmount "
			, m_nPatientID
			, m_nPatientID
			, fragmentEMNChargeFilter))
		{

			CEMNQuoteSelectionDlg dlg(this);
			dlg.m_nPatientID = m_nPatientID;
			dlg.m_nEMNID = EMRID;
			// (j.jones 2012-01-19 09:24) - PLID 47597 - optional filter for EMR charges,
			// NULL will mean no filter, -1 means to filter by patient resp, else insured party ID
			if (bBillEntireEMR) {
				dlg.m_varInsuredPartyID = g_cvarNull;
			}
			else {
				dlg.m_varInsuredPartyID = (long)nInsuredPartyID;
			}
			if (dlg.DoModal() == IDCANCEL) {
				//user cancelled, do not bill
				return;
			}
			else {
				nLinkedToQuoteID = dlg.m_nLinkedToQuoteID;
				// (j.jones 2010-04-09 09:19) - PLID 27671 - track if the quote is a package
				bLinkedQuoteIsPackage = dlg.m_bLinkedQuoteIsPackage;
				nLinkedQuoteBillType = dlg.m_nLinkedQuoteBillType;
			}
		}

		//if the Linked Quote Bill Type is EMN Only with No Link, it means
		//we don't want to link to the quote, so just bill normally
		if (nLinkedQuoteBillType == elqbtEMNOnlyNoLink) {
			nLinkedToQuoteID = -1;
			bLinkedQuoteIsPackage = FALSE;
		}
	}

	//before we continue with the quote linking, set up the EMN's information first

	/* Open the list of services from the EMR */

	// Update description on parent billing module dialog
	// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
	if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
		// (j.gruber 2012-01-04 11:44) - PLID 46291
		SetBillDescriptionBasedOnResp();
		// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
		str = GetBillDescription();
		if (str.GetLength() == 0) {
			CString strProcIDs;
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rsProcNames = CreateParamRecordset("SELECT Name FROM ProcedureT INNER JOIN EmrProcedureT ON ProcedureT.ID = EmrProcedureT.ProcedureID WHERE EmrProcedureT.Deleted = 0 AND EmrProcedureT.EMRID = {INT}", EMRID);
			CString strProcNames;
			while (!rsProcNames->eof) {
				strProcNames += AdoFldString(rsProcNames, "Name") + ", ";
				rsProcNames->MoveNext();
			}
			rsProcNames->Close();
			strProcNames = strProcNames.Left(strProcNames.GetLength() - 2);
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
			SetBillDescription(strProcNames);
		}
	}

	// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
	//LogDetail("Adding EMR to bill");

	long LocationID = -1;

	// (j.jones 2007-05-22 09:27) - PLID 25558 - Added preference to use the EMN primary provider,
	// EMN secondary provider, or G1 provider. If the selected option is blank, use the next in the list.
	long nBillEMNWithProvider = GetRemotePropertyInt("BillEMNWithProvider", 0, 0, GetCurrentUserName(), true);

	// (b.eyers 2016-02-24) - PLID 68325 - update the insurance tab before setting info on it
	if (m_EntryType == 1) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.EnsureInitialized();
	}
	// (j.jones 2008-10-02 12:36) - PLID 20870 - added ability to use the EMN date on new charges
	// (j.jones 2012-04-30 15:11) - PLID 40121 - include the managed status of the location
	// (b.eyers 2016-02-24) - PLID 68325 - get admission time, discharge time, and discharge status from the emr
	_RecordsetPtr rsEmr = CreateParamRecordset("SELECT EMRMasterT.Date, "
		"EMRMasterT.LocationID, LocationsT.Managed, "
		"EmrProvidersT.ProviderID AS PrimaryProviderID, "
		"EmrSecondaryProvidersT.ProviderID AS SecondaryProviderID, "
		"EMRMasterT.AdmissionTime, EMRMasterT.DischargeTime, EMRMasterT.DischargeStatusID "
		"FROM EMRMasterT "
		"INNER JOIN LocationsT ON EMRMasterT.LocationID = LocationsT.ID "
		"LEFT JOIN (SELECT EMRID, ProviderID FROM EmrProvidersT WHERE Deleted = 0) AS EmrProvidersT ON EmrMasterT.ID = EmrProvidersT.EMRID "
		"LEFT JOIN (SELECT EMRID, ProviderID FROM EmrSecondaryProvidersT WHERE Deleted = 0) AS EmrSecondaryProvidersT ON EmrMasterT.ID = EmrSecondaryProvidersT.EMRID "
		"WHERE EmrMasterT.ID = {INT}", EMRID);
	if (!rsEmr->eof) {

		// (j.jones 2011-06-24 16:05) - PLID 30964 - use the EMN location as the POS
		long nPOSID = AdoFldLong(rsEmr, "LocationID", -1);

		if (nPOSID != -1) {
			if (m_nCurPlaceOfServiceID != nPOSID) {
				//always change the place of service				

				// (j.jones 2011-08-24 09:22) - PLID 44868 - call TryChangePlaceOfService,
				// as we might not be allowed to change the place of service
				TryChangePlaceOfService(nPOSID);
			}

			// (j.jones 2012-04-30 15:09) - PLID 40121 - change the bill location if the preference
			// says to do so, and if the location is managed
			BOOL bManaged = AdoFldBool(rsEmr, "Managed");
			if (bManaged && nPOSID != m_nCurLocationID
				&& GetRemotePropertyInt("BillEMNWithLocation", 1, 0, GetCurrentUserName(), true) == 1) {
				//try to change the location (it may fail due to various rules and the existing bill contents)
				TryChangeBillLocation(nPOSID);
			}
		}

		// (j.jones 2008-10-02 12:38) - PLID 20870 - change the default charge date
		// to the EMN date
		COleDateTime dtEMN = AdoFldDateTime(rsEmr, "Date");
		if (dtEMN.GetStatus() != COleDateTime::invalid) {
			//set the default charge date - existing functionality intends
			//for the default date to stay this way until it is changed
			m_cyDefaultChargeDate = dtEMN;
		}

		// (b.eyers 2016-02-24) - PLID 68325 - get admission time, discharge time, and discharge status from the emr
		if (m_EntryType == 1) {
			COleDateTime dtInvalid;
			dtInvalid.SetStatus(COleDateTime::invalid);
			COleDateTime dtAdmissionTime = AdoFldDateTime(rsEmr, "AdmissionTime", dtInvalid);
			COleDateTime dtDischargeTime = AdoFldDateTime(rsEmr, "DischargeTime", dtInvalid);
			if (dtAdmissionTime.GetStatus() != COleDateTime::invalid) {
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pAdmissionTime->SetDateTime(dtAdmissionTime);
			}
			if (dtDischargeTime.GetStatus() != COleDateTime::invalid) {
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pDischargeTime->SetDateTime(dtDischargeTime);
			}
		}
		_variant_t var;
		var = rsEmr->Fields->Item["DischargeStatusID"]->Value;
		if (var.vt != VT_NULL) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.m_DischargeStatusCombo->SetSelByColumn(0, var);
		}

		long nPrimaryProviderID = AdoFldLong(rsEmr, "PrimaryProviderID", -1);
		long nSecondaryProviderID = AdoFldLong(rsEmr, "SecondaryProviderID", -1);

		long nProviderToUse = -1;

		// (j.jones 2007-05-22 09:37) - PLID 25558 - Now based on the preference,
		// decide which provider to use, but in all cases try another provider if
		// our preferred one is blank.
		if (nBillEMNWithProvider == 0) { //use primary, then secondary, then G1

			nProviderToUse = nPrimaryProviderID;

			if (nProviderToUse == -1)
				nProviderToUse = nSecondaryProviderID;

			if (nProviderToUse == -1)
				nProviderToUse = m_Main_Physician;
		}
		else if (nBillEMNWithProvider == 1) { //use secondary, then primary, then G1

			nProviderToUse = nSecondaryProviderID;

			if (nProviderToUse == -1)
				nProviderToUse = nPrimaryProviderID;

			if (nProviderToUse == -1)
				nProviderToUse = m_Main_Physician;
		}
		else if (nBillEMNWithProvider == 2) { //use G1, then primary, then secondary

			nProviderToUse = m_Main_Physician;

			if (nProviderToUse == -1)
				nProviderToUse = nPrimaryProviderID;

			if (nProviderToUse == -1)
				nProviderToUse = nSecondaryProviderID;
		}

		//and now assign as our default provider
		if (nProviderToUse != -1)
			m_DefaultProvider = nProviderToUse;
	}
	rsEmr->Close();

	long nDiagCount = 0;
	if (m_EntryType == 1) {

		_RecordsetPtr rsDiag;

		// (j.jones 2012-01-26 09:40) - PLID 47786 - if we are only billing part of the EMR,
		// filter only on diagnosis codes linked to the charges we're about to bill, but if
		// we're billing the entire EMR we should just use all diagnoses regardless of linking
		if (bBillEntireEMR) {
			//add all diag codes

			// (j.jones 2007-01-05 15:36) - PLID 24070 - supported diagnosis code ordering
			// (j.jones 2009-03-25 16:24) - PLID 9729 - included CodeNumber and CodeDesc			
			// (j.gruber 2014-02-26 13:20) - PLID 61045 - we'll need the ICD9 and ICD10
			rsDiag = CreateParamRecordset("SELECT EMRDiagCodesT.DiagCodeID AS ICD9ID, "
				"DiagCodes.CodeNumber AS ICD9Code, DiagCodes.CodeDesc AS ICD9Desc, "
				" ICD10T.ID as ICD10ID, ICD10T.CodeNumber as ICD10Code, ICD10T.CodeDesc as ICD10Desc "
				"FROM EMRDiagCodesT "
				"LEFT JOIN DiagCodes ON EMRDiagCodesT.DiagCodeID = DiagCodes.ID "
				"LEFT JOIN DiagCodes ICD10T ON EMRDiagCodesT.DiagCodeID_ICD10 = ICD10T.ID "
				"WHERE EMRDiagCodesT.Deleted = 0 AND EMRDiagCodesT.EMRID = {INT} "
				"ORDER BY EMRDiagCodesT.OrderIndex", EMRID);
		}
		else {
			// (j.jones 2012-01-26 09:43) - PLID 47786 - add only codes linked to
			//the charges we're going to bill
			// (j.gruber 2014-02-26 13:20) - PLID 61045 - we'll need the ICD9 and ICD10
			rsDiag = CreateParamRecordset("SELECT EMRDiagCodesT.DiagCodeID AS ICD9ID, "
				"DiagCodes.CodeNumber AS ICD9Code, DiagCodes.CodeDesc AS ICD9Desc, "
				" ICD10T.ID as ICD10ID, ICD10T.CodeNumber as ICD10Code, ICD10T.CodeDesc as ICD10Desc "
				" FROM EMRMasterT  "
				" INNER JOIN EMRDiagCodesT ON EMRMasterT.ID = EMRDiagCodesT.EMRID "
				" INNER JOIN EMRChargesT ON EMRMasterT.ID = EMRChargesT.EMRID "
				" INNER JOIN EMRChargesToDiagCodesT ON EMRChargesT.ID = EMRChargesToDiagCodesT.ChargeID "
				" AND (EMRDiagCodesT.DiagCodeID = EMRChargesToDiagCodesT.DiagCodeID  "
				" 	   OR EMRDiagCodesT.DiagCodeID_ICD10 = EMRChargesToDiagCodesT.DiagCodeID_ICD10) "
				" LEFT JOIN DiagCodes ON EMRChargesToDiagCodesT.DiagCodeID = DiagCodes.ID  "
				" LEFT JOIN DiagCodes ICD10T ON EMRChargesToDiagCodesT.DiagCodeID_ICD10 = ICD10T.ID "
				" INNER JOIN EMRChargeRespT ON EMRChargesT.ID = EMRChargeRespT.EMRChargeID  "
				"WHERE EMRDiagCodesT.Deleted = 0 AND EMRChargesT.Deleted = 0  AND EMRMasterT.Deleted = 0 "
				"AND EMRMasterT.ID = {INT} "
				"{SQL} "
				"GROUP BY EMRDiagCodesT.DiagCodeID, DiagCodes.CodeNumber, DiagCodes.CodeDesc, EMRDiagCodesT.OrderIndex, "
				" ICD10T.ID, ICD10T.CodeNumber, ICD10T.CodeDesc "
				"ORDER BY EMRDiagCodesT.OrderIndex", EMRID, sqlInsPartyFilter);
		}

		// (j.jones 2009-03-25 16:19) - PLID 9729 - now we bill all codes
		// (j.jones 2011-04-20 15:01) - PLID 43344 - We should NOT clear existing diagnosis codes!
		// We need to append to the existing codes.
		while (!rsDiag->eof) {

			nDiagCount++;

			/*long DiagCodeID = AdoFldLong(rsDiag, "DiagCodeID");
			CString strCodeNumber = AdoFldString(rsDiag, "CodeNumber");
			CString strCodeDesc = AdoFldString(rsDiag, "CodeDesc");*/
			long nICD9ID = AdoFldLong(rsDiag->Fields, "ICD9ID", -1);
			long nICD10ID = AdoFldLong(rsDiag->Fields, "ICD10ID", -1);

			// (j.jones 2011-04-20 15:04) - PLID 43344 - see if the diag code is already on this bill
			DiagCodeInfoPtr pDiag = GetDiagCodeByPair(CChargeWhichCodePair(nICD9ID, nICD10ID), FALSE);
			if (!pDiag) {

				//add to the end of our list of extra codes
				DiagCodeInfoPtr pDiag = DiagCodeInfoPtr(new DiagCodeInfo);
				pDiag->nID = -1;
				pDiag->nDiagCode9ID = nICD9ID;
				pDiag->strDiagCode9Code = AdoFldString(rsDiag->Fields, "ICD9Code", "");
				pDiag->strDiagCode9Desc = AdoFldString(rsDiag->Fields, "ICD9Desc", "");
				pDiag->nDiagCode10ID = nICD10ID;
				pDiag->strDiagCode10Code = AdoFldString(rsDiag->Fields, "ICD10Code", "");
				pDiag->strDiagCode10Desc = AdoFldString(rsDiag->Fields, "ICD10Desc", "");

				long nOrderIndex = 1;
				if (m_arypDiagCodes.GetSize() > 0) {
					nOrderIndex = ((DiagCodeInfoPtr)m_arypDiagCodes.GetAt(m_arypDiagCodes.GetSize() - 1))->nOrderIndex + 1;
				}
				pDiag->nOrderIndex = nOrderIndex;
				m_arypDiagCodes.Add(pDiag);

			}
			rsDiag->MoveNext();
		}
		rsDiag->Close();

		//now update our more diags list
		UpdateDiagCodeList();

		// (j.gruber 2014-02-26 13:29) - PLID 61045 - reflect it in the dialog
		ReflectDiagCodeArrayToInterface();
	}

	if (m_EntryType == 1)
		BuildWhichCodesCombo();

	// (j.jones 2007-01-24 15:49) - PLID 19857 - OK, resume linking to a quote,
	// we have already set our link to the EMN
	if (m_EntryType == 1 && nLinkedToQuoteID != -1) {
		switch (nLinkedQuoteBillType) {
			case elqbtQuoteAndEMN:
				//we will bill the quote and then bill the EMN's remaining charges

				// (j.jones 2012-01-18 14:35) - PLID 47597 - if bBillEntireEMR is false,
				// this option should have been impossible to select
				if (!bBillEntireEMR) {
					ThrowNxException("Invalid option chosen: 'Bill the Quote Charges and any EMN Charges not on the Quote' when billing a partial EMN.");
				}

				// (j.jones 2012-01-17 16:18) - PLID 47537 - Pass in our EMN ID.
				// Also, this was renamed from OnBillPackage as it was poorly named.
				// This function actually handles billing any quote or any package.
				OnBillQuoteOrPackage(nLinkedToQuoteID, -1, EMRID);
				break;
			case elqbtQuoteOnly:
				//bill the quote, do not bill the EMN charges

				// (j.jones 2012-01-18 14:35) - PLID 47597 - if bBillEntireEMR is false,
				// this option should have been impossible to select
				if (!bBillEntireEMR) {
					ThrowNxException("Invalid option chosen: 'Bill the Quote Charges only' when billing a partial EMN.");
				}

				// (j.jones 2012-01-17 16:18) - PLID 47537 - Pass in our EMN ID.
				// Also, this was renamed from OnBillPackage as it was poorly named.
				// This function actually handles billing any quote or any package.
				OnBillQuoteOrPackage(nLinkedToQuoteID, -1, EMRID);

				//now we're done, leave this function
				Requery();
				PostChargeAdded();
				return;
				break;
			case elqbtEMNOnly:
				//bill the EMN charges, simply link to the quote

				//set the quote ID, ask to delete the quote, no more

				// (j.jones 2010-04-09 09:15) - PLID 27671 - the ability to delete a billed quote now only applies
				// to quotes, not packages, so only call this code for non-package quotes
				if (!bLinkedQuoteIsPackage) {
					//Deleting the quote could mess up tracking, so we don't want to even give them the chance to.
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					if (!ReturnsRecordsParam("SELECT ID FROM EventsT WHERE ID IN (SELECT EventID FROM EventAppliesT) AND Type = {INT} AND ItemID = {INT}", PhaseTracking::ET_QuoteCreated, nLinkedToQuoteID)
						&& !ReturnsRecordsParam("SELECT QuoteID FROM ProcInfoQuotesT WHERE QuoteID = {INT}", nLinkedToQuoteID)
						&& !ReturnsRecordsParam("SELECT ActiveQuoteID FROM ProcInfoT WHERE ActiveQuoteID = {INT}", nLinkedToQuoteID)) {

						int QuoteDeletionPref = GetRemotePropertyInt("QuoteDeletionPref", 0, 0, "<None>", TRUE);

						//0 = prompt, 1 = delete, 2 = do nothing
						if (QuoteDeletionPref == 1 || (QuoteDeletionPref == 0 && IDYES == MessageBox("Would you like to delete the original quote?", NULL, MB_YESNO))) {
							//it will be deleted from data later, not right away
							bDeleteLinkedQuoteID = TRUE;
						}
					}
				}

				//add to our list, if it's not already there
				BOOL bFound = FALSE;
				for (int i = 0; i < m_arypBilledQuotes.GetSize(); i++) {
					if (((BilledQuote*)m_arypBilledQuotes.GetAt(i))->nQuoteID == nLinkedToQuoteID) {
						bFound = TRUE;
						//update our new deletion choice
						((BilledQuote*)m_arypBilledQuotes.GetAt(i))->bDeleteQuote = bDeleteLinkedQuoteID;
					}
				}
				if (!bFound) {
					BilledQuote *pQuote = new BilledQuote;
					pQuote->nQuoteID = nLinkedToQuoteID;
					pQuote->bDeleteQuote = bDeleteLinkedQuoteID;
					m_arypBilledQuotes.Add(pQuote);
				}

				break;
		}
	}

	//DRT 1/16/2007 - PLID 24177 - Added a count of diagnosis codes in EMRChargesToDiagCodesT for efficiency - 
	//	this saves us a data lookup in the AddExternalXXX function for EMR records.
	// (j.jones 2009-03-31 15:23) - PLID 33747 - OHIP Premium Codes are always loaded last
	CString strOrderBy, strSql;
	if (UseOHIP()) {
		strOrderBy = "ORDER BY (CASE WHEN CPTCodeT.OHIPPremiumCode = 1 THEN 1 ELSE 0 END) ";
	}

	// (d.thompson 2009-07-09) - PLID 34821 - Multipliers need included when loading modifiers
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	// (j.jones 2011-03-28 16:26) - PLID 42575 - ignore non-billable CPT codes
	// (j.jones 2012-01-26 09:59) - PLID 47786 - we already know the diag count, don't need to calculate it here
	// (s.tullis 2015-04-02 11:37) - PLID 64978- Need to support billing EMR charges here
	// (s.tullis 2015-04-02 16:20) - PLID 64975 -Added Category Count for hiding/ showing category column
	m_rsBill = CreateParamRecordset(FormatString("SELECT EMRChargesT.ID, EMRChargesT.ServiceID, EMRChargesT.Description, Quantity, UnitCost, ServiceT.Name AS ServiceName, "
		"CPTModifier1, CPTModifier2, CPTModifier3, CPTModifier4, {INT} AS DiagCount, EMRChargesT.Category ,COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) AS CategoryCount,"
		"Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END) AS IsProduct,  "
		"CPTModifier1.Multiplier AS Multiplier1, CPTModifier2.Multiplier AS Multiplier2, "
		"CPTModifier3.Multiplier AS Multiplier3, CPTModifier4.Multiplier AS Multiplier4 "
		"FROM EMRChargesT "
		"{SQL} "
		"LEFT JOIN ServiceT ON EMRChargesT.ServiceID = ServiceT.ID "
		"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
		"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
		"LEFT JOIN CPTModifierT CPTModifier1 ON EMRChargesT.CPTModifier1 = CPTModifier1.Number "
		"LEFT JOIN CPTModifierT CPTModifier2 ON EMRChargesT.CPTModifier2 = CPTModifier2.Number "
		"LEFT JOIN CPTModifierT CPTModifier3 ON EMRChargesT.CPTModifier3 = CPTModifier3.Number "
		"LEFT JOIN CPTModifierT CPTModifier4 ON EMRChargesT.CPTModifier4 = CPTModifier4.Number "
		"LEFT JOIN ( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount "
		"			 FROM ServiceMultiCategoryT "
		"			 Group BY ServiceID ) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = EmrChargesT.ServiceID "
		"WHERE EMRChargesT.Deleted = 0 AND EMRID = {INT} {SQL}"
		"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
		"%s", strOrderBy), nDiagCount, sqlEmrChargeRespT, EMRID, sqlInsPartyFilter
		);

	while (!m_rsBill->eof) {

		//TODO: We currently call the cpt and product saving code.
		//Should we implement the code in these functions here? Should we make shared code for these functions?

		long ServiceID, EMRChargeID;

		ServiceID = AdoFldLong(m_rsBill, "ServiceID", -1);

		// (j.jones 2007-01-24 15:55) - PLID 19857 - if linking to a quote
		// and we billed the quote, and are only adding in EMN charges not on that quote,
		// we must decide on a per-charge basis
		if (m_EntryType == 1 && nLinkedToQuoteID != -1 && nLinkedQuoteBillType == elqbtQuoteAndEMN) {

			if (m_List->FindByColumn(COLUMN_SERVICE_ID, (long)ServiceID, m_List->GetFirstRow(), FALSE)) {

				//this service exists, so skip it
				m_rsBill->MoveNext();
				continue;
			}
		}

		EMRChargeID = AdoFldLong(m_rsBill, "ID", -1);
		BOOL bIsProduct = AdoFldBool(m_rsBill, "IsProduct", FALSE);
		// Billing
		if (m_EntryType == 1 && bIsProduct == FALSE && IsCodeSelectedBasedOnWarning(ServiceID) == FALSE)
		{
			m_rsBill->MoveNext();
			continue;
		}
		if (bIsProduct) {
			//Product

			if (!AddNewExternalProduct(EMRChargeID, EXT_EMR, ServiceID, AdoFldString(m_rsBill, "ServiceName", ""), AdoFldDouble(m_rsBill, "Quantity", 1.0), AdoFldCurrency(m_rsBill, "UnitCost", COleCurrency(0, 0)), AdoFldLong(m_rsBill, "DiagCount", 0))) {

				CString strName;

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rs = CreateParamRecordset("SELECT Name FROM ServiceT WHERE ID = {INT}", ServiceID);

				if (!rs->eof) {
					strName = AdoFldString(rs, "Name", "");
				}
				rs->Close();

				CString str;
				str.Format("The product '%s' was not able to be billed.\n"
					"If you did not manually cancel this item, please ensure that this product\n"
					"is able to be billed to the selected location, is in stock,\n"
					"and that the product has not been made inactive.", strName);

				AfxMessageBox(str);

				m_rsBill->MoveNext();
				continue;
			}
		}
		else {
			//CPT Code

			if (!AddNewExternalCpt(EMRChargeID, EXT_EMR)) {

				CString strName;

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				// (j.jones 2011-03-28 16:26) - PLID 42575 - ignore non-billable CPT codes
				_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description FROM ServiceT "
					"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
					"WHERE ServiceT.ID = {INT} "
					"AND CPTCodeT.Billable = 1", ServiceID);

				if (!rs->eof) {
					strName = AdoFldString(rs, "Description", "");
				}
				rs->Close();

				CString str;
				str.Format("The Service Code '%s' was not able to be billed.\n"
					"Please ensure that the Code has not been made inactive.", strName);

				AfxMessageBox(str);

				m_rsBill->MoveNext();
				continue;
			}
		}



		m_rsBill->MoveNext();
	}

	m_rsBill->Close();

	/////////////////////////////////////////////////////////////////
	// Sort the list, requery it, and recalculate the bill total
	Requery();

	PostChargeAdded();

	// (j.jones 2007-12-13 17:21) - PLID 27988 - Any allocations we opened, we should be done with them now,
	// so force them to be resolved. But if it returns FALSE, don't worry about it too much here,
	// ValidateChanges will require it before closing.
	if (!ForceResolveAllAllocations()) {
		AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
	}
}

void CBillingDlg::OnSelChosenComboEMR(LPDISPATCH lpRow)
{
	try {
		//m_EMRCombo
		if (lpRow == NULL)
			return;

		IRowSettingsPtr pRow(lpRow);
		_variant_t var = pRow->GetValue(0);

		long EMRID = var.lVal;
		// (j.dinatale 2012-01-13 17:36) - PLID 47514 - broke out the billing EMR logic
		BillEMR(EMRID, true);

	} NxCatchAll("Error in OnSelChosenComboEMR()");
}

void CBillingDlg::ResizeColumns()
{
	try {

		// (j.jones 2010-09-02 17:41) - PLID 40330 - I originally added nRespType so we could show/hide allowables,
		// but it turns out none of the code in here handles the responsibility selection. Seems like this function
		// is only meant to be called when the bill is opened, and selecting a resp. does further column
		// manipulation that is not supported in this function. Therefore, ASSERT if someone called ResizeColumns()
		// when they should not have.
		long nRespType = 0;
		if (m_listBillTo->CurSel != -1) {
			nRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
		}
		if (nRespType != 0 && m_EntryType == 1) {
			ASSERT(FALSE);
			//If you get this assertion, you called ResizeColumns() after the bill has already been loaded.
			//ResizeColumns() does not currently support showing/hiding columns per responsibility.
			//If you need to call ResizeColumns(), that problem needs resolved.
		}

		CString strColWidths;
		// (d.thompson 2012-08-01) - PLID 51898 - Changed default to 1
		long nRememberWidths = GetRemotePropertyInt("RememberBillingColumnWidths", 1, 0, GetCurrentUserName(), TRUE);

		//(e.lally 2011-08-26) PLID 45210 - Check if we are remembering widths before getting them.
		if (nRememberWidths != 0){
			// We distinguish bill and quote widths
			if (m_EntryType == 2) {
				// (j.jones 2009-12-23 09:19) - PLID 32587 - added bShowInitialValue
				strColWidths = GetRemotePropertyText("DefaultQuoteColumnSizes", GetDefaultQuoteColumnWidths(GetIsMultiUsePackage(), m_checkPackageShowInitialValues.GetCheck()), 0, GetCurrentUserName(), false);
			}
			else {
				strColWidths = GetRemotePropertyText("DefaultBillColumnSizes", GetDefaultBillingColumnWidths(), 0, GetCurrentUserName(), false);
			}

			if (strColWidths.IsEmpty())
				nRememberWidths = 0;

			// (d.thompson 2012-09-24) - PLID 52822 - If the number of columns we're remembering is different than the
			//	number of columns that we've got now, let's just go back to not remembering, because otherwise the interface
			//	looks terrible and the users just have to go manually reset them anyways.
			if (GetSaveableColumnCount() != GetColumnCount(strColWidths))
			{
				nRememberWidths = 0;
			}
		}

		// (c.haag 2004-01-27 12:22) - If we should remember widths, we need to ensure
		// each column is defined as a fixed width type.
		if (nRememberWidths)
		{
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			short i = 0;
			for (i = 0; i < m_List->ColumnCount; i++)
			{
				long nStyle = m_List->GetColumn(i)->ColumnStyle;
				nStyle &= ~(csWidthPercent | csWidthAuto);
				m_List->GetColumn(i)->ColumnStyle = nStyle;
			}
			// (b.savon 2012-05-31 17:05) - PLID 50570 - Moved away from Width Column styles, this
			// isn't needed anymore.
			/*for (i=0; i < m_QuoteList->ColumnCount; i++)
			{
			long nStyle = m_QuoteList->GetColumn(i)->ColumnStyle;
			nStyle &= ~(csWidthPercent | csWidthAuto);
			m_QuoteList->GetColumn(i)->ColumnStyle = nStyle;
			}*/
		}
		else
		{
			// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
			short i = 0;
			for (i = 0; i < m_List->ColumnCount; i++)
			{
				m_List->GetColumn(i)->PutColumnStyle(m_aBillColumnStyles[i]);
			}
			for (i = 0; i < m_QuoteList->ColumnCount; i++)
			{
				m_QuoteList->GetColumn(i)->PutColumnStyle(m_aQuoteColumnStyles[i]);
			}
		}

		// (j.jones 2014-04-23 10:17) - PLID 61836 - added referring, ordering, supervising providers
		m_bBillReferringProvider = false;
		m_bBillOrderingProvider = false;
		m_bBillSupervisingProvider = false;

		BOOL bBillServiceDateTo = FALSE;
		BOOL bBillInputDate = FALSE;
		BOOL bBillCPTCode = TRUE;
		BOOL bBillCPTSubCode = TRUE;
		BOOL bBillCPTCategory = FALSE; // (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
		BOOL bBillTOS = TRUE;
		BOOL bBillMod1 = TRUE;
		BOOL bBillMod2 = TRUE;
		BOOL bBillMod3 = FALSE;
		BOOL bBillMod4 = FALSE;
		BOOL bBillCalls = FALSE;
		BOOL bBillSkill = FALSE; // (d.singleton 2012-05-21 12:45) - PLID 48152
		BOOL bBillDiagCs = TRUE;
		//BOOL bBillPercentOff = FALSE;
		//BOOL bBillDiscount = FALSE;
		//BOOL bBillDiscountCategory = TRUE;
		BOOL bBillTotalDiscount = FALSE;
		BOOL bQuoteCPTCode = TRUE;
		BOOL bQuoteCPTSubCode = TRUE;
		BOOL bQuoteCPTCategory = FALSE; // (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
		BOOL bQuoteProvider = TRUE;
		BOOL bQuoteMod1 = FALSE;
		BOOL bQuoteMod2 = FALSE;
		BOOL bQuoteMod3 = FALSE;
		BOOL bQuoteMod4 = FALSE;
		BOOL bQuoteCalls = FALSE;
		BOOL bQuoteSkill = FALSE;// (d.singleton 2012-05-21 12:45) - PLID 48152
		BOOL bQuoteOutsideCost = TRUE;
		//BOOL bQuotePercentOff = TRUE;
		//BOOL bQuoteDiscount = TRUE;
		//BOOL bQuoteDiscountCategory = TRUE;
		BOOL bQuoteTotalDiscount = TRUE;
		BOOL bQuoteTax1 = TRUE;
		BOOL bQuoteTax2 = TRUE;
		// (j.gruber 2009-10-19 15:54) - PLID 36000 - quote allowable
		BOOL bQuoteAllowable = FALSE;


		// (j.jones 2008-09-16 17:21) - PLID 19623 - ensured this recordset only pulls the columns we need
		// (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
		//TODO: try to implement the NetUtils::ConfigBillColumnsT tablechecker here
		// (j.gruber 2009-03-20 12:06) - PLID 33385 - take out percentoff and discount and use total discount
		_RecordsetPtr rs = CreateParamRecordset("SELECT BillServiceDateTo, BillInputDate, BillPatientCoordinator, "
			"BillCPTCode, BillCPTSubCode, BillTOS, BillMod1, BillMod2, BillMod3, BillMod4, BillDiagCs, "
			"BillTotalDiscount, BillTax1, BillTax2, BillAllowable, BillClaimProvider, BillChargeCategory, "
			"QuoteCPTCode, QuoteCPTSubCode, QuoteProvider, QuoteMod1, QuoteMod2, QuoteMod3, QuoteMod4, "
			"QuoteOutsideCost, QuoteTotalDiscount, QuoteTax1, QuoteTax2, QuoteAllowable, QuoteChargeCategory "
			"FROM ConfigBillColumnsT "
			"WHERE LocationID = {INT}", GetCurrentLocationID());
		if (!rs->eof) {
			m_mapSysHiddenBillCols[COLUMN_SERVICE_DATE_TO] = bBillServiceDateTo = AdoFldBool(rs, "BillServiceDateTo", FALSE);
			m_mapSysHiddenBillCols[COLUMN_INPUT_DATE] = bBillInputDate = AdoFldBool(rs, "BillInputDate", FALSE);
			m_mapSysHiddenBillCols[COLUMN_PATCOORD] = m_bBillPatCoord = AdoFldBool(rs, "BillPatientCoordinator", FALSE);
			m_mapSysHiddenBillCols[BILL_COLUMN_CPT_CODE] = bBillCPTCode = AdoFldBool(rs, "BillCPTCode", TRUE);
			m_mapSysHiddenBillCols[BILL_COLUMN_CPT_SUB_CODE] = bBillCPTSubCode = AdoFldBool(rs, "BillCPTSubCode", TRUE);
			// (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
			m_mapSysHiddenBillCols[BILL_COLUMN_CPT_CATEGORY] = bBillCPTCategory = AdoFldBool(rs, "BillChargeCategory", FALSE);
			m_mapSysHiddenBillCols[BILL_COLUMN_CPT_TYPEOFSERVICE] = bBillTOS = AdoFldBool(rs, "BillTOS", TRUE);
			m_mapSysHiddenBillCols[COLUMN_MODIFIER1] = bBillMod1 = AdoFldBool(rs, "BillMod1", TRUE);
			m_mapSysHiddenBillCols[COLUMN_MODIFIER2] = bBillMod2 = AdoFldBool(rs, "BillMod2", TRUE);
			m_mapSysHiddenBillCols[COLUMN_MODIFIER3] = bBillMod3 = AdoFldBool(rs, "BillMod3", FALSE);
			m_mapSysHiddenBillCols[COLUMN_MODIFIER4] = bBillMod4 = AdoFldBool(rs, "BillMod4", FALSE);
			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			m_mapSysHiddenBillCols[COLUMN_CALLS] = bBillCalls = UseAlbertaHLINK();
			// (d.singleton 2012-05-21 12:44) - PLID 48152 added skill column , alberta only
			m_mapSysHiddenBillCols[COLUMN_SKILL] = bBillSkill = UseAlbertaHLINK();
			m_mapSysHiddenBillCols[BILL_COLUMN_WHICH_CODES] = bBillDiagCs = AdoFldBool(rs, "BillDiagCs", TRUE);
			// (j.gruber 2009-03-05 17:43) - PLID 33351 - take out discount fields and add total discount
			// (j.gruber 2009-03-20 12:12) - PLID 33385 - changed to use new structure
			m_mapSysHiddenBillCols[COLUMN_TOTAL_DISCOUNT] = bBillTotalDiscount = AdoFldBool(rs, "BillTotalDiscount", FALSE);
			//m_mapSysHiddenBillCols[COLUMN_PERCENT_OFF] = bBillPercentOff = AdoFldBool(rs, "BillPercentOff",FALSE);
			//m_mapSysHiddenBillCols[COLUMN_DISCOUNT] = bBillDiscount = AdoFldBool(rs, "BillDiscount",FALSE);
			// (j.gruber 2007-03-21 15:36) - PLID 24870 - show the discount category column if either discount or percent off is showing
			//m_mapSysHiddenQuoteCols[COLUMN_DISCOUNT_CATEGORY] = bBillDiscountCategory = (bBillPercentOff|bBillDiscount);
			m_mapSysHiddenBillCols[COLUMN_TAX_RATE_1] = m_bBillTax1 = AdoFldBool(rs, "BillTax1", TRUE);
			m_mapSysHiddenBillCols[COLUMN_TAX_RATE_2] = m_bBillTax2 = AdoFldBool(rs, "BillTax2", TRUE);
			// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills
			m_mapSysHiddenBillCols[BILL_COLUMN_ALLOWABLE] = m_bBillAllowable = AdoFldBool(rs, "BillAllowable", FALSE);
			// (j.jones 2010-11-09 10:45) - PLID 31392 - added claim provider
			m_mapSysHiddenBillCols[BILL_COLUMN_CLAIM_PROVIDER] = m_bBillClaimProvider = AdoFldBool(rs, "BillClaimProvider", FALSE);
			// (j.jones 2014-04-23 10:17) - PLID 61836 - added referring, ordering, supervising providers
			m_mapSysHiddenBillCols[BILL_COLUMN_REFERRING_PROVIDER] = m_bBillReferringProvider;
			m_mapSysHiddenBillCols[BILL_COLUMN_ORDERING_PROVIDER] = m_bBillOrderingProvider;
			m_mapSysHiddenBillCols[BILL_COLUMN_SUPERVISING_PROVIDER] = m_bBillSupervisingProvider;
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_CPT_CODE] = bQuoteCPTCode = AdoFldBool(rs, "QuoteCPTCode", TRUE);
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_CPT_SUB_CODE] = bQuoteCPTSubCode = AdoFldBool(rs, "QuoteCPTSubCode", TRUE);
			// (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
			m_mapSysHiddenBillCols[QUOTE_COLUMN_CPT_CATEGORY] = bQuoteCPTCategory = AdoFldBool(rs, "QuoteChargeCategory", FALSE);
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_PROVIDER] = bQuoteProvider = AdoFldBool(rs, "QuoteProvider", TRUE);
			m_mapSysHiddenBillCols[QUOTE_COLUMN_MODIFIER1] = bQuoteMod1 = AdoFldBool(rs, "QuoteMod1", FALSE);
			m_mapSysHiddenBillCols[QUOTE_COLUMN_MODIFIER2] = bQuoteMod2 = AdoFldBool(rs, "QuoteMod2", FALSE);
			m_mapSysHiddenBillCols[QUOTE_COLUMN_MODIFIER3] = bQuoteMod3 = AdoFldBool(rs, "QuoteMod3", FALSE);
			m_mapSysHiddenBillCols[QUOTE_COLUMN_MODIFIER4] = bQuoteMod4 = AdoFldBool(rs, "QuoteMod4", FALSE);
			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			m_mapSysHiddenBillCols[QUOTE_COLUMN_CALLS] = bQuoteCalls = UseAlbertaHLINK();
			// (d.singleton 2012-05-21 12:44) - PLID 48152 added skill column , alberta only
			m_mapSysHiddenBillCols[QUOTE_COLUMN_SKILL] = bQuoteSkill = UseAlbertaHLINK();
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE] = bQuoteOutsideCost = AdoFldBool(rs, "QuoteOutsideCost", TRUE);
			// (j.gruber 2009-03-05 17:46) - PLID 33351 - take out discount columns and put in total discount
			// (j.gruber 2009-03-20 12:08) - PLID 33385 - changed config table structure
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_TOTAL_DISCOUNT] = bQuoteTotalDiscount = AdoFldBool(rs, "QuoteTotalDiscount", TRUE);
			//m_mapSysHiddenQuoteCols[QUOTE_COLUMN_PERCENT_OFF] = bQuotePercentOff = AdoFldBool(rs, "QuotePercentOff",TRUE);
			//m_mapSysHiddenQuoteCols[QUOTE_COLUMN_DISCOUNT] = bQuoteDiscount = AdoFldBool(rs, "QuoteDiscount",TRUE);
			// (j.gruber 2007-03-21 15:36) - PLID 24870 - show the discount category column if either discount or percent off is showing
			//m_mapSysHiddenQuoteCols[QUOTE_COLUMN_DISCOUNT_CATEGORY] = bQuoteDiscountCategory = (bQuotePercentOff|bQuoteDiscount);
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_TAX_RATE_1] = bQuoteTax1 = AdoFldBool(rs, "QuoteTax1", TRUE);
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_TAX_RATE_2] = bQuoteTax2 = AdoFldBool(rs, "QuoteTax2", TRUE);
			// (j.gruber 2009-10-19 15:56) - PLID  36000 - quote allowable
			m_mapSysHiddenQuoteCols[QUOTE_COLUMN_ALLOWABLE] = bQuoteAllowable = AdoFldBool(rs, "QuoteAllowable", FALSE);
		}
		else
		{
			m_mapSysHiddenBillCols.RemoveAll();
			m_mapSysHiddenQuoteCols.RemoveAll();
		}
		rs->Close();

		IColumnSettingsPtr pCol;

		if (m_EntryType == 1) {
			pCol = m_List->GetColumn(COLUMN_LINE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_LINE_ID) : 0);
			pCol = m_List->GetColumn(COLUMN_CHARGE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_CHARGE_ID) : 0);
			// (d.singleton 2012-03-07 17:39) - PLID 49100 new column always 0
			pCol = m_List->GetColumn(BILL_VALIDATION_STATUS); pCol->PutStoredWidth(0);
			pCol = m_List->GetColumn(BILL_COLUMN_DATE); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_DATE) : 10);

			if (bBillServiceDateTo) {
				//show
				pCol = m_List->GetColumn(COLUMN_SERVICE_DATE_TO);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_SERVICE_DATE_TO) : 10);
				//rename the date to "date from", if the "date to" is shown
				m_List->GetColumn(BILL_COLUMN_DATE)->ColumnTitle = "Date From";
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_SERVICE_DATE_TO);
				pCol->PutStoredWidth(0);
				//rename the date to "date", if the "date to" is not shown
				m_List->GetColumn(BILL_COLUMN_DATE)->ColumnTitle = "Date";
			}

			if (bBillInputDate) {
				//show	
				pCol = m_List->GetColumn(COLUMN_INPUT_DATE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_INPUT_DATE) : 10);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_INPUT_DATE);
				pCol->PutStoredWidth(0);
			}

			pCol = m_List->GetColumn(BILL_COLUMN_PROVIDER); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_PROVIDER) : 10);

			// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
			if (m_bBillClaimProvider) {
				//show	
				pCol = m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER);
				long nWidth = GetColumnWidth(strColWidths, BILL_COLUMN_CLAIM_PROVIDER);
				long nDefault = nRememberWidths ? 74 : 10;
				//if we are showing this column, it has to be nonzero
				if (nWidth <= 0) {
					nWidth = nDefault;
				}
				pCol->PutStoredWidth(nRememberWidths ? nWidth : nDefault);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER);
				pCol->PutStoredWidth(0);
			}

			// (j.jones 2014-04-23 10:17) - PLID 61836 - added referring, ordering, supervising providers
			if (m_bBillReferringProvider) {
				//show	
				pCol = m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER);
				long nWidth = GetColumnWidth(strColWidths, BILL_COLUMN_REFERRING_PROVIDER);
				long nDefault = nRememberWidths ? 74 : 10;
				//if we are showing this column, it has to be nonzero
				if (nWidth <= 0) {
					nWidth = nDefault;
				}
				pCol->PutStoredWidth(nRememberWidths ? nWidth : nDefault);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER);
				pCol->PutStoredWidth(0);
			}

			if (m_bBillOrderingProvider) {
				//show	
				pCol = m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER);
				long nWidth = GetColumnWidth(strColWidths, BILL_COLUMN_ORDERING_PROVIDER);
				long nDefault = nRememberWidths ? 74 : 10;
				//if we are showing this column, it has to be nonzero
				if (nWidth <= 0) {
					nWidth = nDefault;
				}
				pCol->PutStoredWidth(nRememberWidths ? nWidth : nDefault);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER);
				pCol->PutStoredWidth(0);
			}

			if (m_bBillSupervisingProvider) {
				//show	
				pCol = m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER);
				long nWidth = GetColumnWidth(strColWidths, BILL_COLUMN_SUPERVISING_PROVIDER);
				long nDefault = nRememberWidths ? 74 : 10;
				//if we are showing this column, it has to be nonzero
				if (nWidth <= 0) {
					nWidth = nDefault;
				}
				pCol->PutStoredWidth(nRememberWidths ? nWidth : nDefault);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER);
				pCol->PutStoredWidth(0);
			}

			if (m_bBillPatCoord) {
				//show	
				pCol = m_List->GetColumn(COLUMN_PATCOORD);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_PATCOORD) : 10);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_PATCOORD);
				pCol->PutStoredWidth(0);
			}

			pCol = m_List->GetColumn(COLUMN_SERVICE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_SERVICE_ID) : 0);

			if (bBillCPTCode) {
				//show	
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_CODE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_CPT_CODE) : 7);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_CODE);
				pCol->PutStoredWidth(0);
			}

			if (bBillCPTSubCode) {
				//show
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_SUB_CODE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_CPT_SUB_CODE) : 5);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_SUB_CODE);
				pCol->PutStoredWidth(0);
			}
			// (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
			if (bBillCPTCategory) {
				//show
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_CATEGORY);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_CPT_CATEGORY) : 10);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_CATEGORY);
				pCol->PutStoredWidth(0);
			}

			if (bBillTOS) {
				//show
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_TYPEOFSERVICE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_CPT_TYPEOFSERVICE) : 5);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_CPT_TYPEOFSERVICE);
				pCol->PutStoredWidth(0);
			}

			if (bBillMod1) {
				//show
				pCol = m_List->GetColumn(COLUMN_MODIFIER1);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_MODIFIER1) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_MODIFIER1);
				pCol->PutStoredWidth(0);
			}

			if (bBillMod2) {
				//show
				pCol = m_List->GetColumn(COLUMN_MODIFIER2);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_MODIFIER2) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_MODIFIER2);
				pCol->PutStoredWidth(0);
			}

			if (bBillMod3) {
				//show
				pCol = m_List->GetColumn(COLUMN_MODIFIER3);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_MODIFIER3) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_MODIFIER3);
				pCol->PutStoredWidth(0);
			}

			if (bBillMod4) {
				//show
				pCol = m_List->GetColumn(COLUMN_MODIFIER4);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_MODIFIER4) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_MODIFIER4);
				pCol->PutStoredWidth(0);
			}

			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			if (bBillCalls) {
				//show
				pCol = m_List->GetColumn(COLUMN_CALLS);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_CALLS) : 5);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_CALLS);
				// (b.spivey, March 29, 2013) - PLID 50631 - Force the style to visible/fixed width.
				long nStyle = csVisible | csFixedWidth;
				pCol->ColumnStyle = nStyle;
				pCol->PutStoredWidth(0);
			}

			// (d.singleton 2012-05-21 14:01) - PLID 48152 added skill column , alberta only
			if (bBillSkill) {
				//show
				pCol = m_List->GetColumn(COLUMN_SKILL);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_SKILL) : 10);
			}
			else {
				pCol = m_List->GetColumn(COLUMN_SKILL);
				// (b.spivey, April 01, 2013) - PLID 50631 - force the style to visible/fixed width. 
				long nStyle = csVisible | csFixedWidth;
				pCol->ColumnStyle = nStyle;
				pCol->PutStoredWidth(0);
			}

			// (d.singleton 2012-03-22 16:44) - PLID 49136 notes column
			pCol = m_List->GetColumn(BILL_COLUMN_NOTES);
			pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_NOTES) : 10);

			if (bBillDiagCs) {
				//// (s.dhole 2011-05-20 11:05) - PLID 33666
				//show
				if (ShouldShowDiagExt()){
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES);
					pCol->PutStoredWidth(0);
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT);
					pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_WHICH_CODES_EXT) : 7);
				}
				else
				{
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES);
					pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_WHICH_CODES) : 7);
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT);
					pCol->PutStoredWidth(0);
				}

			}
			else {
				//hide
				// (s.dhole 2011-05-20 11:05) - PLID 33666
				if (ShouldShowDiagExt()){
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES);
					pCol->PutStoredWidth(0);
				}
				else{
					pCol = m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT);
					pCol->PutStoredWidth(0);
				}

			}

			pCol = m_List->GetColumn(BILL_COLUMN_DESCRIPTION); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_DESCRIPTION) : -1);
			pCol = m_List->GetColumn(BILL_COLUMN_QUANTITY); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_QUANTITY) : 5);
			pCol = m_List->GetColumn(BILL_COLUMN_UNIT_COST); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_UNIT_COST) : 10);
			// (r.gonet 2015-03-27 18:45) - PLID 65277 - Set the Gift Certificate Value column's width. We'll hide this column later if we determine there are no
			// Gift Certificates in the FillBillList() function.
			pCol = m_List->GetColumn(BILL_COLUMN_VALUE); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_VALUE) : 0);
			
			// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills, not shown if patient resp.
			// is selected
			if (nRespType != 0 && m_bBillAllowable) {
				//show
				pCol = m_List->GetColumn(BILL_COLUMN_ALLOWABLE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_ALLOWABLE) : 10);
			}
			else {
				//hide
				pCol = m_List->GetColumn(BILL_COLUMN_ALLOWABLE);
				pCol->PutStoredWidth(0);
			}

			// (j.gruber 2009-03-05 17:47) - PLID 33351 - take out discount fields and add total discount
			if (bBillTotalDiscount) {
				//show
				pCol = m_List->GetColumn(COLUMN_TOTAL_DISCOUNT);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_TOTAL_DISCOUNT) : 7);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_TOTAL_DISCOUNT);
				pCol->PutStoredWidth(0);
			}
			/*if(bBillPercentOff) {
				//show
				pCol = m_List->GetColumn(COLUMN_PERCENT_OFF);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_PERCENT_OFF) : 6);
				}
				else {
				//hide
				pCol = m_List->GetColumn(COLUMN_PERCENT_OFF);
				pCol->PutStoredWidth(0);
				}

				if(bBillDiscount) {
				//show
				pCol = m_List->GetColumn(COLUMN_DISCOUNT);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_DISCOUNT) : 7);
				}
				else {
				//hide
				pCol = m_List->GetColumn(COLUMN_DISCOUNT);
				pCol->PutStoredWidth(0);
				}

				// (j.gruber 2007-03-21 15:36) - PLID 24870 - show the discount category column if either discount or percent off is showing
				if(bBillDiscountCategory) {
				//show
				pCol = m_List->GetColumn(COLUMN_DISCOUNT_CATEGORY);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_DISCOUNT_CATEGORY) : 7);
				}
				else {
				//hide
				pCol = m_List->GetColumn(COLUMN_DISCOUNT_CATEGORY);
				pCol->PutStoredWidth(0);
				}*/


			pCol = m_List->GetColumn(BILL_COLUMN_LINE_TOTAL); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_LINE_TOTAL) : 10);
			pCol = m_List->GetColumn(COLUMN_INS_RESP); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_INS_RESP) : 0);
			pCol = m_List->GetColumn(COLUMN_INS_PARTY_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_INS_PARTY_ID) : 0);

			if (m_bBillTax1) {
				//show
				pCol = m_List->GetColumn(COLUMN_TAX_RATE_1);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_TAX_RATE_1) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_TAX_RATE_1);
				pCol->PutStoredWidth(0);
			}

			if (m_bBillTax2) {
				//show
				pCol = m_List->GetColumn(COLUMN_TAX_RATE_2);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_TAX_RATE_2) : 6);
			}
			else {
				//hide
				pCol = m_List->GetColumn(COLUMN_TAX_RATE_2);
				pCol->PutStoredWidth(0);
			}
			//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
			pCol = m_List->GetColumn(COLUMN_ITEM_TYPE); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_ITEM_TYPE) : 0);
			pCol = m_List->GetColumn(COLUMN_PRODUCT_ITEM_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_PRODUCT_ITEM_ID) : 0);
			pCol = m_List->GetColumn(COLUMN_ALLOCATION_DETAIL_LIST_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_ALLOCATION_DETAIL_LIST_ID) : 0);
		}
		else {
			pCol = m_QuoteList->GetColumn(COLUMN_LINE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_LINE_ID) : 0);
			pCol = m_QuoteList->GetColumn(COLUMN_CHARGE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_CHARGE_ID) : 0);

			// (b.savon 2012-05-31 17:09) - PLID 50570 - Rearranged the column positioning in code so that it was easier to follow the flow.  Also updated,
			// the default column width (if nRememberWidths is  FALSE) to reflect the default column width
			if (bQuoteProvider) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_PROVIDER) : 74);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER);
				pCol->PutStoredWidth(0);
			}

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_SERVICE_ID); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_SERVICE_ID) : 0);

			//for the quote, we only have to hide columns
			if (bQuoteCPTCode) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CODE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_CPT_CODE) : 44);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CODE);
				pCol->PutStoredWidth(0);
			}

			if (bQuoteCPTSubCode) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_SUB_CODE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_CPT_SUB_CODE) : 34);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_SUB_CODE);
				pCol->PutStoredWidth(0);
			}

			// (s.tullis 2015-04-07 15:55) - PLID 64977 - Added Charge Category
			if (bQuoteCPTCategory) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CATEGORY);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_CPT_CATEGORY) : 74);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CATEGORY);
				pCol->PutStoredWidth(0);
			}

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_TYPE); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_CPT_TYPE) : 0);

			if (bQuoteMod1) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER1);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_MODIFIER1) : 0);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER1);
				pCol->PutStoredWidth(0);
			}

			if (bQuoteMod2) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER2);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_MODIFIER2) : 0);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER2);
				pCol->PutStoredWidth(0);
			}

			if (bQuoteMod3) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER3);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_MODIFIER3) : 0);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER3);
				pCol->PutStoredWidth(0);
			}

			if (bQuoteMod4) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER4);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_MODIFIER4) : 0);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER4);
				pCol->PutStoredWidth(0);
			}

			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
			if (bQuoteCalls) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CALLS);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_CALLS) : 29);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_CALLS);
				// (b.spivey, April 01, 2013) - PLID 50631 - force the style to visible/fixed width. 
				long nStyle = csVisible | csFixedWidth;
				pCol->ColumnStyle = nStyle;
				pCol->PutStoredWidth(0);
			}

			// (d.singleton 2012-05-21 14:15) - PLID 48152 skill column alberta only
			if (bQuoteSkill) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_SKILL);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_SKILL) : 20);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_SKILL);
				// (b.spivey, April 01, 2013) - PLID 50631 - force the style to visible/fixed width.
				long nStyle = csVisible | csFixedWidth;
				pCol->ColumnStyle = nStyle;
				pCol->PutStoredWidth(0);
			}

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_DESCRIPTION); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_DESCRIPTION) : 133);

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_QUANTITY); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_QUANTITY) : 29);

			if (GetIsMultiUsePackage()) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_PACKAGE_QTY_REM) : 58);

				// (j.jones 2009-12-22 16:53) - PLID 32587 - show the original qty. rem. column
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM);
				if (m_checkPackageShowInitialValues.GetCheck()) {
					pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM) : 63);
				}
				else {
					pCol->PutStoredWidth(0);
				}
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM);
				pCol->PutStoredWidth(0);

				// (j.jones 2009-12-22 16:53) - PLID 32587 - hide the original qty. rem. column
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM);
				pCol->PutStoredWidth(0);
			}

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_UNIT_COST) : 93);

			if (bQuoteOutsideCost) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE) : 93);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE);
				pCol->PutStoredWidth(0);
			}

			// (j.gruber 2009-10-19 15:58) - PLID 36000 - allowable column
			if (bQuoteAllowable) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_ALLOWABLE);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_ALLOWABLE) : 89);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_ALLOWABLE);
				pCol->PutStoredWidth(0);
			}

			// (j.gruber 2009-03-05 17:49) - PLID 33351 - take out discount fields and add total discount
			if (bQuoteTotalDiscount) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TOTAL_DISCOUNT);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_TOTAL_DISCOUNT) : 60);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TOTAL_DISCOUNT);
				pCol->PutStoredWidth(0);
			}

			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_LINE_TOTAL); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_LINE_TOTAL) : 89);

			/*if(bQuotePercentOff) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PERCENT_OFF);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_PERCENT_OFF) : 6);
				}
				else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PERCENT_OFF);
				pCol->PutStoredWidth(0);
				}

				if(bQuoteDiscount) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_DISCOUNT) : 7);
				}
				else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT);
				pCol->PutStoredWidth(0);
				}

				// (j.gruber 2007-03-21 15:36) - PLID 24870 - show the discount category column if either discount or percent off is showing
				if(bQuoteDiscountCategory) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT_CATEGORY);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_DISCOUNT_CATEGORY) : 7);
				}
				else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT_CATEGORY);
				pCol->PutStoredWidth(0);
				}*/

			if (bQuoteTax1) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_1);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_TAX_RATE_1) : 37);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_1);
				pCol->PutStoredWidth(0);
			}

			if (bQuoteTax2) {
				//show
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_2);
				pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_TAX_RATE_2) : 37);
			}
			else {
				//hide
				pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_2);
				pCol->PutStoredWidth(0);
			}

			// (j.jones 2007-07-06 13:51) - PLID 26098 - added Quote item type
			pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_ITEM_TYPE); pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_ITEM_TYPE) : 0);

		}

	}NxCatchAll("Error resizing columns");
}

void CBillingDlg::UpdatePatCoordIDs(_variant_t varCoordID) {

	//first set the patcoord of each charge		
	// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
	int i = 0;
	for (i = 0; i < (int)m_billingItems.size(); i++) {

		BillingItemPtr pItem = m_billingItems[i];

		long nChargeID = VarLong(pItem->ChargeID, -2);
		// (j.jones 2011-08-24 08:41) - PLID 44868 - do not do this if an original or void charge
		if (IsOriginalOrVoidCharge(nChargeID)) {
			continue;
		}

		m_billingItems[i]->PatCoordinator = varCoordID;

		if (nChargeID != -2) {
			AddToModifiedList(nChargeID);
		}
	}

	//now update the screen (no need if a quote)
	if (m_EntryType == 1) {
		FillBillList();
	}
}

BOOL CBillingDlg::CheckForBlockedICD9Codes()
{
	try {

		// (j.gruber 2014-03-24 12:51) - PLID 61523 - gut this function and redo it

		//first let's gather our IDs, 2 different ones for ICD-9 and ICD-10
		CArray<long, long> aryICD9IDs;
		CArray<long, long> aryICD10IDs;

		//get our codes, we are only doing the first 12
		long nSize = 12;
		if (m_arypDiagCodes.GetSize() <= 12)
		{
			nSize = m_arypDiagCodes.GetSize();
		}

		for (int i = 0; i < nSize; i++) {

			DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i);

			if (pDiag->nDiagCode9ID != -1)
			{
				aryICD9IDs.Add(pDiag->nDiagCode9ID);
			}

			if (pDiag->nDiagCode10ID != -1)
			{
				aryICD10IDs.Add(pDiag->nDiagCode10ID);
			}
		}

		_RecordsetPtr rsCheck = CreateParamRecordset("SELECT DiagCodeID1, DiagCodeID2, Diag1T.CodeNumber as DiagCode1, Diag2T.CodeNumber as DiagCode2 "
			" FROM BlockedDiagnosisCodesT "
			" LEFT JOIN DiagCodes Diag1T ON BlockedDiagnosisCodesT.DiagCodeID1 = Diag1T.ID "
			" LEFT JOIN DiagCodes Diag2T ON BlockedDiagnosisCodesT.DiagCodeID2 = Diag2T.ID "
			" WHERE ((DiagCodeID1 IN ({INTARRAY}) AND DiagCodeID2 IN ({INTARRAY})) "
			"  OR (DiagCodeID1 IN ({INTARRAY}) AND DiagCodeID2 IN ({INTARRAY}))) "
			" GROUP BY DiagCodeID1, DiagCodeID2, Diag1T.CodeNumber, Diag2T.CodeNumber "
			, aryICD9IDs, aryICD9IDs, aryICD10IDs, aryICD10IDs);


		CString strBlockCodes = "";

		while (!rsCheck->eof)
		{
			CString strWarn;
			CString strCode1 = AdoFldString(rsCheck->Fields, "DiagCode1");
			CString strCode2 = AdoFldString(rsCheck->Fields, "DiagCode2");

			strWarn.Format("%s and %s\n", strCode1, strCode2);
			strBlockCodes += strWarn;

			rsCheck->MoveNext();
		}

		if (!strBlockCodes.IsEmpty()) {
			//some were blocked - warn
			CString strWarning;
			// (r.gonet 03/07/2014) - PLID 61117 - Remove references to ICD-9 (aside from function names). Caught one message box not done.
			strWarning.Format("You are attempting to bill the following diagnosis codes which have been blocked from being used together:\n\n"
				"%s\n"
				"Do you wish to cancel saving this bill?", strBlockCodes);
			if (IDYES == MessageBox(strWarning, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
				return FALSE;
			}
		}

		return TRUE;
		// (r.gonet 03/07/2014) - PLID 61117 - Remove references to ICD-9 in exceptions (aside from function names)
	}NxCatchAll("Error checking for blocked diagnosis codes.");



	/*long DiagCodeID1 = -1, DiagCodeID2 = -1, DiagCodeID3 = -1, DiagCodeID4 = -1;

	if(m_Diag1Combo->CurSel != -1)
	DiagCodeID1 = m_Diag1Combo->GetValue(m_Diag1Combo->GetCurSel(),0).lVal;
	if(m_Diag2Combo->CurSel != -1)
	DiagCodeID2 = m_Diag2Combo->GetValue(m_Diag2Combo->GetCurSel(),0).lVal;
	if(m_Diag3Combo->CurSel != -1)
	DiagCodeID3 = m_Diag3Combo->GetValue(m_Diag3Combo->GetCurSel(),0).lVal;
	if(m_Diag4Combo->CurSel != -1)
	DiagCodeID4 = m_Diag4Combo->GetValue(m_Diag4Combo->GetCurSel(),0).lVal;

	long nDiagArray1[4];
	long nDiagArray2[4];

	nDiagArray1[0] = DiagCodeID1;
	nDiagArray1[1] = DiagCodeID2;
	nDiagArray1[2] = DiagCodeID3;
	nDiagArray1[3] = DiagCodeID4;
	nDiagArray2[0] = DiagCodeID1;
	nDiagArray2[1] = DiagCodeID2;
	nDiagArray2[2] = DiagCodeID3;
	nDiagArray2[3] = DiagCodeID4;

	CString strBlockedICD9s = "";

	int nCount = 1;
	for(int i=0;i<4;i++) {
	for(int j=nCount;j<4;j++) {
	//check to see if any of these are blocked
	if(nDiagArray1[i] == nDiagArray2[j])
	continue;
	if(nDiagArray1[i] == -1)
	continue;
	if(nDiagArray2[j] == -1)
	continue;

	//now check to see if there is a match
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	// (r.gonet 02/20/2014) - PLID 60778 - Renamed BlockedICD9CodesT to remove reference to ICD-9
	if(ReturnsRecordsParam("SELECT DiagCodeID1, DiagCodeID2 FROM BlockedDiagnosisCodesT WHERE (DiagCodeID1 = {INT} AND DiagCodeID2 = {INT}) OR (DiagCodeID1 = {INT} AND DiagCodeID2 = {INT})",nDiagArray1[i],nDiagArray2[j],nDiagArray2[j],nDiagArray1[i])) {
	//there is a match! add the warning
	CString strWarn;
	CString strCode1, strCode2;
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rsDiag1 = CreateParamRecordset("SELECT CodeNumber FROM DiagCodes WHERE ID = {INT}",nDiagArray1[i]);
	if(!rsDiag1->eof) {
	strCode1 = AdoFldString(rsDiag1, "CodeNumber","");
	}
	rsDiag1->Close();
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rsDiag2 = CreateParamRecordset("SELECT CodeNumber FROM DiagCodes WHERE ID = {INT}",nDiagArray2[j]);
	if(!rsDiag2->eof) {
	strCode2 = AdoFldString(rsDiag2, "CodeNumber","");
	}
	rsDiag2->Close();
	strWarn.Format("%s and %s\n",strCode1,strCode2);
	strBlockedICD9s += strWarn;
	}
	}
	nCount++;
	}

	if(strBlockedICD9s != "") {
	//some were blocked - warn
	CString strWarning;
	// (r.gonet 03/07/2014) - PLID 61117 - Remove references to ICD-9 (aside from function names). Caught one message box not done.
	strWarning.Format("You are attempting to bill the following diagnosis codes which have been blocked from being used together:\n\n"
	"%s\n"
	"Do you wish to cancel saving this bill?",strBlockedICD9s);
	if(IDYES == MessageBox(strWarning,"Practice",MB_ICONEXCLAMATION|MB_YESNO)) {
	return FALSE;
	}
	}

	return TRUE;
	// (r.gonet 03/07/2014) - PLID 61117 - Remove references to ICD-9 in exceptions (aside from function names)
	}NxCatchAll("Error checking for blocked diagnosis codes.");*/

	return FALSE;
}

// (j.jones 2013-04-10 11:39) - PLID 56179 - renamed to say services, since it can
// be CPT codes or products now
BOOL CBillingDlg::CheckForBlockedServices()
{
	try {

		CDWordArray dwServiceArray1;
		CDWordArray dwServiceArray2;

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType.  Changed to "!cpt" from "== product"
			//	so that we also include gift certificates.
			//if a product, or a previously saved charge, then don't compare the codes
			// (j.jones 2013-04-10 11:42) - PLID 56179 - this now supports products
			if ((VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) != ITEM_TYPE_CPT && VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) != ITEM_TYPE_PRODUCT)
				|| pRow->GetValue(COLUMN_CHARGE_ID).lVal != -2) {

				pRow = pRow->GetNextRow();
				continue;
			}

			dwServiceArray1.Add((DWORD)VarLong(pRow->GetValue(COLUMN_SERVICE_ID), -1));
			dwServiceArray2.Add((DWORD)VarLong(pRow->GetValue(COLUMN_SERVICE_ID), -1));

			pRow = pRow->GetNextRow();
		}

		CString strBlockedServices = "";

		int nCount = 1;
		for (i = 0; i < dwServiceArray1.GetSize(); i++) {
			for (int j = nCount; j < dwServiceArray2.GetSize(); j++) {
				//check to see if any of these are blocked
				long nID1 = (long)dwServiceArray1.GetAt(i);
				long nID2 = (long)dwServiceArray2.GetAt(j);

				if (nID1 == nID2)
					continue;
				if (nID1 == -1)
					continue;
				if (nID2 == -1)
					continue;

				//now check to see if there is a match
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (ReturnsRecordsParam("SELECT ServiceID1, ServiceID2 FROM BlockedCPTCodesT WHERE (ServiceID1 = {INT} AND ServiceID2 = {INT}) OR (ServiceID1 = {INT} AND ServiceID2 = {INT})", nID1, nID2, nID2, nID1)) {
					//there is a match! add the warning
					CString strWarn;
					CString strService1, strService2;
					// (j.jones 2013-04-10 11:42) - PLID 56179 - this now supports products
					_RecordsetPtr rsService = CreateParamRecordset("SELECT "
						"CASE WHEN ProductT.ID Is Not Null THEN "
						"	ProductT.InsCode + CASE WHEN Coalesce(ProductT.InsCode,'') = '' THEN '' ELSE ' - ' END "
						"ELSE CPTCodeT.Code + ' - ' END "
						"+ ServiceT.Name AS Description "
						"FROM ServiceT "
						"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
						"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
						"WHERE ServiceT.ID = {INT} OR ServiceT.ID = {INT}",
						nID1, nID2);
					if (!rsService->eof) {
						strService1 = AdoFldString(rsService, "Description", "");
						rsService->MoveNext();
						if (!rsService->eof) {
							strService2 = AdoFldString(rsService, "Description", "");
						}
					}
					rsService->Close();
					strWarn.Format("%s and %s\n", strService1, strService2);
					strBlockedServices += strWarn;
				}
			}
			nCount++;
		}

		if (strBlockedServices != "") {
			//some were blocked - warn
			CString strWarning;
			strWarning.Format("You are attempting to bill the following charges which have been blocked from being used together:\n\n"
				"%s\n"
				"Do you wish to cancel saving this bill?", strBlockedServices);
			if (IDYES == MessageBox(strWarning, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
				return FALSE;
			}
		}

		return TRUE;

	}NxCatchAll("Error checking for blocked service codes / products.");

	return FALSE;
}

// (j.gruber 2014-02-28 11:40) - PLID 61078 
CString CBillingDlg::GetItemDescriptionForWarning(BillingItemPtr pItem, BOOL bAllowLinking)
{
	CString strCPTCode = VarString(pItem->CPTCode, "");
	strCPTCode.TrimLeft(); strCPTCode.TrimRight();
	CString strCPTSubCode = VarString(pItem->CPTSubCode, "");
	strCPTSubCode.TrimLeft(); strCPTSubCode.TrimRight();
	CString strFullCPTCode;
	strFullCPTCode.Format("%s %s", strCPTCode, strCPTSubCode);
	strFullCPTCode.TrimRight();
	CString strChargeDesc = VarString(pItem->Description, "");
	strChargeDesc.TrimLeft(); strChargeDesc.TrimRight();

	CString strLineDescription;
	if (bAllowLinking) {
		if (strFullCPTCode.IsEmpty()) {
			strLineDescription = strChargeDesc;
		}
		else {
			strLineDescription.Format("%s - %s", strFullCPTCode, strChargeDesc);
		}
	}
	else
	{
		//if we are not linking the FullCPTCode
		strLineDescription = strFullCPTCode;
	}

	//now add our type
	if (pItem->ItemType.lVal == ITEM_TYPE_CPT)
	{
		strLineDescription = "Service Code " + strLineDescription;
	}
	else {
		//must be a product
		strLineDescription = "Inventory Item " + strLineDescription;
	}

	return strLineDescription;
}

// (j.gruber 2014-02-28 11:40) - PLID 61078
CString CBillingDlg::FormatDiagString(std::vector<std::pair<long, CString>> aryDiags)
{
	if (aryDiags.size() == 1)
	{
		return aryDiags[0].second;
	}
	else if (aryDiags.size() == 2)
	{
		return aryDiags[0].second + " or " + aryDiags[1].second;
	}
	else {
		CString strDiags;
		for (int i = 0; i < ((int)aryDiags.size() - 1); i++)
		{
			strDiags += aryDiags[i].second + ", ";
		}

		//we have one left, or add the or
		strDiags += " or " + aryDiags[i].second;

		return strDiags;
	}
}


// (j.jones 2013-04-10 11:39) - PLID 56179 - renamed to say services, since it can
// be CPT codes or products now
// (j.gruber 2014-02-28 11:40) - PLID 61078 - refactored this function
BOOL CBillingDlg::CheckForLinkedServices()
{
	try {

		CString strDiagCode, strWhichCodes, str;

		BOOL bWhichCodesOnly = FALSE;

		// (r.gonet 02/20/2014) - PLID 60778 - Renamed to remove reference to ICD-9
		if (GetRemotePropertyInt("LinkSelectedCPTDiagnosisCodes", 1, 0, "<None>", TRUE) == 1)
		{
			bWhichCodesOnly = TRUE;
		}
		else
		{
			bWhichCodesOnly = FALSE;
		}


		// (j.jones 2012-12-12 14:04) - PLID 47773 - Added ability to allow linking unlinked CPT/ICD codes.
		// If enabled, they will be prompted one at a time and asked if they wish to link the codes together.
		// This is the historical behavior, and the default.
		// If disabled, they will be prompted just once for all unlinked codes, and given the option to cancel.
		CString strWarnCodes = "";
		BOOL bAllowLinking = TRUE;
		if (GetRemotePropertyInt("AllowDynamicCPTICDLinking", 1, 0, "<None>", true) == 0) {
			bAllowLinking = FALSE;
		}

		std::map<std::pair<long, long>, std::pair<CString, CString>> mapServiceDiagsToCheck;
		CArray<long, long> aryServiceCodes;

		for each(std::vector<BillingItemPtr>::value_type pItem in m_billingItems)
		{

			//we are only dealing with new charges 
			if (pItem->ChargeID.lVal == -2 &&
				//and only CPT codes 
				(pItem->ItemType.lVal == ITEM_TYPE_CPT
				//and products with Insurance Codes, which are in the CPT code field				
				|| (pItem->ItemType.lVal == ITEM_TYPE_PRODUCT && (VarString(pItem->CPTCode, "") != ""))
				)
				//and if we are only doing whichCodes and this charge has none
				&& ((bWhichCodesOnly && pItem->whichCodes->size() > 0) || !bWhichCodesOnly)
				)
			{

				CString strItemDescription = GetItemDescriptionForWarning(pItem, bAllowLinking);

				//add to our list of services
				aryServiceCodes.Add(VarLong(pItem->ServiceID));

				//array for storing the ones that we need to check
				std::vector<DiagCodeInfoPtr> aryDiagsToCheck;

				//if we are only doing whichcodes, loop through our whichcode diags, otherwise loop through our bill dials
				if (bWhichCodesOnly)
				{
					for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *pItem->whichCodes) {
						std::pair<long, long> pairToAdd9 = std::make_pair(VarLong(pItem->ServiceID), entry.second->nDiagCode9ID);
						std::pair<CString, CString> pairDesc9Desc = std::make_pair(strItemDescription, entry.second->strDiagCode9Code);
						if (entry.second->nDiagCode9ID != -1) {
							mapServiceDiagsToCheck.insert(std::make_pair(pairToAdd9, pairDesc9Desc));
						}
						std::pair<long, long> pairToAdd10 = std::make_pair(VarLong(pItem->ServiceID), entry.second->nDiagCode10ID);
						std::pair<CString, CString> pairDesc10Desc = std::make_pair(strItemDescription, entry.second->strDiagCode10Code);
						if (entry.second->nDiagCode10ID != -1) {
							mapServiceDiagsToCheck.insert(std::make_pair(pairToAdd10, pairDesc10Desc));
						}
					}
				}
				else {
					for (int i = 0; i < m_arypDiagCodes.GetSize(); i++)
					{
						DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i);
						std::pair<long, long> pairToAdd9 = std::make_pair(VarLong(pItem->ServiceID), pDiag->nDiagCode9ID);
						std::pair<CString, CString> pairDesc9Desc = std::make_pair(strItemDescription, pDiag->strDiagCode9Code);
						if (pDiag->nDiagCode9ID != -1) {
							mapServiceDiagsToCheck.insert(std::make_pair(pairToAdd9, pairDesc9Desc));
						}
						std::pair<long, long> pairToAdd10 = std::make_pair(VarLong(pItem->ServiceID), pDiag->nDiagCode10ID);
						std::pair<CString, CString> pairDesc10Desc = std::make_pair(strItemDescription, pDiag->strDiagCode10Code);
						if (pDiag->nDiagCode10ID != -1)
						{
							mapServiceDiagsToCheck.insert(std::make_pair(pairToAdd10, pairDesc10Desc));
						}
					}
				}
			}
		}


		//get our list of used services		
		_RecordsetPtr rsCheck = CreateParamRecordset("SELECT ServiceID, DiagCodeID "
			" FROM CPTDiagnosisGroupsT "
			" WHERE ServiceID IN ({INTARRAY}) ", aryServiceCodes);
		while (!rsCheck->eof)
		{
			long nServiceID = AdoFldLong(rsCheck->Fields, "ServiceID");
			long nDiagCodeID = AdoFldLong(rsCheck->Fields, "DiagCodeID");
			std::pair<long, long> pairToFind(nServiceID, nDiagCodeID);

			std::map<std::pair<long, long>, std::pair<CString, CString>>::iterator itFind = mapServiceDiagsToCheck.find(pairToFind);
			if (itFind != mapServiceDiagsToCheck.end())
			{
				//we found the pair in our query, which means we don't need to warn
				mapServiceDiagsToCheck.erase(itFind);
			}

			rsCheck->MoveNext();
		}

		//loop through our map with the warnings
		if (bAllowLinking)
		{
			//we warn for each combination
			CSqlFragment sqlInserts;
			for each(std::map<std::pair<long, long>, std::pair<CString, CString>>::value_type pCombo in mapServiceDiagsToCheck)
			{
				CString str;
				str.Format("The diagnosis code %s does not match up with %s.\n\n"
					"Would you like to associate the two together?", pCombo.second.second, pCombo.second.first);
				if (IDNO == MessageBox(str, "Practice", MB_YESNO)) {
					if (IDYES == MessageBox("You chose to not associate these codes. Would you like to cancel saving this bill?", "Practice", MB_YESNO | MB_ICONEXCLAMATION)) {
						return FALSE;
					}
				}
				else {
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					sqlInserts += CSqlFragment("INSERT INTO CPTDiagnosisGroupsT (ServiceID,DiagCodeID) VALUES ({INT},{INT})", pCombo.first.first, pCombo.first.second);
				}

			}

			//insert our codes
			if (!sqlInserts.IsEmpty())
			{
				ExecuteParamSql(sqlInserts);
			}
		}
		else {

			//we are only warning once

			//first we need to format this into per service
			std::map<std::pair<long, CString>, std::vector<std::pair<long, CString>>> mapByServices;

			for each(std::map<std::pair<long, long>, std::pair<CString, CString>>::value_type pCombo in mapServiceDiagsToCheck)
			{
				//get our serviceID, description pair
				std::pair<long, CString> service = std::make_pair(pCombo.first.first, pCombo.second.first);

				//do we already have this service
				std::map<std::pair<long, CString>, std::vector<std::pair<long, CString>>>::iterator itFind = mapByServices.find(service);
				if (itFind != mapByServices.end())
				{
					//we have it, so we can add to our diagnoses vector
					itFind->second.push_back(std::make_pair(pCombo.first.second, pCombo.second.second));
				}
				else {
					//we don't have it yet, so make our we need to insert

					//make the vector fist
					std::vector<std::pair<long, CString>> aryDiags;
					aryDiags.push_back(std::make_pair(pCombo.first.second, pCombo.second.second));

					//now insert
					mapByServices.insert(std::make_pair(service, aryDiags));
				}
			}


			//now that we have our new map, we have to loop through that to get the message
			CString strWarning;
			for each (std::map<std::pair<long, CString>, std::vector<std::pair<long, CString>>>::value_type pService in mapByServices)
			{
				std::vector<std::pair<long, CString>> aryDiags = pService.second;
				CString strDiags = FormatDiagString(aryDiags);

				CString strTemp;
				strTemp.Format("The %s is not compatible with the diagnosis code%s %s.\n",
					pService.first.second,
					aryDiags.size() > 1 ? "s" : "", strDiags);
				strWarning += strTemp;
			}

			//finally give the warning
			CString strWarn;
			if (!strWarning.IsEmpty())
			{
				strWarn.Format("%s\nWould you like to cancel saving this bill?", strWarning);
				if (IDYES == MessageBox(strWarn, "Practice", MB_YESNO | MB_ICONEXCLAMATION)) {
					return FALSE;
				}
			}
		}

		return TRUE;

	}NxCatchAll("Error checking for linked service codes / products.");

	return FALSE;
}

void CBillingDlg::OnSelChosenWhatToAddCombo(long nRow)
{
	CString strSelItem;

	CWaitCursor wait;

	/*Originally, we used to hide all the combos here, then show the one that was chosen
	however, the SQL requery is not the most expedient process, and this method left us ugly
	gray bars to look at while we waited. So now the user gets a wait cursor, and the current bar is still
	shown until the new one is fully loaded. - JJ*/

	if (m_WhatToAddCombo->GetCurSel() == -1)
		m_WhatToAddCombo->CurSel = 0;

	long sel = VarLong(m_WhatToAddCombo->GetValue(m_WhatToAddCombo->CurSel, 0), 0);

	//Show only the combo(s) needed for the item selected
	if ((m_EntryType == 1 && sel == ROW_BILL_A_CPT_CODE) || (m_EntryType == 2 && sel == ROW_QUOTE_A_CPT_CODE)){
		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457
		//Show the codes filter button (if not a quote)
		// (a.walling 2008-05-05 18:01) - PLID 26105 - Keep the CPT codes filter visible, quote or not.
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_SHOWNOACTIVATE);

		//If a filter is applied for the Products list, the proper icon should be shown
		if (m_bProductsFilter)
		{
			//Set the filter button's icon
			m_filterCodesButton.SetIcon(IDI_FILTER);
		}
		//If a filter is applied for the CPT codes, the proper icon should be shown
		if (m_bCptCodesFilter)
		{
			//Set the filter button's icon
			m_filterCodesButton.SetIcon(IDI_FILTERDN);
		}
		//Ensure that the icon is set to the correct visible color
		m_filterCodesButton.RedrawWindow();

	}
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_SURGERY)
		|| (m_EntryType == 2 && (sel == ROW_QUOTE_A_SURGERY || sel == ROW_QUOTE_A_PACKAGE))){

		// (j.jones 2010-01-06 16:12) - PLID 36757 - a bill will only show surgeries,
		//a quote could show surgeries or packages, and may requery when the selection changes

		CString strWhereClause = "IsPackage = 0";
		if (m_EntryType == 2 && sel == ROW_QUOTE_A_PACKAGE) {
			strWhereClause = "IsPackage = 1";
		}

		CString strOldWhereClause = (LPCTSTR)m_SrgyCombo->GetWhereClause();

		if (m_bSurgeryCombo == FALSE || strOldWhereClause != strWhereClause) {
			m_SrgyCombo->PutWhereClause((LPCTSTR)strWhereClause);
			m_SrgyCombo->Requery();
			m_bSurgeryCombo = TRUE;
		}
		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457 - Hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);

	}
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_PRODUCT) || (m_EntryType == 2 && sel == ROW_QUOTE_A_PRODUCT)) {

		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}
		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457
		//Show the codes filter button (if not a quote)
		//if(sel == ROW_QUOTE_A_PRODUCT)
		// (a.walling 2008-05-05 18:01) - PLID 26105 - Keep the CPT codes filter visible, quote or not.
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_SHOWNOACTIVATE);

		//If a filter on the Products list is not applied, store the default where clause
		if (!m_bProductsFilter)
			m_strProductsWhere = CString((LPCTSTR)m_ProductsCombo->WhereClause);

		//If a filter for the CPT codes list is applied, the proper icon should be shown
		if (m_bCptCodesFilter)
		{
			//Set the filter button's icon
			m_filterCodesButton.SetIcon(IDI_FILTER);
		}
		//If a filter for the Products list is applied, the proper icon should be shown
		if (m_bProductsFilter)
		{
			//Set the filter button's icon
			m_filterCodesButton.SetIcon(IDI_FILTERDN);
		}

		//Ensure that the icon is set to the correct visible color
		m_filterCodesButton.RedrawWindow();
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_QUOTE){
		//JJ- TODO: use network code here? This must requery every time
		//because if you change patients or add quotes, the data changes.
		//if(m_bQuotesCombo==FALSE) {
		m_QuotesCombo->Requery();
		m_bQuotesCombo = TRUE;
		//}
		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457 - Hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_CASE){

		//JJ - same conundrum as the quote, in terms of network code
		m_CaseHistoryCombo->Requery();
		m_bCaseHistoryCombo = TRUE;

		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457 - Hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);

		//TODO: this is a band-aid for saving, for the show, but there might be a better way to save the case history info

		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}

		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}
	}
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_EMR) || (m_EntryType == 2 && sel == ROW_QUOTE_A_EMR)){

		//JJ - same conundrum as the quote, in terms of network code
		m_EMRCombo->Requery();
		m_bEMRCombo = TRUE;

		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 - PLID 16457 - Hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);

		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}

		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}
	}
	else if (m_EntryType == 1 && sel == ROW_BILL_A_GIFT) {

		if (!IsSpa(TRUE)) {
			//If this fails, most likely that means that they are doing usage counts and said no.  Just reset to cpt code
			//	if we can't do this.
			OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)ROW_BILL_A_CPT_CODE));

			return;
		}

		//DRT - Copying above from the EMR
		m_GiftCombo->Requery();
		m_bGiftCombo = FALSE;

		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//m.hancock - 6-15-2005 = PLID 16457 - Hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);
	}
	// (j.jones 2008-06-20 10:36) - PLID 26153 - added ability to bill an appointment
	else if ((m_EntryType == 1 && sel == ROW_BILL_AN_APPT) || (m_EntryType == 2 && sel == ROW_QUOTE_AN_APPT)){

		//much like the quote, EMR, and case history, requery every time this option is selected
		m_AppointmentCombo->Requery();
		m_bAppointmentCombo = TRUE;

		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_HIDE);

		//hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);

		//requery products and services if they have not already been requeried,
		//as we may need their contents
		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}
		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}

		//warn after the requeries start
		DontShowMeAgain(this, "When billing / quoting an appointment, the list of appointments will display "
			"all of the patient's appointments that are of a procedural type (Office Procedure, Surgery, etc.) "
			"and have a purpose that has at least one service code or inventory item linked to it. "
			"If multiple services are available, you will be able to choose which services and products that will be billed.",
			"BillingDlgAppointmentSelection", "Practice", FALSE, FALSE);
	}
	//TES 4/13/2011 - PLID 43249 - Added Glasses Orders
	else if (m_EntryType == 1 && sel == ROW_BILL_A_GLASSES_ORDER) {

		//much like the quote, EMR, and case history, requery every time this option is selected
		m_GlassesOrderCombo->Requery();
		m_bGlassesOrderCombo = TRUE;

		GetDlgItem(IDC_COMBO_CPT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_PRODUCTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_SRGY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_QUOTE)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_CASE_HISTORY)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_EMR)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GIFT)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_APPOINTMENTS)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_COMBO_GLASSES_ORDERS)->ShowWindow(SW_SHOW);

		//hide the codes filter button
		GetDlgItem(IDC_FILTER_CODES)->ShowWindow(SW_HIDE);

		//requery products and services if they have not already been requeried,
		//as we may need their contents
		if (m_bProductsCombo == FALSE) {
			// (j.jones 2014-07-28 09:31) - PLID 56662 - added modular function to requery the product combo
			RequeryProductCombo();
		}
		if (m_bCPTCombo == FALSE) {
			//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
			m_CPTCombo->PutWhereClause(_bstr_t(m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere));
			m_CPTCombo->Requery();
			m_bCPTCombo = TRUE;
		}
	}
}

long CBillingDlg::GetDefaultBillProviderID() {

	// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
	// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
	if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 1) {
		return -1;
	}

	//if they have an applied superbill, see if that superbill is linked with an appointment
	//and that appointment's resource is linked with a provider, then use that provider
	// (j.jones 2011-04-27 15:32) - PLID 43405 - this is now a variant
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_varSuperbillID.vt == VT_I4
		&& GetRemotePropertyInt("ApplySuperbillUseProvider", 0, 0, "<None>", true) == 1) {
		//what to do with multi-resources? For now, take the first resource that has a Provider ID
		long nProviderID = -1;
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rs = CreateParamRecordset("SELECT ProviderID FROM ResourceProviderLinkT "
			"INNER JOIN AppointmentResourceT ON ResourceProviderLinkT.ResourceID = AppointmentResourceT.ResourceID "
			"INNER JOIN PrintedSuperBillsT ON AppointmentResourceT.AppointmentID = PrintedSuperBillsT.ReservationID "
			"INNER JOIN PersonT ON ResourceProviderLinkT.ProviderID = PersonT.ID "
			"WHERE ProviderID Is Not Null AND PersonT.Archived = 0 AND PrintedSuperBillsT.SavedID = {INT} "
			"AND PersonT.Archived = 0", VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_varSuperbillID));
		while (!rs->eof && nProviderID == -1) {
			nProviderID = AdoFldLong(rs, "ProviderID", -1);
			rs->MoveNext();
		}
		rs->Close();

		if (nProviderID != -1)
			return nProviderID;
	}

	// (j.jones 2010-11-10 15:47) - PLID 32887 - added ability to use the provider
	//from the most recent appointment's resource
	if (GetRemotePropertyInt("BillUseAppointmentProvider", 0, 0, "<None>", true) == 1) {
		long nProviderID = -1;
		//use the first linked provider on the appointment
		//TES 5/17/2013 - PLID 45721 - Don't just pick one at random!  Let the user decide which one to use.
		CArray<long, long> arProviderIDs;
		_RecordsetPtr rs = CreateParamRecordset("SELECT ResourceProviderLinkT.ProviderID, AppointmentsT.ID "
			"FROM ResourceProviderLinkT "
			"INNER JOIN AppointmentResourceT ON ResourceProviderLinkT.ResourceID = AppointmentResourceT.ResourceID "
			"INNER JOIN PersonT ON ResourceProviderLinkT.ProviderID = PersonT.ID "
			"INNER JOIN AppointmentsT ON AppointmentResourceT.AppointmentID = AppointmentsT.ID "
			"WHERE ResourceProviderLinkT.ProviderID Is Not Null "
			"AND PersonT.Archived = 0 "
			"AND AppointmentsT.PatientID = {INT} "
			"AND dbo.AsDateNoTime(AppointmentsT.Date) <= {STRING} "
			"AND AppointmentsT.Status <> 4 AND AppointmentsT.ShowState <> 3 "
			"ORDER BY AppointmentsT.Date DESC, AppointmentsT.StartTime DESC, AppointmentsT.ID DESC", m_nPatientID, FormatDateTimeForSql(m_peditBillDate->GetValue()));

		long nAppointmentID = -1;
		bool bFinished = false;
		while (!rs->eof && !bFinished) {
			long nThisApptID = AdoFldLong(rs, "ID");
			if (nAppointmentID == -1) {
				nAppointmentID = nThisApptID;
			}
			if (nAppointmentID == nThisApptID) {
				arProviderIDs.Add(AdoFldLong(rs, "ProviderID"));
			}
			else {
				bFinished = true;
			}
			rs->MoveNext();
		}
		rs->Close();
		//TES 5/17/2013 - PLID 45721 - If they don't have any, do nothing
		if (arProviderIDs.GetCount() > 0) {
			//TES 5/17/2013 - PLID 45721 - If they have one, use it.
			if (arProviderIDs.GetCount() == 1) {
				nProviderID = arProviderIDs[0];
			}
			else {
				//TES 5/17/2013 - PLID 45721 - They have multiple, so prompt them to choose
				CSingleSelectDlg dlg(this);
				if (IDOK == dlg.Open("PersonT", "ID IN (" + ArrayAsString(arProviderIDs) + ")", "ID", "Last + ', ' + First + ' ' + Middle",
					"You have chosen the preference to use the most recent appointment's provider as the provider for this bill.  However, "
					"the most recent appointment is associated with multiple providers.  Please select one of the providers to use for this bill.")) {
					nProviderID = dlg.GetSelectedID();
				}
				else {
					return -1;
				}
			}
		}

		if (nProviderID != -1) {
			return nProviderID;
		}
	}

	//use the default provider from General 1
	if (m_Main_Physician != -1) {
		return m_Main_Physician;
	}
	else {
		//use the default provider for the bill location, if they want
		if (GetRemotePropertyInt("UseDefaultLocationProviderOnCharges", 0, 0, "<None>", TRUE) == 1) {
			long LocationID = GetCurrentLocationID();
			if (m_LocationCombo->GetCurSel() != -1) {
				LocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
			}
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rs = CreateParamRecordset("SELECT DefaultProviderID FROM LocationsT INNER JOIN persont "
				"ON locationst.defaultproviderid=persont.id WHERE persont.archived=0 "
				"AND LocationsT.ID={INT}", LocationID);
			if (!rs->eof) {
				return VarLong(rs->Fields->GetItem("DefaultProviderID")->Value, -1);
			}
			rs->Close();
		}
	}

	return -1;
}
// (s.dhole 2011-06-13 11:51) - PLID 33666 Change code to support BILL_COLUMN_WHICH_CODES_EXT column
int CBillingDlg::GetNextBillColumn(int nCol, int CurrentColumn, BOOL bIsShiftDown) {

	switch (nCol) {
		case COLUMN_LINE_ID:
		case COLUMN_CHARGE_ID:
			// (d.singleton 2012-03-07 17:39) - PLID 25098 new column
		case BILL_VALIDATION_STATUS:
			// (d.singleton 2012-03-22 16:45) - PLID 49136 notes column
		case BILL_COLUMN_NOTES:
			//These columns aren't editable!
			ASSERT(FALSE);

			if (bIsShiftDown)
				return GetNextBillColumn(COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
			else
				return GetNextBillColumn(BILL_COLUMN_DATE, CurrentColumn, bIsShiftDown);

			break;

		case BILL_COLUMN_DATE:

			if (CurrentColumn == BILL_COLUMN_DATE || m_List->GetColumn(BILL_COLUMN_DATE)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_SERVICE_DATE_TO, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_DATE;

			break;

		case COLUMN_SERVICE_DATE_TO:

			if (CurrentColumn == COLUMN_SERVICE_DATE_TO || m_List->GetColumn(COLUMN_SERVICE_DATE_TO)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_DATE, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_SERVICE_DATE_TO;

			break;

			//we purposely don't tab into input date

		case BILL_COLUMN_PROVIDER:

			if (CurrentColumn == BILL_COLUMN_PROVIDER || m_List->GetColumn(BILL_COLUMN_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_SERVICE_DATE_TO, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_CLAIM_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_PROVIDER;

			break;

			// (j.jones 2010-11-09 09:42) - PLID 31392 - added claim provider
		case BILL_COLUMN_CLAIM_PROVIDER:

			if (CurrentColumn == BILL_COLUMN_CLAIM_PROVIDER || m_List->GetColumn(BILL_COLUMN_CLAIM_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_REFERRING_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_CLAIM_PROVIDER;

			break;

			// (j.jones 2014-04-23 10:17) - PLID 61836 - added referring, ordering, supervising providers
		case BILL_COLUMN_REFERRING_PROVIDER:

			if (CurrentColumn == BILL_COLUMN_REFERRING_PROVIDER || m_List->GetColumn(BILL_COLUMN_REFERRING_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_CLAIM_PROVIDER, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_ORDERING_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_REFERRING_PROVIDER;

			break;

		case BILL_COLUMN_ORDERING_PROVIDER:

			if (CurrentColumn == BILL_COLUMN_ORDERING_PROVIDER || m_List->GetColumn(BILL_COLUMN_ORDERING_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_REFERRING_PROVIDER, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_SUPERVISING_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_ORDERING_PROVIDER;

			break;

		case BILL_COLUMN_SUPERVISING_PROVIDER:

			if (CurrentColumn == BILL_COLUMN_SUPERVISING_PROVIDER || m_List->GetColumn(BILL_COLUMN_SUPERVISING_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_ORDERING_PROVIDER, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_PATCOORD, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_SUPERVISING_PROVIDER;

			break;
		
		case COLUMN_PATCOORD:

			if (CurrentColumn == COLUMN_PATCOORD || m_List->GetColumn(COLUMN_PATCOORD)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_SUPERVISING_PROVIDER, CurrentColumn, bIsShiftDown);
				else // (s.tullis 2015-03-24 09:28) - PLID 64973 - Next column is charge category
					return GetNextBillColumn(BILL_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_PATCOORD;

			break;

		case COLUMN_SERVICE_ID:
		case BILL_COLUMN_CPT_CODE:
		case BILL_COLUMN_CPT_SUB_CODE:
		case BILL_COLUMN_CPT_TYPE:
			//These columns aren't editable!
			ASSERT(FALSE);

			if (bIsShiftDown)
				return GetNextBillColumn(COLUMN_PATCOORD, CurrentColumn, bIsShiftDown);
			else // (s.tullis 2015-03-24 09:28) - PLID 64973 - just in case shift down to cpt category
				return GetNextBillColumn(BILL_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);

			break;
			// (s.tullis 2015-03-24 09:28) - PLID 64973 - Added cpt category
		case BILL_COLUMN_CPT_CATEGORY:
			if (CurrentColumn == BILL_COLUMN_CPT_CATEGORY || m_List->GetColumn(BILL_COLUMN_CPT_CATEGORY)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_PATCOORD, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_CPT_TYPEOFSERVICE, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_CPT_CATEGORY;

			break;
		case BILL_COLUMN_CPT_TYPEOFSERVICE:

			if (CurrentColumn == BILL_COLUMN_CPT_TYPEOFSERVICE || m_List->GetColumn(BILL_COLUMN_CPT_TYPEOFSERVICE)->GetStoredWidth() == 0) {
				if (bIsShiftDown)// (s.tullis 2015-03-24 09:28) - PLID 64973 - Shift back to category
					return GetNextBillColumn(BILL_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_MODIFIER1, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_CPT_TYPEOFSERVICE;

			break;

		case COLUMN_MODIFIER1:

			if (CurrentColumn == COLUMN_MODIFIER1 || m_List->GetColumn(COLUMN_MODIFIER1)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_CPT_TYPEOFSERVICE, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_MODIFIER2, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_MODIFIER1;

			break;

		case COLUMN_MODIFIER2:

			if (CurrentColumn == COLUMN_MODIFIER2 || m_List->GetColumn(COLUMN_MODIFIER2)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_MODIFIER1, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_MODIFIER3, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_MODIFIER2;

			break;

		case COLUMN_MODIFIER3:

			if (CurrentColumn == COLUMN_MODIFIER3 || m_List->GetColumn(COLUMN_MODIFIER3)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_MODIFIER2, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_MODIFIER4, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_MODIFIER3;

			break;

		case COLUMN_MODIFIER4:

			if (CurrentColumn == COLUMN_MODIFIER4 || m_List->GetColumn(COLUMN_MODIFIER4)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_MODIFIER3, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_CALLS, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_MODIFIER4;

			break;

			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
		case COLUMN_CALLS:
			if (CurrentColumn == COLUMN_CALLS || m_List->GetColumn(COLUMN_CALLS)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_MODIFIER4, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_SKILL, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_CALLS;

			break;

			// (d.singleton 2012-05-21 14:32) - PLID 48152 added skill column alberta only
		case COLUMN_SKILL:
			if (CurrentColumn == COLUMN_SKILL || m_List->GetColumn(COLUMN_SKILL)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_CALLS, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_WHICH_CODES, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_SKILL;

			break;

		case BILL_COLUMN_WHICH_CODES:

			if (CurrentColumn == BILL_COLUMN_WHICH_CODES || m_List->GetColumn(BILL_COLUMN_WHICH_CODES)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_SKILL, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_DESCRIPTION, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_WHICH_CODES;
			break;
			/*case BILL_COLUMN_WHICH_CODES_EXT:
				if(CurrentColumn == BILL_COLUMN_WHICH_CODES_EXT  || m_List->GetColumn(BILL_COLUMN_WHICH_CODES_EXT)->GetStoredWidth() == 0) {
				if(bIsShiftDown)
				return GetNextBillColumn(BILL_COLUMN_WHICH_CODES,CurrentColumn,bIsShiftDown);
				else
				return GetNextBillColumn(BILL_COLUMN_DESCRIPTION,CurrentColumn,bIsShiftDown);
				}
				else
				return BILL_COLUMN_WHICH_CODES_EXT;
				break;

				*/
		case BILL_COLUMN_DESCRIPTION:

			if (CurrentColumn == BILL_COLUMN_DESCRIPTION || m_List->GetColumn(BILL_COLUMN_DESCRIPTION)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_WHICH_CODES, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_QUANTITY, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_DESCRIPTION;

			break;

		case BILL_COLUMN_QUANTITY:

			if (CurrentColumn == BILL_COLUMN_QUANTITY || m_List->GetColumn(BILL_COLUMN_QUANTITY)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_DESCRIPTION, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(BILL_COLUMN_UNIT_COST, CurrentColumn, bIsShiftDown);
			}
			else
				return BILL_COLUMN_QUANTITY;

			break;

			// (j.gruber 2009-03-05 17:52) - PLID 33351 - take out discount columns, add total discounts
		case BILL_COLUMN_UNIT_COST:

			if (CurrentColumn == BILL_COLUMN_UNIT_COST || m_List->GetColumn(BILL_COLUMN_UNIT_COST)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(BILL_COLUMN_QUANTITY, CurrentColumn, bIsShiftDown);
				else {
					// (r.gonet 2015-03-27 18:53) - PLID 65277 - Go to the Value column.
					return GetNextBillColumn(BILL_COLUMN_VALUE, CurrentColumn, bIsShiftDown);
				}
			}
			else
				return BILL_COLUMN_UNIT_COST;

			break;

		case BILL_COLUMN_VALUE:
			// (r.gonet 2015-03-27 18:48) - PLID 65277 - The Value column is sandwiched in between the Unit Cost column
			// and the Allowable column. The Allowable column is not editable, so we'll go to the next editable column,
			// which is the Insurance Responsibility column.
			if (CurrentColumn == BILL_COLUMN_VALUE || m_List->GetColumn(BILL_COLUMN_VALUE)->GetStoredWidth() == 0) {
				if (bIsShiftDown) {
					return GetNextBillColumn(BILL_COLUMN_UNIT_COST, CurrentColumn, bIsShiftDown);
				} else {
					return GetNextBillColumn(COLUMN_INS_RESP, CurrentColumn, bIsShiftDown);
				}
			} else {
				return BILL_COLUMN_VALUE;
			}
			break;

			// (j.jones 2010-09-01 10:38) - PLID 40330 - added allowable to bills, not editable, nothing should
			// try to select this as an editable field
		case BILL_COLUMN_ALLOWABLE:
			//not editable
			ASSERT(FALSE);
			break;

		case COLUMN_TOTAL_DISCOUNT:
			//not editable
			ASSERT(FALSE);
			break;

		case BILL_COLUMN_LINE_TOTAL:
			//This column isn't editable!
			ASSERT(FALSE);
			break;
		case COLUMN_INS_RESP:

			if (CurrentColumn == COLUMN_INS_RESP || m_List->GetColumn(COLUMN_INS_RESP)->GetStoredWidth() == 0) {
				if (bIsShiftDown) {
					// (r.gonet 2015-03-27 18:53) - PLID 65277 - Return to the new Value column.
					return GetNextBillColumn(BILL_COLUMN_VALUE, CurrentColumn, bIsShiftDown);
				}
				else
					return GetNextBillColumn(COLUMN_TAX_RATE_1, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_INS_RESP;

			break;

		case COLUMN_INS_PARTY_ID:
			//This column isn't editable!
			ASSERT(FALSE);
			break;

		case COLUMN_TAX_RATE_1:

			if (CurrentColumn == COLUMN_TAX_RATE_1 || m_List->GetColumn(COLUMN_TAX_RATE_1)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextBillColumn(COLUMN_INS_RESP, CurrentColumn, bIsShiftDown);
				else
					return GetNextBillColumn(COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
			}
			else
				return COLUMN_TAX_RATE_1;

			break;

		case COLUMN_TAX_RATE_2:

			if (CurrentColumn == COLUMN_TAX_RATE_2 || m_List->GetColumn(COLUMN_TAX_RATE_2)->GetStoredWidth() == 0) {
				if (bIsShiftDown) {
					return GetNextBillColumn(COLUMN_TAX_RATE_1, CurrentColumn, bIsShiftDown);
				}
				else {
					// (j.jones 2008-12-31 15:45) - PLID 32597 - now this goes to the Date, not the Batched column
					return GetNextBillColumn(BILL_COLUMN_DATE, CurrentColumn, bIsShiftDown);
				}
			}
			else
				return COLUMN_TAX_RATE_2;

			break;

			// (j.jones 2008-12-31 15:45) - PLID 32597 - we now skip the Batched column entirely,
			// this case now goes into the ASSERT case below
		case COLUMN_BATCHED:

			/*
			if(CurrentColumn == COLUMN_BATCHED || m_List->GetColumn(COLUMN_BATCHED)->GetStoredWidth() == 0) {
			if(bIsShiftDown)
			return GetNextBillColumn(COLUMN_TAX_RATE_2,CurrentColumn,bIsShiftDown);
			else
			return GetNextBillColumn(COLUMN_DATE,CurrentColumn,bIsShiftDown);
			}
			else
			return COLUMN_BATCHED;

			break;
			*/

			//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
		case COLUMN_ITEM_TYPE:
		case COLUMN_PRODUCT_ITEM_ID:
		case COLUMN_ALLOCATION_DETAIL_LIST_ID:
		case COLUMN_PACKAGE_CHARGE_REF_ID:
		case BILL_COLUMN_ON_HOLD:
		default:
			ASSERT(FALSE);

			if (bIsShiftDown) {
				// (j.jones 2008-12-31 15:45) - PLID 32597 - now this goes to the Tax 2, not the Batched column
				return GetNextBillColumn(COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
			}
			else {
				return GetNextBillColumn(BILL_COLUMN_DATE, CurrentColumn, bIsShiftDown);
			}

			break;
	}

	return nCol;
}

int CBillingDlg::GetNextQuoteColumn(int nCol, int CurrentColumn, BOOL bIsShiftDown) {

	switch (nCol) {
		case QUOTE_COLUMN_PROVIDER:
			if (CurrentColumn == QUOTE_COLUMN_PROVIDER || m_QuoteList->GetColumn(QUOTE_COLUMN_PROVIDER)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
				else// (s.tullis 2015-03-24 09:28) - PLID 64973 - shift to category now
					return GetNextQuoteColumn(QUOTE_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_PROVIDER;

			break;
		case QUOTE_COLUMN_CPT_CODE:
		case QUOTE_COLUMN_CPT_SUB_CODE:
		case QUOTE_COLUMN_CPT_TYPE:
			//These columns aren't editable!
			ASSERT(FALSE);

			if (bIsShiftDown)
				return GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);
			else// (s.tullis 2015-03-24 09:28) - PLID 64973 - shift to category now
				return GetNextQuoteColumn(QUOTE_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);

			break;
			// (s.tullis 2015-03-24 09:28) - PLID 64973 - added cpt category
		case QUOTE_COLUMN_CPT_CATEGORY:

			if (CurrentColumn == QUOTE_COLUMN_CPT_CATEGORY || m_QuoteList->GetColumn(QUOTE_COLUMN_CPT_CATEGORY)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER1, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_CPT_CATEGORY;

			break;


		case QUOTE_COLUMN_MODIFIER1:

			if (CurrentColumn == QUOTE_COLUMN_MODIFIER1 || m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER1)->GetStoredWidth() == 0) {
				if (bIsShiftDown)// (s.tullis 2015-03-24 09:28) - PLID 64973 - shift to category now
					return GetNextQuoteColumn(QUOTE_COLUMN_CPT_CATEGORY, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER2, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_MODIFIER1;

			break;

		case QUOTE_COLUMN_MODIFIER2:

			if (CurrentColumn == QUOTE_COLUMN_MODIFIER2 || m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER2)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER1, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER3, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_MODIFIER2;

			break;

		case QUOTE_COLUMN_MODIFIER3:

			if (CurrentColumn == QUOTE_COLUMN_MODIFIER3 || m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER3)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER2, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER4, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_MODIFIER3;

			break;

		case QUOTE_COLUMN_MODIFIER4:

			if (CurrentColumn == QUOTE_COLUMN_MODIFIER4 || m_QuoteList->GetColumn(QUOTE_COLUMN_MODIFIER4)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER3, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_CALLS, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_MODIFIER4;

			break;

			// (j.jones 2011-10-25 09:04) - PLID 46088 - added Calls column, Alberta only
		case QUOTE_COLUMN_CALLS:
			if (CurrentColumn == QUOTE_COLUMN_CALLS || m_QuoteList->GetColumn(QUOTE_COLUMN_CALLS)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_MODIFIER4, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_SKILL, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_CALLS;

			break;

			// (d.singleton 2012-05-21 14:40) - PLID 48512 added skill column alberta only
			// (b.eyers 2013-03-19) - PLID 55644 Skill case was making calls to the wrong function
		case QUOTE_COLUMN_SKILL:
			if (CurrentColumn == QUOTE_COLUMN_SKILL || m_QuoteList->GetColumn(QUOTE_COLUMN_SKILL)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_CALLS, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_DESCRIPTION, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_SKILL;

			break;

		case QUOTE_COLUMN_DESCRIPTION:

			if (CurrentColumn == QUOTE_COLUMN_DESCRIPTION || m_QuoteList->GetColumn(QUOTE_COLUMN_DESCRIPTION)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_SKILL, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_QUANTITY, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_DESCRIPTION;

			break;

		case QUOTE_COLUMN_QUANTITY:

			if (CurrentColumn == QUOTE_COLUMN_QUANTITY || m_QuoteList->GetColumn(QUOTE_COLUMN_QUANTITY)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_DESCRIPTION, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_QUANTITY;

			break;

		case QUOTE_COLUMN_PACKAGE_QTY_REM:

			if (CurrentColumn == QUOTE_COLUMN_PACKAGE_QTY_REM || m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_QUANTITY, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_PACKAGE_QTY_REM;

			break;

			// (j.jones 2009-12-22 16:53) - PLID 32587 - supported the original qty. rem. column
		case QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM:

			if (CurrentColumn == QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM || m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_PACKAGE_QTY_REM, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM;

			break;

		case QUOTE_COLUMN_UNIT_COST:

			if (CurrentColumn == QUOTE_COLUMN_UNIT_COST || m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_PACKAGE_ORIGINAL_QTY_REM, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_UNIT_COST;

			break;

			// (j.gruber 2009-03-06 08:28) - PLID 33351 - took out discount columns
		case QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE:

			if (CurrentColumn == QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE || m_QuoteList->GetColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_ALLOWABLE, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE;

			break;

			// (j.gruber 2009-10-19 16:05) - PLID 35947
			// (j.jones 2010-09-01 10:52) - PLID 40330 - moved to be after the unit cost
		case QUOTE_COLUMN_ALLOWABLE:

			if (CurrentColumn == QUOTE_COLUMN_ALLOWABLE || m_QuoteList->GetColumn(QUOTE_COLUMN_ALLOWABLE)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_1, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_ALLOWABLE;

			break;

		case QUOTE_COLUMN_TOTAL_DISCOUNT:
			//not editable
			ASSERT(FALSE);
			break;
			/*case QUOTE_COLUMN_PERCENT_OFF:

				if(CurrentColumn == QUOTE_COLUMN_PERCENT_OFF || m_QuoteList->GetColumn(QUOTE_COLUMN_PERCENT_OFF)->GetStoredWidth() == 0) {
				if(bIsShiftDown)
				return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE,CurrentColumn,bIsShiftDown);
				else
				return GetNextQuoteColumn(QUOTE_COLUMN_DISCOUNT,CurrentColumn,bIsShiftDown);
				}
				else
				return QUOTE_COLUMN_PERCENT_OFF;

				break;

				case QUOTE_COLUMN_DISCOUNT:

				if(CurrentColumn == QUOTE_COLUMN_DISCOUNT || m_QuoteList->GetColumn(QUOTE_COLUMN_DISCOUNT)->GetStoredWidth() == 0) {
				if(bIsShiftDown)
				return GetNextQuoteColumn(QUOTE_COLUMN_PERCENT_OFF,CurrentColumn,bIsShiftDown);
				else
				return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_1,CurrentColumn,bIsShiftDown);
				}
				else
				return QUOTE_COLUMN_DISCOUNT;

				break;
				*/
		case QUOTE_COLUMN_LINE_TOTAL:
			//This column isn't editable!
			ASSERT(FALSE);

			if (bIsShiftDown)
				return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, CurrentColumn, bIsShiftDown);
			else
				return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_1, CurrentColumn, bIsShiftDown);

			break;

		case QUOTE_COLUMN_TAX_RATE_1:

			if (CurrentColumn == QUOTE_COLUMN_TAX_RATE_1 || m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_1)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_TAX_RATE_1;

			break;

		case QUOTE_COLUMN_TAX_RATE_2:

			if (CurrentColumn == QUOTE_COLUMN_TAX_RATE_2 || m_QuoteList->GetColumn(QUOTE_COLUMN_TAX_RATE_2)->GetStoredWidth() == 0) {
				if (bIsShiftDown)
					return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_1, CurrentColumn, bIsShiftDown);
				else
					return GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);
			}
			else
				return QUOTE_COLUMN_TAX_RATE_2;

			break;

		default:
			ASSERT(FALSE);

			if (bIsShiftDown)
				return GetNextQuoteColumn(QUOTE_COLUMN_TAX_RATE_2, CurrentColumn, bIsShiftDown);
			else
				return GetNextQuoteColumn(QUOTE_COLUMN_PROVIDER, CurrentColumn, bIsShiftDown);

			break;
	}

	return nCol;
}


void CBillingDlg::OnSelChosenComboGift(long nRow)
{
	CWaitCursor pWait;

	if (nRow == -1)
		return;

	// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
	if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
		AfxMessageBox("You must first select a Responsibility before adding new charges.");
		return;
	}

	// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
	CMaintainFocus maintainFocus(__FUNCTION__);

	try {
		if (GetCurrentBillToRespID() != 0) {
			//billing a GC to insurance ... this is silly!  Warn them, maybe they hit it on accident
			if (MsgBox(MB_YESNO, "You are billing this gift certificate to insurance, are you sure you wish to do this?") == IDNO)
				return;
		}

		COleVariant var;
		// (r.gonet 2015-03-27 18:50) - PLID 65277 - Also grab the Value from the GC combo.
		COleCurrency cyUnitCost, cyValue;
		CString strDescription, strUnitCost, strLineTotal, strCPTCategory, strSQL;

		long nServiceID = -1;
		long nLocationID = -1;
		double dblQuantity = 1.0;	//this will always be 1 for gift certs

		nServiceID = VarLong(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_ID));

		if (m_LocationCombo->GetCurSel() == -1)
			nLocationID = GetCurrentLocationID();
		else
			nLocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));

		//DRT 5/6/03 - Inv items can't be entered to authorizations.  Therefore this should always fail.
		//DRT 4/1/2004 - Copied this in for gifts
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

			// (j.jones 2008-05-01 11:53) - PLID 28606 - this should not fail if the authorization doesn't
			// have any services at all
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (ReturnsRecordsParam("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID)) {

				//there are services on this referral, so NOW we can warn

				if (MsgBox(MB_YESNO, "The chosen item does not exist in your insurance authorization.  Are you sure you wish to select this item?") == IDNO) {
					return;
				}
			}
		}

		DisableBillingScreen();

		//DRT 4/1/2004 - TODO - I'm leaving this here for now, but at the moment there is no way to set
		//	a default provider for a gift cert.  We should remove this code if we decide it is going
		//	to permanently remain that way.
		long nDefaultProviderID = -1;
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
		_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
			"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
			"FROM ServiceT "
			"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", nServiceID);
		if (!rs->eof) {
			nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
		}
		rs->Close();

		//DRT 4/10/2006 - PLID 11734 - This will add an empty charge with a type of CPT... this is OK, because 
		//	below we change all the info on the BillingItem structure.
		int iLineID = AppendChargeToList(nDefaultProviderID)->LineID.lVal;

		// Description (Name from ServiceT table)
		strDescription = VarString(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_NAME), "");

		/* Update description on parent billing module dialog if not already set*/
		CString str;
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDescription);
			}
		}

		long nCategoryID = VarLong(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_CATEGORY), -1);

		// (a.walling 2007-05-24 09:35) - PLID 26114
		COleCurrency cyPoints;
		cyPoints.SetCurrency(0, 0);
		// (j.gruber 2009-03-06 11:49) - PLID 33351 - generate discount list
		//this is not calling the LoadDiscountList function because gift certificates cannot have 
		//the typical discounts
		DiscountList *pDiscountList = new DiscountList;
		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		BOOL bUsingPoints = FALSE;

		_variant_t vtNull;
		vtNull.vt = VT_NULL;

		// (a.wetta 2007-05-16 13:51) - PLID 25959 - Check to see if the item is on sale
		double dblPercentDiscount = 0;
		COleCurrency cyMoneyDiscount = COleCurrency(0, 0), cyDiscount = COleCurrency(0, 0);
		CString strSaleName = "";
		long nDiscountCategoryID = -1, nPercentOff = 0;
		BOOL bUsingDiscount = FALSE;
		// (a.wetta 2007-05-17 09:30) - PLID 25960 - Make sure they have the NexSpa license also
		// (r.farnworth 2013-08-07 13:01) - PLID 45994 - The following block of code allowed the user to apply their Reward Points to Gift Certificates which
		// we no longer support

		//if (g_pLicense && g_pLicense->CheckForLicense(CLicense::lcNexSpa, CLicense::cflrSilent)) {
		//	if (GetServiceItemSaleDiscount(nServiceID, dblPercentDiscount, cyMoneyDiscount, strSaleName, nDiscountCategoryID)) {
		//		CString strMsg;
		//		// Handle a percent off sale
		//		if (dblPercentDiscount > 0) {
		//			strMsg.Format("This gift certificate \'%s\' is on sale for a %.0f%% discount as part of the \'%s\' sale. Would you like to apply the sale discount?", 
		//						strDescription, dblPercentDiscount, strSaleName);
		//			if (IDYES == MessageBox(strMsg, "Practice", MB_YESNO|MB_ICONQUESTION)) {						
		//				// (j.gruber 2009-12-31 13:40) - PLID 36480
		//				_variant_t varDiscountCatID;
		//				if (nDiscountCategoryID == -1) {
		//					varDiscountCatID = vtNull;
		//				}
		//				else {
		//					varDiscountCatID = (long)nDiscountCategoryID;
		//				}
		//				AddToDiscountList(pDiscountList, vtNull, (long)dblPercentDiscount, vtNull, vtNull, varDiscountCatID, vtNull, dpKeepDiscountSeparate);
		//				bUsingDiscount = TRUE;
		//			}
		//		}
		//		else {
		//			// This must be a dollar discount sale
		//			strMsg.Format("This gift certificate \'%s\' is on sale for a %s discount as part of the \'%s\' sale. Would you like to apply the sale discount?", 
		//						strDescription, FormatCurrencyForInterface(cyMoneyDiscount, TRUE, TRUE), strSaleName);
		//			if (IDYES == MessageBox(strMsg, "Practice", MB_YESNO|MB_ICONQUESTION)) {						
		//				AddToDiscountList(pDiscountList, vtNull, vtNull, _variant_t(cyMoneyDiscount), vtNull, vtNull, vtNull, dpKeepDiscountSeparate);
		//				bUsingDiscount = TRUE;
		//			}
		//		}
		//	} else {
		//		// (a.walling 2007-05-24 12:53) - PLID 26114
		//		// check if the user is qualified to redeem some award points for this gift certificate.
		//		BOOL bRedeemable = VarBool(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_REDEEMABLE), FALSE);
		//		if (bRedeemable) {
		//			cyPoints = VarCurrency(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_POINTS), COleCurrency(0, 0));

		//			COleCurrency cyAdjustedPoints = ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetAdjustedRewardPoints();

		//			// (a.walling 2008-06-16 16:34) - PLID 30407 - Should be <=, not <
		//			if (cyPoints != COleCurrency(0, 0) && cyPoints <= cyAdjustedPoints) {
		//				CString strMsg;
		//				strMsg.Format("This gift certificate \'%s\' is redeemable for %s of this patient\'s reward points. Would you like to exchange these points for the certificate?",
		//					strDescription, FormatCurrencyForInterface(cyPoints, FALSE));
		//				if (IDYES == MessageBox(strMsg, "Practice", MB_YESNO | MB_ICONQUESTION)) {
		//					nDiscountCategoryID = VarLong(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_DISCOUNTCATEGORYID), -1);
		//					_variant_t varDiscountCategoryID = g_cvarNull;
		//					if(nDiscountCategoryID != -1) {
		//						varDiscountCategoryID = (long)nDiscountCategoryID;
		//					}

		//					((CBillingModuleDlg*)m_pBillingModuleWnd)->AddAdjustedRewardPoints(cyPoints);

		//					bUsingPoints = TRUE;

		//					bUsingDiscount = TRUE;
		//					// (j.jones 2013-02-20 17:29) - PLID 54891 - the parameters to this function were wrong, and discount category ID was passed as the description
		//					AddToDiscountList(pDiscountList, vtNull, (long)100, vtNull, vtNull, varDiscountCategoryID, vtNull, dpKeepDiscountSeparate);
		//				}
		//			}
		//		}
		//	}
		//}

		// Get unit price
		cyUnitCost = VarCurrency(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_PRICE), COleCurrency(0, 0));
		// (r.gonet 2015-03-27 18:50) - PLID 65277 - Get the Value from the Gift Certificate combo.
		cyValue = VarCurrency(m_GiftCombo->GetValue(nRow, GIFT_COLUMN_VALUE), COleCurrency(0, 0));
		COleCurrency unit, total;
		unit = cyUnitCost;

		////////////////////////////////////////////////////
		//DRT 4/1/2004 - This section was copied from the Product adding code.  Gift certificates are not taxed
		//	items, so all this code will be hidden.
		/* Get Taxable status
		long TaxType = 2;

		//find the insurance company's taxable status
		TaxType = GetInsuranceCoTaxType(GetInsuranceIDFromType(m_nPatientID, GetCurrentBillToRespID()));

		COleCurrency taxTotal1, taxTotal2;
		cyUnitCost = CalculateAmtQuantity(cyUnitCost,dblQuantity);

		//now load the default taxrate for this product
		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_1);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
		dblTax1 = 1.0;
		}
		else {
		dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
		}

		taxTotal1 = CalculateTax(cyUnitCost,dblTax1);

		dblTax1 -= 1.0;
		dblTax1 *= 100.0;

		v = m_ProductsCombo->GetValue(iNewRow, PRODUCTS_COLUMN_TAXABLE_2);
		//if TaxType = 3, we aren't going to charge tax at all
		if (v.boolVal == 0 || TaxType == 3) {
		dblTax2 = 1.0;
		}
		else {
		dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
		}

		taxTotal2 = CalculateTax(cyUnitCost,dblTax2);

		dblTax2 -= 1.0;
		dblTax2 *= 100.0;

		var = cyUnitCost;
		cyUnitCost += taxTotal1;
		cyUnitCost += taxTotal2;
		total = cyUnitCost;
		_variant_t varTotal = total;

		//End tax totals
		*/

		// (j.gruber 2009-03-06 12:09) - PLID 33351 - get the total discounts
		COleCurrency cyTotalDollarDiscount, cyTotalLineDiscount;
		long nTotalPercentOff;

		CalculateTotalDiscount(pDiscountList, cyUnitCost, cyInvalid, nTotalPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);
		// (a.wetta 2007-05-16 14:12) - PLID 25959 - Subtract the percent and mony discounts
		cyUnitCost = (cyUnitCost * (100000 - nTotalPercentOff * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cyUnitCost = cyUnitCost / long(100000);
		cyUnitCost -= cyTotalDollarDiscount;

		var = cyUnitCost;

		total = cyUnitCost;
		RoundCurrency(total);
		_variant_t varTotal = total;

		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {
				m_billingItems[i]->ChargeID = (long)-2;
				m_billingItems[i]->Quantity = (double)dblQuantity;
				m_billingItems[i]->PackageQtyRemaining = (double)dblQuantity;
				// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
				m_billingItems[i]->OriginalPackageQtyRemaining = (double)dblQuantity;
				m_billingItems[i]->ServiceID = nServiceID;
				m_billingItems[i]->CPTCode = _bstr_t("");
				m_billingItems[i]->CPTSubCode = _bstr_t("0");
				// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
				m_billingItems[i]->CPTCategoryID = (nCategoryID > 0 ? (_variant_t)(long)nCategoryID : g_cvarNull);
				m_billingItems[i]->Description = _bstr_t(strDescription);
				m_billingItems[i]->UnitCost = unit;
				m_billingItems[i]->TaxRate1 = (double)0.0;
				m_billingItems[i]->TaxRate2 = (double)0.0;
				m_billingItems[i]->LineTotal = total;
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				m_billingItems[i]->ItemType = (long)ITEM_TYPE_GIFT;
				m_billingItems[i]->GiftID = (long)-1;	//-1 means unselected as-of-yet
				// (r.gonet 2015-03-27 18:50) - PLID 65277 - Set the Value of the line item.
				m_billingItems[i]->Value = cyValue;
				m_billingItems[i]->Batched.vt = VT_BOOL;
				m_billingItems[i]->Batched.boolVal = TRUE;
				// (a.wetta 2007-05-16 14:08) - PLID 25959 - Also set the discounts
				// (j.gruber 2009-03-06 12:11) - PLID 33351 - take out discounts
				//m_billingItems[i]->PercentOff = (long)nPercentOff;
				//m_billingItems[i]->Discount = cyDiscount;
				m_billingItems[i]->TotalDiscount = cyTotalLineDiscount;
				m_billingItems[i]->DiscountList = pDiscountList;
				m_billingItems[i]->PointsUsed = bUsingPoints ? cyPoints : COleCurrency(0, 0); // (a.walling 2007-05-24 09:36) - PLID 26114

				/*if (bUsingDiscount && nDiscountCategoryID != -1) {
					// (a.wetta 2007-05-08 14:41) - PLID 25959 - Use the pre-set discount category for the sale
					m_billingItems[i]->DiscountCategoryID = (long)nDiscountCategoryID;
					m_billingItems[i]->CustomDiscountDescription = "";
					m_billingItems[i]->HasDiscountCategory.boolVal = TRUE;
					m_billingItems[i]->CouponID.vt = VT_NULL;
					}
					else if (nPercentOff > 0 || cyDiscount > COleCurrency(0,0)) {
					// Check to see if they want to add a category
					long nSelection = GetRemotePropertyInt("BillShowDiscountCatScreenWhenAddDiscount", 2, 0, "<None>", true);
					if (nSelection == 1) {
					//always show it
					// (a.wetta 2007-05-23 09:25) - PLID 26104 - Don't show coupons
					ShowDiscountCategoryList(m_billingItems[i], TRUE, FALSE);
					}
					else if (nSelection == 2) {
					//prompt
					if (MsgBox(MB_YESNO, "Would you like to set a discount category?") == IDYES) {
					// (a.wetta 2007-05-23 09:25) - PLID 26104 - Don't show coupons
					ShowDiscountCategoryList(m_billingItems[i], TRUE, FALSE);
					}
					}
					}*/
			}
		}

		for (i = 0; i < (int)m_billingItems.size(); i++) {
			if (m_billingItems[i]->LineID.lVal == iLineID) {

				//find the item in the list
				RPCList *list = m_billingItems[i]->RPCList;

				//DRT 4/1/2004 - This is copied from the product adding code.  There is really 
				//	no reason you would ever bill a gift certificate to insurance, but it's 
				//	left here for completeness.
				//DRT 6/30/03 - For the same reason as the quotes (6/16/03 note), this does
				//		not need to be added for patient resp, only insurance resp!
				long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
				if (nInsuredPartyID > 0) {
					long TaxType = 2;	//pulled out of the commented-out tax code

					bool bFoundResp = false;
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int j = 0;
					for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
						if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
							bFoundResp = true;
					}

					if (bFoundResp) {
						//at this point, var is the amount before tax, and varTotal is the amount with tax
						//use the insurance TaxType to determine which responsibility gets which amount
						if (TaxType == 1)
							UpdateListInsAmount(list, j, varTotal);
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							UpdateListInsAmount(list, j, var);
					}
					else {
						//we're looking at insurance, but there's nothing in our list!  we
						//need to add it
						RespPerCharge rpc;
						rpc.InsuredPartyID = nInsuredPartyID;

						if (TaxType == 1)
							rpc.InsAmount = varTotal;
						else
							//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
							rpc.InsAmount = var;

						// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
						rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
						rpc.RespTypeName = GetCurrentBillToRespTypeName();

						list->aryRPC.Add(rpc);
					}
				}
			}
		}

		////////////////////////////////////////////////////
		if (m_EntryType == 1)
			FillBillList();
		else	//should not happen, gift cards are bill only
			FillQuoteList();

		// (j.jones 2006-12-20 09:25) - PLID 23338 - converted InsertSorted to
		// use the row instead of the LineID
		// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
		IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
		InsertRowSorted(pRowToSort, total);

	} NxCatchAll("Error in OnSelChosenComboGift");

	EnableBillingScreen();

	////////////////////////////////////////////////////
	// Recalculate the bill total
	CalculateTotal();

	PostChargeAdded();

	// (r.gonet 2015-03-27 18:50) - PLID 65277 - Show the Value column since there is now a gift certificate.
	ShowValueColumn(true);
}

void CBillingDlg::OnLaunchCodeLink() {

	LaunchCodeLink(GetSafeHwnd());
}

//when the location is changed, prompt the user if any products are out of stock for that location
void CBillingDlg::PromptInventoryLocationChanged(long nLocationID) {

	try {

		// (j.jones 2007-12-14 11:47) - PLID 27988 - we disallow changing locations
		// if we have any active allocations currently in use on this bill
		if (m_paryAllocationInfo.GetSize() > 0 || HasChargesLinkedToAllocations()) {
			//this function should not have been called if we have tracked allocations or charged allocations
			ASSERT(FALSE);
			ThrowNxException("PromptInventoryLocationChanged called with tracked allocations in memory!");
		}

		CStringArray strInvalidArray;
		CStringArray strOutOfStockArray;
		CArray<double, double> aryOutOfStockOnHandQty;
		CArray<double, double> aryOutOfStockAllocatedQty;

		_variant_t varNull;
		varNull.vt = VT_NULL;

		//clear all selected product items	
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			long CPIListID = m_billingItems[i]->ChargedProductItemListID.lVal;
			for (int j = 0; j < m_aryChargedProductItems.GetSize(); j++) {
				ChargedProductItemList *cpiList = (ChargedProductItemList*)m_aryChargedProductItems.GetAt(j);
				if (cpiList->ID == CPIListID) {
					for (int k = 0; k < cpiList->ProductItemAry.GetSize(); k++) {
						cpiList->ProductItemAry.GetAt(k)->SaveStatus = CPI_DELETE;
					}
				}
			}
		}

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {
			long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID));
			long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);
			long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			_RecordsetPtr rs = CreateParamRecordset("SELECT Name FROM ServiceT INNER JOIN ProductT ON ServiceT.ID = ProductT.ID WHERE ProductT.ID = {INT}", nServiceID);
			if (!rs->eof) {

				CString strName = AdoFldString(rs, "Name", "");

				if (m_EntryType == 1) {
					CString strWhere = GetProductItemWhereClause();
					if (strWhere.GetLength() > 0)
						strWhere += " AND ";

					BOOL bRemove = TRUE;

					long CPIListID = VarLong(pRow->GetValue(COLUMN_PRODUCT_ITEM_ID), -1);

					// (j.jones 2007-11-21 16:40) - PLID 28037 - ensure we account for allocated items
					if (!IsRecordsetEmpty("SELECT ID FROM ProductItemsT WHERE %s ProductID = %li "
						"AND ID NOT IN (SELECT ProductItemID FROM ChargedProductItemsT) "
						"AND ID NOT IN (SELECT ProductItemID FROM PatientInvAllocationDetailsT "
						"			    WHERE (Status = %li OR Status = %li) "
						"				AND ProductItemID Is Not Null) "
						"AND Deleted = 0  AND (ProductItemsT.LocationID = %li OR ProductItemsT.LocationID Is Null)",
						strWhere, nServiceID, InvUtils::iadsActive, InvUtils::iadsUsed, nLocationID)) {

						BOOL bCancel = FALSE;
						BOOL bLoop = TRUE;

						//while we still need to prompt
						while (bLoop) {

							CProductItemsDlg dlg(this);
							dlg.m_EntryType = PI_SELECT_DATA;
							dlg.m_bDisallowQtyChange = TRUE;
							dlg.m_ProductID = nServiceID;
							dlg.m_nLocationID = nLocationID;
							dlg.m_CountOfItemsNeeded = (long)VarDouble(pRow->GetValue(BILL_COLUMN_QUANTITY), 0.0);
							dlg.m_strWhere = GetProductItemWhereClause();

							if (IDCANCEL == dlg.DoModal()) {
								//if they cancelled, warn them!
								if (IDYES == MessageBox("You have chosen to cancel adding this product."
									"\nThe charge will be removed from the bill if you do not fill in the requested information."
									"\nAre you SURE you wish to cancel?", "Practice", MB_ICONQUESTION | MB_YESNO)) {
									//if they wish to not bill the item, stop looping, cancel adding this item
									bLoop = FALSE;
									bCancel = TRUE;
									bRemove = TRUE;
								}
							}
							else {
								//if they selected an item, then stop looping
								bLoop = FALSE;
								AddToChargedProductItemsArray(nChargeID, CPIListID, dlg.m_adwProductItemIDs);

								bRemove = FALSE;
							}
						}
						if (bCancel) {
							//if the loop ended with a cancellation, we'll remove the item
							bRemove = TRUE;
						}
					}

					if (bRemove) {
						//if the product doesn't have any ProductItems, see if it requires them, in which case they cannot bill it
						// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
						_RecordsetPtr rs = CreateParamRecordset("SELECT Name, HasSerialNum, HasExpDate FROM ServiceT "
							"INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
							"WHERE ServiceT.ID = {INT} AND (HasSerialNum = 1 OR HasExpDate = 1)", nServiceID);
						if (!rs->eof) {
							CString strName = AdoFldString(rs, "Name", "");
							BOOL bHasSerialNum = AdoFldBool(rs, "HasSerialNum", FALSE);
							BOOL bHasExpDate = AdoFldBool(rs, "HasExpDate", FALSE);
							CString str;
							str.Format("The product '%s' requires %s%s%s, but has no items in stock at your new location.\n"
								"This product cannot be billed until there are items in stock.\n\n"
								"The charge will be removed from the list.", strName,
								bHasSerialNum ? "a serial number" : "",
								(bHasSerialNum && bHasExpDate) ? " and " : "",
								bHasExpDate ? "an expiration date" : "");
							AfxMessageBox(str);
							pRow = pRow->GetNextRow();
							DeleteChargeFromList(nLineID);
							continue;
						}
						rs->Close();
					}
				}

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (!ReturnsRecordsParam("SELECT ProductID FROM ProductLocationInfoT WHERE ProductID = {INT} AND LocationID = {INT} AND Billable = 1", nServiceID, nLocationID)) {
					//not billable for this location
					BOOL bFound = FALSE;
					for (int j = 0; j < strInvalidArray.GetSize() && !bFound; j++) {
						if (strInvalidArray.GetAt(j) == strName)
							bFound = TRUE;
					}
					if (!bFound)
						strInvalidArray.Add(strName);
				}

				double dblQuantity = 0.0;
				double dblAllocated = 0.0;

				// (j.jones 2007-12-18 11:18) - PLID 28037 - CalcAmtOnHand changed to return allocation information
				// (j.jones 2010-08-13 17:03) - PLID 37695 - only warn if they are billing less than zero, not actual zero
				if (InvUtils::CalcAmtOnHand(nServiceID, nLocationID, dblQuantity, dblAllocated, -GetUnsavedQuantityCount(nServiceID), 0.0) && dblQuantity - dblAllocated < 0.0) {
					//out of stock
					BOOL bFound = FALSE;
					for (int j = 0; j < strOutOfStockArray.GetSize() && !bFound; j++) {
						if (strOutOfStockArray.GetAt(j) == strName) {
							bFound = TRUE;
						}
					}
					if (!bFound) {
						strOutOfStockArray.Add(strName);
						aryOutOfStockOnHandQty.Add(dblQuantity);
						aryOutOfStockAllocatedQty.Add(dblAllocated);
					}
				}
			}
			rs->Close();

			pRow = pRow->GetNextRow();
		}


		if (strInvalidArray.GetSize() > 0 || strOutOfStockArray.GetSize() > 0) {
			//okay, something is invalid, so warn the user

			CString strWarning, strInvalidWarning, strOutOfStockWarning;

			if (strInvalidArray.GetSize() > 0) {
				strInvalidWarning = "The following products are not marked as billable for the new location:\n";
				for (int i = 0; i < strInvalidArray.GetSize(); i++) {
					CString strInvalid;
					strInvalid.Format("    %s\n", strInvalidArray.GetAt(i));
					strInvalidWarning += strInvalid;
				}
				strInvalidWarning += "\n";
			}

			if (strOutOfStockArray.GetSize() > 0) {

				// (j.jones 2010-05-07 15:26) - PLID 37695 - check the permission, we will warn if they are not allowed
				// to bill out of stock products
				BOOL bCanBillOutOfStock = (GetCurrentUserPermissions(bioBill) & sptDynamic1) > 0 ? TRUE : FALSE;
				BOOL bCanBillOutOfStockWithPass = (GetCurrentUserPermissions(bioBill) & sptDynamic1WithPass) > 0 ? TRUE : FALSE;

				CString strPermissionWarning = "";
				if (!bCanBillOutOfStock) {
					if (bCanBillOutOfStockWithPass) {
						strOutOfStockWarning = "The following products are out of stock at the new location."
							"\n\nYour permissions require a password to be entered when you save a bill with out of stock products.\n";
					}
					else {
						strOutOfStockWarning = "The following products are out of stock at the new location."
							"\n\nYou do not have permission to save a bill with out of stock products.\n";
					}
				}
				else {
					strOutOfStockWarning = "The following products are out of stock at the new location:\n";
				}
				for (int i = 0; i < strOutOfStockArray.GetSize(); i++) {
					CString strAllocatedWarning = "";
					if (aryOutOfStockAllocatedQty.GetAt(i) > 0.0) {
						strAllocatedWarning.Format(", %g allocated to patients", aryOutOfStockAllocatedQty.GetAt(i));
					}
					CString strOutOfStock;
					strOutOfStock.Format("    %s (%g in stock%s)\n", strOutOfStockArray.GetAt(i), aryOutOfStockOnHandQty.GetAt(i), strAllocatedWarning);
					strOutOfStockWarning += strOutOfStock;
				}
				strOutOfStockWarning.TrimRight("\n");
			}

			strWarning.Format("Changing the location of this bill has triggered the following warnings:\n\n%s%s", strInvalidWarning, strOutOfStockWarning);

			strWarning.TrimRight("\n");

			AfxMessageBox(strWarning);
		}

	}NxCatchAll("Error validating inventory items for the new location.");
}

void CBillingDlg::OnBtnToggleIndivBatch()
{
	if (!m_bShowChargeBatchColumn) {
		CString strMsg;
		strMsg.Format("The 'Batched' column allows you to specify individual charges to not be included in a claim.\n"
			"Any unchecked charge will not show up on any claim form (i.e. HCFA) or exported electronic claim.\n"
			"The total bill amount on the claim will also exclude the 'unbatched' charge amount.\n\n"
			"All new charges always default to being 'Batched'. Only uncheck the 'Batched' column if you need\n"
			"to resubmit a partial claim, or an individual charge. You cannot uncheck all the charges.\n\n"
			"Whether or not the charge is checked as being 'Batched' does not affect the actual batch\n"
			"that the claim is in - you will still need to specify 'Paper' or 'Electronic' batch on the\n"
			"Insurance tab of this bill.");

		//this will allow them to stop seeing this message
		DontShowMeAgain(this, strMsg, "BillingDlgBatchedColumn", "Practice", FALSE, FALSE);
	}

	ToggleChargeBatchColumn(!m_bShowChargeBatchColumn);
}

void CBillingDlg::ToggleChargeBatchColumn(BOOL bShow)
{
	if (m_EntryType == 2) //should never be called on a quote
		return;

	IColumnSettingsPtr pCol = m_List->GetColumn(COLUMN_BATCHED);

	if (pCol) {
		if (bShow) {
			pCol->PutStoredWidth(50);
			SetDlgItemText(IDC_BTN_TOGGLE_INDIV_BATCH, "Hide Charge Batch Status");
		}
		else {
			pCol->PutStoredWidth(0);
			SetDlgItemText(IDC_BTN_TOGGLE_INDIV_BATCH, "Show Charge Batch Status");
		}
	}

	m_bShowChargeBatchColumn = bShow;
}

void CBillingDlg::WarnTaxedPackage()
{
	CString str;
	str.Format("If you save this Package with a tax rate on a charge, it is important that you understand how Practice handles tax in Packages.\n\n"
		"The Package total is intended to be the non-tax total, and each individual bill created from that package will decrease a non-taxed\n"
		"usage amount from the Package total. The bill will be taxed based on the tax rate on each charge. For example:\n\n"
		"If you have a %s package with 4 uses, and the charge has an 8%% tax rate, each time the Package is billed,\n"
		"%s will be removed from the Package, while the bill total will be %s as it factors in the 8%% tax rate.\n"
		"The total amount billed to the patient, once the Package is complete, will have been %s,\n"
		"which is equal to the Package total plus the 8%% tax rate.\n\n"
		"Keep these rules in mind when determining your Package value, as it will represent the non-taxed total value.",
		FormatCurrencyForInterface(COleCurrency(100, 0), TRUE, TRUE), FormatCurrencyForInterface(COleCurrency(25, 0), TRUE, TRUE),
		FormatCurrencyForInterface(COleCurrency(27, 0), TRUE, TRUE), FormatCurrencyForInterface(COleCurrency(108, 0), TRUE, TRUE));

	DontShowMeAgain(this, str, "PackageTaxWarning", "Packages", FALSE, FALSE);
}

COleCurrency CBillingDlg::GetPreTaxLineTotal(BillingItemPtr pBillingItem)
{
	try {
		// Calculate the pretax line total
		COleVariant var;
		COleCurrency cy;

		COleCurrency cyUnitCost, cyOthrCost;//, cyDiscount;
		double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
		//long iPercentOff;

		var = pBillingItem->UnitCost;
		cyUnitCost = var.cyVal;

		var = pBillingItem->OthrUnitCost;
		if (var.vt != VT_NULL && var.vt != VT_EMPTY)
			cyOthrCost = var.cyVal;
		else
			cyOthrCost = COleCurrency(0, 0);

		var = pBillingItem->Quantity;
		dblQuantity = var.dblVal;

		var = pBillingItem->Multiplier1;
		dblMultiplier1 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);

		var = pBillingItem->Multiplier2;
		dblMultiplier2 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);

		var = pBillingItem->Multiplier3;
		dblMultiplier3 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);

		var = pBillingItem->Multiplier4;
		dblMultiplier4 = (var.vt == VT_EMPTY) ? 1.0 : VarDouble(var, 1.0);

		// (j.gruber 2009-03-06 12:24) - PLID 33351 - take out discounts
		/*var = pBillingItem->PercentOff;
		iPercentOff = (var.vt == VT_EMPTY) ? 0 : VarLong(var,0);

		var = pBillingItem->Discount;
		if (var.vt == VT_NULL || var.vt == VT_EMPTY)
		cyDiscount = COleCurrency(0,0);
		else
		cyDiscount = var.cyVal;
		*/
		if (m_EntryType == 2)
			cy = cyUnitCost + cyOthrCost;
		else
			cy = cyUnitCost;

		cy = CalculateAmtQuantity(cy, dblQuantity);

		//highly unlikely anyone would use modifiers and discounts together,
		//but if so, modify first
		cy = CalculateAmtQuantity(cy, dblMultiplier1);
		cy = CalculateAmtQuantity(cy, dblMultiplier2);
		cy = CalculateAmtQuantity(cy, dblMultiplier3);
		cy = CalculateAmtQuantity(cy, dblMultiplier4);


		long nPercentOff;
		COleCurrency cyTotalLineDiscount, cyTotalDollarDiscount;

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		CalculateTotalDiscount(pBillingItem->DiscountList, cy, cyInvalid, nPercentOff, cyTotalDollarDiscount, cyTotalLineDiscount, dpIgnorePreference);

		cy = (cy * (100000 - nPercentOff * 1000));
		// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator / is ambiguous
		cy = cy / long(100000);
		cy -= cyTotalDollarDiscount;

		RoundCurrency(cy);

		return cy;
	}
	NxCatchAll("BillingDlg::GetPreTaxLineTotal");

	return COleCurrency(0, 0);
}

//m.hancock PLID 16457 - Apply a filter to a data list
bool CBillingDlg::ApplyCodeFilter(NXDATALISTLib::_DNxDataListPtr &pDataListCombo, CNxIconButton *pFilterIcon, CString strDefaultWhereClause, int nFieldToFilter, int nKeyField)
{
	//If default where clause is applied, a filter should be created and applied
	if (CString((LPCTSTR)pDataListCombo->WhereClause) == strDefaultWhereClause)
	{
		//If the data list is for products, store the where clause
		if (pDataListCombo == m_ProductsCombo)
			m_strProductsWhere = CString((LPCTSTR)m_ProductsCombo->WhereClause);

		//Apply filter
		//(d.thompson 2009-03-18) - PLID 33426 - Reworked this slightly so that the diagnosis code selection stays 
		//	consistent on screen.  Do not clear the datalist selection until the user presses OK on the filter.
		if (FilterDatalist(pDataListCombo, nFieldToFilter, nKeyField))
		{
			pDataListCombo->CurSel = -1;
			//Set the filter button's icon
			pFilterIcon->SetIcon(IDI_FILTERDN);
			pFilterIcon->RedrawWindow();
			return true;
		}
		else
			return false;
	}
	else
	{
		//Remove filter
		RemoveCodeFilter(pDataListCombo, pFilterIcon, strDefaultWhereClause);
		return false;
	}
}

//m.hancock PLID 16457 - Remove an existing filter on a data list
void CBillingDlg::RemoveCodeFilter(NXDATALISTLib::_DNxDataListPtr &pDataListCombo, CNxIconButton *pFilterIcon, CString strDefaultWhereClause)
{
	//Retain the currently selected item in the list
	_variant_t selId;
	if (pDataListCombo->CurSel > -1)
		selId = pDataListCombo->GetValue(pDataListCombo->CurSel, 0);

	//If default where clause is applied for diagnosis lists and service codes list, and we're not
	//working with the products list (since it's default where clause changes frequently), just return
	else if ((CString((LPCTSTR)pDataListCombo->WhereClause) == strDefaultWhereClause) && (!m_bProductsFilter))
		return;

	//Set the default where clause and requery
	pDataListCombo->WhereClause = _bstr_t(strDefaultWhereClause);
	for (short i = 0; i < pDataListCombo->ColumnCount; i++)
		pDataListCombo->GetColumn(i)->BackColor = RGB(255, 255, 255);
	pDataListCombo->Requery();

	//Set the filter button's icon
	pFilterIcon->SetIcon(IDI_FILTER);
	pFilterIcon->RedrawWindow();

	//Restore the selected item in the list
	if (selId.vt != VT_EMPTY)
		pDataListCombo->SetSelByColumn(0, selId);
}

//m.hancock PLID 16457 - Filter the CPT codes or Products lists
void CBillingDlg::OnFilterCodes()
{
	long sel = VarLong(m_WhatToAddCombo->GetValue(m_WhatToAddCombo->CurSel, 0), 0);

	// (a.walling 2008-05-06 15:24) - PLID 26105 - This works correctly now
	//Selection for a CPT code
	if ((m_EntryType == 1 && sel == ROW_BILL_A_CPT_CODE) || (m_EntryType == 2 && sel == ROW_QUOTE_A_CPT_CODE))
	{
		//TES 7/16/2008 - PLID 27983 - Quotes and Bills now have slightly different lists of CPT Codes
		if (ApplyCodeFilter(m_CPTCombo, &m_filterCodesButton, m_EntryType == 1 ? m_strBillCptCodesWhere : m_strQuoteCptCodesWhere, 3, 1))
			m_bCptCodesFilter = true;
		else
			m_bCptCodesFilter = false;
	}

	//Selection for a product
	else if ((m_EntryType == 1 && sel == ROW_BILL_A_PRODUCT) || (m_EntryType == 2 && sel == ROW_QUOTE_A_PRODUCT))
	{
		if (ApplyCodeFilter(m_ProductsCombo, &m_filterCodesButton, m_strProductsWhere, 5, 0))
			m_bProductsFilter = true;
		else
			m_bProductsFilter = false;
	}
}

void CBillingDlg::OnAnesthesiaTimeChanged(long nNewMinutes, BOOL bPlaceOfServiceChanged /*= FALSE*/)
{
	try {

		if (m_pList == NULL)
			return;

		//see if there are any anesthesia codes in the list, and if so, change their value

		if (m_PlaceOfServiceCombo->CurSel == -1)
			m_PlaceOfServiceCombo->CurSel = 0;
		long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

		// (j.jones 2004-07-07 16:59) - if the current ins. resp. is set to allow 1/10th rounding, do so!
		long InsID = -1;
		InsID = GetCurrentBillToInsuranceCoID();
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		BOOL bRoundUp = !ReturnsRecordsParam("SELECT PersonID FROM InsuranceCoT WHERE AnesthesiaSetting = 1 AND PersonID = {INT}", InsID);

		BOOL bPrompted = FALSE;

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {

			long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID), -1);
			long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);
			long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

			// (j.jones 2011-08-24 08:41) - PLID 44868 - do not change a charge if it is
			// an original or voided charge
			if (IsOriginalOrVoidCharge(nChargeID)) {
				pRow = pRow->GetNextRow();
				continue;
			}

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (!ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND Anesthesia = 1 AND UseAnesthesiaBilling = 1", nServiceID)) {
				//not an anesthesia charge
				pRow = pRow->GetNextRow();
				continue;
			}

			// (j.jones 2007-10-15 14:57) - PLID 27757 - converted to use the new structure, which required this to be checked per charge
			if (!bPlaceOfServiceChanged) {
				//if it's a flat fee for this POS, and we're only changing the time, 
				//then nothing will be changed, so don't bother trying			
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				if (!ReturnsRecordsParam("SELECT ID FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND AnesthesiaFeeBillType <> 1", nServiceID, nPlaceOfServiceID)) {
					pRow = pRow->GetNextRow();
					continue;
				}
			}

			if (!bPrompted) {
				//this is a "don't show me again" prompt, but if they do actually see it,
				//we don't want to try and show them again during this process

				if (bPlaceOfServiceChanged) {
					//they changed the POS
					DontShowMeAgain(this, "Changing the Place Of Service will change the fee for your Anesthesia charges on this bill.\n"
						"Be sure to double-check the new bill total before saving.", "BillingDlgChangeAnesthesiaPOS", "Practice", FALSE, FALSE);
				}
				else {
					//they changed the time
					DontShowMeAgain(this, "Changing the Anesthesia Time will change the fee for your Anesthesia charges on this bill.\n"
						"Be sure to double-check the new bill total before saving.", "BillingDlgChangeAnesthesiaTime", "Practice", FALSE, FALSE);
				}
				bPrompted = TRUE;
			}

			//ok, we're on an anesthesia charge, they've been warned, and it's not a flat fee, so recalculate the fee!

			// (j.jones 2011-01-25 15:45) - PLID 42156 - if the charge is locked, don't let them change the fee,
			// and instead just return now, we can't prompt on every charge
			if (m_EntryType == 1) {
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
					return;
				}
			}

			// (j.jones 2006-09-19 10:43) - PLID 22106 - determine first if we are going to calculate
			// as a practice fee or an outside fee, for quotes only

			BOOL bUsingOutsideFee = FALSE;

			if (m_EntryType == 2) {
				// (j.jones 2007-10-15 15:37) - PLID 27757 - changed to support new structure
				_RecordsetPtr rs = CreateParamRecordset("SELECT AnesthOutsideFee FROM AnesthesiaSetupT WHERE ServiceID = {INT} AND LocationID = {INT}", nServiceID, nPlaceOfServiceID);
				if (!rs->eof) {

					//check the setting for what they want the fee to be
					BOOL bAnesthOutsideFee = AdoFldBool(rs, "AnesthOutsideFee", FALSE);

					//now check the current setup on the quote
					BOOL bHasPracticeFee = FALSE;
					BOOL bHasOutsideFee = FALSE;

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == nLineID) {

							bHasPracticeFee = VarCurrency(m_billingItems[j]->UnitCost, COleCurrency(0, 0)) != COleCurrency(0, 0);
							bHasOutsideFee = VarCurrency(m_billingItems[j]->OthrUnitCost, COleCurrency(0, 0)) != COleCurrency(0, 0);
						}
					}

					//now we know what their intentions are, plus the values of the quote

					if (bAnesthOutsideFee) {
						//they want the fee to be an outside fee

						if (bHasPracticeFee && !bHasOutsideFee) {
							//the practice fee is nonzero, outside fee is zero, so we should prompt
							if (IDYES == MessageBox("An anesthesia fee on this quote is set as a practice fee, "
								"but your settings for this Place Of Service state that it should be an outside fee.\n\n"
								"Do you wish to recalculate the anesthesia fee as an outside fee?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

								bUsingOutsideFee = TRUE;
							}
							else {
								bUsingOutsideFee = FALSE;
							}
						}
						else {
							//otherwise the practice fee is zero, or an outside fee exists, it's going to be an outside fee
							bUsingOutsideFee = TRUE;
						}
					}
					else {
						//they have not specified that they want the fee to be an outside fee

						//in this case, use the old PLID 19828 logic, where if the practice fee is
						//zero and the outside fee is nonzero, only then use the outside fee
						if (!bHasPracticeFee && bHasOutsideFee) {
							bUsingOutsideFee = TRUE;
						}
						else {
							bUsingOutsideFee = FALSE;
						}
					}
				}
				rs->Close();
			}

			//default these values to their current values in the list
			COleCurrency cyAmount;
			double dblQuantity = VarDouble(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_QUANTITY : QUOTE_COLUMN_QUANTITY), 0.0);

			if (bUsingOutsideFee) {
				cyAmount = VarCurrency(pRow->GetValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE), COleCurrency(0, 0));
			}
			else {
				cyAmount = VarCurrency(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST), COleCurrency(0, 0));
			}

			if (bPlaceOfServiceChanged) {
				//if the POS Changed, we might not have the data stored on the Additional Info tab

				long nAnesthMinutes = GetAnesthMinutes();
				CString strStartTime = GetAnesthStartTime();
				CString strEndTime = GetAnesthEndTime();

				BOOL bAnesthesia = FALSE;
				if (CheckAnesthesia(nServiceID, bAnesthesia, cyAmount, dblQuantity, nAnesthMinutes, strStartTime, strEndTime, nPlaceOfServiceID, bRoundUp) && bAnesthesia) {
					//set the times on the Billing2 dlg
					SetAnesthMinutes(nAnesthMinutes);
					SetAnesthStartTime(strStartTime);
					SetAnesthEndTime(strEndTime);
				}
			}
			else {
				CalcAnesthesia(nServiceID, cyAmount, dblQuantity, nNewMinutes, nPlaceOfServiceID, bRoundUp);
			}

			//we have a new amount and new quantity, now put those back in the charge list

			for (int j = 0; j < (int)m_billingItems.size(); j++) {
				if (m_billingItems[j]->LineID.lVal == nLineID) {

					if (m_EntryType == 2 && bUsingOutsideFee) {
						m_billingItems[j]->OthrUnitCost = _variant_t(cyAmount);
						m_billingItems[j]->UnitCost = _variant_t(COleCurrency(0, 0));
					}
					else {
						m_billingItems[j]->UnitCost = _variant_t(cyAmount);
						m_billingItems[j]->OthrUnitCost = _variant_t(COleCurrency(0, 0));
					}

					m_billingItems[j]->Quantity = dblQuantity;

					if ((GetIsMultiUsePackage() && (GetBillID() == -1 || (!m_bQuoteHasBeenBilled && m_boInitialized)))
						|| !GetIsMultiUsePackage()) {
						//if a multi-use package, only update if new/unbilled, otherwise update at all times (it won't be used anyways)
						m_billingItems[j]->PackageQtyRemaining = dblQuantity;

						// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
						m_billingItems[j]->OriginalPackageQtyRemaining = dblQuantity;
					}
				}
			}

			if (m_EntryType == 2 && bUsingOutsideFee) {
				pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _variant_t(cyAmount));
				pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(COleCurrency(0, 0)));
			}
			else {
				pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(cyAmount));
				if (m_EntryType == 2) {
					pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _variant_t(COleCurrency(0, 0)));
				}
			}
			pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_QUANTITY : QUOTE_COLUMN_QUANTITY, dblQuantity);

			//now mark it for saving, and calculate the total
			m_varBoundItem = nLineID;
			COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
			if (varChargeID.lVal != -2)
			{
				AddToModifiedList(varChargeID.lVal);
			}

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll("Error in OnAnesthesiaTimeChanged");
}

void CBillingDlg::OnFacilityTimeChanged(long nNewMinutes, BOOL bPlaceOfServiceChanged /*= FALSE*/)
{
	try {

		if (m_pList == NULL)
			return;

		//see if there are any facility codes in the list, and if so, change their value

		if (m_PlaceOfServiceCombo->CurSel == -1)
			m_PlaceOfServiceCombo->CurSel = 0;
		long nPlaceOfServiceID = m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0).lVal;

		BOOL bPrompted = FALSE;

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {

			long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID), -1);
			long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);
			long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

			// (j.jones 2011-08-24 08:41) - PLID 44868 - do not change a charge if it is
			// an original or voided charge
			if (IsOriginalOrVoidCharge(nChargeID)) {
				pRow = pRow->GetNextRow();
				continue;
			}

			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (!ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND FacilityFee = 1 AND UseFacilityBilling = 1", nServiceID)) {
				//not a facility billing charge
				pRow = pRow->GetNextRow();
				continue;
			}

			// (j.jones 2007-10-15 14:57) - PLID 27757 - converted to use the new structure, which required this to be checked per charge
			if (!bPlaceOfServiceChanged) {
				//if it's a flat fee for this POS, and we're only changing the time, 
				//then nothing will be changed, so don't bother trying				
				if (!ReturnsRecordsParam("SELECT ID FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT} AND FacilityFeeBillType <> 1", nServiceID, nPlaceOfServiceID)) {
					pRow = pRow->GetNextRow();
					continue;
				}
			}

			if (!bPrompted) {
				//this is a "don't show me again" prompt, but if they do actually see it,
				//we don't want to try and show them again during this process
				if (bPlaceOfServiceChanged) {
					//they changed the POS
					DontShowMeAgain(this, "Changing the Place Of Service will change the fee for your Facility charges on this bill.\n"
						"Be sure to double-check the new bill total before saving.", "BillingDlgChangeFacilityPOS", "Practice", FALSE, FALSE);
				}
				else {
					//they changed the time
					DontShowMeAgain(this, "Changing the Facility Time will change the fee for your Facility charges on this bill.\n"
						"Be sure to double-check the new bill total before saving.", "BillingDlgChangeFacilityTime", "Practice", FALSE, FALSE);
				}
				bPrompted = TRUE;
			}

			//ok, we're on a facility charge, they've been warned, and it's not a flat fee, so recalculate the fee!

			// (j.jones 2011-01-25 15:45) - PLID 42156 - if the charge is locked, don't let them change the fee,
			// and instead just return now, we can't prompt on every charge
			if (m_EntryType == 1) {
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
					return;
				}
			}

			// (j.jones 2006-09-19 10:43) - PLID 22106 - determine first if we are going to calculate
			// as a practice fee or an outside fee, for quotes only

			BOOL bUsingOutsideFee = FALSE;

			if (m_EntryType == 2) {
				// (j.jones 2007-10-15 14:57) - PLID 27757 - converted to use the new structure
				_RecordsetPtr rs = CreateParamRecordset("SELECT FacilityOutsideFee FROM FacilityFeeSetupT WHERE ServiceID = {INT} AND LocationID = {INT}", nServiceID, nPlaceOfServiceID);
				if (!rs->eof) {

					//check the setting for what they want the fee to be
					BOOL bFacilityOutsideFee = AdoFldBool(rs, "FacilityOutsideFee", FALSE);

					//now check the current setup on the quote
					BOOL bHasPracticeFee = FALSE;
					BOOL bHasOutsideFee = FALSE;

					for (int j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == nLineID) {

							bHasPracticeFee = VarCurrency(m_billingItems[j]->UnitCost, COleCurrency(0, 0)) != COleCurrency(0, 0);
							bHasOutsideFee = VarCurrency(m_billingItems[j]->OthrUnitCost, COleCurrency(0, 0)) != COleCurrency(0, 0);
						}
					}

					//now we know what their intentions are, plus the values of the quote

					if (bFacilityOutsideFee) {
						//they want the fee to be an outside fee

						if (bHasPracticeFee && !bHasOutsideFee) {
							//the practice fee is nonzero, outside fee is zero, so we should prompt
							if (IDYES == MessageBox("A facility fee on this quote is set as a practice fee, "
								"but your settings for this Place Of Service state that it should be an outside fee.\n\n"
								"Do you wish to recalculate the facility fee as an outside fee?", "Practice", MB_ICONQUESTION | MB_YESNO)) {

								bUsingOutsideFee = TRUE;
							}
							else {
								bUsingOutsideFee = FALSE;
							}
						}
						else {
							//otherwise the practice fee is zero, or an outside fee exists, it's going to be an outside fee
							bUsingOutsideFee = TRUE;
						}
					}
					else {
						//they have not specified that they want the fee to be an outside fee

						//in this case, use the old PLID 19828 logic, where if the practice fee is
						//zero and the outside fee is nonzero, only then use the outside fee
						if (!bHasPracticeFee && bHasOutsideFee) {
							bUsingOutsideFee = TRUE;
						}
						else {
							bUsingOutsideFee = FALSE;
						}
					}
				}
				rs->Close();
			}

			//default the amount to the current amount in the list
			COleCurrency cyAmount;

			if (bUsingOutsideFee) {
				cyAmount = VarCurrency(pRow->GetValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE), COleCurrency(0, 0));
			}
			else {
				cyAmount = VarCurrency(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST), COleCurrency(0, 0));
			}

			if (bPlaceOfServiceChanged) {
				//if the POS Changed, we might not have the data stored on the Additional Info tab

				long nFacilityMinutes = GetFacilityMinutes();
				CString strStartTime = GetFacilityStartTime();
				CString strEndTime = GetFacilityEndTime();

				BOOL bFacilityFee = FALSE;
				if (CheckFacilityFee(nServiceID, bFacilityFee, cyAmount, nFacilityMinutes, strStartTime, strEndTime, nPlaceOfServiceID) && bFacilityFee) {
					//set the times on the Billing2 dlg
					SetFacilityMinutes(nFacilityMinutes);
					SetFacilityStartTime(strStartTime);
					SetFacilityEndTime(strEndTime);
				}
			}
			else {
				CalcFacilityFee(nServiceID, cyAmount, nNewMinutes, nPlaceOfServiceID);
			}

			//we have a new amount, now put it back in the charge list

			for (int j = 0; j < (int)m_billingItems.size(); j++) {
				if (m_billingItems[j]->LineID.lVal == nLineID) {

					if (m_EntryType == 2 && bUsingOutsideFee) {
						m_billingItems[j]->OthrUnitCost = _variant_t(cyAmount);
						m_billingItems[j]->UnitCost = _variant_t(COleCurrency(0, 0));
					}
					else {
						m_billingItems[j]->UnitCost = _variant_t(cyAmount);
						m_billingItems[j]->OthrUnitCost = _variant_t(COleCurrency(0, 0));
					}
				}
			}

			if (m_EntryType == 2 && bUsingOutsideFee) {
				pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _variant_t(cyAmount));
				pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(COleCurrency(0, 0)));
			}
			else {
				pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(cyAmount));
				if (m_EntryType == 2)
					pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _variant_t(COleCurrency(0, 0)));
			}

			//now mark it for saving, and calculate the total
			m_varBoundItem = nLineID;
			COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
			if (varChargeID.lVal != -2)
			{
				AddToModifiedList(varChargeID.lVal);
			}

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll("Error in OnFacilityTimeChanged");
}

CString CBillingDlg::GetAnesthStartTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAnesthStartTime();
	}

	return "";
}

CString CBillingDlg::GetAnesthEndTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAnesthEndTime();
	}

	return "";
}

CString CBillingDlg::GetFacilityStartTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetFacilityStartTime();
	}

	return "";
}

CString CBillingDlg::GetFacilityEndTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetFacilityEndTime();
	}

	return "";
}

long CBillingDlg::GetAnesthMinutes()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAnesthMinutes();
	}

	return 0;
}

long CBillingDlg::GetFacilityMinutes()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetFacilityMinutes();
	}

	return 0;
}

void CBillingDlg::SetAnesthStartTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAnesthStartTime(strTime, bUpdateCharges);
	}
}

void CBillingDlg::SetAnesthEndTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAnesthEndTime(strTime, bUpdateCharges);
	}
}

void CBillingDlg::SetFacilityStartTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetFacilityStartTime(strTime, bUpdateCharges);
	}
}

void CBillingDlg::SetFacilityEndTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetFacilityEndTime(strTime, bUpdateCharges);
	}
}

void CBillingDlg::SetAnesthMinutes(long nMinutes, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAnesthMinutes(nMinutes, bUpdateCharges);
	}
}

void CBillingDlg::SetFacilityMinutes(long nMinutes, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetFacilityMinutes(nMinutes, bUpdateCharges);
	}
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
CString CBillingDlg::GetAssistingStartTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAssistingStartTime();
	}

	return "";
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
CString CBillingDlg::GetAssistingEndTime()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAssistingEndTime();
	}

	return "";
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
long CBillingDlg::GetAssistingMinutes()
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetAssistingMinutes();
	}

	return 0;
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
void CBillingDlg::SetAssistingStartTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAssistingStartTime(strTime, bUpdateCharges);
	}
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
void CBillingDlg::SetAssistingEndTime(CString strTime, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAssistingEndTime(strTime, bUpdateCharges);
	}
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
void CBillingDlg::SetAssistingMinutes(long nMinutes, BOOL bUpdateCharges /*= FALSE*/)
{
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling2.SetAssistingMinutes(nMinutes, bUpdateCharges);
	}
}

// (j.jones 2011-11-01 08:55) - PLID 41558 - added assisting times
void CBillingDlg::OnAssistingTimeChanged(long nNewMinutes)
{
	try {

		if (m_pList == NULL) {
			return;
		}

		//if not using OHIP, do nothing
		if (!UseOHIP()) {
			return;
		}

		//see if there are any assisting codes in the list, and if so, change their value

		BOOL bPrompted = FALSE;

		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {

			long nLineID = VarLong(pRow->GetValue(COLUMN_LINE_ID), -1);
			long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);
			long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);
			long nItemType = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_ITEM_TYPE : QUOTE_COLUMN_ITEM_TYPE));

			//these are service codes only
			if (nItemType != ITEM_TYPE_CPT) {
				pRow = pRow->GetNextRow();
				continue;
			}

			//do not change a charge if it is an original or voided charge
			if (IsOriginalOrVoidCharge(nChargeID)) {
				pRow = pRow->GetNextRow();
				continue;
			}

			long nBaseUnits = 0;
			_RecordsetPtr rs = CreateParamRecordset("SELECT AssistingBaseUnits "
				"FROM CPTCodeT WHERE ID = {INT} AND AssistingCode = 1", nServiceID);
			if (rs->eof) {
				//not an assisting charge
				pRow = pRow->GetNextRow();
				continue;
			}
			else {
				nBaseUnits = AdoFldLong(rs, "AssistingBaseUnits", 0);
			}
			rs->Close();

			if (!bPrompted) {
				//this is a "don't show me again" prompt, but if they do actually see it,
				//we don't want to try and show them again during this process

				DontShowMeAgain(this, "Changing the Assisting Time will change the fee for your Assisting charges on this bill.\n"
					"Be sure to double-check the new total before saving.", "BillingDlgChangeAssistingTime", "Practice", FALSE, FALSE);

				bPrompted = TRUE;
			}

			//ok, we're on an Assisting charge, they've been warned, so recalculate the fee!

			// if the charge is locked, don't let them change the fee, and instead just return now, we can't prompt on every charge
			if (m_EntryType == 1) {
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				if (nChargeID != -2 && !CanChangeHistoricFinancial("Charge", nChargeID, bioBill, sptWrite)) {
					return;
				}
			}

			//default these values to their current values in the list
			COleCurrency cyAmount = VarCurrency(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST), COleCurrency(0, 0));

			CalcAssistingCode(nServiceID, nNewMinutes, nBaseUnits, cyAmount);

			//we have a new amount and new quantity, now put those back in the charge list

			for (int j = 0; j < (int)m_billingItems.size(); j++) {
				if (m_billingItems[j]->LineID.lVal == nLineID) {

					m_billingItems[j]->UnitCost = _variant_t(cyAmount);
					m_billingItems[j]->OthrUnitCost = _variant_t(COleCurrency(0, 0));
				}
			}

			pRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(cyAmount));
			if (m_EntryType == 2) {
				pRow->PutValue(QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE, _variant_t(COleCurrency(0, 0)));
			}

			//now mark it for saving, and calculate the total
			m_varBoundItem = nLineID;
			COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
			if (varChargeID.lVal != -2)
			{
				AddToModifiedList(varChargeID.lVal);
			}

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);

			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll(__FUNCTION__);
}

BOOL CBillingDlg::CheckAllowAddAnesthesiaFacilityCharge(long nServiceID)
{
	//check and see if nServiceID is an anesthesia code or facility code, and already exists in the charge list
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rs = CreateParamRecordset("SELECT Anesthesia, FacilityFee, Name, Code FROM ServiceT "
		"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
		"WHERE ServiceT.ID = {INT} AND ((Anesthesia = 1 AND UseAnesthesiaBilling = 1) OR (FacilityFee = 1 AND UseFacilityBilling = 1)) "
		"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1)", nServiceID);
	if (!rs->eof) {
		//they are adding an anesthesia or facility fee, so see if any matching charge types exist

		BOOL bAnesthesia = AdoFldBool(rs, "Anesthesia", FALSE);
		BOOL bFacilityFee = AdoFldBool(rs, "FacilityFee", FALSE);

		BOOL bWarned = FALSE;

		// (j.jones 2007-10-15 15:12) - PLID 27757 - reworded these warnings to reflect that we now allow multiple service code setups

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow != NULL && !bWarned) {
			long nChargeServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			if (bAnesthesia && ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND Anesthesia = 1 AND UseAnesthesiaBilling = 1", nChargeServiceID)) {

				//there is an anesthesia code

				bWarned = TRUE;
				CString str;
				str.Format("You are trying to add Service Code '%s - %s' to the list, which is an Anesthesia charge.\n"
					"However, there is already an Anesthesia charge on this %s.\n\n"
					"Are you sure you wish to add another Anesthesia charge?",
					AdoFldString(rs, "Code", ""),
					AdoFldString(rs, "Name", ""),
					m_EntryType == 1 ? "bill" : "quote", m_EntryType == 1 ? "bill" : "quote");

				if (IDNO == MessageBox(str, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
					return FALSE;
				}
			}
			// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
			else if (bFacilityFee && ReturnsRecordsParam("SELECT ID FROM ServiceT WHERE ID = {INT} AND FacilityFee = 1 AND UseFacilityBilling = 1", nChargeServiceID)) {

				//there is a facility code

				bWarned = TRUE;
				CString str;
				str.Format("You are trying to add Service Code '%s - %s' to the list, which is a Facility charge.\n"
					"However, there is already a Facility charge on this %s.\n\n"
					"Are you sure you wish to add another Facility charge?",
					AdoFldString(rs, "Code", ""),
					AdoFldString(rs, "Name", ""),
					m_EntryType == 1 ? "bill" : "quote", m_EntryType == 1 ? "bill" : "quote");

				if (IDNO == MessageBox(str, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
					return FALSE;
				}
			}

			pRow = pRow->GetNextRow();
		}
	}
	rs->Close();

	return TRUE;
}

BOOL CBillingDlg::GetIsAnyPackage()
{
	//simply return true if this is any type of package
	return m_packageCheck.GetCheck();
}

BOOL CBillingDlg::GetIsRepeatPackage()
{
	//return true if this is a repeat package
	if (m_packageCheck.GetCheck()) {
		return m_radioRepeatPackage.GetCheck();
	}
	else {
		return FALSE;
	}
}

BOOL CBillingDlg::GetIsMultiUsePackage()
{
	//return true if this is a multi-use package
	if (m_packageCheck.GetCheck()) {
		return m_radioMultiUsePackage.GetCheck();
	}
	else {
		return FALSE;
	}
}

void CBillingDlg::OnPackageTypeChanged()
{
	if (m_packageCheck.GetCheck()) {

		if (m_radioRepeatPackage.GetCheck()) {

			if (GetBillID() != -1) {
				//this may be an existing package, see if they are changing the type
				// (j.jones 2009-12-23 16:52) - PLID 36699 - saved a recordset by using cached data,
				if (m_nOldPackageType == 2) {
					//they're changing the type
					if (IDNO == MessageBox("You have already saved this quote as a multi-use package. "
						"Are you sure you wish to change it to a repeat package?", "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
						m_radioRepeatPackage.SetCheck(FALSE);
						m_radioMultiUsePackage.SetCheck(TRUE);
						return;
					}
				}
			}

			GetDlgItem(IDC_PACKAGE_COUNT_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_COUNT)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT)->ShowWindow(SW_SHOWNOACTIVATE);

			//hide the remaining qty column
			//IColumnSettingsPtr pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM);
			//pCol->PutStoredWidth(0);

			ResizeColumns();
		}
		else if (m_radioMultiUsePackage.GetCheck()) {

			if (GetBillID() != -1) {
				//this may be an existing package, see if they are changing the type
				// (j.jones 2009-12-23 16:52) - PLID 36699 - saved a recordset by using cached data,
				if (m_nOldPackageType == 1) {
					//they're changing the type
					if (IDNO == MessageBox("You have already saved this quote as a repeat package. "
						"Are you sure you wish to change it to a multi-use package?", "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
						m_radioRepeatPackage.SetCheck(TRUE);
						m_radioMultiUsePackage.SetCheck(FALSE);
						return;
					}
				}
			}

			GetDlgItem(IDC_PACKAGE_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_COUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_TOTAL_COUNT)->ShowWindow(SW_HIDE);

			//show the remaining quantity column
			//IColumnSettingsPtr pCol = m_QuoteList->GetColumn(QUOTE_COLUMN_PACKAGE_QTY_REM);
			//pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, QUOTE_COLUMN_PACKAGE_QTY_REM) : 8);

			ResizeColumns();
		}

		// (j.jones 2009-12-22 16:50) - PLID 32587 - show/hide the initial value fields accordingly
		OnPackageShowInitialValues();

		// (j.jones 2008-04-30 10:32) - PLID 27506 - if they changed the package type,
		// recalculate the total, but only if the quote has not been billed
		if (!m_bQuoteHasBeenBilled && m_boInitialized) {
			CalculateTotal();
		}
	}
}

BOOL CBillingDlg::GetIsPackageQuantityChangeAllowed(double dblQtyChange, long nServiceID, long nPackageChargeRefID)
{
	//if it's not linked to a package, bail
	if (nPackageChargeRefID == -1)
		return TRUE;

	double dblQuantity = 0.0;

	//first calculate any existing uses on this bill and propagate the dialog
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		if (VarLong(m_billingItems[i]->PackageChargeRefID, -1) == nPackageChargeRefID) {

			//okay this package has been added to this bill already
			long nChargeID = VarLong(m_billingItems[i]->ChargeID, -2);
			double dblCurQuantity = VarDouble(m_billingItems[i]->Quantity, 0.0);
			if (nChargeID != -2) {
				//if it has been saved before, we can't know for sure if they haven't changed the quantity
				//so reload it and adjust accordingly
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsQty = CreateParamRecordset("SELECT Quantity FROM ChargesT WHERE ID = {INT}", nChargeID);
				if (!rsQty->eof) {
					double dblOldQuantity = AdoFldDouble(rsQty, "Quantity", 0.0);
					dblCurQuantity -= dblOldQuantity;
				}
				rsQty->Close();
			}
			if (dblCurQuantity != 0.0) {
				dblQuantity += dblCurQuantity;
			}
		}
	}

	//add the offset that the user is changing
	dblQuantity += dblQtyChange;

	//now that we have the total amount used on this bill, if any,
	//check and see if there are any uses left on this package
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rsCheckPackage = CreateParamRecordset("SELECT ServiceID, Sum(PackageQtyRemaining) AS QtyRemain "
		"FROM ChargesT INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID WHERE Deleted = 0 AND ChargesT.ID = {INT} "
		"GROUP BY ServiceID", nPackageChargeRefID);
	if (!rsCheckPackage->eof) {

		//check the remaining quantity
		long nServiceID = AdoFldLong(rsCheckPackage, "ServiceID");
		double dblQtyRemaining = AdoFldDouble(rsCheckPackage, "QtyRemain", 0.0);

		if (dblQtyRemaining - dblQuantity >= 0.0)
			//they aren't using more than there are available uses
			return TRUE;
		else
			//they are trying to use too many items
			return FALSE;
	}
	rsCheckPackage->Close();

	//if we get here it must be okay
	return TRUE;
}

void CBillingDlg::UpdatePalm()
{
	try {
		UpdatePalmSyncTByPerson(m_nPatientID);
		PPCRefreshAppts(m_nPatientID);
	}NxCatchAll("Error in UpdatingPalm");
}

void CBillingDlg::DeleteChargeFromList(long nLineID)
{
	IRowSettingsPtr pRow = m_pList->SetSelByColumn(COLUMN_LINE_ID, (long)nLineID);

	if (pRow == NULL) {
		ASSERT(FALSE);
		return;
	}

	// Mark item for permanent deletion
	_variant_t var = pRow->GetValue(COLUMN_CHARGE_ID);
	long nChargeID = VarLong(var);
	if (nChargeID != -2) {

		// (j.jones 2011-08-24 08:41) - PLID 44868 - shouldn't be possible on an original/void
		// charge, but assert if it happened
		if (IsOriginalOrVoidCharge(nChargeID)) {
			ASSERT(FALSE);
			return;
		}

		m_adwDeletedCharges.Add(nChargeID);

		//////////////////////////////
		// Make sure this is not in
		// the edit list
		DeleteFromModifiedList(nChargeID);
	}

	// Delete item from visible list
	CString str;
	m_pList->RemoveRow(pRow);

	// (j.jones 2011-06-24 16:16) - PLID 27672 - if we removed the last row,
	// yet still are tracking that we have billed a package, clear that tracking
	if (m_pList->GetRowCount() == 0) {
		m_bPaymentPlan = FALSE;
		m_RepeatPackageUses = 0;
		m_bIsABilledPackage = FALSE;
		m_nPackageID = -1;
		m_nPackageType = -1;
	}

	// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
	int i = 0;
	for (i = 0; i < (int)m_billingItems.size(); i++) {
		if (m_billingItems[i]->LineID.lVal == nLineID) {
			//if this charge is the one mentioned in the bill description, change the bill desc.
			// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
			if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
				str = GetBillDescription();
				if (CString(m_billingItems[i]->Description.bstrVal) == str) {
					//clear the description
					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
					SetBillDescription("");
					//if there are other charges, set the description to one of those
					if (m_pList->GetRowCount() > 0) {
						IRowSettingsPtr pFirstRow = m_pList->GetFirstRow();
						if (m_EntryType == 1) {
							// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
							SetBillDescription(CString(pFirstRow->GetValue(BILL_COLUMN_DESCRIPTION).bstrVal));
						} else {
							// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
							SetBillDescription(CString(pFirstRow->GetValue(QUOTE_COLUMN_DESCRIPTION).bstrVal));
						}
					}
				}
			}

			// (a.walling 2007-05-24 09:47) - PLID 26114 - restore any points this may have used
			COleCurrency cyUsedPoints = VarCurrency(m_billingItems[i]->PointsUsed, COleCurrency(0, 0));
			if (cyUsedPoints > COleCurrency(0, 0)) {
				// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - Operator * is ambiguous
				((CBillingModuleDlg*)m_pBillingModuleWnd)->AddAdjustedRewardPoints(cyUsedPoints * long(-1));
			}

			//remove product item IDs
			long delChargedProductItemListID = m_billingItems[i]->ChargedProductItemListID.lVal;
			DeleteOneFromChargedProductItemsArray(delChargedProductItemListID);

			// (j.jones 2007-12-11 11:52) - PLID 27988 - remove allocation detail IDs
			long nDelChargedAllocationDetailListID = VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1);
			if (nDelChargedAllocationDetailListID != -1) {
				DeleteOneFromChargedAllocationDetailsArray(nDelChargedAllocationDetailListID);
			}

			m_billingItems.erase(m_billingItems.begin() + i);
			break;
		}
	}

	//renumber lineIDs
	for (i = 0; i < (int)m_billingItems.size(); i++) {
		long tempID = m_billingItems[i]->LineID.lVal;
		if (tempID > nLineID) {
			tempID--;
			m_billingItems[i]->LineID = tempID;
		}
	}

	// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
	pRow = m_pList->GetFirstRow();
	while (pRow) {
		long tempID = pRow->GetValue(COLUMN_LINE_ID).lVal;
		if (tempID > nLineID) {
			tempID--;
			pRow->PutValue(COLUMN_LINE_ID, tempID);
			if (pRow->GetValue(COLUMN_CHARGE_ID).lVal != -2) {
				// (j.jones 2011-08-24 08:41) - PLID 44868 - this is ok to change if
				// an original/void charge, because we are only changing the line ID
				AddToModifiedList(pRow->GetValue(COLUMN_CHARGE_ID).lVal, TRUE);
			}
		}

		pRow = pRow->GetNextRow();
	}

	// (r.gonet 2015-03-27 18:50) - PLID 65277 - Hide the Value column if that was the last gift certificate
	if (m_EntryType == 1) {
		bool bGiftCertificateRowStillExist = false;
		pRow = m_pList->GetFirstRow();
		while (pRow) {
			_variant_t varItemType = pRow->GetValue(COLUMN_ITEM_TYPE);
			if (varItemType.vt == VT_I4 && VarLong(varItemType) == ITEM_TYPE_GIFT) {
				bGiftCertificateRowStillExist = true;
			}

			pRow = pRow->GetNextRow();
		}

		if (!bGiftCertificateRowStillExist) {
			ShowValueColumn(false);
		}
	}

	Requery();

	m_boChangesMade = TRUE;
}

BOOL CBillingDlg::CheckHasInsuranceCharges()
{
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		RPCList* list = m_billingItems[i]->RPCList;
		for (int j = 0; j < list->aryRPC.GetSize(); j++) {
			RespPerCharge rpc = list->aryRPC.GetAt(j);
			COleCurrency IR = (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));
			if (IR > COleCurrency(0, 0)) {
				//we found an insurance amount
				return TRUE;
			}
		}
	}

	return FALSE;
}

void CBillingDlg::PostChargeAdded()
{
	try {

		// (j.jones 2006-04-17 09:20) - PLID 20156 - if we add a charge for a given insurance company,
		// we need to make sure that the "primary" insurance company on the insurance tab is the company
		// we are adding a charge for, and the "other" insurance company is the next logical choice

		// (j.jones 2010-08-17 10:35) - PLID 40135 - now that we have categories for resp. types, we need
		// to enforce that we don't auto-select an "other" insurance resp

		if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {

			long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
			RespCategoryType eRespCategory = GetCurrentBillToRespTypeCategoryID();

			//don't change anything if it's patient
			if (nInsuredPartyID != -1) {

				//they did choose an insured party

				// (j.jones 2010-01-07 14:25) - PLID 36752 - ensure the insurance tab is initialized,
				// so we can properly set the insurance company selection
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.EnsureInitialized();

				//so first set the main insurance to the selected insured party
				bool bChanged = (m_GuarantorID1 != nInsuredPartyID);
				m_GuarantorID1 = nInsuredPartyID;
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->SetSelByColumn(0, nInsuredPartyID);
				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_GuarantorID1 = nInsuredPartyID;

				if (bChanged) {
					// (j.jones 2014-05-29 10:56) - PLID 61837 - also update the charge provider
					// columns back on the bill tab
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgBilling.TryShowAllChargeProviderColumns();
					// (s.tullis 2016-02-24 16:34) - PLID 68319
					((CBillingModuleDlg*)m_pBillingModuleWnd)->UpdateClaimFormSelection();
				}

				//now determine the other insurance to use

				// (j.jones 2010-08-17 10:51) - PLID 40135 - it must have the same category
				_RecordsetPtr rs = CreateParamRecordset("SELECT InsuredPartyT.PersonID FROM InsuredPartyT "
					"INNER JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
					"WHERE InsuredPartyT.PatientID = {INT} AND RespTypeT.ID <> -1 AND InsuredPartyT.PersonID <> {INT} "
					"AND RespTypeT.CategoryType = {INT} "
					"ORDER BY RespTypeID", m_nPatientID, nInsuredPartyID, (long)eRespCategory);
				if (!rs->eof) {
					//take the first responsibility that isn't this party, so if it's being billed to
					//secondary, we select primary, etc.
					m_GuarantorID2 = AdoFldLong(rs, "PersonID", -1);
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->SetSelByColumn(0, AdoFldLong(rs, "PersonID", -1));
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_GuarantorID2 = AdoFldLong(rs, "PersonID", -1);
				}
				else {
					//if nothing available, then there is no "other" insurance
					m_GuarantorID2 = -1;
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->CurSel = -1;
					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_GuarantorID2 = -2; //not a typo, we don't want the insurance tab to reload this
				}
				rs->Close();
			}
		}

		// (j.jones 2007-07-03 16:05) - PLID 26098 - check the multiple-service modifier linking,
		// such that if a code exists on this bill that is set to use a modifier when another code is added,
		// add that modifier to the code if it isn't already in use on that code
		CheckApplyServiceModifierLinks();

	}NxCatchAll("Error in CBillingDlg::PostChargeAdded");
}

// (j.jones 2007-07-03 16:31) - PLID 26098 - clear out the array and rebuild from data
void CBillingDlg::PopulateServiceModifierLinkArray()
{
	try {

		//first clear the array
		for (int i = m_pServiceModifierLinks.GetSize() - 1; i >= 0; i--) {
			ServiceModifierLink *pLink = (ServiceModifierLink*)(m_pServiceModifierLinks.GetAt(i));
			delete pLink;
		}
		m_pServiceModifierLinks.RemoveAll();

		_RecordsetPtr rs = CreateRecordset("SELECT ServiceID, Modifier, Multiplier FROM MultiServiceModifierLinkT "
			"INNER JOIN ServiceT ON MultiServiceModifierLinkT.ServiceID = ServiceT.ID "
			"INNER JOIN CPTModifierT ON MultiServiceModifierLinkT.Modifier = CPTModifierT.Number "
			"WHERE ServiceT.Active = 1 AND CPTModifierT.Active = 1");
		while (!rs->eof) {

			//add to our array
			ServiceModifierLink *pNew = new ServiceModifierLink;
			pNew->nServiceID = AdoFldLong(rs, "ServiceID", -1);
			pNew->strModifier = AdoFldString(rs, "Modifier", "");
			pNew->dblMultiplier = AdoFldDouble(rs, "Multiplier", 0.0);
			m_pServiceModifierLinks.Add(pNew);

			rs->MoveNext();
		}
		rs->Close();

	}NxCatchAll("Error in CBillingDlg::PopulateServiceModifierLinkArray");
}

// (j.jones 2007-07-03 16:31) - PLID 26098 - added ability to link modifiers to charges
// when other charges are added
void CBillingDlg::CheckApplyServiceModifierLinks()
{
	try {

		// (j.jones 2007-07-03 16:05) - PLID 26098 - check the multiple-service modifier linking,
		// such that if a code exists on this bill that is set to use a modifier when another code is added,
		// add that modifier to the code if it isn't already in use on that code

		if (m_pList->GetRowCount() <= 1) {
			//do nothing if we have one charge
			return;
		}

		//is our array empty? If so, there's nothing to check
		if (m_pServiceModifierLinks.GetSize() == 0)
			return;

		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {

			//if not a service code, continue
			if (VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_ITEM_TYPE : QUOTE_COLUMN_ITEM_TYPE)) != ITEM_TYPE_CPT) {
				pRow = pRow->GetNextRow();
				continue;
			}

			//grab the service ID
			long nServiceID = VarLong(pRow->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

			//see if this service is linked to a modifier
			CString strModifier = "";
			double dblMultiplier = 0.0;

			//check using our array, instead of the database
			BOOL bFound = FALSE;
			for (int a = 0; a < m_pServiceModifierLinks.GetSize() && !bFound; a++) {
				ServiceModifierLink *pLink = (ServiceModifierLink*)(m_pServiceModifierLinks.GetAt(a));
				if (pLink->nServiceID == nServiceID) {
					strModifier = pLink->strModifier;
					dblMultiplier = pLink->dblMultiplier;
					bFound = TRUE;
				}
			}

			//continue if we have a linked, active modifier
			if (!strModifier.IsEmpty()) {

				//now, do we have that modifier selected already?					
				CString strModifier1, strModifier2, strModifier3, strModifier4;
				_variant_t var = pRow->GetValue(m_EntryType == 1 ? COLUMN_MODIFIER1 : QUOTE_COLUMN_MODIFIER1);
				if (var.vt == VT_BSTR)
					strModifier1 = VarString(var, "");
				var = pRow->GetValue(m_EntryType == 1 ? COLUMN_MODIFIER2 : QUOTE_COLUMN_MODIFIER2);
				if (var.vt == VT_BSTR)
					strModifier2 = VarString(var, "");
				var = pRow->GetValue(m_EntryType == 1 ? COLUMN_MODIFIER3 : QUOTE_COLUMN_MODIFIER3);
				if (var.vt == VT_BSTR)
					strModifier3 = VarString(var, "");
				var = pRow->GetValue(m_EntryType == 1 ? COLUMN_MODIFIER4 : QUOTE_COLUMN_MODIFIER4);
				if (var.vt == VT_BSTR)
					strModifier4 = VarString(var, "");

				//see if it is in use
				if (strModifier != strModifier1 && strModifier != strModifier2
					&& strModifier != strModifier3 && strModifier != strModifier4) {

					//not in use, so we can add the modifier

					//that first means we need to confirm that we added a charge that
					//is not linked to the same modifier

					BOOL bNeedToAdd = FALSE;
					// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
					IRowSettingsPtr pRow2 = m_pList->GetFirstRow();
					while (pRow2 != NULL && !bNeedToAdd) {

						//if not a service code, continue
						if (VarLong(pRow2->GetValue(m_EntryType == 1 ? COLUMN_ITEM_TYPE : QUOTE_COLUMN_ITEM_TYPE)) != ITEM_TYPE_CPT) {
							pRow2 = pRow2->GetNextRow();
							continue;
						}

						//no need to check the current row against itself
						if (pRow2 != pRow) {

							long nCheckServiceID = VarLong(pRow2->GetValue(m_EntryType == 1 ? COLUMN_SERVICE_ID : QUOTE_COLUMN_SERVICE_ID), -1);

							//check using our array, instead of the database
							BOOL bFoundMatch = FALSE;
							for (int a = 0; a < m_pServiceModifierLinks.GetSize() && !bFoundMatch; a++) {
								ServiceModifierLink *pLink = (ServiceModifierLink*)(m_pServiceModifierLinks.GetAt(a));
								if (pLink->nServiceID == nCheckServiceID && pLink->strModifier == strModifier) {
									//the service is linked to the same modifier
									bFoundMatch = TRUE;
								}
							}

							//if we did not match up with a record, then that means 
							//there is a charge without the same modifier link as
							//our main charge we're comparing to, so we do need to add
							if (!bFoundMatch) {
								bNeedToAdd = TRUE;
							}
						}

						pRow2 = pRow2->GetNextRow();
					}

					if (bNeedToAdd) {

						_variant_t varLineID = pRow->GetValue(COLUMN_LINE_ID);

						//track line IDs to update
						CArray<long, long> aryLineIDs;

						//update the BillingTabInfo array
						// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
						int j = 0;
						for (j = 0; j < (int)m_billingItems.size(); j++) {
							if (m_billingItems[j]->LineID == varLineID) {
								//found it, so update accordingly

								//update the datalist and the array, just determine which modifier to change

								if (strModifier1.IsEmpty()) {
									m_billingItems[j]->Modifier1 = _bstr_t(strModifier);
									m_billingItems[j]->Multiplier1 = (double)(dblMultiplier);
									pRow->PutValue(m_EntryType == 1 ? COLUMN_MODIFIER1 : QUOTE_COLUMN_MODIFIER1, _bstr_t(strModifier));
								}
								else if (strModifier2.IsEmpty()) {
									m_billingItems[j]->Modifier2 = _bstr_t(strModifier);
									m_billingItems[j]->Multiplier2 = (double)(dblMultiplier);
									pRow->PutValue(m_EntryType == 1 ? COLUMN_MODIFIER2 : QUOTE_COLUMN_MODIFIER2, _bstr_t(strModifier));
								}
								else if (strModifier3.IsEmpty()) {
									m_billingItems[j]->Modifier3 = _bstr_t(strModifier);
									m_billingItems[j]->Multiplier3 = (double)(dblMultiplier);
									pRow->PutValue(m_EntryType == 1 ? COLUMN_MODIFIER3 : QUOTE_COLUMN_MODIFIER3, _bstr_t(strModifier));
								}
								else if (strModifier4.IsEmpty()) {
									m_billingItems[j]->Modifier4 = _bstr_t(strModifier);
									m_billingItems[j]->Multiplier4 = (double)(dblMultiplier);
									pRow->PutValue(m_EntryType == 1 ? COLUMN_MODIFIER4 : QUOTE_COLUMN_MODIFIER4, _bstr_t(strModifier));
								}
								else {
									//They are all in use!

									CString strCode = VarString(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_CPT_CODE : QUOTE_COLUMN_CPT_CODE), "");
									CString strSubCode = VarString(pRow->GetValue(m_EntryType == 1 ? BILL_COLUMN_CPT_SUB_CODE : QUOTE_COLUMN_CPT_SUB_CODE), "");

									CString str;
									str.Format("You have configured the service code '%s %s' to use the modifier '%s' when other charges exist,\n"
										"but all four modifiers are in use on this charge. No modifiers on this charge were changed.", strCode, strSubCode, strModifier);
									AfxMessageBox(str);
									continue;
								}

								//track the affected line ID
								aryLineIDs.Add(VarLong(varLineID));

								// (j.jones 2011-10-11 11:08) - PLID 44941 - if Alberta, we need to change
								// the unit cost based on the modifier we just chose
								// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
								// price unless there are modifiers, but there should be at this point
								if (UseAlbertaHLINK()) {
									UpdateChargePriceWithAlbertaModifiers(m_billingItems[j], FALSE);
								}

								//mark our charge as modified
								AddToModifiedList(pRow->GetValue(COLUMN_CHARGE_ID));
							}
						}

						for (j = 0; j < aryLineIDs.GetSize(); j++) {
							//update each row
							m_varBoundItem = _variant_t(aryLineIDs.GetAt(j));

							COleCurrency cyInvalid;
							cyInvalid.SetStatus(COleCurrency::invalid);
							// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
							CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
						}
					}
				}
			}

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll("Error in CBillingDlg::CheckApplyServiceModifierLinks");
}

//(e.lally 2006-08-08) PLID 21848 - We need a way to share the column number definitions
//We could have made unique macro names in the header file, but this will keep the scope
//limited to the source file where we want it to help avoid misuse.
int CBillingDlg::GetServiceIDColumn()
{
	return COLUMN_SERVICE_ID;
}

// (a.walling 2007-05-04 11:30) - PLID 14717 - Show the suggested sales dialog
void CBillingDlg::OnBtnShowSuggestedSales()
{
	// (a.walling 2007-04-04 14:50)
	try {
		// (a.wetta 2007-05-17 10:36) - PLID 25960 - Need the NexSpa license for suggested sales
		if (!g_pLicense || !g_pLicense->CheckForLicense(CLicense::lcNexSpa, CLicense::cflrSilent))
			return;

		if (m_pSuggestedSalesDlg == NULL) {
			ASSERT(FALSE);
			ThrowNxException("Suggested Sales dialog has not been constructed!");
		}

		if (m_pSuggestedSalesDlg->GetSafeHwnd() == NULL) {
			m_pSuggestedSalesDlg->Create(IDD_BILLING_SUGGESTED_SALES, this);
		}

		if (m_pSuggestedSalesDlg->IsWindowVisible()) {
			GetDlgItem(IDC_BTN_SHOW_SUGGESTED_SALES)->SetWindowText("Show Suggestions");
			m_pSuggestedSalesDlg->ShowWindow(SW_HIDE);
		}
		else {
			GetDlgItem(IDC_BTN_SHOW_SUGGESTED_SALES)->SetWindowText("Hide Suggestions");
			m_pSuggestedSalesDlg->ShowWindow(SW_SHOWNOACTIVATE); // will refresh if needed when showing
		}

	} NxCatchAll("Error creating suggested sales dialog!");
}

// (a.walling 2007-05-04 11:29) - PLID 14717 - The suggested sales dialog has been closed
void CBillingDlg::SetSuggestedSalesHidden()
{
	GetDlgItem(IDC_BTN_SHOW_SUGGESTED_SALES)->SetWindowText("Show Suggestions");
}

//this is the override of the left click event for the datalist
//the OnLeftClickList is the override of the LButtonDown event
// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLeftClickBillList(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	// (c.haag 2008-06-09 16:45) - PLID 27216 - It's entirely possible for this to be
	// fired a second time while the discount popup is pumping messages. We need to
	// check whether we're doing a left-click handle, and if so, then dismiss the
	// message.
	if (m_bHandlingLeftClickBillList) {
		return;
	}
	m_bHandlingLeftClickBillList = TRUE;
	// (j.gruber 2009-03-06 12:32) - PLID 33351 - take out discount category list
	try {
		// (j.gruber 2009-03-10 12:00) - PLID 33351 - added new discount structure
		IRowSettingsPtr pRow(lpRow);
		if (pRow) {
			if (nCol == COLUMN_TOTAL_DISCOUNT) {
				ShowDiscountDetailDialog(pRow, TRUE);
			}
			// (s.dhole 2011-05-20 11:08) - PLID 33666 Call WhichCode Selection window
			else if (nCol == BILL_COLUMN_WHICH_CODES_EXT  && ShouldShowDiagExt()) {
				// (j.gruber 2014-02-19 13:20) - PLID 60901 - moved to its own function
				ShowWhichCodesSelectionDialog(pRow);
			}
			// (d.singleton 2014-03-21 09:06) - PLID 61428 - remove old medassist code.
			// (d.singleton 2012-03-07 12:27) - PLID 25098
			//check to see if they clicked the status column
			//else if(nCol == BILL_VALIDATION_STATUS)
			//{
			//	//make sure we actually have some results
			//	if(m_aryValidatedParsedResults.GetCount() > 0)
			//	{
			//		//need to match up the row we clicked on with the matching result in array
			//		long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

			//		for(int i = 0; i < m_aryValidatedParsedResults.GetCount(); i++)
			//		{
			//			if(m_aryValidatedParsedResults.GetAt(i).nChargeID == nChargeID)
			//			{
			//				//if its a success we have nothing to show
			//				if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsPass)
			//				{
			//					m_bHandlingLeftClickBillList = FALSE;
			//					return;
			//				}
			//				CString strErrorText;
			//				strErrorText = "Code: " + m_aryValidatedParsedResults.GetAt(i).strCptCode + "\r\n\r\nFailure Reasons:";
			//				if(!m_aryValidatedParsedResults.GetAt(i).strCptNotice.IsEmpty())
			//				{
			//					strErrorText += "\r\n" + m_aryValidatedParsedResults.GetAt(i).strCptNotice;
			//				}
			//				if(!m_aryValidatedParsedResults.GetAt(i).strABNReason.IsEmpty())
			//				{
			//					strErrorText += "\r\n" + m_aryValidatedParsedResults.GetAt(i).strABNReason;
			//				}
			//				if(!m_aryValidatedParsedResults.GetAt(i).strPolicyDotColor.IsEmpty())
			//				{
			//					strErrorText += "\r\n" + m_aryValidatedParsedResults.GetAt(i).strPolicyComment;
			//				}
			//				if(!m_aryValidatedParsedResults.GetAt(i).strIcd9Notice.IsEmpty())
			//				{
			//					strErrorText += "\r\n" + m_aryValidatedParsedResults.GetAt(i).strIcd9Notice;
			//				}
			//				if(!m_aryValidatedParsedResults.GetAt(i).strCCIComment.IsEmpty())
			//				{
			//					strErrorText += "\r\n" + m_aryValidatedParsedResults.GetAt(i).strCCIComment;
			//				}
			//				if(!m_aryValidatedParsedResults.GetAt(i).bModValid && !m_aryValidatedParsedResults.GetAt(i).strModReason.IsEmpty())
			//				{								
			//					strErrorText += m_aryValidatedParsedResults.GetAt(i).strModifierNotice + "\r\n";
			//					strErrorText += m_aryValidatedParsedResults.GetAt(i).strModReason + "\r\nAcceptable Mods:\r\n";
			//					strErrorText += m_aryValidatedParsedResults.GetAt(i).strAcceptableMods + "\r\n";
			//				}
			//				MessageBox(strErrorText, "This item has not passed validation", MB_OK|MB_ICONEXCLAMATION);
			//				break;
			//			}
			//		}
			//	}
			//} 
			// (d.singleton 2012-03-26 11:45) - PLID 49257
			else if (nCol == BILL_COLUMN_NOTES) {
				BOOL bIsUnsavedCharge = FALSE;
				_variant_t varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
				_variant_t varLineID = pRow->GetValue(COLUMN_LINE_ID);
				if (!ReturnsRecordsParam("SELECT * FROM ChargesT WHERE ID = {VT_I4}", varChargeID)) {
					bIsUnsavedCharge = TRUE;
				}
				//add the note
				AddUnsavedNotes(bIsUnsavedCharge, varChargeID, varLineID);
			}
		}
	}NxCatchAll("Error in CBillingDlg::OnLeftClickBillList");
	m_bHandlingLeftClickBillList = FALSE;
}


//this is the override of the left click event for the datalist
//the OnLeftClickList is the override of the LButtonDown event
// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnLeftClickListQuote(LPDISPATCH lpRow, short nCol, long x, long y, long nFlags)
{
	// (c.haag 2008-06-09 16:45) - PLID 27216 - It's entirely possible for this to be
	// fired a second time while the discount popup is pumping messages. We need to
	// check whether we're doing a left-click handle, and if so, then dismiss the
	// message.
	if (m_bHandlingLeftClickQuoteList) {
		return;
	}
	m_bHandlingLeftClickQuoteList = TRUE;

	IRowSettingsPtr pRow(lpRow);
	if (pRow) {
		if (nCol == QUOTE_COLUMN_TOTAL_DISCOUNT) {
			ShowDiscountDetailDialog(pRow, FALSE);
		}
	}
	m_bHandlingLeftClickQuoteList = FALSE;
}


void CBillingDlg::SetSuggestionsExist(BOOL bExists)
{
	// (a.walling 2007-05-07 12:30) - PLID 14717 - notify the user if suggestions exist
	if (bExists) {
		m_nxibShowSuggestedSales.SetTextColor(0x00FF0000); // blue
		m_nxibShowSuggestedSales.Invalidate();
	} else {
		m_nxibShowSuggestedSales.SetTextColor(0);
		m_nxibShowSuggestedSales.Invalidate();
	}
}

// (a.wetta 2007-05-08 10:29) - PLID 25959 - Gets the current discount amount of the particular service item if it is on sale.
// Returns TRUE if the item is on sale and FALSE if not.
BOOL CBillingDlg::GetServiceItemSaleDiscount(long nServiceID, double &dblPercentDiscount, COleCurrency &cyMoneyDiscount, CString &strSaleName, long &nDiscountCategoryID)
{
	try {
		// Determine if there are any current sales for this item
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rsSale = CreateParamRecordset("select * "
			"from SaleItemsT "
			"left join SalesT on SaleItemsT.SaleID = SalesT.ID "
			"where StartDate <= CONVERT(datetime, Convert(nvarchar, GetDate(), 101)) and "
			"EndDate >= CONVERT(datetime, Convert(nvarchar, GetDate(), 101)) and ServiceID = {INT}", nServiceID);
		if (!rsSale->eof) {
			dblPercentDiscount = AdoFldDouble(rsSale, "PercentDiscount", 0);
			cyMoneyDiscount = AdoFldCurrency(rsSale, "MoneyDiscount", COleCurrency(0, 0));
			strSaleName = AdoFldString(rsSale, "Name", "");
			nDiscountCategoryID = AdoFldLong(rsSale, "DiscountCategoryID", -1);
			return TRUE;
		}
		else {
			return FALSE;
		}

	}NxCatchAll("Error in CBillingDlg::GetServiceItemSaleDiscount");
	return FALSE;
}

// (j.jones 2011-10-04 09:20) - PLID 45799 - changed charge lists to a DL2
void CBillingDlg::OnEditingStartingQuoteList(LPDISPATCH lpRow, short nCol, VARIANT FAR* pvarValue, BOOL FAR* pbContinue)
{
	try {

		IRowSettingsPtr pRow(lpRow);
		if (pRow == NULL) {
			return;
		}

		switch (nCol) {

			// (j.gruber 2007-08-24 14:53) - PLID 24632 - discount and price permissions
			// (j.gruber 2009-03-06 12:36) - PLID 33351 - take out discount fields
			/*case QUOTE_COLUMN_PERCENT_OFF:
				if (!CheckCurrentUserPermissions(bioQuotePercentOff, sptWrite)) {
				*pbContinue = FALSE;
				m_QuoteList->StopEditing(FALSE);
				return;
				}
				break;

				case QUOTE_COLUMN_DISCOUNT:
				if (!CheckCurrentUserPermissions(bioQuoteAmountOff, sptWrite)) {
				*pbContinue = FALSE;
				m_QuoteList->StopEditing(FALSE);
				return;
				}
				break;*/

			case QUOTE_COLUMN_UNIT_COST:
			case QUOTE_COLUMN_UNIT_COST_OUTSIDE_PRACTICE:
				if (!CheckCurrentUserPermissions(bioQuotePrice, sptWrite)) {
					*pbContinue = FALSE;
					m_QuoteList->StopEditing(FALSE);
					return;
				}
				break;
			case QUOTE_COLUMN_TAX_RATE_1:
				// (d.singleton 2012-09-25 10:33) - PLID 50996 added permission to allow editing of tax fields for quote line items
				if (!CheckCurrentUserPermissions(bioQuoteLineTax, sptWrite)) {
					*pbContinue = FALSE;
					m_List->StopEditing(FALSE);
					return;
				}
				break;

			case QUOTE_COLUMN_TAX_RATE_2:
				// (d.singleton 2012-09-25 10:33) - PLID 50996 added permission to allow editing of tax fields for quote line items
				if (!CheckCurrentUserPermissions(bioQuoteLineTax, sptWrite)) {
					*pbContinue = FALSE;
					m_List->StopEditing(FALSE);
					return;
				}
				break;
		}
	}NxCatchAll("Error in CBillingDlg::OnEditingStartingQuoteList");

}


void CBillingDlg::OnSelChangedComboLocation(long nNewSel)
{
	try {

		long nNewLocationID = -1;
		if (nNewSel != -1) {
			nNewLocationID = VarLong(m_LocationCombo->GetValue(nNewSel, 0));
		}

		if (m_nCurLocationID == nNewLocationID) {
			//nothing changed
			return;
		}

		// (j.jones 2011-08-24 08:41) - PLID 44868 - disallow this if any charge
		// is an original or void charge
		if (m_EntryType == 1 && GetBillID() != -1
			&& HasOriginalOrVoidCharge()) {

			MessageBox("At least one charge on this bill has been corrected, and cannot have its location changed.\n\n"
				"If you need to change the location on this bill, you must exit the bill and right click on it in "
				"the Billing tab and choose \"Correct Bill\" to make a new corrected copy.", "Practice", MB_ICONINFORMATION | MB_OK);

			m_LocationCombo->SetSelByColumn(0, m_nCurLocationID);
			return;
		}

		// (j.gruber 2007-09-07 10:47) - PLID 25191
		//check to see if they have permission to change from the current logged in location
		if (m_EntryType == 1 && GetBillID() == -1) {

			if (!(GetCurrentUserPermissions(bioChargeLocation) & (SPT___W_______))) {

				if (!(GetCurrentUserPermissions(bioChargeLocation) & (SPT___W________ANDPASS))) {

					//they don't have write permission, so don't let them change it
					//make sure they are changing it
					if (nNewLocationID != GetCurrentLocationID()) {
						MsgBox("You do not have permission to change the location from the currently logged in location.");

						m_LocationCombo->SetSelByColumn(0, GetCurrentLocationID());
						return;
					}
				}
				else {

					//they have with password, so we'll check when they change it
				}
			}
		}

	}NxCatchAll("Error in CBillingDlg::OnSelChangedComboLocation");
}

// (j.jones 2007-11-13 17:28) - PLID 27988 - PopulateProductToAllocationArray will repopulate
// m_aryProductAllocationInfoCache, each time a bill is opened, even if the patient didn't change
void CBillingDlg::PopulateProductToAllocationArray()
{
	try {

		FreeTrackedAllocations();

		// (j.jones 2007-11-14 09:05) - PLID 27988 - don't waste a recordset if they don't
		// have the Inventory license
		if (!g_pLicense->CheckForLicense(CLicense::lcInv, CLicense::cflrSilent)) {
			return;
		}

		//find all active products on active allocations
		//OR used products on completed allocations that have not been billed
		//(order by completed allocations first, then in order they were created)
		// (j.jones 2008-01-08 09:03) - PLID 28479 - ignore un-billable products
		// (j.jones 2008-03-03 09:04) - PLID 29125 - ignore case histories
		//TES 7/18/2008 - PLID 29478 - Count "To Be Ordered" details as active.
		_RecordsetPtr rs = CreateParamRecordset("SELECT PatientInvAllocationsT.ID, PatientInvAllocationDetailsT.ProductID, "
			"PatientInvAllocationsT.LocationID, LocationsT.Name AS LocationName, "
			"Convert(bit, CASE WHEN PatientInvAllocationsT.Status = {INT} THEN 1 ELSE 0 END) AS Completed "
			"FROM PatientInvAllocationsT "
			"INNER JOIN PatientInvAllocationDetailsT ON PatientInvAllocationsT.ID = PatientInvAllocationDetailsT.AllocationID "
			"INNER JOIN ProductT ON PatientInvAllocationDetailsT.ProductID = ProductT.ID "
			"INNER JOIN ServiceT ON ProductT.ID = ServiceT.ID "
			"INNER JOIN LocationsT ON PatientInvAllocationsT.LocationID = LocationsT.ID "
			"INNER JOIN ProductLocationInfoT ON ProductT.ID = ProductLocationInfoT.ProductID AND ProductLocationInfoT.LocationID = LocationsT.ID "
			"WHERE ServiceT.Active = 1 AND "
			"((PatientInvAllocationsT.Status = {INT} AND PatientInvAllocationDetailsT.Status IN ({INT},{INT})) "
			"OR (PatientInvAllocationsT.Status = {INT} AND PatientInvAllocationDetailsT.Status = {INT} "
			"	AND PatientInvAllocationDetailsT.ID NOT IN (SELECT AllocationDetailID FROM ChargedAllocationDetailsT WHERE ChargeID IN (SELECT ID FROM LineItemT WHERE Deleted = 0)))) "
			"AND PatientInvAllocationsT.PatientID = {INT} AND ProductLocationInfoT.Billable = 1 "
			"AND PatientInvAllocationsT.ID NOT IN (SELECT AllocationID FROM CaseHistoryAllocationLinkT) "
			"GROUP BY PatientInvAllocationsT.ID, PatientInvAllocationDetailsT.ProductID, "
			"PatientInvAllocationsT.LocationID, LocationsT.Name, PatientInvAllocationsT.Status "
			"ORDER BY Convert(bit, CASE WHEN PatientInvAllocationsT.Status = {INT} THEN 1 ELSE 0 END) DESC, PatientInvAllocationsT.ID ASC ",
			InvUtils::iasCompleted, InvUtils::iasActive, InvUtils::iadsActive, InvUtils::iadsOrder, InvUtils::iasCompleted, InvUtils::iadsUsed, m_nPatientID, InvUtils::iasCompleted);
		while (!rs->eof) {

			BOOL bCompleted = AdoFldBool(rs, "Completed");
			long nProductID = AdoFldLong(rs, "ProductID");
			long nAllocationID = AdoFldLong(rs, "ID");
			long nLocationID = AdoFldLong(rs, "LocationID");
			CString strLocationName = AdoFldString(rs, "LocationName");

			//only track one product/allocation/location combination - the earliest active one,
			//so we only reference the first allocation for that patient, with that product,
			//for a given location

			//make sure it doesn't already exist
			BOOL bFound = FALSE;
			for (int i = 0; i < m_aryProductAllocationInfoCache.GetSize() && !bFound; i++) {
				ProductAllocationInfoCache *pInfo = (ProductAllocationInfoCache*)(m_aryProductAllocationInfoCache.GetAt(i));
				if (pInfo && pInfo->nProductID == nProductID && pInfo->nAllocationLocationID == nLocationID) {
					if (pInfo->nAllocationID != nAllocationID) {
						//the same product exists in multiple allocations
						//for the same patient and location, and will be ignored
						pInfo->bExistsInMultiple = TRUE;
						bFound = TRUE;
					}
					else {
						//There would have to be something wrong with our query
						//for this to occur twice in the same recordset with the same
						//Allocation ID. Assert, but don't set the boolean.
						ASSERT(FALSE);
						bFound = TRUE;
					}
				}
			}

			if (!bFound) {
				//add new
				ProductAllocationInfoCache *pInfo = new ProductAllocationInfoCache;
				pInfo->bCompleted = bCompleted;
				pInfo->nProductID = nProductID;
				pInfo->nAllocationID = nAllocationID;
				pInfo->nAllocationLocationID = nLocationID;
				pInfo->strLocationName = strLocationName;
				pInfo->bExistsInMultiple = FALSE;
				m_aryProductAllocationInfoCache.Add(pInfo);
			}

			rs->MoveNext();
		}
		rs->Close();

	}NxCatchAll("Error in CBillingDlg::PopulateProductToAllocationArray");
}

//FindTrackedAllocationWithAvailableProduct checks our m_paryAllocationInfo array to
//see if we have an allocation in memory that has the given product available to be billed,
//and if so, returns it (otherwise returns NULL)
InvUtils::AllocationMasterInfo* CBillingDlg::FindTrackedAllocationWithAvailableProduct(long nProductID)
{
	try {

		for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {
			InvUtils::AllocationMasterInfo *pAllocationMasterInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pAllocationMasterInfo) {

				//Now loop through each detail - look for any allocation
				//that has products that match, and has anything that is billable
				//Remember that they may have released the product we're looking
				//for, and instead used a different product in its place.

				BOOL bHasBillableProducts = FALSE;
				BOOL bHasOurProduct = FALSE;

				//also track whether all instances of our product has been billed,
				//because if so, then we know this allocation can't be what we
				//are looking for (this should be unlikely to occur though)
				BOOL bHasOurProductBeenCompletelyBilled = TRUE;

				for (int j = 0; j < pAllocationMasterInfo->paryAllocationDetailInfo.GetSize(); j++) {

					InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pAllocationMasterInfo->paryAllocationDetailInfo.GetAt(j));

					// (j.jones 2008-01-07 16:46) - PLID 28479 - only check products that are actually billable
					if (pDetail && pDetail->bIsProductBillable) {

						if (pDetail->nProductID == nProductID) {
							//this allocation does have our product in it
							bHasOurProduct = TRUE;

							if (!pDetail->bBilled) {
								bHasOurProductBeenCompletelyBilled = FALSE;
							}
						}

						//is this detail billable?
						if (pDetail->iadsCurrentStatus != InvUtils::iadsReleased && !pDetail->bBilled) {
							//it is not released, and it is not billed, which means it is billable
							bHasBillableProducts = TRUE;
						}
					}
				}

				if (bHasOurProduct && bHasBillableProducts && !bHasOurProductBeenCompletelyBilled) {
					return pAllocationMasterInfo;
				}
			}
		}

	}NxCatchAll("Error in CBillingDlg::FindTrackedAllocationWithAvailableProduct");

	return NULL;
}

//returns a pointer to a ProductAllocationInfoCache object if a product matches for the current location,
//returns NULL if no match, also populates strOtherLocation if at least one other location has an allocation
//for the same product and patient
ProductAllocationInfoCache* CBillingDlg::FindProductAllocationInfoCache(long nProductID, long nLocationID, CString &strOtherLocation)
{
	try {

		//***this should never be called unless FindTrackedAllocationWithAvailableProduct
		//was called first, and didn't return a result

		if (nProductID == -1 || nLocationID == -1) {
			//this function shouldn't have been called without this data
			ASSERT(FALSE);
			strOtherLocation = "";
			return NULL;
		}

		ProductAllocationInfoCache *pInfoToReturn = NULL;

		//find all matching allocations that have not already been loaded into memory,
		//do NOT stop when we find the first one, we can stop if we find one to return
		//and another location though, because at that point we aren't looking for any
		//more information than that
		for (int i = 0; i < m_aryProductAllocationInfoCache.GetSize() && (pInfoToReturn == NULL || strOtherLocation.IsEmpty()); i++) {
			ProductAllocationInfoCache *pInfo = (ProductAllocationInfoCache*)(m_aryProductAllocationInfoCache.GetAt(i));
			if (pInfo) {
				if (pInfo->nProductID == nProductID) {
					//we have a match by the product, what about location?
					if (pInfo->nAllocationLocationID == nLocationID) {
						//this allocation matches completely, but let's make sure it's not
						//already tracked in memory

						BOOL bCanUseThisAllocation = TRUE;

						for (int j = 0; j < m_paryAllocationInfo.GetSize() && bCanUseThisAllocation; j++) {
							InvUtils::AllocationMasterInfo *pAllocationMasterInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(j));
							if (pAllocationMasterInfo && pAllocationMasterInfo->nAllocationID == pInfo->nAllocationID) {
								//ah, this allocation is already in memory, so this function
								//should not attempt to re-use it
								bCanUseThisAllocation = FALSE;
							}
						}

						if (!bCanUseThisAllocation) {
							continue;
						}

						//we can use it, so we'll return this allocation
						if (pInfoToReturn == NULL) {
							pInfoToReturn = pInfo;
						}
						else {
							//we shouldn't have ever loaded a duplicate
							ASSERT(FALSE);
						}
					}
					else {
						//it's not a matching location, so let's track that location name
						strOtherLocation = pInfo->strLocationName;

						//we don't care if multiple locations match, we just
						//want to give the user the name of one that matches
					}
				}
			}
		}

		return pInfoToReturn;

	}NxCatchAll("Error in CBillingDlg::FindProductAllocationInfoCache");

	strOtherLocation = "";
	return NULL;
}

// (j.jones 2007-11-14 12:47) - PLID 27988 - FreeTrackedAllocations clears the m_paryAllocationInfo array safely,
// and the m_aryProductAllocationInfoCache array
void CBillingDlg::FreeTrackedAllocations()
{
	try {

		int i = 0;

		for (i = m_aryProductAllocationInfoCache.GetSize() - 1; i >= 0; i--) {
			ProductAllocationInfoCache *pInfo = (ProductAllocationInfoCache*)(m_aryProductAllocationInfoCache.GetAt(i));
			delete pInfo;
		}
		m_aryProductAllocationInfoCache.RemoveAll();

		for (i = m_paryAllocationInfo.GetSize() - 1; i >= 0; i--) {
			InvUtils::AllocationMasterInfo *pAllocationMasterInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			InvUtils::FreeAllocationMasterInfoObject(pAllocationMasterInfo);
		}
		m_paryAllocationInfo.RemoveAll();

	}NxCatchAll("Error in CBillingDlg::FreeTrackedAllocations");
}

// (j.jones 2007-11-14 13:57) - PLID 27988 - checks our m_paryAllocationInfo array to see
// if we have an allocation in memory that matches the passed in ID, and if so, returns it
// (otherwise returns NULL)
InvUtils::AllocationMasterInfo* CBillingDlg::FindTrackedAllocationInfoByID(long nAllocationID)
{
	try {

		for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {
			InvUtils::AllocationMasterInfo *pAllocationMasterInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pAllocationMasterInfo->nAllocationID == nAllocationID) {
				//found it!
				return pAllocationMasterInfo;
			}
		}

	}NxCatchAll("Error in CBillingDlg::FindTrackedAllocationInfoByID");

	return NULL;
}

// (j.jones 2007-11-14 14:09) - PLID 27988 - CheckProductAgainstAllocations is the master function
// that will take a product ID and name, find any active allocations for that patient that use that
// product, make the user select the product from the allocation, and return a new quantity and/or
// ChargedProductItemListID, if they are updated by the allocation.
// Returns a ProductAllocationReturnValue enum to tell the caller how to proceed, either
// add the allocated product, add the product normally, or cancel adding the product.
//TES 7/16/2008 - PLID 27983 - Added an optional list of ProductItemIDs to pre-fill as "used" on the allocation.
ProductAllocationReturnValue CBillingDlg::CheckProductAgainstAllocations(long &nProductID, CString &strProductName, double &dblQuantity, long &nChargedProductItemListID, long &nChargedAllocationDetailListID, OPTIONAL IN CArray<long, long> *parInitialProductItemIDs /*= NULL*/)
{
	try {

		//don't do anything if this is a quote
		if (m_EntryType != 1) {
			return arvAddNormally;
		}

		//we need a real product ID and location ID (uses the bill location)
		if (nProductID == -1 && m_nCurLocationID == -1) {
			ASSERT(FALSE);
			return arvAddNormally;
		}

		if (m_nCurLocationID == -1) {
			ASSERT(FALSE);
			return arvAddNormally;
		}

		//check to see if the product is in an allocation

		InvUtils::AllocationMasterInfo *pInfo = NULL;
		ProductAllocationInfoCache *pInfoCache = NULL;

		//first see if the product is in an allocation that we have already modified,
		//but have not completely marked as billed

		pInfo = FindTrackedAllocationWithAvailableProduct(nProductID);
		if (pInfo) {
			//it's available on an allocation we've already opened, so tell the user this
			CString str;
			str.Format("The product '%s' exists in an inventory allocation that you have already started adding to this bill.\n\n"
				"On the following screen, you may confirm that you are using the product that was previously allocated.", strProductName);
			AfxMessageBox(str);
		}
		else {
			//there is no available tracked allocation, so try our cache

			CString strOtherLocation = "";
			pInfoCache = FindProductAllocationInfoCache(nProductID, m_nCurLocationID, strOtherLocation);
			if (pInfoCache == NULL && !strOtherLocation.IsEmpty()) {
				//there is no matching allocation, but another location has one
				CString str;
				str.Format("The product '%s' was found in an allocation for this patient for the '%s' location.\n"
					"You may wish to create a bill for %s instead if you wish to use that allocation.\n\n"
					"The product will continue to be billed normally.",
					strProductName, strOtherLocation, strOtherLocation);
				AfxMessageBox(str);
				//let them continue on normally, they can decide what to do themselves
				return arvAddNormally;
			}
		}

		if (pInfo == NULL && pInfoCache == NULL) {
			//there is no allocation at all that we can use
			return arvAddNormally;
		}
		if (pInfo == NULL && pInfoCache) {
			//it is in an allocation for this location, but it is not being tracked yet

			//first check and see if the product existed in another allocation
			//for this patient and location, and if so, warn the user accordingly
			CString str;
			if (pInfoCache->bExistsInMultiple) {
				str.Format("The product '%s' exists in multiple inventory allocations for this patient.\n"
					"The earliest allocation%s will be used.\n\n"
					"On the following screen, you may confirm that you are using the product that was previously allocated.", strProductName, pInfoCache->bCompleted ? " that has been completed" : "");
			}
			else {
				str.Format("The product '%s' exists in an inventory allocation for this patient.\n\n"
					"On the following screen, you may confirm that you are using the product that was previously allocated.", strProductName);
			}
			AfxMessageBox(str);

			//check and see if we're already tracking this allocation object,
			//and if so, access that (pInfo will be NULL if not found)
			pInfo = FindTrackedAllocationInfoByID(pInfoCache->nAllocationID);
		}

		// (j.jones 2008-06-11 15:18) - PLID 28379 - moved into a modular function
		long nUntrackedAllocationID = -1;
		if (pInfoCache) {
			nUntrackedAllocationID = pInfoCache->nAllocationID;
		}
		//TES 7/16/2008 - PLID 27983 - Pass in our array of pre-selected product items
		return LaunchAllocationScreen(nProductID, strProductName, dblQuantity, nChargedProductItemListID, nChargedAllocationDetailListID, pInfo, nUntrackedAllocationID, -1, parInitialProductItemIDs);

	}NxCatchAll("Error in CBillingDlg::CheckProductAgainstAllocations");

	return arvAddNormally;
}

// (j.jones 2007-11-15 13:58) - PLID 27988 - run through all allocations we have opened,
// if any still have active products then we need to mark them as used or released
BOOL CBillingDlg::ForceResolveAllAllocations()
{
	try {

		//first see if we have any allocations open
		if (m_paryAllocationInfo.GetSize() == 0) {
			//nope!
			return TRUE;
		}

		//now run through all allocations, and if any of them have items
		//that have not been marked as Used or Returned, force the user
		//to finish up those allocations

		//also if any allocations are completed but have used items that
		//aren't billed, see if they want to bill those allocations

		//if we have allocations that are all active, and not partially
		//complete, we will skip them silently

		BOOL bSomeNotResolved = FALSE;

		for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {

			InvUtils::AllocationMasterInfo *pInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pInfo) {

				//now check the details on this allocation object
				BOOL bFoundComplete = FALSE;
				BOOL bFoundUsedButUnbilled = FALSE;
				BOOL bFoundActive = FALSE;

				for (int j = 0; j < pInfo->paryAllocationDetailInfo.GetSize(); j++) {

					InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pInfo->paryAllocationDetailInfo.GetAt(j));
					if (pDetail) {
						//check and see if it is still active
						//TES 7/18/2008 - PLID 29478 - Count "To Be Ordered" details as active.
						if (pDetail->iadsCurrentStatus == InvUtils::iadsActive || pDetail->iadsCurrentStatus == InvUtils::iadsOrder) {
							bFoundActive = TRUE;
						}
						else {
							bFoundComplete = TRUE;
						}

						//see if there are unbilled used items (but not if
						//we've shown the resolution screen once before)
						// (j.jones 2008-01-07 16:46) - PLID 28479 - only check products that are actually billable
						if (pDetail->iadsCurrentStatus == InvUtils::iadsUsed && pDetail->bIsProductBillable && !pDetail->bBilled && !pInfo->bHadResolutionAlready) {
							bFoundUsedButUnbilled = TRUE;
							break;
						}
					}
				}

				//we will skip if we only have active items
				if (bFoundActive && !bFoundComplete) {
					continue;
				}

				if ((bFoundActive && bFoundComplete) || bFoundUsedButUnbilled) {
					//at least one detail in this allocation is Active, or
					//used & unbilled, so the allocation must be resolved properly

					//temporarily disable barcodes in billing
					DisableBarcoding();

					CInvAllocationUsageDlg dlg(this);

					//pass in our memory object
					dlg.SetAllocationInfo(pInfo);

					//they can't save the dialog without completing the allocation
					dlg.m_bForceCompletion = TRUE;

					//tell the dialog it's being called by the bill
					dlg.m_bIsCompletedByBill = TRUE;

					//we are going to be responsible for saving the changes,
					//not the allocation usage dialog
					dlg.m_bSaveToData = FALSE;

					if (dlg.DoModal() == IDOK) {

						//now handle when multiple products are selected, and new charges are needed

						//track arrays of all unique products we're adding
						CArray<long, long> aryProductIDs;

						//track maps of allocation detail lists and product item lists per product
						CMap<long, long, long, long> mapAllocationDetailListIDToProductID;
						CMap<long, long, long, long> mapProductItemListIDToProductID;

						//track a quantity map
						CMap<long, long, double, double> mapQuantityToProductID;

						int k = 0;
						for (k = 0; k < dlg.m_paryDetailsBilled.GetSize(); k++) {

							InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(dlg.m_paryDetailsBilled.GetAt(k));
							if (pDetail) {

								long nProductID = pDetail->nProductID;

								//add to our list if not already in it
								BOOL bFound = FALSE;
								for (int x = 0; x < aryProductIDs.GetSize() && !bFound; x++) {
									if (aryProductIDs.GetAt(x) == nProductID) {
										//already have it
										bFound = TRUE;
									}
								}

								if (!bFound) {
									//add to our product list
									aryProductIDs.Add(nProductID);
									//add to our quantity map
									mapQuantityToProductID.SetAt(nProductID, pDetail->dblCurQuantity);
								}
								else {
									//increment our quantity map
									double dblQuantity = 1.0;
									mapQuantityToProductID.Lookup(nProductID, dblQuantity);
									dblQuantity += pDetail->dblCurQuantity;
									mapQuantityToProductID.SetAt(nProductID, dblQuantity);
								}

								//track this detail ID - add it to an existing or new list
								long nChargedAllocationDetailListID = -1;
								mapAllocationDetailListIDToProductID.Lookup(nProductID, nChargedAllocationDetailListID);
								if (nChargedAllocationDetailListID == -1) {
									nChargedAllocationDetailListID = NewChargedAllocationDetailListID();
									mapAllocationDetailListIDToProductID.SetAt(nProductID, nChargedAllocationDetailListID);
								}
								CDWordArray dwAllocationDetailIDs;
								dwAllocationDetailIDs.Add(pDetail->nDetailID);
								AddToChargedAllocationDetailsArray(-2, nChargedAllocationDetailListID, dwAllocationDetailIDs);

								//if a product item, add to our list
								if (pDetail->nProductItemID != -1) {
									long nChargedProductItemListID = -1;
									mapProductItemListIDToProductID.Lookup(nProductID, nChargedProductItemListID);
									if (nChargedProductItemListID == -1) {
										//create a new list if we don't have one
										nChargedProductItemListID = NewChargedProductItemListID();
										mapProductItemListIDToProductID.SetAt(nProductID, nChargedProductItemListID);
									}
									//now add this product item to that list
									CDWordArray dwProductItemIDs;
									dwProductItemIDs.Add(pDetail->nProductItemID);
									AddToChargedProductItemsArray(-2, nChargedProductItemListID, dwProductItemIDs);
								}
							}
						}

						//now add these products as new charges - one charge per product,
						//don't bother adding to existing charges (we may end up changing
						//this in the future, but for now in most cases it should not exist
						//already anyways)

						//we have to access data for the default price, so generate a list of IDs
						CString strProductIDs;
						for (k = 0; k < aryProductIDs.GetSize(); k++) {

							long nProductID = aryProductIDs.GetAt(k);
							if (!strProductIDs.IsEmpty()) {
								strProductIDs += ",";
							}
							strProductIDs += AsString(nProductID);
						}

						if (!strProductIDs.IsEmpty()) {

							CString strSql;
							strSql.Format("SELECT ServiceT.ID, ServiceT.Name, ServiceT.Price "
								"FROM ServiceT INNER JOIN ProductT ON ServiceT.ID = ProductT.ID "
								"WHERE ServiceT.ID IN (%s)", strProductIDs);
							_RecordsetPtr rs = CreateParamRecordset(strSql);
							while (!rs->eof) {

								long nProductID = AdoFldLong(rs, "ID");
								long nChargedAllocationDetailListID = -1;
								mapAllocationDetailListIDToProductID.Lookup(nProductID, nChargedAllocationDetailListID);
								long nChargedProductItemListID = -1;
								mapProductItemListIDToProductID.Lookup(nProductID, nChargedProductItemListID);
								double dblQuantity = 1.0;
								mapQuantityToProductID.Lookup(nProductID, dblQuantity);

								//now finally add the product
								AddNewExternalProduct(pInfo->nAllocationID, EXT_ALLOCATION, nProductID, AdoFldString(rs, "Name", ""), dblQuantity, AdoFldCurrency(rs, "Price", COleCurrency(0, 0)), -1, nChargedProductItemListID, nChargedAllocationDetailListID);

								rs->MoveNext();
							}
							rs->Close();
						}
					}
					else {
						//rather than return immediately, just track that one didn't resolve itself
						bSomeNotResolved = TRUE;
					}

					//track that we have shown the resolution screen, such that
					//if the allocation is completed, and we only prompted them
					//to bill used products, that we don't do it twise
					pInfo->bHadResolutionAlready = TRUE;

					//re-enable barcodes in billing
					EnableBarcoding();
				}
			}
		}

		//if some were not resolved, return false, otherwise return true
		return !bSomeNotResolved;

	}NxCatchAll("Error in CBillingDlg::ForceResolveAllAllocations");

	return FALSE;
}

// (j.jones 2007-12-12 08:50) - PLID 27988 - commit any allocations we changed to data
BOOL CBillingDlg::SaveTrackedAllocations()
{
	//due to the nature of the billing design, there is no massive batch of
	//sql statements (yet), but in this function we can at least batch save here

	long nAuditTransactionID = -1;
	// (c.haag 2008-02-29 15:49) - PLID 29115 - Support for inventory transactions
	int nInvTodoTransactionID = -1;

	try {
		//first see if we have any allocations open
		if (m_paryAllocationInfo.GetSize() == 0) {
			//nope!
			return TRUE;
		}

		nInvTodoTransactionID = InvUtils::BeginInventoryTodoAlarmsTransaction();

		//save any allocations that we worked on, that were not already completed,
		//and we completed them - this will skip allocations that were not changed
		//at all

		CString strSqlBatch = BeginSqlBatch();

		for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {

			InvUtils::AllocationMasterInfo *pInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pInfo) {

				//run a quick check to make sure the allocation isn't partially completed
				//if so, throw an exception, because the code should not have allowed
				//the bill to save in this case
				int j = 0;
				BOOL bHasActiveDetails = FALSE;
				BOOL bHasCompletedDetails = FALSE;
				for (j = 0; j < pInfo->paryAllocationDetailInfo.GetSize(); j++) {

					InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pInfo->paryAllocationDetailInfo.GetAt(j));
					if (pDetail) {
						//check and see if it is still active
						//TES 7/18/2008 - PLID 29478 - Count "To Be Ordered" details as active.
						if (pDetail->iadsCurrentStatus == InvUtils::iadsActive || pDetail->iadsCurrentStatus == InvUtils::iadsOrder) {
							bHasActiveDetails = TRUE;
						}
						else {
							bHasCompletedDetails = TRUE;
						}
					}

					// (c.haag 2008-02-29 15:51) - PLID 29115 - Add this detail to the inventory TODO transaction
					if (-1 != pDetail->nProductItemID) {
						InvUtils::AddToInventoryTodoAlarmsTransaction(nInvTodoTransactionID, InvUtils::eInvTrans_ProductItemID, pDetail->nProductItemID);
					} else if (-1 != pDetail->nProductID) {
						InvUtils::AddToInventoryTodoAlarmsTransaction(nInvTodoTransactionID, InvUtils::eInvTrans_ProductID, pDetail->nProductID);
					}
				}

				//it's partially completed, which is an error state
				if (bHasActiveDetails && bHasCompletedDetails) {
					ThrowNxException("Tried to save an incomplete allocation!");
				}

				//if allocation is still marked active, we must save it as being completed
				if (bHasCompletedDetails && pInfo->iasStatus == InvUtils::iasActive) {
					// (j.jones 2008-02-19 17:54) - PLID 28948 - this function now takes in a parameter to determine
					// if the allocation should be saved as completed, and in this case we are completing it
					if (!InvUtils::GenerateAllocationSaveSql(TRUE, pInfo, strSqlBatch, nAuditTransactionID)) {

						if (nAuditTransactionID != -1) {
							RollbackAuditTransaction(nAuditTransactionID);
						}
						InvUtils::RollbackInventoryTodoAlarmsTransaction(nInvTodoTransactionID);

						return FALSE;
					}
				}
				else {
					//if already completed, or we're not completing it,
					//ONLY save notes that changed, if any changed

					for (j = 0; j < pInfo->paryAllocationDetailInfo.GetSize(); j++) {

						InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pInfo->paryAllocationDetailInfo.GetAt(j));
						if (pDetail) {

							CString strNotes = pDetail->strNotes;
							CString strOldNotes = pDetail->strOriginalNotes;
							strNotes.TrimLeft();
							strNotes.TrimRight();
							strOldNotes.TrimLeft();
							strOldNotes.TrimRight();

							//only update if the notes changed
							if (strNotes != strOldNotes) {

								//update the detail in data
								AddStatementToSqlBatch(strSqlBatch, "UPDATE PatientInvAllocationDetailsT SET Notes = '%s' WHERE ID = %li", _Q(strNotes), pDetail->nDetailID);

								if (nAuditTransactionID == -1) {
									nAuditTransactionID = BeginAuditTransaction();
								}

								//used for auditing
								CString strOldValue, strDesc = pDetail->strProductName;
								_variant_t varSerialNumber = pDetail->varSerialNum;
								_variant_t varExpDate = pDetail->varExpDate;

								if (varSerialNumber.vt == VT_BSTR) {
									CString str;
									str.Format(", Serial Num: %s", VarString(varSerialNumber));
									strDesc += str;
								}
								if (varExpDate.vt == VT_DATE) {
									CString str;
									str.Format(", Exp. Date: %s", FormatDateTimeForInterface(VarDateTime(varExpDate), NULL, dtoDate));
									strDesc += str;
								}
								if (pDetail->dblOriginalQty != 1.0) {
									//only show the quantity if not 1.0
									CString str;
									str.Format(", Quantity: %g", pDetail->dblOriginalQty);
									strDesc += str;
								}

								strOldValue = strDesc + ", Notes: " + pDetail->strOriginalNotes;
								AuditEvent(pInfo->nPatientID, pInfo->strPatientName, nAuditTransactionID, aeiInvAllocationDetailNotes, pInfo->nAllocationID, strOldValue, strNotes, aepMedium, aetChanged);
							}
						}
					}
				}

			} // if(pInfo) {

		} // for(int i=0;i<m_paryAllocationInfo.GetSize();i++) {

		if (!strSqlBatch.IsEmpty()) {
			ExecuteSqlBatch(strSqlBatch);
		}

		if (nAuditTransactionID != -1) {
			CommitAuditTransaction(nAuditTransactionID);
			nAuditTransactionID = -1;
		}

		// (c.haag 2008-02-29 15:54) - PLID 29115 - Update inventory TODO alarms
		//TES 11/15/2011 - PLID 44716 - This function needs to know if we're in a transaction
		InvUtils::CommitInventoryTodoAlarmsTransaction(nInvTodoTransactionID, false);

		// (j.jones 2008-03-24 16:49) - PLID 29388 - need to update the allocations' linked appointments
		for (i = 0; i < m_paryAllocationInfo.GetSize(); i++) {
			InvUtils::AllocationMasterInfo *pInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pInfo && pInfo->nAppointmentID != -1) {
				TrySendAppointmentTablecheckerForInventory(pInfo->nAppointmentID, TRUE);
			}
		}

		return TRUE;

	}NxCatchAllCall("Error in CBillingDlg::SaveTrackedAllocations",
		if (nAuditTransactionID != -1) {
		RollbackAuditTransaction(nAuditTransactionID);
		}
	// (c.haag 2008-02-29 15:50) - PLID 29115 - Roll back any inventory TODO transaction
	if (nInvTodoTransactionID != -1) {
		InvUtils::RollbackInventoryTodoAlarmsTransaction(nInvTodoTransactionID);
	}
	);

	return FALSE;
}

// (j.jones 2007-11-15 15:05) - PLID 27988 - reworked the barcoding mutex to support reference counting
void CBillingDlg::DisableBarcoding()
{
	//increment our reference count
	m_nDisableBarcodeMutex++;
}

void CBillingDlg::EnableBarcoding()
{
	m_nDisableBarcodeMutex--;

	if (m_nDisableBarcodeMutex < 0) {
		//if negative, make sure we properly reset to zero
		m_nDisableBarcodeMutex = 0;
	}
}

BOOL CBillingDlg::IsBarcodingDisabled()
{
	if (m_nDisableBarcodeMutex < 0) {
		//if negative, we can barcode, but make sure
		//we properly reset to zero
		m_nDisableBarcodeMutex = 0;
	}

	return m_nDisableBarcodeMutex > 0;
}

// (j.jones 2007-12-10 14:57) - PLID 27988 - supported ChargedAllocationDetailListID
void CBillingDlg::AddToChargedAllocationDetailsArray(long nChargeID, long nChargedAllocationDetailListID, CDWordArray &adwAllocationDetailIDs)
{
	try {

		//initialize the list
		ChargedAllocationDetailList *pNewList;

		BOOL bFound = FALSE;

		int i = 0;
		for (i = 0; i < m_aryChargedAllocationDetails.GetSize() && !bFound; i++) {
			if (m_aryChargedAllocationDetails.GetAt(i)->nID == nChargedAllocationDetailListID) {
				bFound = TRUE;
				pNewList = m_aryChargedAllocationDetails.GetAt(i);
			}
		}

		if (!bFound) {
			pNewList = new ChargedAllocationDetailList;
			pNewList->nChargeID = nChargeID;
			pNewList->nID = nChargedAllocationDetailListID;
		}

		//now add the product items
		for (i = 0; i < adwAllocationDetailIDs.GetSize(); i++) {
			AllocationItems *pNewDetail = new AllocationItems;
			pNewDetail->nAllocationDetailID = (long)adwAllocationDetailIDs.GetAt(i);
			pNewDetail->nSaveStatus = CPI_SAVENEW;
			pNewList->paryAllocationItems.Add(pNewDetail);
		}

		if (!bFound) {
			m_aryChargedAllocationDetails.Add(pNewList);
		}

	}NxCatchAll("Error in CBillingDlg::AddToChargedAllocationDetailsArray");
}

long CBillingDlg::LoadIntoChargedAllocationDetailsArray(long nChargeID)
{
	try {

		long nChargedAllocationDetailListID = -1;

		_RecordsetPtr rs = CreateParamRecordset("SELECT AllocationDetailID FROM ChargedAllocationDetailsT WHERE ChargeID = {INT} "
			"AND AllocationDetailID IN (SELECT ID FROM PatientInvAllocationDetailsT WHERE Status <> {INT})", nChargeID, InvUtils::iadsDeleted);

		if (!rs->eof) {

			//initialize the list
			ChargedAllocationDetailList *pNewList = new ChargedAllocationDetailList;
			pNewList->nChargeID = nChargeID;
			nChargedAllocationDetailListID = NewChargedAllocationDetailListID();
			pNewList->nID = nChargedAllocationDetailListID;

			//now add the product items
			while (!rs->eof) {
				long nAllocationDetailID = AdoFldLong(rs, "AllocationDetailID");
				AllocationItems *pNewDetail = new AllocationItems;
				pNewDetail->nAllocationDetailID = nAllocationDetailID;
				pNewDetail->nSaveStatus = CPI_NONE;
				pNewList->paryAllocationItems.Add(pNewDetail);

				rs->MoveNext();
			}

			m_aryChargedAllocationDetails.Add(pNewList);
		}
		rs->Close();

		return nChargedAllocationDetailListID;

	}NxCatchAll("Error in CBillingDlg::LoadIntoChargedAllocationDetailsArray");

	return -1;
}

void CBillingDlg::SaveChargedAllocationDetailsArray(long nChargeID, long nChargedAllocationDetailListID)
{
	//Just like SaveChargedProductItemsArray(), this function is called within a transaction,
	//so do not have a try/catch here and do not have a messagebox!

	//the billing saving is not set up for batch executes / audits, and since this is in a transaction,
	//this new function is NOT going to batch anything in the near term

	// (j.jones 2007-12-11 09:36) - PLID 28043 - but that doesn't mean we can't at least try to be efficient,
	//let's loop through everything and generate audit descriptions, which saves recordsets later

	CMap<long, long, CString, CString> mapAuditDescToDetailID;

	// (j.jones 2008-01-17 10:05) - PLID 28641 - used to cache the notes for each allocation detail
	CMap<long, long, CString, CString> mapNotesToDetailID;

	// (j.jones 2008-01-17 10:03) - PLID 28641 - check the preference to see if we
	// should create a note for this allocation
	// (j.jones 2008-02-18 12:49) - PLID 28991 - now defaults to on
	BOOL bCreateAllocationNote = GetRemotePropertyInt("BillCreateAllocationNotes", 1, 0, "<None>", true) == 1;

	CString strPatientName = GetBillPatientName();

	{
		CString strAllocationDetailIDs;

		//do an initial pass through the loop to grab IDs
		for (int i = 0; i < m_aryChargedAllocationDetails.GetSize(); i++) {
			ChargedAllocationDetailList *pList = (ChargedAllocationDetailList*)m_aryChargedAllocationDetails.GetAt(i);
			if (pList->nID == nChargedAllocationDetailListID) {

				//generate a list of IDs that we will be modifying
				for (int j = 0; j < pList->paryAllocationItems.GetSize(); j++) {
					AllocationItems *pDetail = (AllocationItems*)(pList->paryAllocationItems.GetAt(j));

					CString strAuditDesc = "";
					if (pDetail->nSaveStatus != CPI_NONE) { //ignores items we aren't changing

						if (!strAllocationDetailIDs.IsEmpty()) {
							strAllocationDetailIDs += ",";
						}

						strAllocationDetailIDs += AsString(pDetail->nAllocationDetailID);
					}
				}
			}
		}

		//now, with those IDs, let's generate a map of descriptions, for audit purposes

		//find the description of the product, and product item if needed,
		//from the detail record, for the purposes of auditing (don't bother including qty.)

		CString strSql;
		//IN clauses can't be parameterized, so generate outside of the CreateParamRecordset
		// (j.jones 2008-01-17 10:05) - PLID 28641 - added the Notes field
		strSql.Format("SELECT PatientInvAllocationDetailsT.ID, ServiceT.Name, SerialNum, ExpDate, PatientInvAllocationDetailsT.Notes "
			"FROM PatientInvAllocationDetailsT "
			"INNER JOIN ServiceT ON PatientInvAllocationDetailsT.ProductID = ServiceT.ID "
			"LEFT JOIN ProductItemsT ON PatientInvAllocationDetailsT.ProductItemID = ProductItemsT.ID "
			"WHERE PatientInvAllocationDetailsT.ID IN (%s)", strAllocationDetailIDs);
		_RecordsetPtr rs = CreateParamRecordset(strSql);
		while (!rs->eof) {

			long nDetailID = AdoFldLong(rs, "ID");
			CString strAuditDesc = AdoFldString(rs, "Name", "");

			_variant_t varSerialNumber = rs->Fields->Item["SerialNum"]->Value;
			_variant_t varExpDate = rs->Fields->Item["ExpDate"]->Value;

			if (varSerialNumber.vt == VT_BSTR) {
				CString str;
				str.Format(", Serial Num: %s", VarString(varSerialNumber));
				strAuditDesc += str;
			}
			if (varExpDate.vt == VT_DATE) {
				CString str;
				str.Format(", Exp. Date: %s", FormatDateTimeForInterface(VarDateTime(varExpDate), NULL, dtoDate));
				strAuditDesc += str;
			}

			//update our maps
			mapAuditDescToDetailID.SetAt(nDetailID, strAuditDesc);

			// (j.jones 2008-01-17 10:06) - PLID 28641 - cache the notes field
			if (bCreateAllocationNote) {
				CString strNotes = AdoFldString(rs, "Notes", "");
				mapNotesToDetailID.SetAt(nDetailID, strNotes);
			}

			rs->MoveNext();
		}
		rs->Close();
	}

	//now we have all our to-be-saved detail descriptions in the map,
	//which means we can now re-loop through the memory object and
	//save - the executes and audits can't be batched (yet) but at
	//least we won't have to access data to get the audit information

	for (int i = 0; i < m_aryChargedAllocationDetails.GetSize(); i++) {
		ChargedAllocationDetailList *pList = (ChargedAllocationDetailList*)m_aryChargedAllocationDetails.GetAt(i);
		if (pList->nID == nChargedAllocationDetailListID) {
			//found it, now save
			for (int j = 0; j < pList->paryAllocationItems.GetSize(); j++) {
				AllocationItems *pDetail = (AllocationItems*)(pList->paryAllocationItems.GetAt(j));

				if (pDetail->nSaveStatus == CPI_SAVENEW) {
					//save this item - always an insert

					// (j.jones 2007-12-11 09:37) - PLID 28043 - audit using our map
					// (j.jones 2008-01-17 10:07) - PLID 28641 - moved this lookup to be
					// earlier in the code so the note insert can use this audit value
					CString strNewValue;
					mapAuditDescToDetailID.Lookup(pDetail->nAllocationDetailID, strNewValue);

					if (!bCreateAllocationNote) {
						ExecuteParamSql("INSERT INTO ChargedAllocationDetailsT (ChargeID, AllocationDetailID) VALUES ({INT},{INT})", nChargeID, pDetail->nAllocationDetailID);
					}
					else {
						// (j.jones 2008-01-17 10:04) - PLID 28641 - if we are creating a note for the charge,
						// do it in a bulk SQL insert, and add one note per allocation detail

						CString strAllocNotes, strNote;
						mapNotesToDetailID.Lookup(pDetail->nAllocationDetailID, strAllocNotes);
						strAllocNotes.TrimLeft();
						strAllocNotes.TrimRight();

						strNote.Format("Charged Allocation Product: %s", strNewValue);
						if (!strAllocNotes.IsEmpty()) {
							strNote += ", Notes: ";
							strNote += strAllocNotes;
						}

						//ok now we can do our bulk SQL insert
						CString strSqlBatch;
						AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @nNewID INT");
						// (j.armen 2014-01-31 09:31) - PLID 60568 - Idenitate NoteDataT
						AddStatementToSqlBatch(strSqlBatch,
							"INSERT INTO Notes (PersonID, Date, UserID, Note) "
							"	VALUES ({INT}, GetDate(), {INT}, {STRING})");
						AddStatementToSqlBatch(strSqlBatch, "SET @nNewID = SCOPE_IDENTITY()");

						// (a.walling 2010-08-02 12:11) - PLID 39867 - Moved Notes metadata to NoteInfoT
						AddStatementToSqlBatch(strSqlBatch, "INSERT INTO NoteInfoT "
							"(NoteID, LineItemID) "
							"VALUES (@nNewID, {INT})");

						//and now insert into the ChargedAllocationDetailsT table
						AddStatementToSqlBatch(strSqlBatch, "INSERT INTO ChargedAllocationDetailsT (ChargeID, AllocationDetailID) VALUES ({INT},{INT})");

						//this borrowed logic from ExecuteSqlBatch, but parameterized it
						ExecuteParamSql("BEGIN TRAN \r\n" + strSqlBatch + "COMMIT TRAN \r\n",
							//parameters for the Notes insert (strNote doesn't need a _Q() when parameterized)
							m_nPatientID, GetCurrentUserID(), strNote, nChargeID,
							//paramaters for the ChargedAllocationDetailsT insert
							nChargeID, pDetail->nAllocationDetailID);
					}

					//update so we don't try to save it twice
					pDetail->nSaveStatus = CPI_NONE;

					long nAuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, nAuditID, aeiAddChargedAllocationDetail, nChargeID, "", strNewValue, aepMedium, aetCreated);
				}
				else if (pDetail->nSaveStatus == CPI_DELETE) {

					//***This is not currently used, we do not currently allow disassociating
					//allocations from charges - you have to delete the charge.

					//this status is only used if an allocation detail is explicitly removed from
					//a still-active charge - it is not called when the charge itself is deleted

					//delete this item
					ExecuteParamSql("DELETE FROM ChargedAllocationDetailsT WHERE ChargeID = {INT} AND AllocationDetailID = {INT}", nChargeID, pDetail->nAllocationDetailID);

					// (j.jones 2007-12-11 09:37) - PLID 28043 - audit using our map
					CString strOldValue;
					mapAuditDescToDetailID.Lookup(pDetail->nAllocationDetailID, strOldValue);

					long nAuditID = BeginNewAuditEvent();
					AuditEvent(m_nPatientID, strPatientName, nAuditID, aeiDeleteChargedAllocationDetail, nChargeID, strOldValue, "", aepMedium, aetDeleted);
				}
				else if (pDetail->nSaveStatus == CPI_NONE) {
					//do nothing, this item doesn't need to be saved or deleted
				}
			}

			//now, if we deleted any, remove from the list
			for (int q = pList->paryAllocationItems.GetSize() - 1; q >= 0; q--) {
				AllocationItems *pDetail = (AllocationItems*)(pList->paryAllocationItems.GetAt(q));
				if (pDetail->nSaveStatus == CPI_DELETE) {
					delete pList->paryAllocationItems.GetAt(q);
					pList->paryAllocationItems.RemoveAt(q);
				}
			}

			//last, update the charge ID to use the new charge ID
			pList->nChargeID = nChargeID;
		}
	}
}

void CBillingDlg::DeleteOneFromChargedAllocationDetailsArray(long nChargedAllocationDetailListID)
{
	try {

		for (int i = m_aryChargedAllocationDetails.GetSize() - 1; i >= 0; i--) {
			ChargedAllocationDetailList *pList = (ChargedAllocationDetailList*)(m_aryChargedAllocationDetails.GetAt(i));

			if (pList->nID == nChargedAllocationDetailListID) {

				for (int j = pList->paryAllocationItems.GetSize() - 1; j >= 0; j--) {
					AllocationItems *pItem = (AllocationItems*)(pList->paryAllocationItems.GetAt(j));
					//we should unmark the item as billed from any tracked allocations in memory, if any exist
					TryUnBillTrackedAllocationDetailID(pItem->nAllocationDetailID);
					delete pItem;
				}
				pList->paryAllocationItems.RemoveAll();

				delete pList;
				m_aryChargedAllocationDetails.RemoveAt(i);

				break;
			}
		}

	}NxCatchAll("Error in CBillingDlg::DeleteOneFromChargedAllocationDetailsArray");
}

void CBillingDlg::DeleteAllFromChargedAllocationDetailsArray()
{
	try {

		for (int i = m_aryChargedAllocationDetails.GetSize() - 1; i >= 0; i--) {
			ChargedAllocationDetailList *pList = (ChargedAllocationDetailList*)(m_aryChargedAllocationDetails.GetAt(i));

			for (int j = pList->paryAllocationItems.GetSize() - 1; j >= 0; j--) {
				delete (AllocationItems*)(pList->paryAllocationItems.GetAt(j));
			}
			pList->paryAllocationItems.RemoveAll();

			delete pList;
			m_aryChargedAllocationDetails.RemoveAt(i);
		}

	}NxCatchAll("Error in CBillingDlg::DeleteAllFromChargedAllocationDetailsArray");
}

long CBillingDlg::NewChargedAllocationDetailListID()
{
	//intentionally throws any exceptions to the caller

	long nMaxID = -1;
	if (m_aryChargedAllocationDetails.GetSize() == 0) {
		return 1;
	}
	else {
		for (int i = 0; i < m_aryChargedAllocationDetails.GetSize(); i++) {
			long nID = m_aryChargedAllocationDetails.GetAt(i)->nID;
			if (nID > nMaxID) {
				nMaxID = nID;
			}
		}
		nMaxID++;
		return nMaxID;
	}
}

// (j.jones 2007-12-13 15:05) - PLID 27988 - if the given detail ID is in any allocation
// currently tracked in memory, mark that detail as unbilled - do not change any other status
void CBillingDlg::TryUnBillTrackedAllocationDetailID(long nAllocationDetailID)
{
	try {

		for (int i = 0; i < m_paryAllocationInfo.GetSize(); i++) {
			InvUtils::AllocationMasterInfo *pAllocationMasterInfo = (InvUtils::AllocationMasterInfo*)(m_paryAllocationInfo.GetAt(i));
			if (pAllocationMasterInfo) {
				for (int j = 0; j < pAllocationMasterInfo->paryAllocationDetailInfo.GetSize(); j++) {
					InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(pAllocationMasterInfo->paryAllocationDetailInfo.GetAt(j));
					if (pDetail && pDetail->nDetailID == nAllocationDetailID) {
						//found it! force it to be unbilled, and leave
						pDetail->bBilled = FALSE;
						return;
					}
				}
			}
		}

	}NxCatchAll("Error in CBillingDlg::TryUnBillTrackedAllocationDetailID");
}

// (j.jones 2007-12-14 15:42) - PLID 27988 - checks and sees if we have charges linked
// to allocations, returns TRUE if so
BOOL CBillingDlg::HasChargesLinkedToAllocations()
{
	try {

		if (m_EntryType == 2) {
			//a quote won't have allocations
			return FALSE;
		}

		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			if (VarLong(m_billingItems[i]->ChargedAllocationDetailListID, -1) != -1) {

				//we are linked to an allocation
				return TRUE;
			}
		}

	}NxCatchAll("Error in CBillingDlg::HasChargesLinkedToAllocations");

	return FALSE;
}

// (a.walling 2008-05-05 13:15) - PLID 29897 - Patient name
CString CBillingDlg::GetBillPatientName()
{
	ASSERT(m_pBillingModuleWnd);

	if (m_pBillingModuleWnd)
		return ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetBillPatientName(m_nPatientID);
	else return GetExistingPatientName(m_nPatientID);
}

// (j.jones 2008-05-14 16:51) - PLID 30044 - takes in an array of CStrings for codes,
// and returns TRUE if any charge on the bill (remember, could be a product) has a
// matching ItemCode as any item in the given array
BOOL CBillingDlg::DoesBillHaveMatchingServiceCode(CStringArray &aryCodes)
{
	try {

		for (int i = 0; i < aryCodes.GetSize(); i++) {

			CString strCode = aryCodes.GetAt(i);

			if (strCode.IsEmpty()) {
				continue;
			}

			for (int j = 0; j < (int)m_billingItems.size(); j++) {

				CString strCodeToCheck = VarString(m_billingItems[j]->CPTCode, "");
				if (!strCodeToCheck.IsEmpty() && strCodeToCheck.CompareNoCase(strCode) == 0) {
					//we found a match
					return TRUE;
				}
			}
		}

	}NxCatchAll("Error in CBillingDlg::DoesBillHaveMatchingServiceCode");

	return FALSE;
}

// (j.jones 2008-06-11 15:01) - PLID 28379 - TryBillProductBySerialNumber is called when barcoding,
// it will try to find a product by a serial number, warn if it exists but cannot be used, add to
// the bill if it exists and can be used, or returns silently if not found.
// Returns TRUE if added, FALSE if not added.
BOOL CBillingDlg::TryBillProductBySerialNumber(CString strSerialNumber)
{
	try {

		//let's see if it's a serial number in the system, and whether it's available or not
		//(remember, like all other product item searches, this will still consider items
		//deleted but not saved on this allocation as still being in use)
		long nProductItemID = -1;
		long nProductID = -1;
		CString strProductName = "";
		_variant_t varExpDate = g_cvarNull;
		InvUtils::Barcode_CheckExistenceOfSerialNumberResultEx result;

		//TES 7/7/2008 - PLID 24726 - Pass in the product items that are already on the bill to 
		// Barcode_CheckExistenceofSerialNumber(), so it knows not to return any of them.
		CArray<long, long> arExistingProductItems;
		for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
			ChargedProductItemList *cpiList = (ChargedProductItemList*)m_aryChargedProductItems.GetAt(i);
			for (int j = 0; j < cpiList->ProductItemAry.GetSize(); j++) {
				ProductItems *prodItem = cpiList->ProductItemAry.GetAt(j);
				if (prodItem->SaveStatus != CPI_DELETE) {
					arExistingProductItems.Add(prodItem->ProductItemID);
				}
			}
		}
		//this function will still warn if the product item was saved on a bill,
		//then deleted we haven't saved the deletion yet, this is atypical, and
		//I decided to leave it as-is
		if (InvUtils::Barcode_CheckExistenceOfSerialNumber(strSerialNumber, m_nCurLocationID, FALSE, nProductItemID, nProductID, strProductName, varExpDate, &result, TRUE, TRUE, TRUE, TRUE, &arExistingProductItems)) {

			//make sure it's not already on this bill, but unsaved
				{
					for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
						ChargedProductItemList *cpiList = (ChargedProductItemList*)m_aryChargedProductItems.GetAt(i);
						for (int j = 0; j < cpiList->ProductItemAry.GetSize(); j++) {
							ProductItems *prodItem = cpiList->ProductItemAry.GetAt(j);
							if (prodItem->SaveStatus != CPI_DELETE && prodItem->ProductItemID == nProductItemID) {

								//it IS in our bill, so abort
								CString str;
								str.Format("The serial number %s for product '%s' has already been added to this bill.", strSerialNumber, strProductName);
								AfxMessageBox(str);

								//return true because we did find something
								return TRUE;
							}
						}
					}
				}

			//this product is available, so we need to add it to the bill, skipping the product items screen

			OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)ROW_BILL_A_PRODUCT));
			m_ProductsCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);

			// (j.jones 2014-07-28 09:15) - PLID 56662 - changed to use FindProductRowInComboByServiceID
			long nRow = FindProductRowInComboByServiceID(nProductID, TRUE);
			if (nRow < 0) {
				MessageBox("This product was not able to be added to the bill. Ensure the product is billable for this location.", "Practice", MB_ICONINFORMATION | MB_OK);
				return FALSE;
			}

			if (result.nAllocationID != -1) {

				//don't say we're adding a serial number, because the allocation should,
				//and if the allocation is cancelled, then it may add normally and they
				//need to select a new number
				AddNewProductToBill(nRow, FALSE, result.nAllocationID, result.nAllocationDetailID);

				//we don't care what happened above, we return silently in all cases
				//return true because we did find something
				return TRUE;
			}
			else {

				BOOL bQtyIncrementFailed = TRUE;

				BillingItemPtr pLineItem;

				// If we want to increment any existing amount of the product on a bill,
				// try doing it.
				if (GetRemotePropertyInt("BarcodeAllowQtyIncrement", 1, 0, "<None>", TRUE) == 1) {

					pLineItem = CheckIncreaseDuplicateChargeQuantity(nProductID, TRUE, 1.0, TRUE);
					//code below will add the product to pLineItem, if one was found
				}

				// If we did not increment an existing quantity for a product, then
				// we just add the item to the bill individually.
				if (pLineItem == NULL) {

					if (nRow == -1) {
						//this shouldn't be possible, because Barcode_CheckExistenceOfSerialNumber
						//should have checked if it was inactive or for another location,
						//so ASSERT(), but otherwise silently return if we get here
						ASSERT(FALSE);
						//return true because we did find something
						return TRUE;
					}

					pLineItem = AddNewProductToBill(nRow, TRUE);
				}

				if (pLineItem) {
					//add this serialized information to the list
					long nChargedProductItemListID = pLineItem->ChargedProductItemListID;
					if (nChargedProductItemListID == -1) {
						//add a new list
						nChargedProductItemListID = NewChargedProductItemListID();
					}
					//now add this product item to that list
					CDWordArray dwProductItemIDs;
					dwProductItemIDs.Add((DWORD)nProductItemID);
					AddToChargedProductItemsArray(pLineItem->ChargeID, nChargedProductItemListID, dwProductItemIDs);
					pLineItem->ChargedProductItemListID = nChargedProductItemListID;

					//we're done, so get out of here
					//return true because we did find something
					return TRUE;
				}
				else {
					//should be impossible
					ThrowNxException("Could not add serialized info. to existing item!");
				}
			}
		}

	}NxCatchAll("Error in CBillingDlg::TryBillProductBySerialNumber");

	return FALSE;
}

// (j.jones 2008-06-11 15:09) - PLID 28379 - this functionality is shared by
// CheckProductAgainstAllocations and TryBillProductBySerialNumber
//TES 7/16/2008 - PLID 27983 - This now takes an optional array of ProductItemIDs to pre-fill as Used on the allocation screen.
ProductAllocationReturnValue CBillingDlg::LaunchAllocationScreen(long &nProductID, CString &strProductName, double &dblQuantity, long &nChargedProductItemListID, long &nChargedAllocationDetailListID, InvUtils::AllocationMasterInfo *pInfo /*= NULL*/, long nUntrackedAllocationID /*= -1*/, long nAutoUseDetailID /*= -1*/, OPTIONAL IN CArray<long, long> *parInitialProductItemIDs /*= NULL*/)
{
	//all errors are intentionally thrown to the caller

	BOOL bAlreadyTrackingAllocation = (pInfo != NULL);

	//now handle the allocation usage

	//temporarily disable barcodes in billing
	DisableBarcoding();

	CInvAllocationUsageDlg dlg(this);

	if (pInfo == NULL) {
		//if NULL, the dialog will create a new object based on the ID
		dlg.SetAllocationInfo(nUntrackedAllocationID);
	}
	else {
		//otherwise, pass in the memory object
		dlg.SetAllocationInfo(pInfo);
	}

	//we are not yet forcing the allocation to be completed
	dlg.m_bForceCompletion = FALSE;

	//we are going to be responsible for saving the changes,
	//not the allocation usage dialog
	dlg.m_bSaveToData = FALSE;

	//pass in the product ID we're adding, its name, and the quantity we want to use
	//TES 7/16/2008 - PLID 27983 - Also pass in the pre-selected ProductItemIDs
	dlg.SetInitialProductInfo(nProductID, strProductName, dblQuantity, nAutoUseDetailID, parInitialProductItemIDs);

	//tell the dialog it's being called by the bill
	dlg.m_bIsCompletedByBill = TRUE;

	if (dlg.DoModal() == IDOK) {

		if (dlg.m_paryDetailsBilled.GetSize() == 0) {
			//if we didn't select any details, then ask the user if they still want to add the product				
			//we will also let the dialog clean up the pInfo object *if* we didn't pass one into it
			CString strWarn;
			strWarn.Format("Do you still wish to add the '%s' product to the bill?", strProductName);
			if (IDYES == MessageBox(strWarn, "Practice", MB_ICONQUESTION | MB_YESNO)) {
				//re-enable barcodes in billing
				EnableBarcoding();
				return arvAddNormally;
			}
			else {
				//re-enable barcodes in billing
				EnableBarcoding();
				return arvAbortAdding;
			}
		}

		if (pInfo == NULL) {
			//if we didn't previously have an info object,
			//we will take ownership of the dialog's info object,
			//so tell the dialog not to free its memory
			dlg.m_bFreeInfoObject = FALSE;
			pInfo = dlg.GetAllocationInfo();
		}

		//if we already had the pInfo and we had passed it to the dialog,
		//it would have modified our existing pointer and already known
		//it is not responsible for deleting the object

		if (pInfo == NULL) {
			//at this point, this should be impossible
			ThrowNxException("BillingDlg could not acquire the allocation information!");
		}

		//track the allocation memory object locally
		//if we were not previously tracking it
		if (!bAlreadyTrackingAllocation) {
			m_paryAllocationInfo.Add(pInfo);
		}

		//now run through the details we selected and handle appropriately

		CDWordArray dwProductItemIDs; //tracks any product item IDs we may have selected
		CDWordArray dwAllocationDetailIDs;	//tracks all allocation detail IDs we selected
		double dblNewQuantity = 0.0;

		for (int i = 0; i < dlg.m_paryDetailsBilled.GetSize(); i++) {

			InvUtils::AllocationDetailInfo *pDetail = (InvUtils::AllocationDetailInfo*)(dlg.m_paryDetailsBilled.GetAt(i));

			//Because an initial product ID was set, and force completion is set to false, all the items we receive back
			//will have the same product ID (albeit not necessarily the same as the initial product ID!).
			//If we ever allow the user to complete the allocation while also giving it an initial product ID,
			//this block of code would need to handle adding new charges for the other products, much like we do
			//in ForceResolveAllAllocations()

			if (pDetail->nProductID != nProductID) {
				//we chose a different product ID!
				nProductID = pDetail->nProductID;
				strProductName = pDetail->strProductName;
			}

			//track this detail ID
			dwAllocationDetailIDs.Add(pDetail->nDetailID);

			//if a product item, add to our list
			if (pDetail->nProductItemID != -1) {
				dwProductItemIDs.Add(pDetail->nProductItemID);
			}

			//track the quantity
			dblNewQuantity += pDetail->dblCurQuantity;
		}

		//now track the allocation IDs with the charge
		if (dwAllocationDetailIDs.GetSize() > 0) {
			if (nChargedAllocationDetailListID == -1) {
				nChargedAllocationDetailListID = NewChargedAllocationDetailListID();
			}
			AddToChargedAllocationDetailsArray(-2, nChargedAllocationDetailListID, dwAllocationDetailIDs);
		}

		//and track the product item IDs as usual
		if (dwProductItemIDs.GetSize() > 0) {
			if (nChargedProductItemListID == -1) {
				//create a new list if we don't have one
				nChargedProductItemListID = NewChargedProductItemListID();
			}
			//now add this product item to that list
			AddToChargedProductItemsArray(-2, nChargedProductItemListID, dwProductItemIDs);

			//if we're using a ChargedProductItemList, make sure the new quantity
			//is size of that list
			dblNewQuantity = dwProductItemIDs.GetSize();
		}

		dblQuantity = dblNewQuantity;

		//we only return arvUsingAllocation if they confirmed the allocation, which
		//they would have had to do to get into this block of code
		EnableBarcoding();
		return arvUsingAllocation;
	}
	else {
		//if we didn't select any details, then ask the user if they still want to add the product
		CString strWarn;
		strWarn.Format("Do you still wish to add the '%s' product to the bill?", strProductName);
		if (IDYES == MessageBox(strWarn, "Practice", MB_ICONQUESTION | MB_YESNO)) {
			//re-enable barcodes in billing
			EnableBarcoding();
			return arvAddNormally;
		}
		else {
			//re-enable barcodes in billing
			EnableBarcoding();
			return arvAbortAdding;
		}
	}

	//re-enable barcodes in billing
	EnableBarcoding();
}

// (j.jones 2008-06-20 11:29) - PLID 26153 - added ability to bill an appointment
void CBillingDlg::OnSelChosenComboAppointments(LPDISPATCH lpRow)
{
	try {

		IRowSettingsPtr pRow(lpRow);
		if (pRow == NULL) {
			return;
		}

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return;
		}

		long nApptID = VarLong(pRow->GetValue(0), -1);

		if (nApptID == -1) {
			return;
		}

		// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
		CMaintainFocus maintainFocus(__FUNCTION__);

		// (j.jones 2008-06-24 10:57) - PLID 30457 - warn if the appointment has been billed before,
		// or in the case of quotes whether it has been quoted or billed

		//see if the appointment is referenced on this bill (or quote), and warn
		BOOL bFound = FALSE;
		for (int i = 0; i < (int)m_billingItems.size() && !bFound; i++) {

			_variant_t var = m_billingItems[i]->AppointmentID;
			long nExistingID = -1;
			if (var.vt == VT_I4) {
				nExistingID = VarLong(var);
			}

			if (nExistingID != -1 && nExistingID == nApptID) {
				bFound = TRUE;
			}
		}

		if (bFound) {
			CString str;
			str.Format("This appointment has already been added to this %s. Do you wish to add it again?", m_EntryType == 1 ? "bill" : "quote");

			if (IDNO == MessageBox(str,
				"Practice", MB_ICONQUESTION | MB_YESNO)) {
				return;
			}
		}
		else {
			//if not found, next check and see if the appointment has been billed before,
			//or in the case of quotes whether it has been quoted or billed
			_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 BillsT.ID, BillsT.EntryType "
				"FROM BillsT "
				"INNER JOIN ChargesT ON BillsT.ID = ChargesT.BillID "
				"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
				"WHERE LineItemT.Deleted = 0 AND BillsT.Deleted = 0 "
				"AND ChargesT.AppointmentID = {INT} AND BillsT.EntryType <> {INT} "
				"ORDER BY BillsT.EntryType",
				nApptID, m_EntryType == 1 ? 2 : -1);
			if (!rs->eof) {
				if (m_EntryType == 1) {
					//only warn for bills
					if (IDNO == MessageBox("This appointment has already been billed before. Do you wish to bill it again?",
						"Practice", MB_ICONQUESTION | MB_YESNO)) {
						return;
					}
				}
				else {
					//warn about bills or quotes

					CString strType = "bill";
					if (AdoFldByte(rs, "EntryType") == 2) {
						strType = "quote";
					}

					//this message will warn if it has been billed, if a bill exists,
					//otherwise will warn if it has been quoted, if only a quote exists

					CString str;
					str.Format("This appointment has already been %sed before. Do you wish to quote it again?", strType);

					if (IDNO == MessageBox(str,
						"Practice", MB_ICONQUESTION | MB_YESNO)) {
						return;
					}
				}
			}
		}


		// (f.dinatale 2010-10-06) - PLID 40509 - Refactored and modified the way billing an appointment is handled to allow the date 
		// to be set when an appointment is selected within the a manually created bill.
		// Get the date from the appointment combo. We expect it to be up to date.
		COleDateTime dtAppt = VarDateTime(pRow->Value[1L], g_cvarNull);

		// Set the bill date to the appointment date if the preference is set up to do it
		if (GetRemotePropertyInt("SetNewBillDateToApptDate", 1, 0, "<None>", true)) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->SetDefaultDate(dtAppt);
			m_peditBillDate->SetValue(dtAppt);
			m_peditBillDate->Invalidate();
		}
		else {
			// Defer to whatever date is already assigned to the bill
		}

		// Set all charge dates to the appointmnet date if the preference is set up to do it
		if (GetRemotePropertyInt("SetNewBillChargeDatesToApptDate", 1, 0, "<None>", true)) {
			m_cyDefaultChargeDate = dtAppt;
		}
		else {
			// Defer to whatever date is already assigned to the services
		}

		//before we do anything else, build a comma delimited list of
		//all services linked to all purposes on this appointment,
		//and arrays of CPTs and Products

		CString strServiceIDs;
		CArray<long, long> aryServiceIDs;
		CArray<long, long> aryProductIDs;

		{
			CWaitCursor pWait;

			// (j.gruber 2010-07-20 16:00) - PLID 39739 - changed to support service items linked to appt types			
			// (j.jones 2011-07-22 13:10) - PLID 42059 - Other Procedure appts. now use the procedure's codes, not the appt type codes
			_RecordsetPtr rsServices = CreateParamRecordset("SELECT ServiceT.ID, Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END) AS IsProduct "
				"FROM ServiceT "
				"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
				"INNER JOIN AppointmentPurposeT ON ServiceT.ProcedureID = AppointmentPurposeT.PurposeID "
				"LEFT JOIN AppointmentsT ON AppointmentPurposeT.AppointmentID = AppointmentsT.ID "
				"LEFT JOIN AptTypeT ON AppointmentsT.AptTypeID = AptTypeT.ID "
				"WHERE Active = 1 AND AptTypeT.Category IN (3,4,6) AND AppointmentID = {INT} "
				//"GROUP BY ServiceT.ID, Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END)"
				"UNION "
				"SELECT ServiceT.ID, Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END) AS IsProduct "
				"FROM ServiceT "
				"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
				"INNER JOIN ApptTypeServiceLinkT ON ServiceT.ID = ApptTypeServiceLinkT.ServiceID "
				"LEFT JOIN AptTypeT ON ApptTypeServiceLinkT.AptTypeID = AptTypeT.ID "
				"LEFT JOIN AppointmentsT ON AptTypeT.ID = AppointmentsT.AptTypeID "
				"WHERE Active = 1 AND AptTypeT.Category NOT IN (3,4,6) AND AppointmentsT.ID = {INT} "
				//"GROUP BY ServiceT.ID, Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END)"
				, nApptID, nApptID);
			if (rsServices->eof) {
				//no services!
				rsServices->Close();
				// (j.gruber 2010-07-20 16:39) - PLID 39739 - changed to support linked types
				AfxMessageBox("There are no service codes or inventory items linked to purposes or the type on this appointment.\n"
					"To configure codes and products for an appointment purpose, you can edit the 'Linked Service Codes / Inventory Items' "
					"section of the Procedure tab in the Administrator module. To configure codes and products for an appointment type, click the "
					"'Configure Code' button in the Appointment Type section of the Scheduler Tab in the Administrator Module.");
				return;
			}
			while (!rsServices->eof) {

				//add each ID to our list
				long nServiceID = AdoFldLong(rsServices, "ID");
				BOOL bIsProduct = AdoFldBool(rsServices, "IsProduct");

				if (!strServiceIDs.IsEmpty()) {
					strServiceIDs += ",";
				}
				strServiceIDs += AsString(nServiceID);

				if (bIsProduct) {
					aryProductIDs.Add(nServiceID);
				}
				else {
					aryServiceIDs.Add(nServiceID);
				}

				rsServices->MoveNext();
			}
			rsServices->Close();

			// (j.jones 2008-06-24 13:50) - PLID 30458 - now that we have our potential service IDs, search for quotes/packages
			// that match these service IDs or this appointment ID, and build a list of those quotes
			if (m_EntryType == 1) { //bills only
				_RecordsetPtr rsQuotes = CreateRecordset("SELECT BillsT.ID "
					"FROM BillsT "
					"INNER JOIN ChargesT ON BillsT.ID = ChargesT.BillID "
					"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"WHERE BillsT.Deleted = 0 AND LineItemT.Deleted = 0 "
					"AND BillsT.PatientID = %li AND BillsT.EntryType = 2 "
					"AND (ChargesT.ServiceID IN (%s) OR ChargesT.AppointmentID = %li) "
					"AND BillsT.Active = 1 "
					"GROUP BY BillsT.ID ", m_nPatientID, strServiceIDs, nApptID);
				if (!rsQuotes->eof) {
					if (IDYES == MessageBox("This patient has quotes and/or packages for services related to this appointment. Would you like to bill the related quote instead?",
						"Practice", MB_ICONQUESTION | MB_YESNO)) {

						CString strQuoteIDs;

						if (rsQuotes->GetRecordCount() == 1) {
							//just one, so bill it now
							long nQuoteID = AdoFldLong(rsQuotes, "ID");

							// (j.jones 2012-01-17 16:18) - PLID 47537 - Renamed from OnBillPackage as it was poorly named.
							// This function actually handles billing any quote or any package.
							OnBillQuoteOrPackage(nQuoteID, nApptID);
							//return now, no matter what happens, we're not billing an appt. anymore
							return;
						}
						else {

							while (!rsQuotes->eof) {

								if (!strQuoteIDs.IsEmpty()) {
									strQuoteIDs += ",";
								}
								strQuoteIDs += AsString(AdoFldLong(rsQuotes, "ID"));

								rsQuotes->MoveNext();
							}

							CSingleSelectDlg dlg(this);
							CString strFrom;
							// (j.gruber 2009-03-17 11:58) - PLID 33351 - update discount structure
							strFrom.Format("(SELECT [PatientBillsQ].ID, "
								"[PatientBillsQ].Description + CASE WHEN PackagesT.QuoteID Is Null THEN ' ' ELSE ' (Package) ' END + ' - ' + "
								"Convert(nvarchar, [PatientBillsQ].Date, 1)  + ' - ' + Convert(nvarchar, (CASE WHEN PackagesT.QuoteID Is Not Null THEN PackagesT.CurrentAmount "
								"ELSE Sum(Round(Convert(money,((([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null "
								"THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) "
								"THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))) + (([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) "
								"THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END)*(CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE "
								"CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) THEN 0 ELSE [TotalDiscount] END))*(TaxRate-1)) + "
								"(([Amount]*[Quantity]*(CASE WHEN(CPTMultiplier1 Is Null) THEN 1 ELSE CPTMultiplier1 END)*(CASE WHEN CPTMultiplier2 Is Null THEN 1 ELSE CPTMultiplier2 END)*(CASE WHEN(CPTMultiplier3 Is Null) THEN 1 ELSE CPTMultiplier3 END) "
								"* (CASE WHEN CPTMultiplier4 Is Null THEN 1 ELSE CPTMultiplier4 END)*(CASE WHEN([TotalPercentOff] Is Null) THEN 1 ELSE ((100-Convert(float,[TotalPercentOff]))/100) END)-(CASE WHEN([TotalDiscount] Is Null OR (Amount = 0 AND OthrBillFee > 0)) "
								"THEN 0 ELSE [TotalDiscount] END))*(TaxRate2-1)) )),2)) END)) AS Description "
								"FROM ((SELECT BillsT.* FROM BillsT WHERE BillsT.PatientID = %li AND BillsT.Deleted=0 AND BillsT.Active = 1) AS PatientBillsQ "
								"INNER JOIN (SELECT LineItemT.*, ChargesT.BillID, ChargesT.DoctorsProviders, TotalPercentageQ.TotalPercentOff, TotalDiscountQ.TotalDiscount FROM LineItemT INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID LEFT JOIN (SELECT ChargeID, SUM(Percentoff) as TotalPercentOff FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalPercentageQ ON ChargesT.ID = TotalPercentageQ.ChargeID LEFT JOIN (SELECT ChargeID, SUM(Discount) as TotalDiscount FROM ChargeDiscountsT WHERE DELETED = 0 GROUP BY ChargeID) TotalDiscountQ ON ChargesT.ID = TotalDiscountQ.ChargeID WHERE LineItemT.PatientID = %li AND LineItemT.Deleted=0 AND LineItemT.Type >= 10 AND (ChargesT.OthrBillFee = 0 OR LineItemT.Amount > 0)) AS PatientChargesQ "
								"ON [PatientBillsQ].ID = [PatientChargesQ].BillID) INNER JOIN ChargesT ON [PatientChargesQ].ID = ChargesT.ID LEFT JOIN PackagesT ON PatientBillsQ.ID = PackagesT.QuoteID WHERE (([PatientBillsQ].EntryType)=2) "
								"AND PatientBillsQ.ID IN (%s) "
								"GROUP BY [PatientBillsQ].ID, [PatientBillsQ].Date, [PatientBillsQ].Description, PackagesT.QuoteID, PackagesT.CurrentAmount) AS Q",
								m_nPatientID, m_nPatientID, strQuoteIDs);

							if (IDOK == dlg.Open(strFrom, "", "ID", "Description", "Select a quote or package:")) {
								long nQuoteID = dlg.GetSelectedID();

								//now try to bill this quote

								// (j.jones 2012-01-17 16:18) - PLID 47537 - Renamed from OnBillPackage as it was poorly named.
								// This function actually handles billing any quote or any package.
								OnBillQuoteOrPackage(nQuoteID, nApptID);

								//return now, no matter what happens, we're not billing an appt. anymore
								return;
							}
							else {
								if (IDNO == MessageBox("You have not selected a quote to use. Would you like to continue adding the default services for this appointment?",
									"Practice", MB_ICONQUESTION | MB_YESNO)) {
									return;
								}
							}
						}
					}
				}
				rsQuotes->Close();
			}

			long nTotal = aryServiceIDs.GetSize() + aryProductIDs.GetSize();
			if (nTotal > 1) {
				//we have more than one service, so prompt which services to use
				// (j.armen 2012-06-20 15:23) - PLID 49607 - Provide MultiSelect Sizing ConfigRT Entry
				CMultiSelectDlg dlg(this, "CPTCodeT");

				CString strWhere;
				// (j.jones 2011-03-28 16:27) - PLID 42575 - ignore non-billable CPT codes
				strWhere.Format("ServiceT.ID IN (%s) AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) ", strServiceIDs);

				//we will require at least one service to be selected, otherwise they have to cancel billing the appt.
				if (dlg.Open("ServiceT LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID", strWhere, "ServiceT.ID", "CASE WHEN CPTCodeT.ID Is Null THEN ServiceT.Name ELSE CPTCodeT.Code + ' ' + CPTCodeT.SubCode + ' - ' + ServiceT.Name END", "Select the services / products to use:", 1) == IDOK) {

					CArray<long, long> aryResults;
					dlg.FillArrayWithIDs(aryResults);
					if (aryResults.GetSize() == 0) {
						return;
					}

					//now, in lieu of running recordsets, just compare aryResults to our
					//service code and product lists, remove anything that isn't in aryResults
					int i = 0;
					for (i = aryServiceIDs.GetSize() - 1; i >= 0; i--) {

						BOOL bFound = FALSE;
						for (int j = 0; j < aryResults.GetSize() && !bFound; j++) {
							if (aryResults.GetAt(j) == aryServiceIDs.GetAt(i)) {
								bFound = TRUE;
							}
						}
						//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
						// if we found service code seletion/ now check for warning
						if (bFound && IsCodeSelectedBasedOnWarning(AsLong( aryServiceIDs.GetAt(i)))==FALSE)
						{
							bFound = FALSE;
						}
						else
						{
							// continue
						}

						if (!bFound) {
							//the service is not in the results list, so remove it from our service list
							aryServiceIDs.RemoveAt(i);
						}
					}
					for (i = aryProductIDs.GetSize() - 1; i >= 0; i--) {

						BOOL bFound = FALSE;
						for (int j = 0; j < aryResults.GetSize() && !bFound; j++) {
							if (aryResults.GetAt(j) == aryProductIDs.GetAt(i)) {
								bFound = TRUE;
							}
						}

						if (!bFound) {
							//the product is not in the results list, so remove it from our product list
							aryProductIDs.RemoveAt(i);
						}
					}

					if (aryServiceIDs.GetSize() == 0 && aryProductIDs.GetSize() == 0)
					{
						// they must be remove all codde due to warnig
						return;
					}
					//we should still have at least one service or product
					//ASSERT(aryServiceIDs.GetSize() > 0 || aryProductIDs.GetSize() > 0);
				}
				else {
					//if they cancelled, don't add the appt.
					return;
				}

				//clear out and rebuild our comma-delimited list
				strServiceIDs = "";

				int i = 0;
				for (i = 0; i < aryServiceIDs.GetSize(); i++) {

					if (!strServiceIDs.IsEmpty()) {
						strServiceIDs += ",";
					}

					strServiceIDs += AsString(aryServiceIDs.GetAt(i));
				}
				for (i = 0; i < aryProductIDs.GetSize(); i++) {

					if (!strServiceIDs.IsEmpty()) {
						strServiceIDs += ",";
					}

					strServiceIDs += AsString(aryProductIDs.GetAt(i));
				}
			}
		}

		CWaitCursor pWait;

		//compare against the insurance referral, if we have one
		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

			try {

				//we need to loop through every item being added and compare them against the items 
				//in our referral
				BOOL bOneFailed = FALSE;

				//setup an array for all the items we'll need to be checking in the auth
				CArray<long, long> aryAuthIDs;
				_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
				while (!rsAuth->eof) {
					aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
					rsAuth->MoveNext();
				}
				rsAuth->Close();

				//do not bother checking if services match if the referral has no services in it
				if (aryAuthIDs.GetSize() > 0) {

					for (int i = 0; i < aryServiceIDs.GetSize() && !bOneFailed; i++) {

						long nServiceID = aryServiceIDs.GetAt(i);

						BOOL bFound = FALSE;
						for (int j = 0; j < aryAuthIDs.GetSize() && !bFound; j++) {
							if (aryAuthIDs.GetAt(j) == nServiceID) {
								bFound = TRUE;
							}
						}

						if (!bFound) {
							bOneFailed = TRUE;
						}
					}

					if (bOneFailed) {
						if (MsgBox(MB_YESNO, "At least one service you have selected does not match your insurance authorization.\n"
							"Are you sure you wish to add services from this appointment?") == IDNO) {
							return;
						}
					}
				}

			} NxCatchAll("Error determining authorization status for the appointment.");
		}


		/************************************
		* Bill the Appointment		        *
		*************************************/

		// (j.jones 2010-03-15 15:19) - PLID 37719 - removed unnecessary log
		//LogDetail("Adding appointment services to bill");

		//find the provider linked to the appt. resource, if any, and the location ID
		_RecordsetPtr rsProvider = CreateParamRecordset("SELECT TOP 1 PersonT.ID, AppointmentsT.LocationID "
			"FROM AppointmentsT "
			"LEFT JOIN AppointmentResourceT ON AppointmentsT.ID = AppointmentResourceT.AppointmentID "
			"LEFT JOIN ResourceT ON AppointmentResourceT.ResourceID = ResourceT.ID "
			"LEFT JOIN ResourceProviderLinkT ON ResourceT.ID = ResourceProviderLinkT.ResourceID "
			"LEFT JOIN PersonT ON ResourceProviderLinkT.ProviderID = PersonT.ID "
			"WHERE PersonT.Archived = 0 "
			"AND AppointmentsT.ID = {INT} ", nApptID);
		if (!rsProvider->eof) {

			// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
			// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
			if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 0) {
				long nProviderID = AdoFldLong(rsProvider, "ID", -1);
				if (nProviderID != -1) {
					m_DefaultProvider = nProviderID;
				}
			}
			else {
				m_DefaultProvider = -1;
			}

			long nPOSID = AdoFldLong(rsProvider, "LocationID", -1);

			if (nPOSID != -1 && m_nCurPlaceOfServiceID != nPOSID) {
				//change the place of service				

				// (j.jones 2011-08-24 08:41) - PLID 44868 - call TryChangePlaceOfService,
				// as we might not be allowed to change the place of service
				TryChangePlaceOfService(nPOSID);
			}
		}
		rsProvider->Close();

		//now add the services & products selected earlier
		// (j.jones 2011-03-28 16:27) - PLID 42575 - ignore non-billable CPT codes
		m_rsBill = CreateRecordset("SELECT %li AS ID, ServiceT.ID AS ServiceID, ServiceT.Name AS Description, "
			"Convert(float, 1.0) AS Quantity, ServiceT.Price AS UnitCost, ServiceT.Name AS ServiceName, "
			"NULL AS CPTModifier1, NULL AS CPTModifier2, NULL AS CPTModifier3, NULL AS CPTModifier4, 0 AS DiagCount, "
			"CPTCodeT.Code, Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END) AS IsProduct, "
			"ServiceT.Category,  COALESCE(CptCategoryCountQ.CPTCategoryCount, 0 ) as CategoryCount "
			"FROM ServiceT "
			"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
			"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
			"LEFT JOIN "
			"	( Select ServiceID, COUNT( DISTINCT ServiceMultiCategoryT.CategoryID ) as CPTCategoryCount "
			"	FROM ServiceMultiCategoryT "
			"	Group BY ServiceID "
			"	) CptCategoryCountQ On  CptCategoryCountQ.ServiceID = ServiceT.ID "
			"WHERE ServiceT.Active = 1 AND ServiceT.ID IN (%s) "
			"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) ", nApptID, strServiceIDs);

		while (!m_rsBill->eof) {

			long nServiceID = AdoFldLong(m_rsBill, "ServiceID");

			BOOL bIsProduct = AdoFldBool(m_rsBill, "IsProduct", FALSE);

			if (bIsProduct) {
				//Product

				if (!AddNewExternalProduct(nApptID, EXT_APPOINTMENT, nServiceID, AdoFldString(m_rsBill, "ServiceName", ""), 1.0, AdoFldCurrency(m_rsBill, "UnitCost", COleCurrency(0, 0)))) {

					CString strName = AdoFldString(m_rsBill, "ServiceName", "");

					CString str;
					str.Format("The product '%s' was not able to be billed.\n"
						"If you did not manually cancel this item, please ensure that this product\n"
						"is able to be billed to the selected location, is in stock,\n"
						"and that the product has not been made inactive.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}
			else {
				//CPT Code

				if (!AddNewExternalCpt(nApptID, EXT_APPOINTMENT)) {

					CString strName = AdoFldString(m_rsBill, "Code", "") + " - " + AdoFldString(m_rsBill, "ServiceName", "");

					CString str;
					str.Format("The Service Code '%s' was not able to be billed.\n"
						"Please ensure that the Code has not been made inactive.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}

			m_rsBill->MoveNext();
		}

		m_rsBill->Close();

		/////////////////////////////////////////////////////////////////
		// Sort the list, requery it, and recalculate the bill total
		Requery();

		PostChargeAdded();

		// Any allocations we opened, we should be done with them now, so force them to be resolved.
		// But if it returns FALSE, don't worry about it too much here, ValidateChanges will require
		// it before closing.
		if (!ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}

	}NxCatchAll("Error in CBillingDlg::OnSelChosenComboAppointments");
}

//TES 7/1/2008 - PLID 26143 - The caller wants us to apply these payments to the current bill when we save it.
void CBillingDlg::ApplyPaymentIDs(const CDWordArray &dwaPaymentIDs)
{
	m_dwaPaymentIDsToApply.RemoveAll();
	for (int i = 0; i < dwaPaymentIDs.GetSize(); i++) {
		m_dwaPaymentIDsToApply.Add(dwaPaymentIDs[i]);
	}
}


//TES 7/15/2008 - PLID 27983 - Checks whether the given ServiceID is a CPT Code that is linked to Products.  If it is,
// prompts the user for which products to add instead of this code, and adds them.
//TES 7/17/2008 - PLID 27983 - Added bMassAdding, set this to true to tell the code to not force all allocations to be completed,
// it is then the caller's reponsibility to do that once it's finished adding charges.
// (j.jones 2010-11-23 16:13) - PLID 41549 - added nPackageChargeRefID, cyUnitPrice override, and discount info,
// none of which is optional, so callers are forced to denote whether we have this informatio
BOOL CBillingDlg::CheckLinkProducts(long nServiceID, double dDefaultQty, bool bMassAdding, IN COleCurrency *cyUnitPrice, long nPackageChargeRefID,
	long nLoadDiscountFromChargeID, BOOL bLoadDiscountFromSurgery)
{
	//TES 7/15/2008 - PLID 27983 - Does the product have any linked products?
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	if (ReturnsRecordsParam("SELECT ProductID FROM ServiceToProductLinkT WHERE CptID = {INT}", nServiceID)) {
		//TES 7/15/2008 - PLID 27983 - It does, we will prompt the user.
		CSelectLinkedProductsDlg dlg(this);
		//TES 7/15/2008 - PLID 27983 - Give the dialog the information it needs.
		dlg.m_nCptID = nServiceID;
		dlg.m_dDefaultQty = dDefaultQty;
		dlg.m_nLocationID = m_nCurLocationID;
		// (j.jones 2010-11-24 09:46) - PLID 41549 - tell the dialog if this is a package
		if (nPackageChargeRefID != -1) {
			dlg.m_bIsPackage = TRUE;
		}
		if (IDOK == dlg.DoModal()) {
			//TES 7/15/2008 - PLID 27983 - Go through and compile a list of all the ProductItemIDs that they selected.
			CArray<long, long> arProductItemIDs;
			for (int i = 0; i < dlg.m_arProductsToBill.GetSize(); i++) {
				for (int j = 0; j < dlg.m_arProductsToBill[i].arProductItemIDs.GetSize(); j++) {
					arProductItemIDs.Add(dlg.m_arProductsToBill[i].arProductItemIDs[j]);
				}
			}
			//TES 7/15/2008 - PLID 27983 - Now, go through each product they selected.
			for (i = 0; i < dlg.m_arProductsToBill.GetSize(); i++) {
				ProductToBill ptb = dlg.m_arProductsToBill[i];
				if (ptb.arProductItemIDs.GetSize() == 0) {
					//TES 7/15/2008 - PLID 27983 - If they don't have any product items, we can just add this normally.
					//TES 7/17/2008 - PLID 27983 - Pass in false for bMassAdding, regardless of what was passed in to us,
					// because we're (potentially) adding multiple products.
					// (j.jones 2010-11-23 16:25) - PLID 41549 - pass in our nPackageChargeRefID, cyUnitPrice, and discount information
					AddNewProductToBillByServiceID(ptb.nProductID, ptb.nQty, FALSE, FALSE, true,
						cyUnitPrice, nPackageChargeRefID, nLoadDiscountFromChargeID, bLoadDiscountFromSurgery);
				}
				else {
					//TES 7/15/2008 - PLID 27983 - They do have product items.  We need to first check against allocations,
					// prompting the user and pre-filling the product items they selected as "Used", then we can add the product.
					double dblQty = (double)ptb.arProductItemIDs.GetSize();
					long nChargedProductItemListID = -1;
					long nChargedAllocationDetailListID = -1;
					//TES 7/15/2008 - PLID 27983 - Check for allocations.
					ProductAllocationReturnValue parv = CheckProductAgainstAllocations(ptb.nProductID, dlg.m_strCptName, dblQty, nChargedProductItemListID,
						nChargedAllocationDetailListID, &arProductItemIDs);
					if (parv != arvAbortAdding) {
						//TES 7/15/2008 - PLID 27983 - They want us to add it, so lets do so (use the variables that
						// were filled in by CheckProductAgainstAllocations()
						//TES 7/17/2008 - PLID 27983 - Pass in false for bMassAdding, regardless of what was passed in to us,
						// because we're (potentially) adding multiple products.
						// (j.jones 2010-11-23 16:25) - PLID 41549 - pass in our nPackageChargeRefID, cyUnitPrice, and discount information
						BillingItemPtr pNew = AddNewProductToBillByServiceID(ptb.nProductID, dblQty, TRUE, nChargedAllocationDetailListID != -1, true,
							cyUnitPrice, nPackageChargeRefID, nLoadDiscountFromChargeID, bLoadDiscountFromSurgery);
						if (pNew) {
							if (parv == arvAddNormally) {
								//TES 7/15/2008 - PLID 27983 - It wasn't on an allocation, so just fill in the product item 
								// information from the SelectLinkedProducts dialog
								//add this serialized information to the list
								long nChargedProductItemListID = pNew->ChargedProductItemListID;
								if (nChargedProductItemListID == -1) {
									//add a new list
									nChargedProductItemListID = NewChargedProductItemListID();
								}
								//now add this product item to that list
								CDWordArray dwProductItemIDs;
								for (int nProductItem = 0; nProductItem < ptb.arProductItemIDs.GetSize(); nProductItem++) {
									dwProductItemIDs.Add((DWORD)ptb.arProductItemIDs[nProductItem]);
								}
								AddToChargedProductItemsArray(pNew->ChargeID, nChargedProductItemListID, dwProductItemIDs);
								pNew->ChargedProductItemListID = nChargedProductItemListID;

							}
							else {
								//TES 7/15/2008 - PLID 27983 - They used an allocation, so pull the variables that 
								// CheckProductAgainstAllocations generated.
								pNew->Quantity = dblQty;
								pNew->ChargedProductItemListID = nChargedProductItemListID;
								pNew->ChargedAllocationDetailListID = nChargedAllocationDetailListID;
							}
						}
						else {
							//should be impossible
							ThrowNxException("Could not add serialized info. to existing item!");
						}
					}
				}
			}
		}
		//TES 7/17/2008 - PLID 27983 - If bMassAdding is false, the caller expects us to resolve allocations, and we told
		// the AddNewProduct() functions not to, so do it now.
		if (!bMassAdding) {
			if (!ForceResolveAllAllocations()) {
				AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
			}
		}

		//TES 7/15/2008 - PLID 27983 - We have now handled this product, let our caller know not to do anything else.
		return TRUE;
	}
	else {
		//TES 7/15/2008 - PLID 27983 - We didn't handle this product, let the caller know to proceed.
		return FALSE;
	}
}

// (j.jones 2008-09-12 13:04) - PLID 4423 - added PostSelChosenComboBillTo,
// to differentiate between a manual selection and a code-based selection
void CBillingDlg::PostSelChosenComboBillTo(long nRow)
{
	try {

		CString strColWidths;
		// (d.thompson 2012-08-01) - PLID 51898 - Changed default to 1
		long nRememberWidths = GetRemotePropertyInt("RememberBillingColumnWidths", 1, 0, GetCurrentUserName(), TRUE);
		//(e.lally 2011-08-26) PLID 45210 - Check if we are remembering widths before getting them.
		if (nRememberWidths != 0){
			if (m_EntryType == 2) {
				// (j.jones 2009-12-23 09:19) - PLID 32587 - added bShowInitialValue
				strColWidths = GetRemotePropertyText("DefaultQuoteColumnSizes", GetDefaultQuoteColumnWidths(GetIsMultiUsePackage(), m_checkPackageShowInitialValues.GetCheck()), 0, GetCurrentUserName(), false);
			}
			else {
				strColWidths = GetRemotePropertyText("DefaultBillColumnSizes", GetDefaultBillingColumnWidths(), 0, GetCurrentUserName(), false);
			}
			if (strColWidths.IsEmpty())
				nRememberWidths = 0;
		}

		_RecordsetPtr rs;
		//BOOL boWarnNoResp = FALSE;
		CString str;

		// (j.jones 2010-08-31 09:18) - PLID 39218 - we can default to no resp. chosen, for display purposes
		// treat this as though they selected patient
		long nRespType = 0;
		if (nRow != -1) {
			nRespType = VarLong(m_listBillTo->GetValue(nRow, btcID));
		}

		switch (nRespType) {
			case 0: {
				//Patient responsibility - do not show any insurance info, but do 
				//include tax rates
				if (m_bBillTax1) {
					m_List->GetColumn(COLUMN_TAX_RATE_1)->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_TAX_RATE_1) : 6);
				}
				else {
					m_List->GetColumn(COLUMN_TAX_RATE_1)->PutStoredWidth(0);
				}
				if (m_bBillTax2) {
					m_List->GetColumn(COLUMN_TAX_RATE_2)->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_TAX_RATE_2) : 6);
				}
				else {
					m_List->GetColumn(COLUMN_TAX_RATE_2)->PutStoredWidth(0);
				}
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				m_List->GetColumn(COLUMN_ITEM_TYPE)->PutStoredWidth(0);

				// (j.jones 2005-09-22 09:46) - PLID 17616 - make the InsResp column NOT viewable through column resizing
				IColumnSettingsPtr pCol = m_List->GetColumn(COLUMN_INS_RESP);
				pCol->PutColumnStyle(csVisible | csFixedWidth);

				m_List->GetColumn(COLUMN_INS_RESP)->PutStoredWidth(0);
				m_List->GetColumn(COLUMN_INS_PARTY_ID)->PutStoredWidth(0);

				// (j.jones 2010-09-02 17:35) - PLID 40330 - hide the allowable
				if (m_EntryType == 1) {
					m_List->GetColumn(BILL_COLUMN_ALLOWABLE)->PutStoredWidth(0);
				}
				break;
			}

			default: {

				//primary responsibility - show only the primary resp column
				m_List->GetColumn(COLUMN_TAX_RATE_1)->PutStoredWidth(0);
				m_List->GetColumn(COLUMN_TAX_RATE_2)->PutStoredWidth(0);
				//DRT 4/7/2006 - PLID 11734 - Changed from ProcCode to ItemType
				m_List->GetColumn(COLUMN_ITEM_TYPE)->PutStoredWidth(0);

				// (j.jones 2005-09-22 09:46) - PLID 17616 - make the InsResp column sizeable and editable
				IColumnSettingsPtr pCol = m_List->GetColumn(COLUMN_INS_RESP);
				// (z.manning 2008-06-10 15:32) - PLDI 27392 - Removed csWidthPercent
				pCol->PutColumnStyle(csVisible | csEditable);

				m_List->GetColumn(COLUMN_INS_RESP)->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, COLUMN_INS_RESP) : 74);
				m_List->GetColumn(COLUMN_INS_PARTY_ID)->PutStoredWidth(0);

				//set the InsResp column name to be whatever the current resp type is
				CString str = VarString(m_listBillTo->GetValue(m_listBillTo->GetCurSel(), btcRespName), "");
				pCol->PutColumnTitle(_bstr_t(str));

				//////////////
				//Right here we need to fill in the InsResp and RespType columns, 
				//			since they changed what we're currently looking at.

				//we need to loop through every item currently in the datalist and set it's value with
				//what's in the list for this ins resp

				long nInsuredPartyID = GetCurrentBillToInsuredPartyID();

				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				IRowSettingsPtr pRow = m_List->GetFirstRow();
				while (pRow) {

					//find our current row
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int j = 0;
					for (j = 0; j < (int)m_billingItems.size(); j++) {
						if (m_billingItems[j]->LineID.lVal == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {
							break;
						}
					}

					//i is our current datalist row, j is the index in our billing array
					RPCList *list = m_billingItems[j]->RPCList;

					//now we need to loop (yes, again) through all the items in the RPCList until
					//we find the current responsibility (GetCurrentBillToRespID())
					bool bRespFound = false;
					// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
					int k = 0;
					for (k = 0; k < list->aryRPC.GetSize() && !bRespFound; k++) {
						if (VarLong(list->aryRPC.GetAt(k).InsuredPartyID) == nInsuredPartyID) {
							bRespFound = true;
							k--;	//looping around again will inc it
						}
					}

					//now k is the index (into the RPCList) of the resp we're looking at
					if (bRespFound) {
						pRow->PutValue(COLUMN_INS_RESP, list->aryRPC.GetAt(k).InsAmount);
						pRow->PutValue(COLUMN_INS_PARTY_ID, list->aryRPC.GetAt(k).InsuredPartyID);
					}

					pRow = pRow->GetNextRow();
				}

				// (j.jones 2010-09-02 17:36) - PLID 40330 - show the allowable
				if (m_EntryType == 1) {
					if (nRespType != 0 && m_bBillAllowable) {
						//show
						pCol = m_List->GetColumn(BILL_COLUMN_ALLOWABLE);
						pCol->PutStoredWidth(nRememberWidths ? GetColumnWidth(strColWidths, BILL_COLUMN_ALLOWABLE) : 10);
					}
					else {
						//hide
						pCol = m_List->GetColumn(BILL_COLUMN_ALLOWABLE);
						pCol->PutStoredWidth(0);
					}
				}

				break;
			}

		}	//end switch

		// (j.jones 2010-09-01 11:28) - PLID 40330 - if a bill, reload the allowable values
		// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Don't reload the allowables anymore because they're not based on this dropdown, they're tied to each charge's responsibility


		FillBillList();

		//ResizeColumns();

		// (j.jones 2005-09-14 16:57) - warn about diag. codes, now that we've changed the responsibility
		// do not warn about CPT codes, since they are resp. specific
		if (nRespType != 0) {
			long nInsCoID = GetCurrentBillToInsuranceCoID();
			// (j.gruber 2014-03-24 14:02) - PLID 61529 - refactored for new structure
			OutputInsuranceDiagCodeWarning(nInsCoID);
		}

	}NxCatchAll("Error in CBillingDlg::PostSelChosenComboBillTo");
}


// (j.gruber 2014-03-24 14:03) - PLID 61529 - redid how the warning works
// (j.armen 2014-03-26 08:29) - PLID 61517 - uses vector

// this function handles the diagnosis code/Insurance company warning
//this version just adds all the diagnosis codes on the bill to an array and then sends that array to be checked
//this version is called when changing the responsibility drop down
void CBillingDlg::OutputInsuranceDiagCodeWarning(long nInsCoID)
{
	vector<long> aryDiagIDs;

	for (int i = 0; i < m_arypDiagCodes.GetSize(); i++)
	{
		DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i);

		if (pDiag->nDiagCode9ID != -1)
		{
			aryDiagIDs.push_back(pDiag->nDiagCode9ID);
		}
		if (pDiag->nDiagCode10ID != -1){
			aryDiagIDs.push_back(pDiag->nDiagCode10ID);
		}
	}

	OutputInsuranceDiagCodeWarning(nInsCoID, aryDiagIDs, FALSE);

}

// (j.gruber 2014-03-24 15:01) - PLID 61529 - we need a version that takes an array
// (j.armen 2014-03-26 08:29) - PLID 61517 - uses vector
// this function handles the diagnosis code/Insurance company warning
// you give it the insurance company ID and the array of diagnosis code IDs you want to check
// bWantResponse is to use when you want to ask the user if they want to still add the code, 
// if this is true, it will prompt the user to add the code, otherwise it will just popup the warning
//the return value is whether to add the code or not.

// This is called when changing the repsonsibility on a bill (no repsonse) and adding a diagnosis code (want response)
BOOL CBillingDlg::OutputInsuranceDiagCodeWarning(long nInsCoID, const vector<long>& aryDiagIDs, BOOL bWantResponse)
{
	// (j.armen 2014-03-26 08:29) - PLID 61517 - I was having difficulty with this throwing exceptions.
	// Changed param to a vector so that the values can be seen while debugging
	_RecordsetPtr rsCheck = CreateParamRecordset("SELECT Notes, DiagCodes.CodeNumber as DiagCode "
		" FROM DiagInsNotesT "
		" INNER JOIN DiagCodes on DiagInsNotesT.DiagCodeID = DiagCodes.ID "
		" WHERE DiagCodeID IN ({INTVECTOR}) "
		" AND InsuranceCoID = {INT}",
		aryDiagIDs, nInsCoID);

	BOOL bWarn = FALSE;
	CString strWarn = "For this Insurance Company, the selected Diagnosis Codes have the following warnings:\r\n";

	while (!rsCheck->eof)
	{

		CString strNote = AdoFldString(rsCheck->Fields, "Notes");
		CString strCode = AdoFldString(rsCheck->Fields, "DiagCode");
		CString str;
		str.Format("\r\n%s: %s", strCode, strNote);
		strWarn += str;
		bWarn = TRUE;

		rsCheck->MoveNext();
	}

	if (bWarn)
	{
		if (bWantResponse)
		{
			if (MsgBox(MB_YESNO, "%s\r\n\r\nAre you sure you wish to select this code?", strWarn) == IDNO)
			{
				return FALSE;
			}
			else {
				return TRUE;
			}
		}
		else {

			AfxMessageBox(strWarn);
			return TRUE;
		}
	}

	return TRUE;
}




// (j.jones 2008-11-14 08:41) - PLID 21149 - added UpdateAllChargesWithNewProvider, which will update all charges
// but the original to have the original charge's provider, if they don't already, and check multifees
void CBillingDlg::UpdateAllChargesWithNewProvider(_variant_t varProvider)
{
	try {

		//first update the current line total, using the current m_varBoundItem
		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);
		// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
		CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

		int i = 0, j = 0;

		int nProviderColumn = BILL_COLUMN_PROVIDER;
		if (m_EntryType == 2) {
			nProviderColumn = QUOTE_COLUMN_PROVIDER;
		}

		BOOL bAllProvidersMatch = FALSE;

		//we have to potentially loop more than once, really only incase a multifee re-sorts the list,
		//but just double check no matter what
		while (!bAllProvidersMatch) {

			//set bAllProvidersMatch to true, if we find one that doesn't, set to false
			bAllProvidersMatch = TRUE;

			//loop through all charges in the lis
			// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
			IRowSettingsPtr pRow = m_pList->GetFirstRow();
			while (pRow) {

				// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
				long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));
				if (m_EntryType == 1 && IsOriginalOrVoidCharge(nChargeID)) {
					pRow = pRow->GetNextRow();
					continue;
				}

				//see if the provider is different
				if (pRow->GetValue(nProviderColumn) != varProvider) {

					//if one changes, set bAllProvidersMatch to FALSE, which means
					//when we are done looping, we'll double-check to ensure
					//we didn't skip any rows
					//(this is currently only possible if the multi-fee changes and the list re-sorts)
					bAllProvidersMatch = FALSE;

					//find the matching billing item
					BillingItemPtr pItem;
					for (int j = 0; j < (int)m_billingItems.size() && pItem == NULL; j++) {
						if (VarLong(m_billingItems[j]->LineID) == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {
							pItem = m_billingItems[j];
						}
					}

					if (pItem == NULL) {
						//should be impossible
						ASSERT(FALSE);
						continue;
					}

					// (j.gruber 2009-10-19 10:05) - PLID 35995 - Call the function to update one
					UpdateOneChargeWithNewProvider(pItem, pRow, varProvider);
				}

				pRow = pRow->GetNextRow();
			}
		}

	}NxCatchAll("Error in CBillingDlg::UpdateAllChargesWithNewProvider");
}

// (j.gruber 2009-10-19 10:01) - PLID 35995 - update one charge at a time
void CBillingDlg::UpdateOneChargeWithNewProvider(BillingItemPtr pItem, NXDATALIST2Lib::IRowSettingsPtr pRow, _variant_t varProvider)
{
	try {

		COleCurrency cyInvalid;
		cyInvalid.SetStatus(COleCurrency::invalid);

		// (d.singleton 2012-06-19 14:36) - PLID 48152 auto load the skill code
		int nProviderColumn = BILL_COLUMN_PROVIDER;
		int nSkillColumn = COLUMN_SKILL;
		if (m_EntryType == 2) {
			nProviderColumn = QUOTE_COLUMN_PROVIDER;
			nSkillColumn = QUOTE_COLUMN_SKILL;
		}

		pItem->Provider = varProvider;
		pRow->PutValue(nProviderColumn, varProvider);

		// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
		if (m_EntryType == 1 && VarLong(pItem->ChargeID) != -2
			&& (VarBool(pItem->IsOriginalCharge, FALSE) || VarBool(pItem->IsVoidingCharge, FALSE))) {
			return;
		}

		//now check the multifee value - but only if not a quote
		//(e.lally 2009-08-18) PLID 35267 - Move the check for if it is a CPT code up here. If it is not a CPT code,
		//we can skip the multifee checks.
		// (j.jones 2013-04-12 14:30) - PLID 56250 - multifees are allowed on products now
		if (m_EntryType == 1 &&
			(VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) == ITEM_TYPE_CPT || VarLong(pRow->GetValue(COLUMN_ITEM_TYPE)) == ITEM_TYPE_PRODUCT)) {

			//////////////////////////////////////////////////////////////////
			// Get the fee from the Multi-Fee Scheduling table. If there is none,
			// set it to the default CPT unit cost.
			if (varProvider.vt == VT_I4) {
				BOOL boMultiFeeExists = FALSE;
				BOOL boWarn = TRUE;
				COleCurrency cyUnitCost;
				_variant_t var;
				long InsID;
				long ServiceID;
				_RecordsetPtr nxrs(__uuidof(Recordset));
				var = pRow->GetValue(COLUMN_SERVICE_ID);
				if (var.vt == VT_I4) {
					ServiceID = VarLong(var);
				}
				else {
					ServiceID = -1;
				}

				//find out what the current row's ins co ID is.  This is much simpler in the new setup
				_variant_t varIns = pRow->GetValue(COLUMN_INS_RESP);
				_variant_t varUnit = pRow->GetValue(COLUMN_INS_RESP);
				if ((varIns.vt == VT_CY && VarCurrency(varIns) > COleCurrency(0, 0)) ||
					(varUnit.vt == VT_CY && VarCurrency(varUnit) == COleCurrency(0, 0))) {

					//our amount fits what we're looking for, so lookup the insurance co id

					long nInsuredPartyID = -2;
					var = pRow->GetValue(COLUMN_INS_PARTY_ID);
					if (var.vt == VT_I4 && VarLong(var) >= -1) {
						nInsuredPartyID = VarLong(var);
					}

					// (d.lange 2015-12-01 11:51) - PLID 67127 - Determine the most-primary insurance based on the insurance
					// category for the given insured party
					_RecordsetPtr rsIns = GetMostPrimaryInsCoIDForInsuredPartyRecordset(nInsuredPartyID);
					if (!rsIns->eof) {
						InsID = AdoFldLong(rsIns, "InsuranceCoID");
					}
					else {
						InsID = 0;
					}
				}
				else {
					InsID = 0;
				}

				CString text;

				long LocationID = -1;

				if (m_LocationCombo->GetCurSel() == -1) {
					LocationID = GetCurrentLocationID();
				}
				else {
					LocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
				}

				// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
				long nPOSID = -1;
				if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
					nPOSID = GetCurrentLocationID();
				}
				else {
					nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
				}

				// (j.jones 2008-11-14 09:21) - PLID 32037 - send in the charge code and description,
				// so the multifee warning makes sense
				CString strChargeInfo;
				CString strCPTCode = VarString(pRow->GetValue(BILL_COLUMN_CPT_CODE), "");
				CString strSubCode = VarString(pRow->GetValue(BILL_COLUMN_CPT_SUB_CODE), "");
				CString strFullCode = strCPTCode;
				if (!strCPTCode.IsEmpty() && !strSubCode.IsEmpty()) {
					strFullCode = strCPTCode + " " + strSubCode;
				}
				strFullCode.TrimLeft(); strFullCode.TrimRight();
				// (j.jones 2013-04-12 14:29) - PLID 56250 - You can now have multifees on products, which usually
				// don't have a CPT code. Clean this up if so.
				strChargeInfo.Format("the charge '%s%s%s'", strFullCode, strFullCode.IsEmpty() ? "" : " - ", VarString(pRow->GetValue(BILL_COLUMN_DESCRIPTION), ""));

				// (j.jones 2009-08-10 12:56) - PLID 34841 - properly initialized these variables
				BOOL bHasAllowable = FALSE;
				COleCurrency cyAllowable = COleCurrency(0, 0);

				// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
				cyUnitCost = GetMultiFee(ServiceID, VarLong(pItem->Provider), (InsID != 0) ? InsID : -1, LocationID, nPOSID, VarDateTime(pItem->Date), boMultiFeeExists, boWarn, text, bHasAllowable, cyAllowable, strChargeInfo);

				if ((boMultiFeeExists && boWarn && IDYES == MessageBox(text, "Practice", MB_YESNO)) ||
					(boMultiFeeExists && !boWarn)) {
					//multifee exists, and they DO want to keep it
					pItem->UnitCost = _variant_t(cyUnitCost);
					pRow->PutValue(BILL_COLUMN_UNIT_COST, _variant_t(cyUnitCost));
				}

				// (j.jones 2011-10-31 11:59) - PLID 44941 - if Alberta, we need to change
				// the unit cost based on our modifiers
				// (j.jones 2012-01-23 09:13) - PLID 47695 - this will not change the
				// price unless there are modifiers
				if (UseAlbertaHLINK()) {
					UpdateChargePriceWithAlbertaModifiers(pItem, FALSE);

					// (d.singleton 2012-06-19 14:36) - PLID 48152 auto load the skill code
					long nProviderID = varProvider.lVal;
					CString strSkillCode = "";
					_RecordsetPtr prs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", nProviderID);
					if (!prs->eof) {
						strSkillCode = AdoFldString(prs, "TaxonomyCode", "");
					}
					if (strSkillCode.GetLength() > 4) {
						strSkillCode = "";
					}
					pRow->PutValue(nSkillColumn, _bstr_t(strSkillCode));
				}

				pItem->UnitAllowable = _variant_t(COleCurrency(0, 0));

				if (bHasAllowable) {
					pItem->HasAllowable = _variant_t(VARIANT_TRUE, VT_BOOL);
					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable will be loaded shortly
					pItem->UnitAllowable = _variant_t(COleCurrency(0, 0));
				}
				else {
					pItem->HasAllowable = _variant_t(VARIANT_FALSE, VT_BOOL);
					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
					pItem->TotalAllowable = g_cvarNull;
				}
			}
		}

		// (j.gruber 2009-10-16 12:41) - PLID 35947 Reload the allowable amount
		LoadAllowableColumn(pItem, FALSE);

		// (j.jones 2014-04-30 15:25) - PLID 61837 - the new provider may
		// potentially show additional provider columns
		if (m_EntryType == 1) {
			TryShowChargeProviderColumns(pItem, false);
		}

		AddToModifiedList(VarLong(pRow->GetValue(COLUMN_CHARGE_ID)));	//we need to mark this charge as modified so it saves the provider on editing

		//we also have to update the totals
		m_varBoundItem = pRow->GetValue(COLUMN_LINE_ID);
		if (m_varBoundItem.vt == VT_I4) {
			// (j.gruber 2009-03-05 17:39) - PLID 33351 - changed to use totaldiscount
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);
		}

	}NxCatchAll(__FUNCTION__);

}

// (j.jones 2008-11-14 10:12) - PLID 21149 - HasChargesWithDifferentProvider will take in a provider variant,
// and return TRUE if any charge exists with a different provider
BOOL CBillingDlg::HasChargesWithDifferentProvider(_variant_t varProvider)
{
	//throw exceptions to the caller

	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		if (m_billingItems[i]->Provider != varProvider) {
			return TRUE;
		}
	}

	return FALSE;
}

// (j.jones 2010-11-09 11:07) - PLID 31392 - added HasChargesWithDifferentClaimProvider, takes in a provider variant,
// returns TRUE if any charge exists with a different claim provider (remember it can be -1)
BOOL CBillingDlg::HasChargesWithDifferentClaimProvider(_variant_t varClaimProvider)
{
	//throw exceptions to the caller

	for (int i = 0; i < (int)m_billingItems.size(); i++) {

		//-1 and NULL are equivalent
		_variant_t varExisting = m_billingItems[i]->ClaimProvider;
		long nExisting = -1;
		if (varExisting.vt == VT_I4) {
			nExisting = VarLong(varExisting, -1);
		}
		long nCompare = -1;
		if (varClaimProvider.vt == VT_I4) {
			nCompare = VarLong(varClaimProvider, -1);
		}
		if (nExisting != nCompare) {
			return TRUE;
		}
	}

	return FALSE;
}

// (j.jones 2010-11-09 11:15) - PLID 31392 - added UpdateAllChargesWithNewClaimProvider, which will update all charges
// but the original to have the original charge's claim provider, if they don't already
void CBillingDlg::UpdateAllChargesWithNewClaimProvider(_variant_t varClaimProvider)
{
	try {

		int j = 0;

		//loop through all charges in the list
		// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
		IRowSettingsPtr pRow = m_pList->GetFirstRow();
		while (pRow) {

			//is the claim provider different? (-1 and NULL are equivalent)
			_variant_t varExisting = pRow->GetValue(BILL_COLUMN_CLAIM_PROVIDER);
			long nExisting = -1;
			if (varExisting.vt == VT_I4) {
				nExisting = VarLong(varExisting, -1);
			}
			long nCompare = -1;
			if (varClaimProvider.vt == VT_I4) {
				nCompare = VarLong(varClaimProvider, -1);
			}
			if (nExisting != nCompare) {

				//find the matching billing item
				BillingItemPtr pItem;
				for (int j = 0; j < (int)m_billingItems.size() && pItem == NULL; j++) {
					if (VarLong(m_billingItems[j]->LineID) == VarLong(pRow->GetValue(COLUMN_LINE_ID))) {
						pItem = m_billingItems[j];
					}
				}

				if (pItem == NULL) {
					//should be impossible
					ASSERT(FALSE);
					continue;
				}

				// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
				if (m_EntryType == 1 && VarLong(pItem->ChargeID) != -2
					&& (VarBool(pItem->IsOriginalCharge, FALSE) || VarBool(pItem->IsVoidingCharge, FALSE))) {

					pRow = pRow->GetNextRow();
					continue;
				}

				pItem->ClaimProvider = varClaimProvider;
				pRow->PutValue(BILL_COLUMN_CLAIM_PROVIDER, varClaimProvider);
				//we need to mark this charge as modified so it saves the new claim provider
				AddToModifiedList(VarLong(pRow->GetValue(COLUMN_CHARGE_ID)));

				// (j.jones 2014-04-30 15:25) - PLID 61837 - the new claim provider may
				// potentially change additional provider columns
				if (m_EntryType == 1) {
					TryShowChargeProviderColumns(pItem, false, true, true);
				}
			}

			pRow = pRow->GetNextRow();
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2008-12-15 14:54) - PLID 32431 - added FindCPTRowInComboByServiceID and FindProductRowInComboByServiceID,
// which is a safe way to call FindByColumn on each respective combo, that checks for a row of -2,
// and if -2 is found, wait for the combo to requery and try again. Returns the Row ID,
// and always returns -1 if no row is found.
long CBillingDlg::FindCPTRowInComboByServiceID(long nServiceID, BOOL bAutoSelectRow)
{
	int iCPTRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, bAutoSelectRow);
	if (iCPTRow >= 0) {
		//found a row, return it
		return iCPTRow;
	}
	else if (iCPTRow == sriNoRowYet_WillFireEvent) {
		//wait for the requery to finish, and try again
		m_CPTCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);

		//try again
		iCPTRow = m_CPTCombo->FindByColumn(CPT_COLUMN_SERVICE_ID, nServiceID, 0, bAutoSelectRow);
		if (iCPTRow >= 0) {
			//found a row, return it
			return iCPTRow;
		}
		else if (iCPTRow == sriNoRowYet_WillFireEvent) {
			//talk to Bob, this shouldn't be possible
			ASSERT(FALSE);
		}
	}

	//if not found, always return -1
	return sriNoRow;
}

long CBillingDlg::FindProductRowInComboByServiceID(long nServiceID, BOOL bAutoSelectRow)
{
	// (j.jones 2014-07-28 09:30) - PLID 56662 - if the product combo hasn't begun to requery,
	// do so now, for the current location
	if (m_bProductsCombo == FALSE) {
		RequeryProductCombo();
	}

	int iProductRow = m_ProductsCombo->FindByColumn(PRODUCTS_COLUMN_ID, nServiceID, 0, bAutoSelectRow);
	if (iProductRow >= 0) {
		//found a row, return it
		return iProductRow;
	}
	else if (iProductRow == sriNoRowYet_WillFireEvent) {
		//wait for the requery to finish, and try again
		m_ProductsCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);

		//try again
		iProductRow = m_ProductsCombo->FindByColumn(PRODUCTS_COLUMN_ID, nServiceID, 0, bAutoSelectRow);
		if (iProductRow >= 0) {
			//found a row, return it
			return iProductRow;
		}
		else if (iProductRow == sriNoRowYet_WillFireEvent) {
			//talk to Bob, this shouldn't be possible
			ASSERT(FALSE);
		}
	}

	//if not found, always return -1
	return sriNoRow;
}

// (j.jones 2009-03-24 10:11) - PLID 9729 - adds one of the 4 diag codes to a given list,
// returns TRUE if the order index matches our code index, false if a mismatch
// (j.gruber 2014-02-21 09:07) - PLID 61494 - this function is no longer used, removed
//BOOL CBillingDlg::AddDiagCodeToTrackedList(long nDiagCodeIndex, long nDiagCodeID, NXDATALISTLib::_DNxDataListPtr &pDiagCodeCombo, CArray<DiagCodeInfoPtr, DiagCodeInfoPtr> &aryDiagCodes)


// (j.jones 2009-03-20 09:38) - PLID 9729 - added ClearMoreDiagCodesList
// (b.spivey March 10th, 2014) - PLID 60980 - 
void CBillingDlg::ClearDiagCodesList()
{
	try {

		m_arypDiagCodes.RemoveAll();

	}NxCatchAll(__FUNCTION__);
}


// (j.jones 2009-03-25 10:02) - PLID 33653 - added ClearOldMoreDiagCodesList
// (b.spivey, February 26, 2014) - PLID 60975 - since it's an array of smart pointers the memory will reallocate itself when we remove all 
//	  references to it. However I didn't want to remove the function since it's used in a bunch of places so I just refactored this to remove all. 
void CBillingDlg::ClearOldDiagCodesList()
{
	m_arypOldDiagCodes.RemoveAll();
}

// (b.spivey, Febraury 24, 2014) - PLID 60981 - this function will update the order indexes of diag codes to reflect their position in the array. 
//To be called before updating the UI. 
void CBillingDlg::UpdateDiagCodeList()
{
	try {

		//this list should always be in order, and with
		//an order index greater than 4
		long nLastOrderIndex = 0;

		for (int i = 0; i < m_arypDiagCodes.GetSize(); i++) {
			// (j.gruber 2014-02-21 09:10) - PLID 61494
			DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i); //get

			pDiag->nOrderIndex = i + 1; //update

			m_arypDiagCodes.SetAt(i, pDiag); //set

			//this list should always be in order - but check for that,
			//and ASSERT if that's not true
			if (pDiag->nOrderIndex <= nLastOrderIndex) {
				ASSERT(FALSE);
			}
			else {
				nLastOrderIndex = pDiag->nOrderIndex;
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2009-03-24 17:37) - PLID 9729 - this function will load extra diag codes and display them on the screen
// (b.spivey March 10th, 2014) - PLID 60980 - This function was refactored to load ICD 9 and 10 combinations. 
void CBillingDlg::LoadDiagnosisCodes()
{
	try {

		ClearDiagCodesList();
		// (j.jones 2009-03-25 10:02) - PLID 33653 - also clear the "old" array
		ClearOldDiagCodesList();

		long nBillID = GetBillID();
		if (nBillID == -1) {
			// (j.gruber 2014-02-24 15:40) - PLID 61011 - reflect our blank boxes still
			ReflectDiagCodeArrayToInterface();
			return;
		}

		_RecordsetPtr rsDiag = CreateParamRecordset("SELECT BillDiagCodeT.ID, "
			"BillDiagCodeT.ICD9DiagID, BillDiagCodeT.ICD10DiagID, BillDiagCodeT.OrderIndex, "
			"DiagCodesICD9.CodeNumber as ICD9Code, DiagCodesICD9.CodeDesc  as ICD9CodeDesc, "
			"DiagCodesICD10.CodeNumber as ICD10Code, DiagCodesICD10.CodeDesc  as ICD10CodeDesc "
			"FROM BillDiagCodeT "
			"LEFT JOIN DiagCodes DiagCodesICD9 ON BillDiagCodeT.ICD9DiagID = DiagCodesICD9.ID "
			"LEFT JOIN DiagCodes DiagCodesICD10 ON BillDiagCodeT.ICD10DiagID = DiagCodesICD10.ID "
			"WHERE BillDiagCodeT.BillID = {INT} "
			"ORDER BY BillDiagCodeT.OrderIndex", nBillID);
		while (!rsDiag->eof) {

				{
					// (j.gruber 2014-02-21 09:10) - PLID 61494
					DiagCodeInfoPtr pDiagNew = DiagCodeInfoPtr(new DiagCodeInfo);
					pDiagNew->nID = AdoFldLong(rsDiag, "ID");
					pDiagNew->nDiagCode9ID = AdoFldLong(rsDiag, "ICD9DiagID", -1);
					pDiagNew->nDiagCode10ID = AdoFldLong(rsDiag, "ICD10DiagID", -1);
					pDiagNew->strDiagCode9Code = AdoFldString(rsDiag, "ICD9Code", "");
					pDiagNew->strDiagCode10Code = AdoFldString(rsDiag, "ICD10Code", "");
					pDiagNew->strDiagCode9Desc = AdoFldString(rsDiag, "ICD9CodeDesc", "");
					pDiagNew->strDiagCode10Desc = AdoFldString(rsDiag, "ICD10CodeDesc", "");
					pDiagNew->nOrderIndex = AdoFldLong(rsDiag, "OrderIndex");
					m_arypDiagCodes.Add(pDiagNew);
				}

			// (j.jones 2009-03-25 10:07) - PLID 33653 - now add the same info. to our "old" array,
			// which will later be used for auditing
			{
				// (j.gruber 2014-02-21 09:19) - PLID 61494
				DiagCodeInfoPtr pDiagOld = DiagCodeInfoPtr(new DiagCodeInfo);
				pDiagOld->nDiagCode9ID = AdoFldLong(rsDiag, "ICD9DiagID", -1);
				pDiagOld->nDiagCode10ID = AdoFldLong(rsDiag, "ICD10DiagID", -1);
				pDiagOld->strDiagCode9Code = AdoFldString(rsDiag, "ICD9Code", "");
				pDiagOld->strDiagCode10Code = AdoFldString(rsDiag, "ICD10Code", "");
				pDiagOld->strDiagCode9Desc = AdoFldString(rsDiag, "ICD9CodeDesc", "");
				pDiagOld->strDiagCode10Desc = AdoFldString(rsDiag, "ICD10CodeDesc", "");
				pDiagOld->nOrderIndex = AdoFldLong(rsDiag, "OrderIndex");
				m_arypOldDiagCodes.Add(pDiagOld);
			}

			rsDiag->MoveNext();
		}
		rsDiag->Close();

		//now update the list on the screen
		UpdateDiagCodeList();

		// (j.gruber 2014-02-24 15:40) - PLID 61011 - reflect it in the interface
		ReflectDiagCodeArrayToInterface();

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2009-03-31 10:43) - PLID 33747 - added support for OHIP Premium Codes
//returns TRUE if we processed something and the calling function SHOULD NOT add the code
//(the user may have cancelled adding the premium code altogether)
BOOL CBillingDlg::ProcessOHIPPremiumCode(long nServiceID)
{
	try {

		//if they don't have OHIP enabled, return FALSE so the caller will
		//continue to try and add the code normally
		if (!UseOHIP()) {
			return FALSE;
		}

		int iCPTRow = FindCPTRowInComboByServiceID(nServiceID, FALSE);
		if (iCPTRow == -1) {
			//how was this not found?
			ASSERT(FALSE);

			//try to add normally
			return FALSE;
		}

		BOOL bOHIPPC_UsePercent = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_OHIP_PC_USE_PERCENT), TRUE);
		double dblOHIPPC_Percentage = VarDouble(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_OHIP_PC_PERCENTAGE), 0.0);
		BOOL bOHIPPC_AddMultiple = VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_OHIP_PC_ADD_MULTIPLE), FALSE);
		COleCurrency cyStdFee = VarCurrency(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_PRICE), COleCurrency(0, 0));
		CString strCPTCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_CODE), "");
		CString strCPTSubCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_SUBCODE), "");
		long nCategoryID = VarLong(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_CATEGORY), -1);
		CString strDescription = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NAME), "");

		//see how many other charges are in the list - if zero, warn
		if ((int)m_billingItems.size() == 0) {
			CString strWarn;
			strWarn.Format("The OHIP Premium Code '%s' can not be added to this %s until there are other charges on this %s.",
				strCPTCode, m_EntryType == 1 ? "bill" : "quote", m_EntryType == 1 ? "bill" : "quote");
			AfxMessageBox(strWarn);

			//return TRUE because we did process this code, we just cannot add it
			return TRUE;
		}

		BOOL bAdded = FALSE;

		//now prompt for the codes to link to

		// (j.armen 2012-06-20 15:23) - PLID 49607 - Provide MultiSelect Sizing ConfigRT Entry
		CMultiSelectDlg dlg(this, "CPTCodeT");

		CString strFrom;
		//add each charge to the list, regardless of type, even if it is another premium code
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {

			BillingItemPtr pItem = m_billingItems[i];

			if (!strFrom.IsEmpty()) {
				strFrom += " UNION ";
			}
			CString str, strName;

			if (VarLong(pItem->ItemType) == ITEM_TYPE_CPT) {
				CString strCPT = VarString(pItem->CPTCode) + " " + VarString(pItem->CPTSubCode);
				strCPT.TrimRight();
				strName.Format("%s - %s: %s", strCPT, VarString(pItem->Description), FormatCurrencyForInterface(VarCurrency(pItem->LineTotal)));
			}
			else {
				strName.Format("%s: %s", VarString(pItem->Description), FormatCurrencyForInterface(VarCurrency(pItem->LineTotal)));
			}

			str.Format("SELECT %li AS ID, '%s' AS Name", (long)pItem.get(), _Q(strName));
			strFrom += str;
		}

		strFrom = "(" + strFrom + ") AS ChargesQ";

		CString strWindowDesc;
		strWindowDesc.Format("Select the charges that the premium code '%s' applies to:", strCPTCode);

		std::vector<BillingItemPtr> chargesToUse;

		//we will require at least one charge to be selected, otherwise they have to cancel billing the appt.
		if (dlg.Open(strFrom, "", "ID", "Name", strWindowDesc, 1) == IDOK) {
			CArray<long, long> arynChargesToUse;
			dlg.FillArrayWithIDs(arynChargesToUse);

			chargesToUse.reserve((size_t)arynChargesToUse.GetSize());

			foreach(long n, arynChargesToUse) {
				BillingItem* pItem = (BillingItem*)n;
				chargesToUse.push_back(pItem->shared_from_this());
			}
		}
		else {
			CString strWarn;
			strWarn.Format("The OHIP Premium Code '%s' can not be added to this %s without selecting other charges to apply the premium code to.",
				strCPTCode, m_EntryType == 1 ? "bill" : "quote");
			AfxMessageBox(strWarn);

			//return TRUE because we did process this code, we just cannot add it
			return TRUE;
		}

		//now build an array of prices
		CArray<COleCurrency, COleCurrency> aryPrices;

		//for each charge we linked to, we're either going to add our premium code once per charge,
		//or just once, period
		for (i = 0; i < (int)chargesToUse.size(); i++) {
			BillingItemPtr pItem = chargesToUse[i];

			COleCurrency cyAmtToUse = COleCurrency(0, 0);

			//are we calculating a percentage of each charge?
			if (bOHIPPC_UsePercent) {

				//track the full line total of each charge, not the unit cost
				COleCurrency cyLineTotal = VarCurrency(pItem->LineTotal);

				//reduce by our percent off
				cyAmtToUse = CalculateAmtQuantity(cyLineTotal, (dblOHIPPC_Percentage / 100.0));
				RoundCurrency(cyAmtToUse);
			}
			else {
				//use the standard fee of the premium code we're adding
				cyAmtToUse = cyStdFee;
			}

			//add this price to the list
			if (bOHIPPC_AddMultiple || aryPrices.GetSize() == 0) {
				//if we add for each charge, or have no entries, simply add now
				aryPrices.Add(cyAmtToUse);
			}
			else {
				//we are summing a total value
				COleCurrency cyPrice = aryPrices.GetAt(0);
				cyPrice += cyAmtToUse;
				aryPrices.SetAt(0, cyPrice);
			}
		}

		//get the default provider ID
		long nDefaultProviderID = -1;
		// (j.jones 2011-06-24 15:37) - PLID 22586 - ensure we preserve -2
		_RecordsetPtr rs = CreateParamRecordset("SELECT CASE WHEN ProviderID = -2 THEN ProviderID "
			"WHEN personT.archived = 0 THEN ProviderID ELSE NULL END AS ProviderID "
			"FROM ServiceT "
			"LEFT JOIN personT ON serviceT.ProviderID = PersonT.ID WHERE ServiceT.ID = {INT}", nServiceID);
		if (!rs->eof) {
			nDefaultProviderID = AdoFldLong(rs, "ProviderID", -1);
		}
		rs->Close();

		//and now add the charge for each entry in aryPrices
		for (int x = 0; x < aryPrices.GetSize(); x++) {

			COleCurrency cyUnitCost = (COleCurrency)aryPrices.GetAt(x);

			BillingItemPtr pNew = AppendChargeToList(nDefaultProviderID);

			int iLineID = VarLong(pNew->LineID);

			/* Update description on parent billing module dialog */
			CString str;
			// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
			if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
				// (j.gruber 2012-01-04 11:44) - PLID 46291
				SetBillDescriptionBasedOnResp();
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
				str = GetBillDescription();
				if (str.IsEmpty()) {
					// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
					SetBillDescription(strDescription);
				}
			}

			COleCurrency unit, cyOthrUnit, total;
			unit = cyUnitCost;

			cyOthrUnit = COleCurrency(0, 0);

			//if a quote, our total will include the outside fee
			if (m_EntryType == 2) {
				cyUnitCost += cyOthrUnit;
			}

			////////////////////////////////////////////////////
			// Get Taxable status

			long TaxType = 2;

			//find the insurance company's taxable status
			TaxType = GetInsuranceCoTaxType(GetCurrentBillToInsuredPartyID());

			COleCurrency taxTotal1, taxTotal2;
			double dblTax1 = 1.0, dblTax2 = 1.0;

			//now load the default taxrates

			//if TaxType = 3, we aren't going to charge tax at all
			if (VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_TAXABLE1), FALSE) && TaxType != 3) {
				dblTax1 = 1.0 + (m_fltPracticeTax1 / 100.0);
			}

			taxTotal1 = CalculateTax(cyUnitCost, dblTax1);

			dblTax1 -= 1.0;
			dblTax1 *= 100.0;

			// (j.jones 2009-06-12 16:12) - PLID 34616 - fixed bug where Tax 2 was used when
			// it was turned off, and not when it was turned on
			if (VarBool(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_TAXABLE2), FALSE) && TaxType != 3) {
				dblTax2 = 1.0 + (m_fltPracticeTax2 / 100.0);
			}

			taxTotal2 = CalculateTax(cyUnitCost, dblTax2);

			dblTax2 -= 1.0;
			dblTax2 *= 100.0;

			_variant_t var = cyUnitCost;
			cyUnitCost += taxTotal1;
			cyUnitCost += taxTotal2;
			total = cyUnitCost;

			RoundCurrency(total);
			_variant_t varTotal = total;

			pNew->ChargeID = (long)-2;
			pNew->Quantity = (double)1.0;
			pNew->PackageQtyRemaining = (double)1.0;
			// (j.jones 2009-12-22 16:53) - PLID 32587 - update the original qty. rem. column
			pNew->OriginalPackageQtyRemaining = (double)1.0;
			pNew->ServiceID = nServiceID;
			pNew->CPTCode = _bstr_t(strCPTCode);
			pNew->CPTSubCode = _bstr_t(strCPTSubCode);
			// (j.jones 2015-03-18 14:24) - PLID 64974 - Category is now nullable
			pNew->CPTCategoryID = (nCategoryID > 0 ? (_variant_t)(long)nCategoryID : g_cvarNull);
			pNew->Description = _bstr_t(strDescription);
			pNew->UnitCost = unit;
			pNew->OthrUnitCost = cyOthrUnit;
			pNew->DiscountList = new DiscountList; //this is an empty list, not null
			pNew->TotalDiscount = COleCurrency(0, 0);
			pNew->TaxRate1 = (double)dblTax1;
			pNew->TaxRate2 = (double)dblTax2;
			pNew->LineTotal = total;
			pNew->ItemType = (long)ITEM_TYPE_CPT;
			pNew->Batched = g_cvarTrue;
			pNew->ChargedProductItemListID = (long)-1;
			pNew->ChargedAllocationDetailListID = (long)-1;
			pNew->PointsUsed = COleCurrency(0, 0);

			if (m_EntryType == 1) {
				// (j.jones 2012-04-12 10:00) - PLID 49609 - Add the default claim note, if it exists.
				CString strClaimNote = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_CLAIM_NOTE), "");
				strClaimNote.TrimLeft(); strClaimNote.TrimRight();
				if (strClaimNote.GetLength() > 0) {
					AddNewUnsavedChargeNote(pNew, strClaimNote, TRUE);
				}

				// (j.dinatale 2012-06-13 13:57) - PLID 50959 - NDC defaults
				CString strNDCCode = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFCODE), "");
				double dblNDCQty = VarDouble(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFQTY), 0.0);
				COleCurrency cyNDCUnitPrice = VarCurrency(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITPRICE), g_ccyZero);
				CString strNDCUnitType = VarString(m_CPTCombo->GetValue(iCPTRow, CPT_COLUMN_NDCDEFUNITTYPE), "");

				pNew->NDCCode = strNDCCode;
				pNew->DrugUnitPrice = cyNDCUnitPrice;
				pNew->DrugUnitType = strNDCUnitType;
				pNew->DrugUnitQuantity = dblNDCQty;
			}

			for (i = 0; i < (int)m_billingItems.size(); i++) {
				if (m_billingItems[i]->LineID.lVal == iLineID) {

					// (j.jones 2008-06-11 13:02) - PLID 28379 - track the BillingItem
					BillingItemPtr pLineItem = m_billingItems[i];

					//find the item in the list
					RPCList *list = m_billingItems[i]->RPCList;

					//DRT 6/30/03 - For the same reason as the quotes (6/16/03 note), this does
					//		not need to be added for patient resp, only insurance resp!
					long nInsuredPartyID = GetCurrentBillToInsuredPartyID();
					if (nInsuredPartyID > 0) {

						bool bFoundResp = false;
						// (a.walling 2007-11-05 13:07) - PLID 27974 - VS2008 - for() loops
						int j = 0;
						for (j = 0; j < list->aryRPC.GetSize() && !bFoundResp; j++) {
							if (VarLong(list->aryRPC.GetAt(j).InsuredPartyID) == nInsuredPartyID)
								bFoundResp = true;
						}

						if (bFoundResp) {
							//at this point, var is the amount before tax, and varTotal is the amount with tax
							//use the insurance TaxType to determine which responsibility gets which amount
							if (TaxType == 1)
								UpdateListInsAmount(list, j, varTotal);
							else
								//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
								UpdateListInsAmount(list, j, var);
						}
						else {
							//we're looking at insurance, but there's nothing in our list!  we
							//need to add it
							RespPerCharge rpc;
							rpc.InsuredPartyID = nInsuredPartyID;

							if (TaxType == 1)
								rpc.InsAmount = varTotal;
							else
								//TaxType 2 doesn't include tax for insurance, and TaxType 3 means no tax should exist
								rpc.InsAmount = var;

							// (j.jones 2007-02-27 17:53) - PLID 24844 - for auditing
							rpc.InsuranceCoName = GetCurrentBillToInsuranceCoName();
							rpc.RespTypeName = GetCurrentBillToRespTypeName();

							list->aryRPC.Add(rpc);
						}
					}
				}
			}

			m_varBoundItem = (long)iLineID;

			COleCurrency cyInvalid;
			cyInvalid.SetStatus(COleCurrency::invalid);
			CalculateLineTotal(cyInvalid, cyInvalid, -1, -1, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, cyInvalid);

			////////////////////////////////////////////////////
			if (m_EntryType == 1) {
				FillBillList();
			}
			else {
				FillQuoteList();
			}

			// (j.jones 2011-10-04 16:12) - PLID 45799 - find the row by LineID, and pass it in
			IRowSettingsPtr pRowToSort = m_pList->FindByColumn(COLUMN_LINE_ID, iLineID, m_pList->GetFirstRow(), FALSE);
			InsertRowSorted(pRowToSort, total);

			bAdded = TRUE;
		}

		if (bAdded) {
			CalculateTotal();
			PostChargeAdded();
		}

		return bAdded;

	}NxCatchAll("Error in CBillingDlg::ProcessOHIPPremiumCode");

	//return TRUE if we get an error, so the code won't be added
	return TRUE;
}

// (j.jones 2009-08-12 15:32) - PLID 35179 - added functions to clear our case history arrays
void CBillingDlg::ClearCaseHistoryArray()
{
	//throw exceptions to the caller
	for (int i = m_arypBilledCaseHistories.GetSize() - 1; i >= 0; i--) {
		CaseHistoryInfo* pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);
		if (pCase) {
			delete pCase;
		}
	}
	m_arypBilledCaseHistories.RemoveAll();
}

void CBillingDlg::ClearOldCaseHistoryArray()
{
	//throw exceptions to the caller	

	for (int i = m_arypOldBilledCaseHistories.GetSize() - 1; i >= 0; i--) {
		CaseHistoryInfo* pCase = (CaseHistoryInfo*)m_arypOldBilledCaseHistories.GetAt(i);
		if (pCase) {
			delete pCase;
		}
	}
	m_arypOldBilledCaseHistories.RemoveAll();
}

// (d.thompson 2009-08-18) - PLID 16758 - When the quotes combo requeries, color all the expired rows
void CBillingDlg::RequeryFinishedComboQuote(short nFlags)
{
	try {
		long p = m_QuotesCombo->GetFirstRowEnum();
		LPDISPATCH pDisp = NULL;
		while (p) {
			m_QuotesCombo->GetNextRowEnum(&p, &pDisp);
			NXDATALISTLib::IRowSettingsPtr pRow(pDisp);

			if (VarBool(pRow->GetValue(5))) {
				//Expired quote, set the color
				pRow->PutForeColor(EXPIRED_QUOTE_FORECOLOR);
			}
			pDisp->Release();
		}
	} NxCatchAll(__FUNCTION__);
}

// (d.thompson 2009-08-26) - PLID 33953 - Provides a method for an outside caller to update the service date of all charges
//	 on this bill.
//The bulk of this function's code was taken from the actions of the 'ChangeChargeDatesPrompt' preference
void CBillingDlg::UpdateAllChargesWithNewServiceDate(_variant_t varNewDate)
{
	//ServiceDateTo field, which can be updated also if it's not being used (kept in sync)
	IColumnSettingsPtr pDateToCol = m_pList->GetColumn(COLUMN_SERVICE_DATE_TO);

	//First, update our underlying structure for charges
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr pItem = m_billingItems[i];

		// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
		if (m_EntryType == 1 && VarLong(pItem->ChargeID) != -2
			&& (VarBool(pItem->IsOriginalCharge, FALSE) || VarBool(pItem->IsVoidingCharge, FALSE))) {
			continue;
		}

		// (j.jones 2006-11-29 09:54) - PLID 23684 - if the "service date to" is the same date,
		// or the column for it is size 0, auto-update it
		if (pDateToCol->GetStoredWidth() <= 0 || pItem->ServiceDateTo == pItem->Date) {
			pItem->ServiceDateTo = varNewDate;
		}

		pItem->Date = varNewDate;
		// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Update allowable because the charge date now matters (and it just changed)
		LoadAllowableColumn(pItem, TRUE);
	}

	//Then update the interface to reflect what we've put in 
	// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {

		long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID));

		// (j.jones 2011-08-24 08:41) - PLID 44868 - skip original and void charges
		if (IsOriginalOrVoidCharge(nChargeID)) {
			pRow = pRow->GetNextRow();
			continue;
		}

		// (j.jones 2006-11-29 09:54) - PLID 23684 - if the "service date to" is the same date,
		// or the column for it is size 0, auto-update it
		if (pDateToCol->GetStoredWidth() <= 0 ||
			pRow->GetValue(COLUMN_SERVICE_DATE_TO) == pRow->GetValue(BILL_COLUMN_DATE)) {

			pRow->PutValue(COLUMN_SERVICE_DATE_TO, varNewDate);
		}

		pRow->PutValue(BILL_COLUMN_DATE, varNewDate);
		AddToModifiedList(nChargeID);	//we need to mark this charge as modified so it saves the date on editing

		pRow = pRow->GetNextRow();
	}
}

// (j.jones 2009-09-14 15:37) - PLID 35382 - this function looks at all the new charges on the bill,
// and tries to link case histories to the bill based on the procedures those charges are linked to
void CBillingDlg::TryLinkCaseHistoriesByProcedure()
{
	try {

		if (!IsSurgeryCenter(FALSE)) {
			return;
		}

		//bills only
		if (m_EntryType == 2) {
			return;
		}

		//1 - prompt, 2 - always link, 3 - never link
		long nAutoLinkCaseHistoriesToBills = GetRemotePropertyInt("AutoLinkCaseHistoriesToBills", 1, 0, "<None>", true);

		//if the preference is 3, we never link to case histories, so don't bother trying
		if (nAutoLinkCaseHistoriesToBills == 3) {
			return;
		}

		//get the service IDs on all new charges, we will search for procedure by these IDs
		CString strServiceIDs;
		int i = 0;
		for (i = 0; i < (int)m_billingItems.size(); i++) {
			long nChargeID = VarLong(m_billingItems[i]->ChargeID);
			long nServiceID = VarLong(m_billingItems[i]->ServiceID);

			if (nChargeID == -2) {
				if (!strServiceIDs.IsEmpty()) {
					strServiceIDs += ",";
				}
				strServiceIDs += AsString(nServiceID);
			}
		}

		//get all the case histories linked to the bill
		CString strCaseHistoryIDs = "-1";
		for (i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {
			CaseHistoryInfo *pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);
			strCaseHistoryIDs += ",";
			strCaseHistoryIDs += AsString(pCase->nCaseHistoryID);
		}

		if (!strServiceIDs.IsEmpty()) {

			//search for case histories with matching procedures, or with appointments that have matching procedures,
			//and not linked to any bill (except this bill, maybe we unlinked it manually and didn't save yet)
			//can't be parameterized
			_RecordsetPtr rs = CreateRecordset("SELECT CaseHistoryT.ID, CaseHistoryT.Name, CaseHistoryT.SurgeryDate "
				"FROM CaseHistoryT "
				"WHERE CaseHistoryT.PersonID = %li "
				"AND CaseHistoryT.ID NOT IN (SELECT CaseHistoryID FROM BilledCaseHistoriesT "
				"	INNER JOIN BillsT ON BilledCaseHistoriesT.BillID = BillsT.ID "
				"	WHERE BillsT.Deleted = 0 AND BillsT.ID <> %li) "
				"AND ("
				"CaseHistoryT.ID IN (SELECT CaseHistoryID FROM CaseHistoryProceduresT WHERE ProcedureID IN (SELECT ProcedureID FROM ServiceT WHERE ID IN (%s))) "
				"OR CaseHistoryT.AppointmentID IN (SELECT AppointmentID FROM AppointmentPurposeT WHERE PurposeID IN (SELECT ProcedureID FROM ServiceT WHERE ID IN (%s))) "
				")", m_nPatientID, GetBillID(), strServiceIDs, strServiceIDs);

			while (!rs->eof) {

				long nCaseHistoryID = AdoFldLong(rs, "ID");
				CString strCaseHistoryName = AdoFldString(rs, "Name");
				COleDateTime dtSurgeryDate = AdoFldDateTime(rs, "SurgeryDate");

				//make sure it's not already linked to this bill
				BOOL bFound = FALSE;
				for (int i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {
					CaseHistoryInfo *pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);
					if (pCase->nCaseHistoryID == nCaseHistoryID) {
						//it's already linked to this bill
						bFound = TRUE;
					}
				}

				if (!bFound) {
					//ask to add to the bill, prompt once per case history as it is not likely
					//they would have multiple case histories, let alone want to add them all
					//to this bill
					CString str;
					str.Format("You have added charges that are linked to procedures on the case history '%s' (Surgery Date: %s).\n\n"
						"Would you like to link this case history to this bill?", strCaseHistoryName,
						FormatDateTimeForInterface(dtSurgeryDate, NULL, dtoDate));
					if (nAutoLinkCaseHistoriesToBills == 2 || IDYES == MessageBox(str, "Practice", MB_YESNO | MB_ICONQUESTION)) {
						CaseHistoryInfo *pNewCase = new CaseHistoryInfo;
						pNewCase->nCaseHistoryID = nCaseHistoryID;
						pNewCase->strCaseHistoryName = strCaseHistoryName;
						pNewCase->dtSurgeryDate = dtSurgeryDate;
						m_arypBilledCaseHistories.Add(pNewCase);
					}
				}

				rs->MoveNext();
			}
			rs->Close();
		}

	}NxCatchAll("Error in CBillingDlg::TryLinkCaseHistories");
}

// (j.jones 2009-09-14 15:48) - PLID 35382 - this function takes in a quote ID,
// and tries to link case histories to the bill based on whether the case history
// is on the same PIC as the quote
void CBillingDlg::TryLinkCaseHistoriesByQuote(long nQuoteID)
{
	try {

		if (!IsSurgeryCenter(FALSE)) {
			return;
		}

		//1 - prompt, 2 - always link, 3 - never link
		long nAutoLinkCaseHistoriesToBills = GetRemotePropertyInt("AutoLinkCaseHistoriesToBills", 1, 0, "<None>", true);

		//if the preference is 3, we never link to case histories, so don't bother trying
		if (nAutoLinkCaseHistoriesToBills == 3) {
			return;
		}

		//see if the quote is on the same PIC as a case history,
		//and not linked to any bill (except this bill, maybe we unlinked it manually and didn't save yet)
		_RecordsetPtr rs = CreateParamRecordset("SELECT CaseHistoryID, CaseHistoryT.Name, CaseHistoryT.SurgeryDate "
			"FROM ProcInfoT "
			"INNER JOIN CaseHistoryT ON ProcInfoT.CaseHistoryID = CaseHistoryT.ID "
			"WHERE ActiveQuoteID = {INT} "
			"AND CaseHistoryID Is Not Null "
			"AND CaseHistoryID NOT IN (SELECT CaseHistoryID FROM BilledCaseHistoriesT "
			"	INNER JOIN BillsT ON BilledCaseHistoriesT.BillID = BillsT.ID "
			"	WHERE BillsT.Deleted = 0 AND BillsT.ID <> {INT})", nQuoteID, GetBillID());
		if (!rs->eof) {

			long nCaseHistoryID = AdoFldLong(rs, "CaseHistoryID");
			CString strCaseHistoryName = AdoFldString(rs, "Name");
			COleDateTime dtSurgeryDate = AdoFldDateTime(rs, "SurgeryDate");

			//make sure it's not already linked to this bill
			for (int i = 0; i < m_arypBilledCaseHistories.GetSize(); i++) {
				CaseHistoryInfo *pCase = (CaseHistoryInfo*)m_arypBilledCaseHistories.GetAt(i);
				if (pCase->nCaseHistoryID == nCaseHistoryID) {
					//it's already linked to this bill
					return;
				}
			}

			//if we get here, ask to add to the bill

			CString str;
			str.Format("This quote linked to the case history '%s' (Surgery Date: %s), using the Procedure Information Center.\n\n"
				"Would you like to link this case history to this bill?", strCaseHistoryName,
				FormatDateTimeForInterface(dtSurgeryDate, NULL, dtoDate));

			if (nAutoLinkCaseHistoriesToBills == 2 || IDYES == MessageBox(str, "Practice", MB_YESNO | MB_ICONQUESTION)) {
				CaseHistoryInfo *pNewCase = new CaseHistoryInfo;
				pNewCase->nCaseHistoryID = nCaseHistoryID;
				pNewCase->strCaseHistoryName = strCaseHistoryName;
				pNewCase->dtSurgeryDate = dtSurgeryDate;
				m_arypBilledCaseHistories.Add(pNewCase);
			}
		}
		rs->Close();

	}NxCatchAll("Error in CBillingDlg::TryLinkCaseHistoriesByQuote");
}

// (j.jones 2010-09-01 11:19) - PLID 40330 - renamed to reflect that this is now used on bills
// (b.cardillo 2015-11-24 11:02) - PLID 67121 - Changed second parameter name and made the meaning more 
// firm so we could use it for updating New Fee as well.
// Calculates the allowable for pItem and sets pItem to reflect that allowable. If bReflectOnExistingItem 
// is TRUE, it is assumed the item already exists and therefore the Allowable should be updated on 
// screen AND the item's New Fee should be calculated as well and if it has changed, the user should be 
// prompted to change the charge's unit price both in memory and on screen.
void CBillingDlg::LoadAllowableColumn(BillingItemPtr pItem, BOOL bReflectOnExistingItem) {

	try {

		//are we in a quote?
		if (m_EntryType == 2) {

			//we have to get the patient's primary insurance company
			// (j.jones 2013-04-12 14:30) - PLID 56250 - allowables are allowed on products now
			if (m_nPrimaryInsCoID == PRI_INSCO_NOT_SET &&
				(VarLong(pItem->ItemType) == ITEM_TYPE_CPT || VarLong(pItem->ItemType) == ITEM_TYPE_PRODUCT)) {

				_RecordsetPtr rsPriIns = CreateParamRecordset("SELECT InsuranceCoID FROM InsuredPartyT WHERE PatientID = {INT} AND RespTypeID = 1", m_nPatientID);

				if (!rsPriIns->eof) {

					m_nPrimaryInsCoID = AdoFldLong(rsPriIns, "InsuranceCoID", -1);
				}
				else {
					//set it to -2 meaning that we don't need to check it because there isn't one
					m_nPrimaryInsCoID = PRI_INSCO_NOT_EXIST;
				}
			}

			//don't do any of this if not a CPT code
			// (j.jones 2013-04-12 14:30) - PLID 56250 - allowables are allowed on products now
			if (m_nPrimaryInsCoID != PRI_INSCO_NOT_EXIST && m_nPrimaryInsCoID != PRI_INSCO_NOT_SET
				&& (VarLong(pItem->ItemType) == ITEM_TYPE_CPT || VarLong(pItem->ItemType) == ITEM_TYPE_PRODUCT)) {

				BOOL bExists, bWarn, bHasAllowable;
				COleCurrency cyAllowable;
				CString strMsg;

				long nLocationID;
				if (m_LocationCombo->GetCurSel() == -1)
					nLocationID = GetCurrentLocationID();
				else
					nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

				// (j.jones 2009-10-23 11:05) - PLID 18558 - this requires nPlaceOfServiceID now
				long nPOSID = -1;
				if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
					nPOSID = GetCurrentLocationID();
				}
				else {
					nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
				}

				// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
				GetMultiFee(VarLong(pItem->ServiceID), VarLong(pItem->Provider, -1), m_nPrimaryInsCoID, nLocationID, nPOSID, VarDateTime(pItem->Date), bExists, bWarn, strMsg, bHasAllowable, cyAllowable);

				if (bHasAllowable) {

					pItem->HasAllowable = g_cvarTrue;
					pItem->UnitAllowable = _variant_t(cyAllowable);

					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is multiplied by quantity & modifiers,
					// it's never shown on a quote, but it's loaded everywhere else, might as well be here
					COleCurrency cyAllowableTotal = cyAllowable;

					double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
					dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

					if (pItem->Quantity.vt == VT_R8) {
						dblQuantity = VarDouble(pItem->Quantity, 1.0);
					}
					if (pItem->Multiplier1.vt == VT_R8) {
						dblMultiplier1 = VarDouble(pItem->Multiplier1, 1.0);
					}
					if (pItem->Multiplier2.vt == VT_R8) {
						dblMultiplier2 = VarDouble(pItem->Multiplier2, 1.0);
					}
					if (pItem->Multiplier3.vt == VT_R8) {
						dblMultiplier3 = VarDouble(pItem->Multiplier3, 1.0);
					}
					if (pItem->Multiplier4.vt == VT_R8) {
						dblMultiplier4 = VarDouble(pItem->Multiplier4, 1.0);
					}

					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

					RoundCurrency(cyAllowableTotal);

					pItem->TotalAllowable = _variant_t(cyAllowableTotal);
				}
				else {
					pItem->HasAllowable = g_cvarFalse;
					pItem->UnitAllowable = COleCurrency(0, 0);
					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
					pItem->TotalAllowable = g_cvarNull;
				}
			}
			else {

				//set it to 0			
				pItem->HasAllowable = g_cvarFalse;
				pItem->UnitAllowable.cyVal = COleCurrency(0, 0);
				// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
				pItem->TotalAllowable = g_cvarNull;
			}

			if (bReflectOnExistingItem) {

				//loop through the datalist to find the row
				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				IRowSettingsPtr pRow = m_QuoteList->GetFirstRow();
				while (pRow) {

					if (VarLong(pRow->GetValue(COLUMN_LINE_ID), -1) == VarLong(pItem->LineID, -1)) {

						//we found it
						// (j.jones 2010-09-02 09:48) - PLID 40330 - for quotes this is the unit allowable
						pRow->PutValue(QUOTE_COLUMN_ALLOWABLE, pItem->UnitAllowable);
					}

					pRow = pRow->GetNextRow();
				}
			}
		}
		else {
			//we're in a bill

			// (j.jones 2010-09-01 11:20) - PLID 40330 - supported this for bills

			// (d.lange 2015-11-17 17:00) - PLID 67127 - Load the allowable based on the responsibility type
			long nInsuranceCoID = -1;
			long nChargeID = VarLong(pItem->ChargeID, -1);
			if (nChargeID < 0) {
				// For a new charge, load the allowable based on the most-primary insurance company of the selected insurance category
				nInsuranceCoID = GetCurrentBillToMostPriInsCoIDForCategory();
			}
			else {
				// For an existing charge, load the allowable based on the stored insurance company or fall back to
				// patient responsibility
				nInsuranceCoID = (pItem->AllowableInsuranceCoID.vt == VT_I4 ? VarLong(pItem->AllowableInsuranceCoID, -1) : -1);
			}

			//don't do any of this if not a CPT code
			// (j.jones 2013-04-12 14:30) - PLID 56250 - allowables are allowed on products now
			// (d.lange 2015-11-17 16:16) - PLID 67127 - Calculate allowable for all responsibility types
			if ((VarLong(pItem->ItemType) == ITEM_TYPE_CPT || VarLong(pItem->ItemType) == ITEM_TYPE_PRODUCT)) {

				BOOL bExists, bWarn, bHasAllowable;
				COleCurrency cyAllowable;
				CString strMsg;

				long nLocationID;
				if (m_LocationCombo->GetCurSel() == -1)
					nLocationID = GetCurrentLocationID();
				else
					nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;

				long nPOSID = -1;
				if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
					nPOSID = GetCurrentLocationID();
				}
				else {
					nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
				}

				// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
				COleCurrency cyUnitCost = GetMultiFee(VarLong(pItem->ServiceID), VarLong(pItem->Provider, -1), nInsuranceCoID, nLocationID, nPOSID, VarDateTime(pItem->Date), bExists, bWarn, strMsg, bHasAllowable, cyAllowable
					// Pass in strChargeInfo as "the charge '<code> <subcode> - <description>'"
					, FormatString("the charge '%s'", ConcatNonEmpty(ConcatNonEmpty(VarString(pItem->CPTCode, ""), VarString(pItem->CPTSubCode, ""), " ").Trim(), VarString(pItem->Description, "").Trim(), " - ")) 
					);

				// (b.cardillo 2015-11-24 11:02) - PLID 67121 - For bills, if we're updating an existing charge on 
				// screen, also give the user the option to update the unit cost if the fee schedule is changing
				if (bReflectOnExistingItem) {
					if ((bExists && bWarn && IDYES == MessageBox(strMsg, "Practice", MB_YESNO)) ||
						(bExists && !bWarn)) {
						//multifee exists, and they DO want to keep it
						pItem->UnitCost = _variant_t(cyUnitCost);

						// Update on screen
						IRowSettingsPtr pRow = m_List->FindByColumn(COLUMN_LINE_ID, pItem->LineID, NULL, VARIANT_FALSE);
						// Should always find our row because we're under bReflectOnExistingItem. If not, let exception fly.
						ASSERT(pRow != NULL);
						pRow->PutValue(BILL_COLUMN_UNIT_COST, _variant_t(cyUnitCost));
					}
				}

				if (bHasAllowable) {
					pItem->HasAllowable = g_cvarTrue;
					pItem->UnitAllowable = _variant_t(cyAllowable);

					// (j.jones 2010-09-02 09:50) - PLID 40330 - the TotalAllowable takes quantity and modifiers into account
					double dblQuantity, dblMultiplier1, dblMultiplier2, dblMultiplier3, dblMultiplier4;
					dblQuantity = dblMultiplier1 = dblMultiplier2 = dblMultiplier3 = dblMultiplier4 = 1.0;

					if (pItem->Quantity.vt == VT_R8) {
						dblQuantity = VarDouble(pItem->Quantity, 1.0);
					}
					if (pItem->Multiplier1.vt == VT_R8) {
						dblMultiplier1 = VarDouble(pItem->Multiplier1, 1.0);
					}
					if (pItem->Multiplier2.vt == VT_R8) {
						dblMultiplier2 = VarDouble(pItem->Multiplier2, 1.0);
					}
					if (pItem->Multiplier3.vt == VT_R8) {
						dblMultiplier3 = VarDouble(pItem->Multiplier3, 1.0);
					}
					if (pItem->Multiplier4.vt == VT_R8) {
						dblMultiplier4 = VarDouble(pItem->Multiplier4, 1.0);
					}

					COleCurrency cyAllowableTotal = VarCurrency(pItem->UnitAllowable, COleCurrency(0, 0));
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblQuantity);

					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier1);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier2);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier3);
					cyAllowableTotal = CalculateAmtQuantity(cyAllowableTotal, dblMultiplier4);

					RoundCurrency(cyAllowableTotal);

					pItem->TotalAllowable = _variant_t(cyAllowableTotal);
				}
				else {
					pItem->HasAllowable = g_cvarFalse;
					pItem->UnitAllowable = COleCurrency(0, 0);
					// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
					pItem->TotalAllowable = g_cvarNull;
				}
			}
			else {
				//patient or non-CPT, set it to NULL
				pItem->HasAllowable = g_cvarFalse;
				pItem->UnitAllowable = g_cvarNull;
				// (j.jones 2010-09-02 09:46) - PLID 40330 - TotalAllowable is NULL if one does not exist
				pItem->TotalAllowable = g_cvarNull;
			}

			if (bReflectOnExistingItem) {

				//loop through the datalist to find the row
				// (j.jones 2011-10-04 09:51) - PLID 45799 - converted to a DL2
				IRowSettingsPtr pRow = m_List->GetFirstRow();
				while (pRow) {

					if (VarLong(pRow->GetValue(COLUMN_LINE_ID), -1) == VarLong(pItem->LineID, -1)) {

						//we found it
						pRow->PutValue(BILL_COLUMN_ALLOWABLE, pItem->TotalAllowable);
					}

					pRow = pRow->GetNextRow();
				}
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2009-11-02 15:23) - PLID 35934 - given a string of quote IDs and an array
// of applied payments see if we just finished billing a package and applied linked
// prepayments to it, and adjust the balance as necessary
void CBillingDlg::TryAdjustPackagePaymentDifference(CString strQuoteIDs, CArray<PaymentToApply, PaymentToApply&> &aryAppliedPayments)
{
	try {

		//this function will adjust a prepayment or charges given the following rules:
		//- prepayments were made that totalled the exact original package estimated total with tax
		//- the prepayments were auto-applied by practice
		//- we've billed the package down to $0.00
		//- if we underestimated tax, the charge balance needs to exactly match the charge total - prepayments
		//- if we overestimated tax, the payment balance needs to exactly match the prepayments - charge total
		//- if all the above is true, adjust either the charge or the payment

		//if we did not bill a quote or did not apply any payments, leave
		if (strQuoteIDs.IsEmpty() || aryAppliedPayments.GetSize() == 0) {
			return;
		}

		//if the preference to adjust packages is disabled, leave
		if (GetRemotePropertyInt("PackageTaxAdjustments", 0, 0, "<None>", true) == 0) {
			return;
		}

		//is the preference set to over or under estimate tax?
		BOOL bOverestimateTax = GetRemotePropertyInt("PackageTaxEstimation", 0, 0, "<None>", true) == 0;

		int i = 0;
		CString strAppliedPaymentIDs;
		for (i = 0; i < aryAppliedPayments.GetSize(); i++) {
			PaymentToApply pta = aryAppliedPayments[i];
			if (!strAppliedPaymentIDs.IsEmpty()) {
				strAppliedPaymentIDs += ",";
			}
			strAppliedPaymentIDs += AsString(pta.nID);
		}

		//find out if there are any prepayments that are linked to our quotes that are not in our applied list,
		//and if so, grab them now and add to our list
		_RecordsetPtr rsOtherPrepays = CreateParamRecordset(FormatString("SELECT PaysQ.PayID, PaysQ.QuoteID, PaysQ.InsuredPartyID, PaysQ.PrePayment, "
			"PaysQ.Amount, Amount - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) "
			"+ (CASE WHEN PaymentAppliesQ.ApplyAmt IS NULL THEN 0 ELSE PaymentAppliesQ.ApplyAmt END) AS RespAmount, "
			"CASE WHEN InsuranceCoT.Name IS NULL THEN '<None>' ELSE InsuranceCoT.Name END AS InsCoName, "
			"CASE WHEN RespTypeT.ID IS NULL THEN 'Patient' ELSE RespTypeT.TypeName END AS RespType, "
			"Description, Date "
			"FROM "
			"(/* The amount of all non-deleted payments for this patient */ "
			"SELECT LineItemT.ID AS PayID, PaymentsT.QuoteID, PrePayment, Amount, PatientID, InsuredPartyID, Description, LineItemT.Date "
			"FROM LineItemT INNER JOIN PaymentsT ON LineItemT.ID = PaymentsT.ID "
			"WHERE Deleted = 0 AND Type >= 1 AND Type <= 2 "
			") PaysQ "
			"LEFT JOIN "
			"(/* The amt of each payment that has been applied for this patient */ "
			"SELECT AppliesT.SourceID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
			"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
			"WHERE Deleted = 0 "
			"GROUP BY SourceID, PatientID "
			") ChargeAppliesQ "
			"ON PaysQ.PayID = ChargeAppliesQ.SourceID "
			"LEFT JOIN "
			"(/* The amt of each payment that has had applies to it*/ "
			"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
			"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
			"WHERE Deleted = 0 "
			"GROUP BY DestID, PatientID "
			") PaymentAppliesQ "
			"ON PaysQ.PayID = PaymentAppliesQ.DestID "
			"LEFT JOIN InsuredPartyT ON PaysQ.InsuredPartyID = InsuredPartyT.PersonID "
			"LEFT JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
			"LEFT JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
			"WHERE PaysQ.PatientID = {INT} "
			"AND PaysQ.QuoteID IN (%s) AND PaysQ.PrePayment = 1 AND PaysQ.PayID NOT IN (%s)",
			strQuoteIDs, strAppliedPaymentIDs),
			m_nPatientID);

		while (!rsOtherPrepays->eof) {
			PaymentToApply pta;
			pta.nID = AdoFldLong(rsOtherPrepays, "PayID");
			pta.nInsuredPartyID = AdoFldLong(rsOtherPrepays, "InsuredPartyID", -1);
			pta.cyRespAmount = AdoFldCurrency(rsOtherPrepays, "RespAmount", COleCurrency(0, 0));
			pta.nQuoteID = AdoFldLong(rsOtherPrepays, "QuoteID", -1);
			pta.cyPayAmount = AdoFldCurrency(rsOtherPrepays, "Amount", COleCurrency(0, 0));
			pta.bIsPrePayment = AdoFldBool(rsOtherPrepays, "PrePayment", FALSE);
			aryAppliedPayments.Add(pta);

			rsOtherPrepays->MoveNext();
		}
		rsOtherPrepays->Close();

		//for each billed quote, find out if it a package, and is the current amount now zero?					
		_RecordsetPtr rsZeroPackages = CreateRecordset("SELECT QuoteID "
			"FROM PackagesT WHERE QuoteID IN (%s) AND CurrentAmount = Convert(money,0)", strQuoteIDs);
		while (!rsZeroPackages->eof) {

			//for each zero-balance package we've billed, find out if the payments we just
			//auto-applied were prepayments linked to that package

			long nQuoteID = AdoFldLong(rsZeroPackages, "QuoteID");

			CArray<PaymentToApply, PaymentToApply> aryLinkedPayments;
			CString strLinkedPaymentIDs;

			COleCurrency cyPaymentTotal = COleCurrency(0, 0);

			for (i = 0; i < aryAppliedPayments.GetSize(); i++) {
				PaymentToApply pta = aryAppliedPayments[i];
				if (pta.nQuoteID == nQuoteID && pta.bIsPrePayment) {
					//this is a pre-payment linked to this package
					aryLinkedPayments.Add(pta);
					if (!strLinkedPaymentIDs.IsEmpty()) {
						strLinkedPaymentIDs += ",";
					}
					strLinkedPaymentIDs += AsString(pta.nID);
					cyPaymentTotal += pta.cyPayAmount;
				}
			}

			if (!aryLinkedPayments.IsEmpty()) {

				//we have prepayments linked to zero-balance packages,
				//so we need to try and adjust any difference we may have,
				//provided the difference is precisely what we expect

				//before we continue, we need to see if the total linked prepayments
				//precisely match the original value of the package with tax, because
				//if they do not match, then we can't adjust anyways
				COleCurrency cyPackageTotal = CalculateOriginalPackageValueWithTax(nQuoteID);
				if (cyPackageTotal != cyPaymentTotal) {
					//the payment was not for the exact estimated package amount,
					//so we cannot possibly auto-adjust
					return;
				}

				//now we need to get the new balance of the payments we just applied
				//(note: if rsOtherPrepays returned records above, those payments would already
				//be up to date, but since we have to check the balances of those we just
				//applied, it doesn't hurt that it's recalculating these that we just loaded)

				_RecordsetPtr rsPayBalances = CreateRecordset("SELECT LineItemT.ID, "
					"LineItemT.Amount - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) "
					"+ (CASE WHEN PaymentAppliesQ.ApplyAmt IS NULL THEN 0 ELSE PaymentAppliesQ.ApplyAmt END) AS Balance "
					"FROM LineItemT "
					"LEFT JOIN "
					"(/* The amt of each payment that has been applied for this patient */ "
					"SELECT AppliesT.SourceID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
					"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
					"WHERE Deleted = 0 "
					"GROUP BY SourceID, PatientID "
					") ChargeAppliesQ "
					"ON LineItemT.ID = ChargeAppliesQ.SourceID "
					"LEFT JOIN "
					"(/* The amt of each payment that has had applies to it*/ "
					"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt, PatientID "
					"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
					"WHERE Deleted = 0 "
					"GROUP BY DestID, PatientID "
					") PaymentAppliesQ "
					"ON LineItemT.ID = PaymentAppliesQ.DestID "
					"WHERE LineItemT.ID IN (%s) ", strLinkedPaymentIDs);

				COleCurrency cyTotalPaymentBalance = COleCurrency(0, 0);

				while (!rsPayBalances->eof) {

					long nID = AdoFldLong(rsPayBalances, "ID");

					BOOL bFound = FALSE;
					int j = 0;
					for (j = 0; j < aryLinkedPayments.GetSize() && !bFound; j++) {
						PaymentToApply pta = aryLinkedPayments.GetAt(j);
						if (pta.nID == nID) {
							bFound = TRUE;

							//update the balance
							pta.cyRespAmount = AdoFldCurrency(rsPayBalances, "Balance", COleCurrency(0, 0));
							aryLinkedPayments.SetAt(j, pta);
							cyTotalPaymentBalance += pta.cyRespAmount;
						}
					}

					rsPayBalances->MoveNext();
				}
				rsPayBalances->Close();

				//now get the balance of the current charges for the given package

				_RecordsetPtr rsChargeBalances = CreateParamRecordset("SELECT "
					"Sum(dbo.GetChargeTotal(ChargesT.ID)) AS TotalCharges, "
					"Sum(dbo.GetChargeTotal(ChargesT.ID)) - Sum(CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) AS TotalBalance, "
					"Sum(CASE WHEN BillsT.ID = {INT} THEN dbo.GetChargeTotal(ChargesT.ID) ELSE 0 END) "
					"	- Sum(CASE WHEN BillsT.ID <> {INT} OR ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) AS BillBalance "
					"FROM LineItemT "
					"INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
					"INNER JOIN BillsT ON ChargesT.BillID = BillsT.ID "
					"LEFT JOIN "
					"(/* The amt of payments applied to each charge */ "
					"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt "
					"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
					"WHERE Deleted = 0 "
					"GROUP BY DestID "
					") ChargeAppliesQ "
					"ON LineItemT.ID = ChargeAppliesQ.DestID "
					"WHERE LineItemT.Deleted = 0 AND BillsT.Deleted = 0 "
					"AND ChargesT.PackageChargeRefID Is Not Null "
					"AND ChargesT.PackageChargeRefID IN (SELECT ChargesT.ID "
					"	FROM ChargesT "
					"	INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
					"	WHERE Deleted = 0 AND ChargesT.BillID = {INT})", GetBillID(), GetBillID(), nQuoteID);
				if (!rsChargeBalances->eof) {

					COleCurrency cyTotalCharges = AdoFldCurrency(rsChargeBalances, "TotalCharges", COleCurrency(0, 0));
					COleCurrency cyTotalBalance = AdoFldCurrency(rsChargeBalances, "TotalBalance", COleCurrency(0, 0));
					COleCurrency cyBillBalance = AdoFldCurrency(rsChargeBalances, "BillBalance", COleCurrency(0, 0));

					// (j.jones 2009-12-11 08:37) - PLID 35934 - it is rare but funky rounding possibilities mean
					// that there can sometimes be a payment balance when we're underestimating or a charge balance
					// when we're overestimating, so we should just check both cases where the balances mismatch
					//if(bOverestimateTax) {

					//if we are overestimating tax, the payment may have a balance

					//if the charge is paid off, and the payment balance matches
					//our expected difference between the package balance and
					//the original payment totals, we need to adjust the payment

					if (cyTotalBalance == COleCurrency(0, 0) && cyTotalPaymentBalance > COleCurrency(0, 0)) {
						//the charges are all paid off, but a payment balance remains

						//does the total payments - total charges equal the payment balance?
						if (cyPaymentTotal - cyTotalCharges == cyTotalPaymentBalance) {
							//it does match, we need to adjust the payments

							//prompt first
							CString strWarn;
							strWarn.Format("This package has been fully billed, but the linked prepayment balance is %s.\n"
								"Would you like to adjust the %s payment balance?",
								FormatCurrencyForInterface(cyTotalPaymentBalance), FormatCurrencyForInterface(cyTotalPaymentBalance));
							if (IDNO == MessageBox(strWarn, "Practice", MB_YESNO | MB_ICONQUESTION)) {
								return;
							}

							CPaymentDlg dlg(this);

							dlg.m_PatientID = m_nPatientID;
							dlg.m_cyFinalAmount = cyTotalPaymentBalance;
							dlg.m_cyMaxAmount = dlg.m_cyFinalAmount;
							dlg.m_ApplyOnOK = FALSE;
							dlg.m_iDefaultPaymentType = 1;

							if (IDCANCEL != dlg.DoModal(__FUNCTION__, __LINE__)) {

								//loop through each payment with a balance, and apply
								for (int j = 0; j < aryLinkedPayments.GetSize(); j++) {
									PaymentToApply pta = aryLinkedPayments.GetAt(j);
									if (pta.cyRespAmount > COleCurrency(0, 0)) {
										AutoApplyPayToPay(VarLong(dlg.m_varPaymentID), m_nPatientID, "Adjustment", pta.nID);
									}
								}
							}
						}
					}
					//}
					//else {
					//if we are underestimating tax, the charge may have a balance

					//if the payment balance is zero, and the charge balance matches
					//our expected difference between the package balance and
					//the original payment totals, we need to adjust the charge(s)

					//also we can only do this if the charge balance exists only on this bill,
					//we won't go back and adjust other bills

					else if (cyTotalBalance > COleCurrency(0, 0) && cyTotalPaymentBalance == COleCurrency(0, 0)
						&& cyBillBalance == cyTotalBalance) {
						//the payment is fully applied, but a charge balance remains

						//does the total charge - total payments equal the charge balance?
						if (cyTotalCharges - cyPaymentTotal == cyTotalBalance) {
							//it does match, we need to adjust the charge

							//prompt first
							CString strWarn;
							strWarn.Format("The billed package balance is %s, and the linked prepayment is fully applied.\n"
								"Would you like to adjust the %s package balance of this bill?",
								FormatCurrencyForInterface(cyTotalBalance), FormatCurrencyForInterface(cyTotalBalance));
							if (IDNO == MessageBox(strWarn, "Practice", MB_YESNO | MB_ICONQUESTION)) {
								return;
							}

							CPaymentDlg dlg(this);

							long nLocationID;
							if (m_LocationCombo->GetCurSel() == -1) {
								nLocationID = GetCurrentLocationID();
							}
							else {
								nLocationID = m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0).lVal;
							}

							dlg.m_PatientID = m_nPatientID;
							dlg.m_cyFinalAmount = cyTotalBalance;
							dlg.m_cyMaxAmount = dlg.m_cyFinalAmount;
							dlg.m_ApplyOnOK = FALSE;
							dlg.m_iDefaultPaymentType = 1;
							dlg.m_cyFinalAmount *= -1;
							dlg.m_DefLocationID = nLocationID;

							if (IDCANCEL != dlg.DoModal(__FUNCTION__, __LINE__)) {

								//loop through each package charge with a balance, and apply
								_RecordsetPtr rsCharges = CreateParamRecordset("SELECT ChargesT.ID "
									"FROM LineItemT "
									"INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
									"LEFT JOIN "
									"(/* The amt of payments applied to each charge */ "
									"SELECT AppliesT.DestID, Sum(AppliesT.Amount) AS ApplyAmt "
									"FROM AppliesT INNER JOIN LineItemT ON AppliesT.SourceID = LineItemT.ID "
									"WHERE Deleted = 0 "
									"GROUP BY DestID "
									") ChargeAppliesQ "
									"ON LineItemT.ID = ChargeAppliesQ.DestID "
									"WHERE LineItemT.Deleted = 0 AND ChargesT.BillID = {INT} "
									"AND ChargesT.PackageChargeRefID Is Not Null "
									"AND ChargesT.PackageChargeRefID IN (SELECT ChargesT.ID "
									"	FROM ChargesT "
									"	INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
									"	WHERE Deleted = 0 AND ChargesT.BillID = {INT}) "
									"AND dbo.GetChargeTotal(ChargesT.ID) - (CASE WHEN ChargeAppliesQ.ApplyAmt IS NULL THEN 0 ELSE ChargeAppliesQ.ApplyAmt END) > Convert(money,0)",
									GetBillID(), nQuoteID);

								while (!rsCharges->eof) {

									AutoApplyPayToBill(VarLong(dlg.m_varPaymentID), m_nPatientID, "Charge", AdoFldLong(rsCharges, "ID"));

									rsCharges->MoveNext();
								}
								rsCharges->Close();
							}
						}
					}
					//}
				}
				rsChargeBalances->Close();
			}

			rsZeroPackages->MoveNext();
		}
		rsZeroPackages->Close();

	}NxCatchAll("Error in CBillingDlg::TryAdjustPackagePaymentDifference");
}

// (j.jones 2009-12-22 14:36) - PLID 32587 - made the original amount fields editable
void CBillingDlg::OnPackageShowInitialValues()
{
	try {

		//simply show or hide the initial value fields based on the checkbox
		if (m_checkPackageShowInitialValues.GetCheck()) {
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT)->ShowWindow(SW_SHOWNOACTIVATE);

			if (m_radioRepeatPackage.GetCheck()) {
				//if repeatable, show the count info
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_SHOWNOACTIVATE);
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_SHOWNOACTIVATE);
			}
			else {
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_HIDE);
				GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_HIDE);
			}
		}
		else {
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT)->ShowWindow(SW_HIDE);
		}

		//resize columns will handle the initial quantity column accordingly
		ResizeColumns();

	}NxCatchAll("Error in CBillingDlg::OnPackageShowInitialValues");
}

// (j.jones 2009-12-23 11:21) - PLID 32587 - made the original amount fields editable
void CBillingDlg::OnKillfocusPackageOriginalCurrentAmount()
{
	try {

		if (!m_bPackageOriginalAmountChanged) {
			return;
		}

		CString strOriginalAmount;
		GetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, strOriginalAmount);
		COleCurrency cyOriginalAmount = ParseCurrencyFromInterface(strOriginalAmount);

		CString strTotalAmount;
		GetDlgItemText(IDC_PACKAGE_TOTAL_COST, strTotalAmount);
		COleCurrency cyTotalAmount = ParseCurrencyFromInterface(strTotalAmount);

		if (cyOriginalAmount.GetStatus() == COleCurrency::invalid) {
			AfxMessageBox("The value you entered is not a valid amount, please enter in a dollar amount.");
			//reset to the total amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cyTotalAmount));
		}
		else if (cyOriginalAmount > cyTotalAmount) {
			AfxMessageBox("The Initial Value cannot be greater than the Total Package Cost.");
			//reset to the total amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cyTotalAmount));
		}
		else if (cyOriginalAmount < COleCurrency(0, 0)) {
			AfxMessageBox("The Initial Value cannot be less than zero.");
			//reset to the total amount
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cyTotalAmount));
		}
		else {
			SetDlgItemText(IDC_PACKAGE_ORIGINAL_CURRENT_AMOUNT, FormatCurrencyForInterface(cyOriginalAmount));
		}

		m_bPackageOriginalAmountChanged = FALSE;

	}NxCatchAll("Error in OnKillfocusPackageOriginalCurrentAmount");
}

void CBillingDlg::OnKillfocusPackageOriginalCurrentCount()
{
	try {

		if (!m_bPackageOriginalCountChanged) {
			return;
		}

		long nInitCount = GetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT);
		//cannot be less than 1
		if (nInitCount < 1) {
			nInitCount = 1;
		}
		//if the number was huge, or negative, this will re-set it
		SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, nInitCount);

		long nTotalCount = GetDlgItemInt(IDC_PACKAGE_TOTAL_COUNT);
		if (nInitCount > nTotalCount) {
			AfxMessageBox("The Initial Uses cannot be greater than the total uses.\n"
				"Please update the 'Total Uses' field first.");
			SetDlgItemInt(IDC_PACKAGE_ORIGINAL_CURRENT_COUNT, nTotalCount);
		}

		m_bPackageOriginalCountChanged = FALSE;

	}NxCatchAll("Error in OnKillfocusPackageOriginalCurrentCount");
}

void CBillingDlg::OnChangePackageOriginalCurrentAmount()
{
	m_bPackageOriginalAmountChanged = TRUE;
}

void CBillingDlg::OnChangePackageOriginalCurrentCount()
{
	m_bPackageOriginalCountChanged = TRUE;
}

// (j.gruber 2014-02-26 15:13) - PLID 60898 
CString CBillingDlg::GetDiagDescription(DiagCodeInfoPtr pDiag)
{

	if (pDiag->nDiagCode9ID != -1 && pDiag->nDiagCode10ID != -1)
	{
		return pDiag->strDiagCode10Code + " (" + pDiag->strDiagCode9Code + ")";
	}
	else if (pDiag->nDiagCode9ID != -1)
	{
		//only show the 9 code
		return pDiag->strDiagCode9Code;
	}
	else if (pDiag->nDiagCode10ID != -1)
	{
		//only show the 10 code
		return pDiag->strDiagCode10Code;
	}

	//we shouldn't be able to get here because that would mean both the 
	//ICD9ID and ICD10 ID == -1
	ASSERT(FALSE);
	return "";
}

// (j.jones 2010-08-30 13:46) - PLID 40293 - added a function to calculate if there are any
// diagnosis codes on the bill (with an index < 13) that aren't linked to any charges
// (j.gruber 2014-02-26 14:32) - PLID 60898 - redo this craziness
BOOL CBillingDlg::CheckWarnUnlinkedDiagnosisCodes()
{
	if (m_EntryType == 2) {
		return TRUE;
	}

	CString strUnlinkedDiags = "";

	for (int i = 0; i < m_arypDiagCodes.GetSize(); i++)
	{
		//get our pair we'll be searching for
		DiagCodeInfoPtr pDiag = m_arypDiagCodes[i];

		CChargeWhichCodePair pairToFind = CChargeWhichCodePair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID);

		//loop through our billing array to see if any have this pair
		//only if the index is < 13
		if (pDiag->nOrderIndex < 13)
		{

			BOOL bFound = FALSE;
			for each(std::vector<BillingItemPtr>::value_type pItem in m_billingItems)
			{
				//search for our pair
				CChargeWhichCodesIterator itFind = pItem->whichCodes->find(pairToFind);
				if (itFind != pItem->whichCodes->end())
				{
					bFound = TRUE;
				}
			}

			if (!bFound)
			{
				strUnlinkedDiags += GetDiagDescription(pDiag) + "\n";
			}
		}
	}

	if (!strUnlinkedDiags.IsEmpty()) {
		//warn about the unlinked codes
		CString strWarn;
		strWarn.Format("The following diagnosis codes are not linked to any charge on this bill:\n\n"
			"%s\n"
			"Are you sure you wish to continue saving this bill?", strUnlinkedDiags);
		if (IDNO == MessageBox(strWarn, "Practice", MB_ICONEXCLAMATION | MB_YESNO)) {
			return FALSE;
		}
	}

	return TRUE;
}

//(c.copits 2010-10-01) PLID 40317 - Allow duplicate UPC codes for FramesData certification.
// This function will likely be updated to pick the most suitable
// UPC code in response to a barcode scan. Practice now allows multiple
// products to have the same UPC codes. Further, products can share UPC codes
// with service codes (however, service codes cannot share UPC codes).

// Current behavior: returns the first matching UPC inventory item from m_ProductsCombo list

long CBillingDlg::GetBestUPCProductInventory(_variant_t var)
{
	long row = -1;

	try {
		row = m_ProductsCombo->SetSelByColumn(PRODUCTS_COLUMN_BARCODE, var);
	} NxCatchAll(__FUNCTION__);

	return row;

}

//(c.copits 2010-10-26) PLID 38598 - Warranty tracking system
// This function will update all charged inventory products' warranty expiration dates if they have warranties.
void CBillingDlg::UpdateInvWarrantyExpDates(long ChargedProductItemListID)
{
	CString strSqlStatement, strSql = BeginSqlBatch();
	bool bItemsFound = false;

	// Set up some preliminary data types for the query
	strSqlStatement = "DECLARE @nProductTID INT";
	AddStatementToSqlBatch(strSql, strSqlStatement);

	strSqlStatement = "DECLARE @nProductItemsTID INT";
	AddStatementToSqlBatch(strSql, strSqlStatement);

	strSqlStatement = "DECLARE @nDays INT";
	AddStatementToSqlBatch(strSql, strSqlStatement);

	// Find relevant inventory items
	for (int i = 0; i < m_aryChargedProductItems.GetSize(); i++) {
		ChargedProductItemList *cpiList = (ChargedProductItemList*)m_aryChargedProductItems.GetAt(i);
		if (cpiList->ID == ChargedProductItemListID) {
			for (int j = 0; j < cpiList->ProductItemAry.GetSize(); j++) {
				ProductItems *prodItem = cpiList->ProductItemAry.GetAt(j);

				// Update warranty expiration date in ProductItemsT
				strSqlStatement.Format(
					"SET @nProductItemsTID = %ld "
					"SET @nProductTID = (SELECT ProductID FROM ProductItemsT WHERE ID = @nProductItemsTID) "
					"SET @nDays = (SELECT WarrantyDays FROM ProductT WHERE ID = @nProductTID) "
					"UPDATE ProductItemsT "
					"SET ProductItemsT.WarrantyExpDate = "
					//"	(SELECT GETDATE() + (SELECT WarrantyDays FROM ProductT WHERE ID = @nProductTID)) "
					"	(SELECT Convert(datetime,Convert(nvarchar, DATEADD(day, @nDays, GetDate()), 1))) "
					"WHERE ProductItemsT.ProductID = @nProductTID "
					"	AND ProductItemsT.ID = @nProductItemsTID "
					"	AND ((SELECT WarrantyDays FROM ProductT WHERE ID = @nProductTID) IS NOT NULL) "
					"	AND ((SELECT WarrantyActive FROM ProductT WHERE ID = @nProductTID) = 1) ",
					prodItem->ProductItemID
					);

				AddStatementToSqlBatch(strSql, strSqlStatement);
				bItemsFound = true;

			}
		}
	}

	if (bItemsFound) {
		ExecuteSqlBatch(strSql);
	}

}

//TES 4/13/2011 - PLID 43249 - Added the ability to bill Glasses Orders, modelled off of OnSelChosenComboEMR()
void CBillingDlg::OnSelChosenComboGlassesOrders(LPDISPATCH lpRow)
{
	try {

		//m_GlassesOrdersCombo
		if (lpRow == NULL)
			return;

		// (j.jones 2010-08-31 09:17) - PLID 39218 - require a resp. selection
		if (m_EntryType == 1 && m_listBillTo->CurSel == -1) {
			AfxMessageBox("You must first select a Responsibility before adding new charges.");
			return;
		}

		// (a.walling 2010-02-04 15:09) - PLID 36889 - Maintains the current focus
		CMaintainFocus maintainFocus(__FUNCTION__);

		CWaitCursor pWait;

		EnsureRemoteData();

		_RecordsetPtr rs, rsTrack, rsDtls;
		CString str;
		long AuditID = -1;
		IRowSettingsPtr pRow(lpRow);
		_variant_t var = pRow->GetValue(0);

		long nGlassesOrderID = var.lVal;

		// (j.dinatale 2012-03-20 11:33) - PLID 48893 - need to check our "already billed optical orders" set, if this glasses order
		//		has yet to be billed, then we add it to our set. Also need to ensure that we dont allow the user to add a glasses order
		//		that has been billed.
		if (nGlassesOrderID != -1){
			// (j.dinatale 2012-06-06 16:01) - PLID 50849 - only can bill an optical order once, no duplicates
			if (m_setBilledOpticalOrderIDs.count(nGlassesOrderID)){
				m_pBillingModuleWnd->MessageBox("This optical order is already on this bill and cannot be added again.", "Alert!", MB_OK | MB_ICONEXCLAMATION);
				return;
			}

			// (j.dinatale 2012-06-06 16:01) - PLID 50849 - only allow one optical order per bill
			if (m_setBilledOpticalOrderIDs.size() > 0){
				m_pBillingModuleWnd->MessageBox("Only one optical order may be added to a bill. If you need to bill additional optical orders, create one bill for each order.", "Alert!", MB_OK | MB_ICONEXCLAMATION);
				return;
			}

			if (ReturnsRecordsParam(
				"SELECT TOP 1 1 FROM GlassesOrderT "
				"LEFT JOIN BillsT ON GlassesOrderT.BillID = BillsT.ID "
				"LEFT JOIN BillCorrectionsT ON BillsT.ID = BillCorrectionsT.OriginalBillID "
				"INNER JOIN ( "
				"	SELECT DISTINCT BillID "
				"	FROM "
				"	LineItemT "
				"	INNER JOIN ChargesT ON LineItemT.ID = ChargesT.ID "
				" 	WHERE LineItemT.Deleted = 0 "
				") ChargesSubQ ON BillsT.ID = ChargesSubQ.BillID "
				"WHERE BillsT.Deleted = 0 AND BillCorrectionsT.ID IS NULL AND GlassesOrderT.ID = {INT}",
				nGlassesOrderID)){
				m_pBillingModuleWnd->MessageBox("This optical order has already been billed and cannot be billed again.", "Alert!", MB_OK | MB_ICONEXCLAMATION);
				return;
			}
			m_setBilledOpticalOrderIDs.insert(nGlassesOrderID);
		}

		/****************************************************************************************
		* Check all the items being added to make sure it fits the authorization.  This is		*
		* probably somewhat slow, but this case really should rarely come up, it just doesn't	*
		* make much sense.																		*
		****************************************************************************************/

		if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID != -1) {

			try {

				//we need to loop through every item being added and compare them against the items 
				//in our referral
				bool bOneFailed = false;

				//setup an array for all the items we'll need to be checking in the auth
				CArray<long, long> aryAuthIDs;
				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				_RecordsetPtr rsAuth = CreateParamRecordset("SELECT ServiceID FROM InsuranceReferralCPTCodesT WHERE ReferralID = {INT}", ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_nInsuranceReferralID);
				while (!rsAuth->eof) {
					aryAuthIDs.Add(AdoFldLong(rsAuth, "ServiceID"));
					rsAuth->MoveNext();
				}
				rsAuth->Close();

				// (j.jones 2008-05-01 11:53) - PLID 28606 - do not bother checking if services match
				// if the referral has no services in it
				if (aryAuthIDs.GetSize() > 0) {

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rsAuthCheck = CreateParamRecordset("SELECT ServiceID FROM GlassesOrderServiceT WHERE GlassesOrderID = {INT}", nGlassesOrderID);
					while (!rsAuthCheck->eof && !bOneFailed) {
						long nServiceID = AdoFldLong(rsAuthCheck, "ServiceID");

						bool bFound = false;
						for (int i = 0; i < aryAuthIDs.GetSize() && !bFound; i++) {
							if (aryAuthIDs.GetAt(i) == nServiceID)
								bFound = true;
						}

						if (!bFound)
							bOneFailed = true;

						rsAuthCheck->MoveNext();
					}

					if (bOneFailed) {
						// (j.dinatale 2012-04-17 17:24) - PLID 49078 - replace glasses order with optical order
						if (MsgBox(MB_YESNO, "At least one item selected on this Optical Order does not match your insurance authorization.\n"
							"Are you sure you wish to add this Optical Order?") == IDNO) {
							return;
						}
					}
				}

			} NxCatchAll("Error determining authorization status for the Optical Order.");
		}


		/************************************
		* Bill the Optical Order	        *
		*************************************/

		/* Open the list of services from the Optical Order */

		// (j.dinatale 2012-04-18 17:20) - PLID 49713 - need to select the primary vision insurance if we have one
		// (j.dinatale 2012-06-05 11:11) - PLID 49713 - we now are deciding to select the insured party on the glasses order
		_RecordsetPtr rsInsToBill = CreateParamRecordset(
			"SELECT InsuredPartyID, RespTypeT.TypeName AS RespName, InsuranceCoT.Name AS InsName "
			"FROM GlassesOrderT "
			"LEFT JOIN InsuredPartyT ON GlassesOrderT.InsuredPartyID = InsuredPartyT.PersonID "
			"LEFT JOIN RespTypeT ON InsuredPartyT.RespTypeID = RespTypeT.ID "
			"LEFT JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
			"WHERE GlassesOrderT.ID = {INT}", nGlassesOrderID);

		long nInsuredPartyID = -1;
		CString strInsName = "";
		CString strRespTypeName = "";

		if (!rsInsToBill->eof){
			nInsuredPartyID = AdoFldLong(rsInsToBill, "InsuredPartyID", -1);
			strInsName = AdoFldString(rsInsToBill, "InsName", "");
			strRespTypeName = AdoFldString(rsInsToBill, "RespName", "");
		}

		m_listBillTo->SetSelByColumn(btcInsuredPartyID, nInsuredPartyID);

		// (j.dinatale 2012-06-05 11:11) - PLID 49713 - if we dont have an insured party, we cant batch this so clear out the insurance tab
		if (nInsuredPartyID < 0){
			ClearInsuranceTabInsPlans();
		}

		// (j.dinatale 2012-05-23 17:56) - PLID 49713 - need to select resp based on if we have any vision resp or not, due to the
		//		auto update bill description feature.
		bool bHasVisionRespAmounts = !!ReturnsRecordsParam(
			"SELECT TOP 1 1 FROM GlassesOrderServiceT "
			"LEFT JOIN ServiceT ON GlassesOrderServiceT.ServiceID = ServiceT.ID "
			"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
			"WHERE GlassesOrderServiceT.GlassesOrderID = {INT} "
			"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
			"AND COALESCE(VisionRespAmt, 0) > 0 ", nGlassesOrderID);

		// (j.dinatale 2012-05-30 09:25) - PLID 49731 - need this to be higher up
		// (j.dinatale 2012-04-25 14:36) - PLID 49690 - prompt and let the user know if vision resp is going to end up as patient resp
		if (nInsuredPartyID < 0 && bHasVisionRespAmounts){
			this->MessageBox("The optical order you are trying to bill contains line items that have insurance resp. amounts and no insurance selected. "
				"All vision resp. amounts on the optical order you are trying to bill will be added back into the patient resp. amounts.",
				"Alert", MB_OK | MB_ICONEXCLAMATION);
		}

		// Update description on parent billing module dialog
		// (j.jones 2010-08-30 09:53) - PLID 32788 - added pref. to not auto-fill the bill description
		if (GetRemotePropertyInt("BillDoNotAutoFillDescription", 0, 0, "<None>", true) == 0) {
			// (j.gruber 2012-01-04 11:44) - PLID 46291
			SetBillDescriptionBasedOnResp();
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
			str = GetBillDescription();
			if (str.GetLength() == 0) {
				CString strDescription = VarString(pRow->GetValue(GLASSES_ORDERS_COLUMN_DESCRIPTION), "");
				// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
				SetBillDescription(strDescription);
			}
		}

		long nLocationID = -1;

		// (j.dinatale 2012-05-16 12:54) - PLID 50423 - pull some locationsT info that we need later
		_RecordsetPtr rsGlassesOrder = CreateParamRecordset("SELECT Date, LocationID, ProviderID, LocationsT.Managed AS Managed "
			"FROM GlassesOrderT "
			"LEFT JOIN LocationsT ON GlassesOrderT.LocationID = LocationsT.ID "
			"WHERE GlassesOrderT.ID = {INT}", nGlassesOrderID);
		if (!rsGlassesOrder->eof) {

			COleDateTime dtGlassesOrder = AdoFldDateTime(rsGlassesOrder, "Date");
			if (dtGlassesOrder.GetStatus() != COleDateTime::invalid) {
				//set the default charge date - existing functionality intends
				//for the default date to stay this way until it is changed
				m_cyDefaultChargeDate = dtGlassesOrder;
			}

			// (j.dinatale 2012-05-16 12:46) - PLID 50423 - Attempt to change the location and place of service when billing a glasses order
			nLocationID = AdoFldLong(rsGlassesOrder, "LocationID", -1);
			if (nLocationID != -1) {
				// try setting place of service
				TryChangePlaceOfService(nLocationID);

				// now, if the location is managed, then go ahead and attempt to set the bill location
				BOOL bManaged = AdoFldBool(rsGlassesOrder, "Managed");
				if (bManaged) {
					//try to change the location (it may fail due to various rules and the existing bill contents)
					TryChangeBillLocation(nLocationID);
				}
			}

			// (j.jones 2011-07-08 17:38) - PLID 32067 - added preference to default charges to no provider
			// (d.thompson 2012-08-07) - PLID 51969 - Changed default to Yes
			if (GetRemotePropertyInt("DefaultChargesNoProvider", 1, 0, "<None>", true) == 0) {
				long nProviderID = AdoFldLong(rsGlassesOrder, "ProviderID", -1);

				if (nProviderID != -1) {
					m_DefaultProvider = nProviderID;
				}
				else {
					m_DefaultProvider = m_Main_Physician;
				}
			}
			else {
				m_DefaultProvider = -1;
			}
		}
		rsGlassesOrder->Close();

		// (d.thompson 2009-07-09) - PLID 34821 - Multipliers need included when loading modifiers
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.jones 2011-03-28 16:26) - PLID 42575 - ignore non-billable CPT codes
		//TES 5/25/2011 - PLID 43837 - Added Quantity
		// (j.dinatale 2013-02-20 09:55) - PLID 54698 - need to know if the product is being sold off shelf
		m_rsBill = CreateParamRecordset("SELECT GlassesOrderServiceT.ID, GlassesOrderServiceT.ServiceID, "
			"GlassesOrderServiceT.IsOffTheShelf, "
			"GlassesOrderServiceT.Price, ServiceT.Name AS ServiceName, "
			"Convert(bit, CASE WHEN ProductT.ID Is Null THEN 0 ELSE 1 END) AS IsProduct, "
			"GlassesOrderServiceT.Quantity "
			"FROM GlassesOrderServiceT "
			"LEFT JOIN ServiceT ON GlassesOrderServiceT.ServiceID = ServiceT.ID "
			"LEFT JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
			"LEFT JOIN ProductT ON ServiceT.ID = ProductT.ID "
			"WHERE GlassesOrderServiceT.GlassesOrderID = {INT} "
			"AND (CPTCodeT.Billable Is Null OR CPTCodeT.Billable = 1) "
			, nGlassesOrderID
			);

		while (!m_rsBill->eof) {

			//TODO: We currently call the cpt and product saving code.
			//Should we implement the code in these functions here? Should we make shared code for these functions?

			long ServiceID, nGlassesOrderServiceID;

			ServiceID = AdoFldLong(m_rsBill, "ServiceID", -1);

			nGlassesOrderServiceID = AdoFldLong(m_rsBill, "ID", -1);
			BOOL bIsProduct = AdoFldBool(m_rsBill, "IsProduct", FALSE);
			//(s.dhole 3/25/2015 2:54 PM ) - PLID 61135 check if we are on billing screen and loadin sevice items
			if (m_EntryType == 1 && bIsProduct == FALSE && IsCodeSelectedBasedOnWarning(ServiceID) == FALSE)
			{
				m_rsBill->MoveNext();
				continue;
			}

			if (bIsProduct) {
				//Product

				// (j.dinatale 2013-02-20 10:01) - PLID 54698 - need to keep track of off the shelf
				bool bIsOffTheShelf = !!AdoFldBool(m_rsBill, "IsOffTheShelf", FALSE);

				//TES 5/25/2011 - PLID 43837 - Pass in the quantity
				// (j.dinatale 2012-06-06 16:05) - PLID 49713 - pass in insured party info
				if (!AddNewExternalProduct(nGlassesOrderServiceID, EXT_GLASSES_ORDER, ServiceID, AdoFldString(m_rsBill, "ServiceName", ""), AdoFldDouble(m_rsBill, "Quantity"), AdoFldCurrency(m_rsBill, "Price", COleCurrency(0, 0)), 0, -1, -1, nInsuredPartyID, strInsName, strRespTypeName, !bIsOffTheShelf)) {

					CString strName;

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					_RecordsetPtr rs = CreateParamRecordset("SELECT Name FROM ServiceT WHERE ID = {INT}", ServiceID);

					if (!rs->eof) {
						strName = AdoFldString(rs, "Name", "");
					}
					rs->Close();

					CString str;
					str.Format("The product '%s' was not able to be billed.\n"
						"If you did not manually cancel this item, please ensure that this product\n"
						"is able to be billed to the selected location, is in stock,\n"
						"and that the product has not been made inactive.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}
			else {
				//CPT Code
				// (j.dinatale 2012-06-06 16:05) - PLID 49713 - pass in insured party info
				if (!AddNewExternalCpt(nGlassesOrderServiceID, EXT_GLASSES_ORDER, nInsuredPartyID, strInsName, strRespTypeName)) {

					CString strName;

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					// (j.jones 2011-03-28 16:26) - PLID 42575 - ignore non-billable CPT codes
					_RecordsetPtr rs = CreateParamRecordset("SELECT Code + ' - ' + Name AS Description FROM ServiceT "
						"INNER JOIN CPTCodeT ON ServiceT.ID = CPTCodeT.ID "
						"WHERE ServiceT.ID = {INT} "
						"AND CPTCodeT.Billable = 1", ServiceID);

					if (!rs->eof) {
						strName = AdoFldString(rs, "Description", "");
					}
					rs->Close();

					CString str;
					str.Format("The Service Code '%s' was not able to be billed.\n"
						"Please ensure that the Code has not been made inactive.", strName);

					AfxMessageBox(str);

					m_rsBill->MoveNext();
					continue;
				}
			}



			m_rsBill->MoveNext();
		}

		m_rsBill->Close();

		/////////////////////////////////////////////////////////////////
		// Sort the list, requery it, and recalculate the bill total
		Requery();

		PostSelChosenComboBillTo(m_listBillTo->GetCurSel());
		PostChargeAdded();

		// (j.jones 2007-12-13 17:21) - PLID 27988 - Any allocations we opened, we should be done with them now,
		// so force them to be resolved. But if it returns FALSE, don't worry about it too much here,
		// ValidateChanges will require it before closing.
		if (!ForceResolveAllAllocations()) {
			AfxMessageBox("There are still unresolved allocations linked to this bill. You will need to resolve them completely before the bill can be saved.");
		}

	} NxCatchAll("Error in OnSelChosenComboGlassesOrder()");
}

// (r.gonet 08/05/2014) - PLID 63098 - Appends to a save batch SQL statements to save lab test codes linked to a charge to the database.
// - strSqlBatch - The save batch to append to. If nUpdateForChargeID is -1, the batch must include a @ChargeID variable.
// - aryParams - Save batch parameter array.
// - nUpdateForChargeID - ID of the charge to link the test codes to. -1 if the charge is new. Non-negative if it is existing.
// - pBillingItem - BillingItem associated with the charge. Should not be NULL.
// - atAuditTrans - Audit transaction to audit to.
void CBillingDlg::UpdateChargeLabTestCodes(IN OUT CString &strSqlBatch, IN OUT CNxParamSqlArray &aryParams,
	IN long nUpdateForChargeID, IN BillingItemPtr pBillingItem, IN OUT CAuditTransaction &atAuditTrans)
{
	if (!pBillingItem) {
		// (r.gonet 08/05/2014) - PLID 63098 - Odd.
		return;
	}

	//all exceptions are thrown to the caller

	// (r.gonet 08/05/2014) - PLID 63098 - -1 would indicate that this charge has not been saved to the database yet.
	BOOL bNewCharge = nUpdateForChargeID < 0;

	// (r.gonet 08/05/2014) - PLID 63098 - Goal is to save the codes to ChargeLabTestCodesT and then
	// audit if codes changed. We'll audit once as a alphanumeric sorted, comma separated string of test codes.

	// (r.gonet 08/05/2014) - PLID 63098 - Container for the IDs of the old linked lab test codes
	// We'll need this to compare against the current test codes to see if the user edited them, 
	// then audit if they did.
	std::vector<long> OldTestCodeList;
	// (r.gonet 08/05/2014) - PLID 63098 - Maps bill lab test code IDs to code numbers. We'll need this
	// in order to audit code numbers rather than internal database IDs.
	std::map<long, CString> mapTestCodeIDToTestCode;

	// (r.gonet 08/05/2014) - PLID 63098 - Get the code numbers associated with the new linked test code IDs.
	CParamSqlBatch sqlTestCodes;
	sqlTestCodes.Add(
		"SELECT BillLabTestCodesT.ID, BillLabTestCodesT.Code "
		"FROM BillLabTestCodesT "
		"WHERE BillLabTestCodesT.ID IN ({INTVECTOR}) "
		, pBillingItem->TestCodeList);
	if (!bNewCharge) {
		// (r.gonet 08/05/2014) - PLID 63098 - The charge is not new. Get the test code ids and numbers of the old linked
		// test codes.
		sqlTestCodes.Add(
			"SELECT BillLabTestCodesT.ID, BillLabTestCodesT.Code "
			"FROM BillLabTestCodesT "
			"INNER JOIN ChargeLabTestCodesT ON BillLabTestCodesT.ID = ChargeLabTestCodesT.BillLabTestCodeID "
			"INNER JOIN ChargesT ON ChargeLabTestCodesT.ChargeID = ChargesT.ID "
			"WHERE ChargesT.ID = {INT}; "
			, nUpdateForChargeID);
	}
	_RecordsetPtr prsTestCodes = sqlTestCodes.CreateRecordset(GetRemoteDataSnapshot());
	// (r.gonet 08/05/2014) - PLID 63098 - Start mapping code ids to code numbers so we can audit by code number later. 
	// We'll need code numbers for each code id we use in the old lab test code vector and the new lab test code vector.
	while (!prsTestCodes->eof) {
		long nTestCodeID = AdoFldLong(prsTestCodes->Fields, "ID");
		CString strTestCode = AdoFldString(prsTestCodes->Fields, "Code");
		mapTestCodeIDToTestCode[nTestCodeID] = strTestCode;
		prsTestCodes->MoveNext();
	}
	if (!bNewCharge) {
		prsTestCodes = prsTestCodes->NextRecordset(NULL);
		// (r.gonet 08/05/2014) - PLID 63098 - Get the old lab test code ids into a vector, and also contribute to the
		// map of code ids to numbers so we can audit by code number later.
		while (!prsTestCodes->eof) {
			long nTestCodeID = AdoFldLong(prsTestCodes->Fields, "ID");
			CString strTestCode = AdoFldString(prsTestCodes->Fields, "Code");
			OldTestCodeList.push_back(nTestCodeID);
			mapTestCodeIDToTestCode[nTestCodeID] = strTestCode;
			prsTestCodes->MoveNext();
		}
	}
	prsTestCodes->Close();

	// (r.gonet 08/05/2014) - PLID 63098 - May need to audit if test codes changed.
	if (!bNewCharge) {
		// (r.gonet 08/05/2014) - PLID 63098 - Before we compare, the lists have to be sorted.
		std::sort(OldTestCodeList.begin(), OldTestCodeList.end());
		std::sort(pBillingItem->TestCodeList.begin(), pBillingItem->TestCodeList.end());
		if (OldTestCodeList != pBillingItem->TestCodeList) {
			// (r.gonet 08/05/2014) - PLID 63098 - They did indeed change. We need to construct strings
			// of ordered, comma-separated test code numbers. Start with vectors, sort them, then make them strings.
			std::vector<CString> vecOldTestCodes, vecNewTestCodes;
			for each(long nTestCodeID in OldTestCodeList)
			{
				std::map<long, CString>::iterator it;
				// (r.gonet 08/05/2014) - PLID 63098 - Get the code number from the code id.
				if ((it = mapTestCodeIDToTestCode.find(nTestCodeID)) != mapTestCodeIDToTestCode.end()) {
					CString strCode = it->second;
					vecOldTestCodes.push_back(strCode);
				} else {
					// (r.gonet 08/05/2014) - PLID 63098 - Shouldn't ever occur since we added them
					// in this function.
					ThrowNxException("%s : Map does not contain a test code number for test code ID = %li", __FUNCTION__, nTestCodeID);
				}
			}
			for each(long nTestCodeID in pBillingItem->TestCodeList)
			{
				std::map<long, CString>::iterator it;
				// (r.gonet 08/05/2014) - PLID 63098 - Get the code number from the code id.
				if ((it = mapTestCodeIDToTestCode.find(nTestCodeID)) != mapTestCodeIDToTestCode.end()) {
					CString strCode = it->second;
					vecNewTestCodes.push_back(strCode);
				} else {
					// (r.gonet 08/05/2014) - PLID 63098 - Shouldn't ever occur since we added them
					// in this function.
					ThrowNxException("%s : Map does not contain a test code number for test code ID = %li", __FUNCTION__, nTestCodeID);
				}
			}

			// (r.gonet 08/05/2014) - PLID 63098 - Sort each vector of code numbers so it displays nice and orderd in auditing.
			std::sort(vecOldTestCodes.begin(), vecOldTestCodes.end());
			std::sort(vecNewTestCodes.begin(), vecNewTestCodes.end());

			// (r.gonet 08/05/2014) - PLID 63098 - Construct the new and old values for auditing.
			CString strOldValue, strNewValue;
			for each(CString strTestCode in vecOldTestCodes)
			{
				if (strOldValue != "") {
					strOldValue += ", ";
				}
				if (strOldValue.GetLength() + strTestCode.GetLength() > 3000) {
					// (r.gonet 08/05/2014) - PLID 63098 - Auditing value is too long. Truncate it.
					strOldValue += "...";
					break;
				} else {
					strOldValue += strTestCode;
				}
			}
			for each(CString strTestCode in vecNewTestCodes)
			{
				if (strNewValue != "") {
					strNewValue += ", ";
				}
				if (strNewValue.GetLength() + strTestCode.GetLength() > 3000) {
					// (r.gonet 08/05/2014) - PLID 63098 - Auditing value is too long. Truncate it.
					strNewValue += "...";
					break;
				} else {
					strNewValue += strTestCode;
				}
			}

			// (r.gonet 08/05/2014) - PLID 63098 - Next two are required for auditing the charge.
			CString strPatientName = GetBillPatientName();
			COleCurrency LT = (pBillingItem->LineTotal.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(pBillingItem->LineTotal, COleCurrency(0, 0));

			// (r.gonet 08/05/2014) - PLID 63098 - Prepend the charge so they know which charge the list of test codes is for.
			strOldValue = FormatString("%s charge: %s", FormatCurrencyForInterface(LT), strOldValue);
			AuditEvent(m_nPatientID, strPatientName, atAuditTrans, aeiChargeLabTestCodesChanged, nUpdateForChargeID, strOldValue, strNewValue, aepMedium, aetChanged);

			// (r.gonet 08/05/2014) - PLID 63098 - Now save the test code changes to the database.
			AddParamStatementToSqlBatch(strSqlBatch, aryParams,
				"DELETE FROM ChargeLabTestCodesT "
				"WHERE ChargeID = {INT}; "
				, nUpdateForChargeID);
			AddParamStatementToSqlBatch(strSqlBatch, aryParams,
				"INSERT INTO ChargeLabTestCodesT (ChargeID, BillLabTestCodeID) "
				"SELECT ChargesT.ID, BillLabTestCodesT.ID "
				"FROM ChargesT "
				"CROSS JOIN BillLabTestCodesT "
				"WHERE ChargesT.ID = {INT} AND BillLabTestCodesT.ID IN ({INTVECTOR}) "
				, nUpdateForChargeID, pBillingItem->TestCodeList);
		}
	} else {
		// (r.gonet 08/05/2014) - PLID 63098 - Save the test code changes to the database.
		AddParamStatementToSqlBatch(strSqlBatch, aryParams,
			"INSERT INTO ChargeLabTestCodesT (ChargeID, BillLabTestCodeID) "
			"SELECT ChargesT.ID, BillLabTestCodesT.ID "
			"FROM ChargesT "
			"CROSS JOIN BillLabTestCodesT "
			"WHERE ChargesT.ID = @ChargeID AND BillLabTestCodesT.ID IN ({INTVECTOR}) "
			, pBillingItem->TestCodeList);
	}
}

// (j.jones 2011-04-27 17:38) - PLID 43405 - moved the ChargeRespT logic to its own function
void CBillingDlg::UpdateChargeRespT(IN OUT CString &strSqlBatch, IN OUT CNxParamSqlArray &aryParams,
	IN long nUpdateForChargeID, IN BillingItemPtr pBillingItem, IN OUT CAuditTransaction &atAuditTrans,
	IN COleDateTime dtNewInputDate)
{
	//all exceptions are thrown to the caller

	BOOL bNewCharge = nUpdateForChargeID < 0;

	CString strPatientName = GetBillPatientName();

	COleCurrency LT, IR;	//LineTotal, InsResp

	//TS:  Let's use VarCurrency, it's typesafe, and some weird values have been showing up in ChargeRespT, they might have come from here.
	//LT is the total amount of this charge
	LT = (pBillingItem->LineTotal.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(pBillingItem->LineTotal, COleCurrency(0, 0));

	//PatResp is starting out at the LineTotal.  As we loop through each resp, decrement the insurance
	//amount from PatResp.  When we're done, whatever is left will be the Patient Resp
	COleCurrency patResp = LT;

	/////////////////////////////////////////
	//This code needs to loop over all available resps, instead of hard-coded pri/sec/inactive
	RPCList* list = pBillingItem->RPCList;

	BOOL bCreatedResp = FALSE;

	for (int j = 0; j < list->aryRPC.GetSize(); j++) {
		RespPerCharge rpc = list->aryRPC.GetAt(j);

		IR = (rpc.InsAmount.vt == VT_EMPTY) ? COleCurrency(0, 0) : VarCurrency(rpc.InsAmount, COleCurrency(0, 0));

		//Add/Update each Resp
		if (rpc.InsAmount.vt != VT_NULL && rpc.InsAmount.vt != VT_EMPTY) {
			// (j.jones 2007-02-27 17:38) - PLID 24844 - pull the Amount for auditing purposes
			//DRT 10/21/2008 - PLID 31774 - Parameterized
			// (j.jones 2011-04-28 09:03) - PLID 43405 - skip this if it's a new charge
			//(a.wilson 2011-9-21) PLID 44949
			_RecordsetPtr rsResp;
			if (!bNewCharge) {
				rsResp = CreateParamRecordset("SELECT ChargeRespT.ID, ChargeRespT.Amount, "
					"LineItemT.Amount AS OrigTotal FROM ChargeRespT LEFT JOIN LineItemT ON "
					"ChargeID = LineItemT.ID WHERE ChargeID = {INT} AND InsuredPartyID = {INT}", nUpdateForChargeID, VarLong(rpc.InsuredPartyID));
			}
			if (bNewCharge || rsResp->eof) {
				//nothing exists for this charge, we need to add new items
				long nInsRespID = VarLong(rpc.InsuredPartyID);
				if (nInsRespID != -1) {
					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					// (j.armen 2013-06-28 15:03) - PLID 57383 - Idenitate ChargeRespT
					AddParamStatementToSqlBatch(strSqlBatch, aryParams, "INSERT INTO ChargeRespT (ChargeID, InsuredPartyID, Amount) VALUES (@ChargeID, {INT}, {OLECURRENCY})", nInsRespID, IR);
					AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespID = SCOPE_IDENTITY() ");

					//track that we created a resp
					bCreatedResp = TRUE;

					// (j.jones 2007-02-27 17:41) - PLID 24844 - audit the change
					if (!bNewCharge && IR != COleCurrency(0, 0)) {
						CString strOld, strNew;
						//show the dollar amount, insco name, resp type name
						strOld.Format("%s (of a %s charge) for %s (%s)", FormatCurrencyForInterface(COleCurrency(0, 0)), FormatCurrencyForInterface(LT), VarString(rpc.InsuranceCoName, ""), VarString(rpc.RespTypeName, ""));
						strNew.Format("%s (of a %s charge) for %s (%s)", FormatCurrencyForInterface(IR), FormatCurrencyForInterface(LT), VarString(rpc.InsuranceCoName, ""), VarString(rpc.RespTypeName, ""));
						AuditEvent(m_nPatientID, strPatientName, atAuditTrans, aeiResponsibilityEdited, nUpdateForChargeID, strOld, strNew, aepHigh, aetChanged);
					}

					//if the Charge Resp doesn't exist for this charge, then neither does the ChargeRespDetail
					//so just add it
					COleDateTime dtDate;
					if (GetRemotePropertyInt("DefaultAssignmentToInputDate", 0, 0, "<None>", true)) {
						//This was set way the hell up in this function, but it should still be valid.
						dtDate = dtNewInputDate;
					}
					else {
						// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
						dtDate = (m_peditBillDate->GetValue());
					}
					dtDate.SetDateTime(dtDate.GetYear(), dtDate.GetMonth(), dtDate.GetDay(), 0, 0, 0);

					// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
					// (j.armen 2013-06-28 16:49) - PLID 57384 - Idenitate ChargeRespDetailT
					AddParamStatementToSqlBatch(strSqlBatch, aryParams, "INSERT INTO ChargeRespDetailT (ChargeRespID, Amount, Date) VALUES "
						" (@ChargeRespID, {OLECURRENCY}, {OLEDATETIME}) ", IR, COleDateTime(dtDate.GetYear(), dtDate.GetMonth(), dtDate.GetDay(), 0, 0, 0));

					((CBillingModuleDlg*)m_pBillingModuleWnd)->m_bInsurance = TRUE;
					patResp -= IR;	//decrement the pat resp by what we just put in as insurance resp
				}
			}
			else if (!bNewCharge && !rsResp->eof) {
				//we need to update an existing ChargeResp
				// (j.jones 2007-02-27 17:38) - PLID 24844 - grab the old amount for auditing
				COleCurrency cyOldAmount = AdoFldCurrency(rsResp, "Amount", COleCurrency(0, 0));
				//(a.wilson 2011-9-21) PLID 44949
				COleCurrency cyOriginalTotal = AdoFldCurrency(rsResp, "OrigTotal", COleCurrency(0, 0));
				long nChargeRespID = AdoFldLong(rsResp, "ID");

				// (j.jones 2011-04-28 09:06) - PLID 43405 - add to our batch
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespID = {INT}", nChargeRespID);

				// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
				AddParamStatementToSqlBatch(strSqlBatch, aryParams, "UPDATE ChargeRespT SET Amount = {OLECURRENCY} WHERE ChargeID = @ChargeID AND InsuredPartyID = {INT}", IR, VarLong(rpc.InsuredPartyID));

				// (j.jones 2007-02-27 17:41) - PLID 24844 - audit the change
				if (!bNewCharge && IR != cyOldAmount && (cyOldAmount != COleCurrency(0, 0) || IR != COleCurrency(0, 0))) {
					CString strOld, strNew;
					//(a.wilson 2011-9-21) PLID 44949 - need replace with correct oldtotal
					//show the dollar amount, insco name, resp type name
					strOld.Format("%s (of a %s charge) for %s (%s)", FormatCurrencyForInterface(cyOldAmount), FormatCurrencyForInterface(cyOriginalTotal), VarString(rpc.InsuranceCoName, ""), VarString(rpc.RespTypeName, ""));
					strNew.Format("%s (of a %s charge) for %s (%s)", FormatCurrencyForInterface(IR), FormatCurrencyForInterface(LT), VarString(rpc.InsuranceCoName, ""), VarString(rpc.RespTypeName, ""));
					AuditEvent(m_nPatientID, strPatientName, atAuditTrans, aeiResponsibilityEdited, nUpdateForChargeID, strOld, strNew, aepHigh, aetChanged);
				}

				//Set the date and then call the appropriate function
				COleDateTime dtDate;
				if (GetRemotePropertyInt("DefaultAssignmentToInputDate", 0, 0, "<None>", true)) {
					//This was set way the hell up in this function, but it should still be valid.
					dtDate = dtNewInputDate;
				}
				else {
					// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
					dtDate = (m_peditBillDate->GetValue());
				}
				dtDate.SetDateTime(dtDate.GetYear(), dtDate.GetMonth(), dtDate.GetDay(), 0, 0, 0);
				UpdateChargeRespDetails(strSqlBatch, aryParams, nChargeRespID, m_bUpdateDate, m_dtOldDate, dtDate, IR);


				((CBillingModuleDlg*)m_pBillingModuleWnd)->m_bInsurance = TRUE;
				patResp -= IR;	//decrement the pat resp by what we just put in as insurance resp
			}
		}
	}

	/////////////////////////////
	////Add/Update Patient Resp
	//JJ - this looks complicated, but it is used to ensure the correct state of ChargeRespT;
	BOOL b_NoChargeResp, b_NoPatResp;
	COleCurrency cyOldAmount = COleCurrency(0, 0);
	//(a.wilson 2011-9-21) PLID 44949
	COleCurrency cyOriginalTotal = COleCurrency(0, 0);

	// (j.jones 2011-04-28 09:03) - PLID 43405 - skip this if it's a new charge
	if (bNewCharge) {
		b_NoChargeResp = !bCreatedResp;
		b_NoPatResp = TRUE;
	}
	else {
		//(a.wilson 2011-9-21) PLID 44949 - addded lineitemt join for original total
		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.jones 2007-02-27 17:38) - PLID 24844 - pull the Amount for auditing purposes
		//DRT 10/21/2008 - PLID 31774 - Parameterized
		_RecordsetPtr rsResp = CreateParamRecordset("SELECT ID FROM ChargeRespT WHERE ChargeID = {INT} \r\n"
			"SELECT ChargeRespT.ID, ChargeRespT.Amount, LineItemT.Amount AS OrigTotal FROM ChargeRespT "
			"LEFT JOIN LineItemT ON ChargeID = LineItemT.ID "
			"WHERE ChargeID = {INT} AND InsuredPartyID Is Null", nUpdateForChargeID, nUpdateForChargeID);
		if (rsResp->eof)
			b_NoChargeResp = TRUE;
		else
			b_NoChargeResp = FALSE;

		rsResp = rsResp->NextRecordset(NULL);

		if (rsResp->eof)
			b_NoPatResp = TRUE;
		else {
			b_NoPatResp = FALSE;

			// (j.jones 2007-02-27 17:38) - PLID 24844 - grab the old amount for auditing
			cyOldAmount = AdoFldCurrency(rsResp, "Amount", COleCurrency(0, 0));
			//(a.wilson 2011-9-21) PLID 44949 - get original total
			cyOriginalTotal = AdoFldCurrency(rsResp, "OrigTotal", COleCurrency(0, 0));
		}

		rsResp->Close();
	}

	//if there are no ChargeResp records, or none with patient responsibility and there is patient responsibility, add a new record
	if (b_NoChargeResp || (patResp > COleCurrency(0, 0) && b_NoPatResp)) {

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.armen 2013-06-28 15:03) - PLID 57383 - Idenitate ChargeRespT
		AddParamStatementToSqlBatch(strSqlBatch, aryParams, "INSERT INTO ChargeRespT (ChargeID, InsuredPartyID, Amount) VALUES (@ChargeID, NULL, {OLECURRENCY})", patResp);
		AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespID = SCOPE_IDENTITY() ");

		// (j.jones 2007-02-27 17:41) - PLID 24844 - audit the change
		if (!bNewCharge && patResp != COleCurrency(0, 0)) {
			CString strOld, strNew;
			//show the dollar amount, and that it was patient
			strOld.Format("%s (of a %s charge) for Patient", FormatCurrencyForInterface(COleCurrency(0, 0)), FormatCurrencyForInterface(LT));
			strNew.Format("%s (of a %s charge) for Patient", FormatCurrencyForInterface(patResp), FormatCurrencyForInterface(LT));
			AuditEvent(m_nPatientID, strPatientName, atAuditTrans, aeiResponsibilityEdited, nUpdateForChargeID, strOld, strNew, aepHigh, aetChanged);
		}

		//we just have to insert into chargeRespDetailsT because there is no ChargeResp for patient resp. yet, so there can't be a chargeREspDetail
		COleDateTime dtDate;
		if (GetRemotePropertyInt("DefaultAssignmentToInputDate", 0, 0, "<None>", true)) {
			//This was set way the hell up in this function, but it should still be valid.
			dtDate = dtNewInputDate;
		}
		else {
			// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
			dtDate = (m_peditBillDate->GetValue());
		}
		dtDate.SetDateTime(dtDate.GetYear(), dtDate.GetMonth(), dtDate.GetDay(), 0, 0, 0);

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		// (j.armen 2013-06-28 16:49) - PLID 57384 - Idenitate ChargeRespDetailT
		AddParamStatementToSqlBatch(strSqlBatch, aryParams, "INSERT INTO ChargeRespDetailT (ChargeRespID, Amount, Date) VALUES "
			" (@ChargeRespID, {OLECURRENCY}, {OLEDATETIME}) ", patResp, dtDate);
	}
	//otherwise there exists a patresp record and it needs to stay there, so keep it there and update the info
	else if (!b_NoPatResp) {

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		AddParamStatementToSqlBatch(strSqlBatch, aryParams, "UPDATE ChargeRespT SET Amount = {OLECURRENCY} WHERE ChargeID = @ChargeID AND InsuredPartyID Is Null", patResp);

		// (j.jones 2007-02-27 17:41) - PLID 24844 - audit the change
		if (!bNewCharge && patResp != cyOldAmount && (cyOldAmount != COleCurrency(0, 0) || patResp != COleCurrency(0, 0))) {
			CString strOld, strNew;
			//(a.wilson 2011-9-21) PLID 44949 - fixed so that it shows the correct charge amount.
			//show the dollar amount, and that it was patient
			strOld.Format("%s (of a %s charge) for Patient", FormatCurrencyForInterface(cyOldAmount), FormatCurrencyForInterface(cyOriginalTotal));
			strNew.Format("%s (of a %s charge) for Patient", FormatCurrencyForInterface(patResp), FormatCurrencyForInterface(LT));
			AuditEvent(m_nPatientID, strPatientName, atAuditTrans, aeiResponsibilityEdited, nUpdateForChargeID, strOld, strNew, aepHigh, aetChanged);
		}

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		_RecordsetPtr rsID = CreateParamRecordset("SELECT ID FROM ChargeRespT WHERE ChargeID = {INT} AND InsuredPartyID IS NULL", nUpdateForChargeID);
		if (!rsID->eof) {
			//Update ChargeRespDetailT
			long nChargeRespID = AdoFldLong(rsID, "ID");

			COleDateTime dtDate;
			if (GetRemotePropertyInt("DefaultAssignmentToInputDate", 0, 0, "<None>", true)) {
				//This was set way the hell up in this function, but it should still be valid.
				dtDate = dtNewInputDate;
			}
			else {
				// (a.walling 2008-05-13 15:28) - PLID 27591 - VarDateTime not needed any longer
				dtDate = (m_peditBillDate->GetValue());
			}
			dtDate.SetDateTime(dtDate.GetYear(), dtDate.GetMonth(), dtDate.GetDay(), 0, 0, 0);
			UpdateChargeRespDetails(strSqlBatch, aryParams, nChargeRespID, m_bUpdateDate, m_dtOldDate, dtDate, patResp);
		}
		rsID->Close();
	}

	//JMJ 2/16/2004 - Right now, LT is the calculated Line Total, with tax, discounts, modifiers, etc.
	//So sum up the charge resps and ASSERT if they don't match
	// (j.jones 2011-04-28 09:20) - PLID 43405 - this is now added to the batch

	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SET @ChargeRespTotalToCheck = COALESCE((SELECT Sum(Amount) AS Total FROM ChargeRespT WHERE ChargeID = @ChargeID), 0)");
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "IF @ChargeRespTotalToCheck <> {OLECURRENCY} "
		"BEGIN RAISERROR('The charge cannot be saved because its ChargeRespT responsibilites do not match the line total.', 16, 1) ROLLBACK TRAN RETURN END", LT);

	//similarly throw an exception if any ChargeRespT record for this charge mismatches the ChargeRespDetailT total underneath it
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "SELECT "
		"@ChargeRespIDToCheck = ChargeRespT.ID, "
		"@ChargeRespInsuredPartyIDToCheck = ChargeRespT.InsuredPartyID, "
		"@ChargeRespAmountToCheck = ChargeRespT.Amount, "
		"@ChargeRespDetailTotalToCheck = Sum(IsNull(ChargeRespDetailT.Amount, Convert(money,0))) "
		"FROM ChargeRespT "
		"LEFT JOIN ChargeRespDetailT ON ChargeRespT.ID = ChargeRespDetailT.ChargeRespID "
		"WHERE ChargeRespT.ChargeID = @ChargeID "
		"GROUP BY ChargeRespT.ID, ChargeRespT.InsuredPartyID, ChargeRespT.Amount "
		"HAVING ChargeRespT.Amount <> Sum(IsNull(ChargeRespDetailT.Amount, Convert(money, 0)))");
	AddParamStatementToSqlBatch(strSqlBatch, aryParams, "IF @ChargeRespIDToCheck Is Not Null \r\n"
		"BEGIN \r\n"
		"SET @errorText = 'The charge ID ' + Convert(nvarchar, @ChargeID) + ' cannot be saved because its ChargeRespDetailT responsibilites do not match the ChargeRespT responsibility total.\n\n"
		"ChargeRespT.ID = ' + Convert(nvarchar, @ChargeRespIDToCheck) + ', ChargeRespT.InsuredPartyID = ' + Convert(nvarchar, IsNull(@ChargeRespInsuredPartyIDToCheck, -1)) + ', "
		"ChargeRespT.Amount = ' + Convert(nvarchar, @ChargeRespAmountToCheck) + ', ChargeRespDetailT Total = ' + Convert(nvarchar, @ChargeRespDetailTotalToCheck); \r\n"
		"RAISERROR(@errorText, 16, 1) ROLLBACK TRAN RETURN \r\n"
		"END");
}

// (j.jones 2011-04-28 10:03) - PLID 43405 - there is a batch save
// for both creating and updating charges, both batches need the same
// declared variables, so this function prevents duplicate code
void CBillingDlg::DeclareVariablesForChargeSave(IN OUT CString &strSqlBatch)
{
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeID INT");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespID INT");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailID INT");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ApplyDetailID INT");
	
	//variables for validating content before committing the batch
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespTotalToCheck money");			//used both when checking the total ChargeRespT value against the line total
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespIDToCheck INT");				//used when validating one ChargeRespT against its ChargeRespDetailT total
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespInsuredPartyIDToCheck INT");	//used when validating one ChargeRespT against its ChargeRespDetailT total
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespAmountToCheck money");		//used when validating one ChargeRespT against its ChargeRespDetailT total
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailTotalToCheck money");	//used when validating one ChargeRespT against its ChargeRespDetailT total
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @errorText nvarchar(max)");				//used when formatting a complex error

	// (j.jones 2015-02-03 16:17) - PLID 64501 - added more variables for complex charge resp calculations
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailUpdate_ChargeRespID INT");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailUpdate_ChargeRespDetailID INT");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailUpdate_NewDate DATETIME");
	AddDeclarationToSqlBatch(strSqlBatch, "DECLARE @ChargeRespDetailUpdate_AmtToAdd MONEY");
}

// (s.dhole 2011-05-17 10:38) - PLID 33666 return comma separated dig code string
// (j.gruber 2014-03-21 13:00) - PLID 61494 - no longer used - removed
//CString CBillingDlg::GetDiagCodesExtStr( CString strDiags)

// (s.dhole 2011-06-10 14:19) - PLID 33666 This function will return diag code
CString CBillingDlg::GetDiagCodes(NXDATALISTLib::_DNxDataListPtr pDiagCombo, long nDiagID)
{
	CString strResult = "";
	if (pDiagCombo->CurSel != -1)	{
		strResult = VarString(pDiagCombo->GetValue(pDiagCombo->GetCurSel(), 1), "");
	}
	else{
		// this will fire if there is inactie code selection 
		_RecordsetPtr rsCode = CreateParamRecordset("SELECT CodeNumber FROM DiagCodes WHERE ID = {INT}", nDiagID);
		if (!rsCode->eof) {
			strResult = AdoFldString(rsCode, "CodeNumber", "");
		}
	}
	return strResult;
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - returns true if any charge
// is an "original" or "void" charge, and therefore read only
BOOL CBillingDlg::HasOriginalOrVoidCharge()
{
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr bi = m_billingItems[i];
		if (VarBool(bi->IsOriginalCharge, FALSE) || VarBool(bi->IsVoidingCharge, FALSE)) {
			//this is an original or a void charge
			return TRUE;
		}
	}

	//no original or void charges were found
	return FALSE;
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - Returns true if any charge
// is NOT an "original" or "void" charge, and therefore writeable.
// nLineIDToSkip is if you only want to check other lines, and skip one you
// may already be editing.
BOOL CBillingDlg::HasUncorrectedCharge(long nLineIDToSkip /*= -1*/)
{
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr bi = m_billingItems[i];
		if (VarLong(bi->LineID) != nLineIDToSkip
			&& !VarBool(bi->IsOriginalCharge, FALSE) && !VarBool(bi->IsVoidingCharge, FALSE)) {
			//this charge is writeable
			return TRUE;
		}
	}

	//no writeable were found
	return FALSE;
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - returns true if the given charge
// is an "original" or "void" charge, and therefore read only
// (r.gonet 2016-02-06 16:46) - PLID 68193 - Now const.
BOOL CBillingDlg::IsOriginalOrVoidCharge(long nChargeID) const
{
	//new charges & quote charges can't be corrected
	if (nChargeID == -2 || m_EntryType != 1) {
		return FALSE;
	}

	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr bi = m_billingItems[i];
		if (VarLong(bi->ChargeID) == nChargeID) {
			if (VarBool(bi->IsOriginalCharge, FALSE) || VarBool(bi->IsVoidingCharge, FALSE)) {
				return TRUE;
			}
		}
	}

	return FALSE;
}

// (r.goldschmidt 2016-03-08 09:34) - PLID 68541 - UB04 Enhancements - get the min and max dates out list of billing items
void CBillingDlg::GetMinAndMaxChargeDates(COleDateTime& dtMinDate, COleDateTime& dtMaxDate, bool excludeUnbatched /*= true */, bool excludeOriginalOrVoidCharge /* = true */) 
{
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr bi = m_billingItems[i];
		// if we are excluding unbatched, skip it if so, otherwise include
		if (excludeUnbatched ? VarBool(bi->Batched, TRUE) : TRUE) {
			// if we are excluding original or void, skip it if so, otherwise include
			if (excludeOriginalOrVoidCharge ? (m_EntryType != 1 || VarLong(bi->ChargeID) == -2 || !(VarBool(bi->IsOriginalCharge, FALSE) || VarBool(bi->IsVoidingCharge, FALSE))) : TRUE) {
				COleDateTime dtChargeDate = VarDateTime(bi->Date, g_cdtInvalid);
				if (dtChargeDate.GetStatus() == COleDateTime::valid) {
					if (dtMinDate.GetStatus() != COleDateTime::valid || dtChargeDate.m_dt < dtMinDate.m_dt) {
						dtMinDate = dtChargeDate;
					}
				}
				// (r.goldschmidt 2016-03-14 12:53) - PLID 68541 - UB04 Enhancements - Get date defaults; there is a separate field for ServiceDateTo
				COleDateTime dtChargeDateTo = VarDateTime(bi->ServiceDateTo, g_cdtInvalid);
				if (dtChargeDateTo.GetStatus() == COleDateTime::valid) {
					if (dtMaxDate.GetStatus() != COleDateTime::valid || dtChargeDateTo.m_dt > dtMaxDate.m_dt) {
						dtMaxDate = dtChargeDateTo;
					}
				}
			}
		}		
	}
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - added OnSelChangedComboPlaceofservice
void CBillingDlg::OnSelChangedComboPlaceofservice(long nNewSel)
{
	try {

		long nNewPlaceOfServiceID = -1;
		if (nNewSel != -1) {
			nNewPlaceOfServiceID = VarLong(m_PlaceOfServiceCombo->GetValue(nNewSel, 0), -1);
		}

		if (m_nCurPlaceOfServiceID == nNewPlaceOfServiceID) {
			//nothing changed
			return;
		}

		// (j.jones 2011-08-24 08:41) - PLID 44868 - disallow this if any charge
		// is an original or void charge
		if (m_EntryType == 1 && GetBillID() != -1
			&& HasOriginalOrVoidCharge()) {

			MessageBox("At least one charge on this bill has been corrected, and cannot have its place of service changed.\n\n"
				"If you need to change the place of service on this bill, you must exit the bill and right click on it in "
				"the Billing tab and choose \"Correct Bill\" to make a new corrected copy.", "Practice", MB_ICONINFORMATION | MB_OK);

			m_PlaceOfServiceCombo->SetSelByColumn(0, m_nCurPlaceOfServiceID);
			return;
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - TryChangeBillLocation will
// attempt to switch to the new location ID, returns FALSE if the change
// could not be made
BOOL CBillingDlg::TryChangeBillLocation(long nNewLocationID)
{
	//throw exceptions to the caller

	//if they didn't change the selection, return TRUE, because
	//the selection is what we want it to be
	if (m_nCurLocationID == nNewLocationID) {
		return TRUE;
	}

	// (j.jones 2011-08-24 08:41) - PLID 44868 - the location cannot change
	// on a bill that has an original or void charge
	if (m_EntryType == 1 && GetBillID() != -1
		&& HasOriginalOrVoidCharge()) {

		return FALSE;
	}

	// (j.jones 2007-12-14 11:47) - PLID 27988 - disallow changing locations
	// if we have any allocations currently in use on this bill
	if (m_paryAllocationInfo.GetSize() > 0 || HasChargesLinkedToAllocations()) {
		return FALSE;
	}

	// (j.politis 2015-07-06 11:36) - PLID 65949 - Getting error when try to open edit a bill has  active location but not managed !
	// if you edit any bill for that loaction ( Dr.John Vine )  will give you the error .
	ChangeLocationComboSelection(nNewLocationID, TRUE);
	return TRUE;
}

// (j.jones 2011-08-24 08:41) - PLID 44868 - TryChangePlaceOfService will
// attempt to switch to the new POS ID, returns FALSE if the change
// could not be made
BOOL CBillingDlg::TryChangePlaceOfService(long nNewPlaceOfServiceID)
{
	//throw exceptions to the caller

	//if they didn't change the selection, return TRUE, because
	//the selection is what we want it to be
	if (m_nCurPlaceOfServiceID == nNewPlaceOfServiceID) {
		return TRUE;
	}

	// (j.jones 2011-08-24 08:41) - PLID 44868 - the POS cannot change
	// on a bill that has an original or void charge
	if (m_EntryType == 1 && GetBillID() != -1
		&& HasOriginalOrVoidCharge()) {

		return FALSE;
	}

	m_PlaceOfServiceCombo->SetSelByColumn(0, nNewPlaceOfServiceID);
	PostPlaceOfServiceChanged();

	return TRUE;
}

// (j.jones 2011-10-06 10:23) - PLID 44941 - this function creates/recreates m_pfsCPTModifierComboSource, not used with Alberta
void CBillingDlg::RefreshCPTModifierComboSource()
{
	//Alberta billing does not use m_pfsCPTModifierComboSource
	if (UseAlbertaHLINK()) {
		return;
	}

	if (m_pfsCPTModifierComboSource == NULL) {
		//create the format settings

		IFormatSettingsPtr pfs(__uuidof(FormatSettings));

		//create the format settings
		pfs->PutDataType(VT_BSTR);
		pfs->PutFieldType(cftComboSimple);
		pfs->PutEditable(VARIANT_TRUE);
		pfs->PutConnection(_variant_t((LPDISPATCH)GetRemoteData())); //we're going to let this combo use Practice's connection		
		pfs->EmbeddedComboDropDownMaxHeight = 300;
		pfs->EmbeddedComboDropDownWidth = 200;

		m_pfsCPTModifierComboSource = pfs;
	}

	// (z.manning, 05/01/2007) - PLID 16623 - Don't show inactive modifiers.
	CString strModifierList =
		"SELECT Number AS ID, (Number + '   ' + Note) AS Text, Active "
		"FROM CPTModifierT "
		"UNION "
		"SELECT '-1' AS ID, '     (None)' AS Text, 1 "
		"ORDER BY Text ASC ";

	//in all cases, update the combo source, which will force a requery even if the query didn't change
	m_pfsCPTModifierComboSource->PutComboSource(_bstr_t(strModifierList));
}

// (j.jones 2011-10-06 11:19) - PLID 44941 - fills the four modifier columns for a row with the appropriate
// modifier combo source, whether US or Alberta, quote or a bill
void CBillingDlg::SetModifierComboSource(NXDATALIST2Lib::IRowSettingsPtr pRow, BillingItemPtr pBillItem)
{
	//the pRow should at this point be a new row that has no content in it, so we need to use
	//pBillItem if we want to look up any information on the charge that will be inserted into this row

	IFormatSettingsPtr pfs = NULL;
	if (!UseAlbertaHLINK()) {
		//not Alberta, so use our master m_pfsCPTModifierComboSource, which
		//should already be loaded, but reload it if not
		if (m_pfsCPTModifierComboSource == NULL) {
			RefreshCPTModifierComboSource();
		}
		pfs = m_pfsCPTModifierComboSource;

		if (pfs == NULL) {
			ThrowNxException("Could not load modifiers!");
		}
	}
	else {
		//for Alberta, we need a unique modifier dropdown for this service ID

		long nServiceID = VarLong(pBillItem->ServiceID, -1);
		long nItemType = VarLong(pBillItem->ItemType, -1);
		if (nItemType != ITEM_TYPE_CPT) {
			//pass in -1
			nServiceID = -1;
		}

		pfs = GetAlbertaModifierFormatSettingsForServiceID(nServiceID);

		if (pfs == NULL) {
			ThrowNxException("Could not load modifiers for service ID %li!", nServiceID);
		}
	}

	if (m_EntryType == 1) {
		//bill
		pRow->PutRefCellFormatOverride(COLUMN_MODIFIER1, pfs);
		pRow->PutRefCellFormatOverride(COLUMN_MODIFIER2, pfs);
		pRow->PutRefCellFormatOverride(COLUMN_MODIFIER3, pfs);
		pRow->PutRefCellFormatOverride(COLUMN_MODIFIER4, pfs);
	}
	else {
		//quote
		pRow->PutRefCellFormatOverride(QUOTE_COLUMN_MODIFIER1, pfs);
		pRow->PutRefCellFormatOverride(QUOTE_COLUMN_MODIFIER2, pfs);
		pRow->PutRefCellFormatOverride(QUOTE_COLUMN_MODIFIER3, pfs);
		pRow->PutRefCellFormatOverride(QUOTE_COLUMN_MODIFIER4, pfs);
	}
}

// (j.jones 2011-10-06 11:24) - PLID 44941 - Alberta service codes have a unique set of modifiers per code.
// This will return the IFormatSettingsPtr for the given code. This function will pull from the map, or
// generate new and add to the map if needed.
NXDATALIST2Lib::IFormatSettingsPtr CBillingDlg::GetAlbertaModifierFormatSettingsForServiceID(long nServiceID)
{
	//does this service ID already have an entry in the map?
	{
		IFormatSettingsPtr pfsExisting = NULL;
		if (m_mapAlbertaServiceIDToModifierComboSource.Lookup(nServiceID, pfsExisting) && pfsExisting != NULL) {
			return pfsExisting;
		}
	}

	IFormatSettingsPtr pfs(__uuidof(FormatSettings));

	//create a new entry by loading all applicable modifiers for this service ID
	CString strModifierList;
	if (nServiceID == -1) {
		//just create the "none" entry
		strModifierList = "SELECT '-1' AS ID, '     (None)' AS Text, 1 AS Active";
	}
	else {
		strModifierList.Format("SELECT CPTModifierT.Number AS ID, (CPTModifierT.Number + '   ' + CPTModifierT.Note) AS Text, CPTModifierT.Active "
			"FROM CPTModifierT "
			"INNER JOIN AlbertaCptModLinkT ON CPTModifierT.Number = AlbertaCptModLinkT.Mod "
			"WHERE ServiceID = %li "
			"UNION "
			"SELECT '-1' AS ID, '     (None)' AS Text, 1 AS Active "
			"ORDER BY Text ASC", nServiceID);
	}

	//create the format settings
	pfs->PutDataType(VT_BSTR);
	pfs->PutFieldType(cftComboSimple);
	pfs->PutEditable(VARIANT_TRUE);
	pfs->PutConnection(_variant_t((LPDISPATCH)GetRemoteData())); //we're going to let this combo use Practice's connection
	pfs->PutComboSource(_bstr_t(strModifierList));
	pfs->EmbeddedComboDropDownMaxHeight = 300;
	pfs->EmbeddedComboDropDownWidth = 200;

	//add to our map, and return it
	m_mapAlbertaServiceIDToModifierComboSource.SetAt(nServiceID, pfs);
	return pfs;
}

// (j.jones 2011-10-11 10:30) - PLID 44941 - called after a modifier is changed on a charge,
// for Alberta only, so we can change the unit price of the charge
// (j.jones 2012-01-23 09:09) - PLID 47695 - added bForceCalc parameter to force calculating
// even if there are no modifiers, if FALSE, this will not change the cost unless there are
// modifiers on the charge
void CBillingDlg::UpdateChargePriceWithAlbertaModifiers(BillingItemPtr pBillItem, BOOL bForceCalc)
{
	try {

		//this should have never been allowed if the charge was closed,
		//so we do not need to check again

		//do nothing if this is not a CPT code
		if (VarLong(pBillItem->ItemType) != ITEM_TYPE_CPT) {
			return;
		}

		//do nothing if Alberta is not enabled
		if (!UseAlbertaHLINK()) {
			return;
		}

		//get the service ID
		long nServiceID = VarLong(pBillItem->ServiceID);

		// (j.jones 2012-01-23 10:29) - PLID 47695 - do nothing if this has no Alberta modifier links
		if (!ReturnsRecordsParam("SELECT TOP 1 ID FROM AlbertaCPTModLinkT WHERE ServiceID = {INT}", nServiceID)) {
			return;
		}

		//get the unit cost and calls
		COleCurrency cyOldUnitCost = VarCurrency(pBillItem->UnitCost);
		double dblOldCalls = VarDouble(pBillItem->Calls, 0.0);

		//at all times we need the "original" unit cost, which means the multifee value for this charge
		//if it exists, standard fee otherwise, and means that we are not able to maintain any user-entered cost
		//once they pick a modifier
		BOOL bInvalid;
		CString strInvalid;
		BOOL bWarn = FALSE;
		BOOL bHasAllowable = FALSE;
		COleCurrency cyAllowable = COleCurrency(0, 0);

		long nLocationID;
		if (m_LocationCombo->GetCurSel() == -1) {
			nLocationID = GetCurrentLocationID();
		}
		else {
			nLocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0), -1);
		}

		long nPOSID = -1;
		if (m_PlaceOfServiceCombo->GetCurSel() == -1) {
			nPOSID = GetCurrentLocationID();
		}
		else {
			nPOSID = VarLong(m_PlaceOfServiceCombo->GetValue(m_PlaceOfServiceCombo->CurSel, 0), -1);
		}

		long nInsuranceCoID = -1;

		//we could be on a bill or quote, so use m_pList
		IRowSettingsPtr pBillingRow = m_pList->FindByColumn(COLUMN_LINE_ID, pBillItem->LineID, m_pList->GetFirstRow(), FALSE);
		//it might not be in the datalist yet, so a NULL row is ok
		if (pBillingRow) {

			if (m_EntryType == 1) {

				_variant_t varIns = pBillingRow->GetValue(COLUMN_INS_RESP);

				if ((varIns.vt == VT_CY && COleCurrency(varIns.cyVal) > COleCurrency(0, 0))) {

					//our amount fits what we're looking for, so lookup the insurance co id

					long nInsuredPartyID = -2;
					_variant_t var = pBillingRow->GetValue(COLUMN_INS_PARTY_ID);
					if (var.vt == VT_I4 && var.lVal >= -1)
						nInsuredPartyID = var.lVal;

					// (d.lange 2015-12-01 11:51) - PLID 67127 - Determine the greatest insurance responsibility based on the insurance
					// category for the given insured party
					_RecordsetPtr rsIns = GetMostPrimaryInsCoIDForInsuredPartyRecordset(nInsuredPartyID);
					if (!rsIns->eof) {
						nInsuranceCoID = AdoFldLong(rsIns, "InsuranceCoID");
					}
					else {
						nInsuranceCoID = -1;
					}

				}
				else {
					nInsuranceCoID = -1;
				}
			}
		}

		if (nInsuranceCoID == -1 && m_EntryType == 1) {
			// (d.lange 2015-12-01 10:49) - PLID 67127 - Calculate the multi-fee based on the most-primary insurance for the selected insurance category
			nInsuranceCoID = GetCurrentBillToMostPriInsCoIDForCategory();
		}

		// (b.cardillo 2015-11-03 20:47) - PLID 67121 - Take charge date into account
		COleCurrency cyOriginalUnitCost = GetMultiFee(nServiceID, VarLong(pBillItem->Provider, -1), nInsuranceCoID, nLocationID, nPOSID, VarDateTime(pBillItem->Date), bInvalid, bWarn, strInvalid, bHasAllowable, cyAllowable);

		COleCurrency cyNewUnitCost = cyOriginalUnitCost;
		double dblCalls = dblOldCalls;

		//Now call CalculateChargePriceFromAlbertaModifier for each modifier, 
		//which will load the actions and update the new unit cost accordingly.
		//In each case, the new "base" for a given calculation is the new cost
		//from the previous modifier.

		//if dblCalls is 0, it may potentially be altered to 1

		// (j.jones 2012-01-23 09:10) - PLID 47695 - track whether we actually have modifers
		BOOL bHasModifiers = FALSE;

		// (j.jones 2012-03-05 17:46) - PLID 48149 - if there are no active modifiers,
		// check for "implied" modifiers, defined as NBRSER, NBRDAY, or NBRMON
		BOOL bHasImpliedModifiers = FALSE;
		if (dblCalls > 0) {
			//no services currently have more than one of these implied modifiers
			_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 Mod FROM AlbertaCPTModLinkT "
				"WHERE ServiceID = {INT} AND Mod IN ('NBRSER', 'NBRDAY', 'NBRMON') "
				"GROUP BY Mod", nServiceID);
			if (!rs->eof) {
				CString strMod = VarString(rs->Fields->Item["Mod"]->Value);
				cyNewUnitCost = CalculateChargePriceFromAlbertaModifier(strMod, nServiceID, cyNewUnitCost, dblCalls);
				bHasImpliedModifiers = TRUE;
			}
			rs->Close();
		}

		if (pBillItem->Modifier1.vt == VT_BSTR) {
			CString strModifier1 = VarString(pBillItem->Modifier1, "");
			if (!strModifier1.IsEmpty()) {
				bHasModifiers = TRUE;
				cyNewUnitCost = CalculateChargePriceFromAlbertaModifier(strModifier1, nServiceID, cyNewUnitCost, dblCalls);
			}
		}

		if (pBillItem->Modifier2.vt == VT_BSTR) {
			CString strModifier2 = VarString(pBillItem->Modifier2, "");
			if (!strModifier2.IsEmpty()) {
				bHasModifiers = TRUE;
				cyNewUnitCost = CalculateChargePriceFromAlbertaModifier(strModifier2, nServiceID, cyNewUnitCost, dblCalls);
			}
		}

		if (pBillItem->Modifier3.vt == VT_BSTR) {
			CString strModifier3 = VarString(pBillItem->Modifier3, "");
			if (!strModifier3.IsEmpty()) {
				bHasModifiers = TRUE;
				cyNewUnitCost = CalculateChargePriceFromAlbertaModifier(strModifier3, nServiceID, cyNewUnitCost, dblCalls);
			}
		}

		if (pBillItem->Modifier4.vt == VT_BSTR) {
			CString strModifier4 = VarString(pBillItem->Modifier4, "");
			if (!strModifier4.IsEmpty()) {
				bHasModifiers = TRUE;
				cyNewUnitCost = CalculateChargePriceFromAlbertaModifier(strModifier4, nServiceID, cyNewUnitCost, dblCalls);
			}
		}

		//if the unit cost and calls did not change, leave now, and do nothing
		if (cyNewUnitCost == cyOldUnitCost && dblCalls == dblOldCalls) {
			//do nothing
			return;
		}

		// (j.jones 2012-01-23 09:10) - PLID 47695 - if bForceCalc is FALSE and
		// we have no modifiers, do nothing
		// (j.jones 2012-03-05 17:53) - PLID 48149 - same if there are no implied modifiers
		if (!bForceCalc && !bHasModifiers && !bHasImpliedModifiers) {
			//do nothing
			return;
		}

		//if the unit cost changed, we do NOT need to check closed
		//permissions, because we should not have disallowed editing
		//modifiers on closed charges when Alberta is enabled

		//save the new unit cost in the pBillItem and in the datalist
		pBillItem->UnitCost = cyNewUnitCost;
		//same for the calls, they may have changed
		pBillItem->Calls = dblCalls;

		//it might not be in the datalist yet, so a NULL row is ok
		if (pBillingRow) {
			pBillingRow->PutValue(m_EntryType == 1 ? BILL_COLUMN_UNIT_COST : QUOTE_COLUMN_UNIT_COST, _variant_t(cyNewUnitCost));
			pBillingRow->PutValue(m_EntryType == 1 ? COLUMN_CALLS : QUOTE_COLUMN_CALLS, dblCalls);
		}

		//mark the charge as changed
		long nChargeID = VarLong(pBillItem->ChargeID, -2);
		if (nChargeID != -2) {
			AddToModifiedList(nChargeID, FALSE);
		}

		//the calling function is expected to call CalculateLineTotal, so we do not have to

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2011-10-11 12:42) - PLID 44941 - calculates the unit cost based on one Alberta modifier
// (j.jones 2011-10-11 12:42) - PLID 44941 - given an Alberta service code and modifier,
// we calculate the new unit cost for the charge
COleCurrency CBillingDlg::CalculateChargePriceFromAlbertaModifier(CString strModifier, long nServiceID, const COleCurrency cyBaseUnitCost,
	IN OUT double &dblCalls)
{
	// (j.jones 2012-03-06 10:36) - PLID 48646 - default the new unit cost to invalid
	// so each action can choose how it initializes
	COleCurrency cyNewUnitCost;
	cyNewUnitCost.SetStatus(COleCurrency::invalid);

	//the ORDER BY clause here ensures that when calls are involved, we order by the 
	//call count, forcing the MAX action to be the last record, if a MAX action exists
	// (j.jones 2012-03-06 12:00) - PLID 48654 - added a GROUP BY because these columns should
	// not be duplicated, and a prior version of the importer often did duplicate things
	_RecordsetPtr rs = CreateParamRecordset("SELECT AlbertaCPTModLinkT.Action, "
		"AlbertaCPTModLinkT.AmountPec AS AmtPercent, AlbertaCPTModLinkT.Amount, "
		"AlbertaCPTModLinkT.CallLowerLimit, AlbertaCPTModLinkT.CallUpperLimit "
		"FROM AlbertaCPTModLinkT "
		"INNER JOIN ServiceT ON AlbertaCPTModLinkT.ServiceID = ServiceT.ID "
		""
		"WHERE AlbertaCPTModLinkT.Mod = {STRING} AND ServiceT.ID = {INT} "
		""
		"GROUP BY AlbertaCPTModLinkT.ServiceID, AlbertaCPTModLinkT.Mod, "
		"AlbertaCPTModLinkT.Action, AlbertaCPTModLinkT.AmountPec, AlbertaCPTModLinkT.Amount, "
		"AlbertaCPTModLinkT.CallLowerLimit, AlbertaCPTModLinkT.CallUpperLimit "
		""
		"ORDER BY (CASE WHEN AlbertaCPTModLinkT.Action = {CONST} THEN 1 ELSE 0 END), "
		"AlbertaCPTModLinkT.CallLowerLimit, AlbertaCPTModLinkT.CallUpperLimit",
		strModifier, nServiceID, amatMAX);
	while (!rs->eof) {

		//in the case of calls, there might be multiple records
		AlbertaHLINKModifierActionType amatAction = (AlbertaHLINKModifierActionType)VarLong(rs->Fields->Item["Action"]->Value, (long)amatUnknown);
		long nAmtPercent = VarLong(rs->Fields->Item["AmtPercent"]->Value, 0);
		COleCurrency cyAmount = VarCurrency(rs->Fields->Item["Amount"]->Value, COleCurrency(0, 0));
		long nCallLowerLimit = VarLong(rs->Fields->Item["CallLowerLimit"]->Value, -1);
		long nCallUpperLimit = VarLong(rs->Fields->Item["CallUpperLimit"]->Value, -1);
		//Sometimes if the lower limit is 1, the upper limit is NULL, which often happens
		//if the next record represents 2 and up. This means the upper limit and the lower
		//limit are the same value.
		if (nCallUpperLimit < nCallLowerLimit) {
			nCallUpperLimit = nCallLowerLimit;
		}

		switch (amatAction) {

			case amatReplace:
			case amatReplaceBase:
				//replace the current price with the new price, provided it is non-zero
				if (cyAmount > COleCurrency(0, 0)) {
					cyNewUnitCost = cyAmount;
				}
				break;

			case amatIncreaseBy:
			case amatIncreaseBaseBy:
				// (j.jones 2012-01-16 16:26) - PLID 47563 - these are usually increasing by
				// fixed amounts, but sometimes it can increase by %
				if (nAmtPercent > 0) {
					//increase the current amount by that %, which means to increase
					//by 25% means to bring it to 125% of the current value

					// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
					//cyNewUnitCost, set it at the base cost
					if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
						cyNewUnitCost = cyBaseUnitCost;
					}

					COleCurrency cyTempCost = cyNewUnitCost * ((nAmtPercent + 100) * 1000);
					cyTempCost = cyTempCost / long(100000);
					RoundCurrency(cyTempCost);

					cyNewUnitCost = cyTempCost;
				}
				else {

					//increase the current price by the amount
					if (cyAmount > COleCurrency(0, 0)) {

						// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
						//cyNewUnitCost, set it at the base cost
						if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
							cyNewUnitCost = cyBaseUnitCost;
						}

						cyNewUnitCost += cyAmount;
					}
				}
				break;

			case amatForEachCallPayBaseAt:

				//if the call is 0, make it be 1
				if (dblCalls == 0.0) {
					dblCalls = 1.0;
				}

				//this is always a percentage of the base
				if (nAmtPercent > 0) {

					//our call count is a double, but the calculation only permits longs,
					//so round accordingly
					long nCalls = (long)Round(dblCalls, 0);

					long nCallCountToUse = 0;
					//if the calls are higher than this limit, calculate up until this limit
					if (nCalls > nCallUpperLimit) {

						//Example, if the call lower limit is 1 and the upper is 2,
						//but our call count is 5, we only need to calculate 2 calls (1 and 2).
						//They would be the % of the unit cost, times 2.
						nCallCountToUse = (nCallUpperLimit - nCallLowerLimit) + 1;
					}
					//if the calls are within this range, calculate the calls within this range
					else if (nCalls >= nCallLowerLimit && nCalls <= nCallUpperLimit) {

						//Example, if the call lower limit is 2 and the upper is 10,
						//but our call count is 5, we only need to calculate 4 calls (2,3,4,5).
						//They would be the % of the unit cost, times 4.

						nCallCountToUse = (nCalls - nCallLowerLimit) + 1;
					}

					if (nCallCountToUse > 0) {

						//calculate the % of the old cost, multiply by our call count to use,
						//and replace the new unit cost

						COleCurrency cyTempCost = cyBaseUnitCost * (nAmtPercent * 1000);
						cyTempCost = cyTempCost / long(100000);
						RoundCurrency(cyTempCost);

						cyTempCost *= nCallCountToUse;
						RoundCurrency(cyTempCost);

						// (j.jones 2012-03-06 10:22) - PLID 48646 - When the "pay base at" rule is used,
						// for the first call count it should replace the new unit cost, and higher call
						// counts should add to that cost. So for example, "For 1 Call Pay Base at 100%"
						// should replace the cost with the pay base, and "For 2 Calls Pay Base at 75%"
						// should add 75% of the pay base to the existing cost. For 2 calls, we would
						// process both rules in order, as this is a loop.
						// An easier way to think of it is that if Calls > 1, Pay Base at 100% would make
						// Calls act like quantity, and Pay Base at X% means that it doesn't fully double in value.

						//cyNewUnitCost now defaults to invalid so we know the first time we're calculating
						//a call, versus successive calculations for higher call rules
						if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
							cyNewUnitCost = cyTempCost;
						}
						else {
							cyNewUnitCost += cyTempCost;
						}
					}
				}
				break;

			case amatForEachCallIncreaseBy:

				//if the call is 0, make it be 1
				if (dblCalls == 0.0) {
					dblCalls = 1.0;
				}

				//this is always a fixed amount, per call
				if (cyAmount > COleCurrency(0, 0)) {

					//our call count is a double, but the calculation only permits longs,
					//so round accordingly
					long nCalls = (long)Round(dblCalls, 0);

					long nCallCountToUse = 0;
					//if the calls are higher than this limit, calculate up until this limit
					if (nCalls > nCallUpperLimit) {

						//Example, if the call lower limit is 1 and the upper is 2,
						//but our call count is 5, we only need to calculate 2 calls (1 and 2).
						//They would be the fixed cyAmount, times 2.
						nCallCountToUse = (nCallUpperLimit - nCallLowerLimit) + 1;
					}
					//if the calls are within this range, calculate the calls within this range
					else if (nCalls >= nCallLowerLimit && nCalls <= nCallUpperLimit) {

						//Example, if the call lower limit is 2 and the upper is 10,
						//but our call count is 5, we only need to calculate 4 calls (2,3,4,5).
						//They would be the fixed cyAmount, times 4.

						nCallCountToUse = (nCalls - nCallLowerLimit) + 1;
					}

					if (nCallCountToUse > 0) {

						//multiply cyAmount by our call count to use,
						//and add to the new unit cost

						COleCurrency cyTempCost = cyAmount * nCallCountToUse;

						// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
						//cyNewUnitCost, set it at the base cost
						if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
							cyNewUnitCost = cyBaseUnitCost;
						}

						cyNewUnitCost += cyTempCost;
						RoundCurrency(cyNewUnitCost);
					}
				}
				break;

			case amatReduceBaseTo:
			case amatIncreaseBaseTo:
				//reducing is usually 25 - 75%, increasing is 125% and up,
				//and when reducing, we reduce TO a given %, not BY that percent,
				//therefore these calculations are the same
				if (nAmtPercent > 0) {

					// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
					//cyNewUnitCost, set it at the base cost
					if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
						cyNewUnitCost = cyBaseUnitCost;
					}

					COleCurrency cyTempCost = cyNewUnitCost * (nAmtPercent * 1000);
					cyTempCost = cyTempCost / long(100000);
					RoundCurrency(cyTempCost);

					cyNewUnitCost = cyTempCost;
				}
				break;

			case amatMAX:
				//if the MAX amount is non-zero, and it is less than our current cost,
				//replace the current price with the new price, as it is the maximum possible value
				if (cyAmount > COleCurrency(0, 0) && cyAmount < cyNewUnitCost) {
					cyNewUnitCost = cyAmount;
				}
				break;

			case amatReduceBaseBy:
				//reduce current price by the amount
				if (cyAmount > COleCurrency(0, 0)) {

					// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
					//cyNewUnitCost, set it at the base cost
					if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
						cyNewUnitCost = cyBaseUnitCost;
					}

					cyNewUnitCost -= cyAmount;
				}
				break;

			case amatUnknown:
			default:
				//this is not a valid modifier action
				// (j.jones 2016-01-19 16:47) - PLID 67853 - this is now possible because Alberta weirdly has
				// modifiers that truly have no action, the amount just doesn't change
				//ASSERT(FALSE);
				break;
		}

		rs->MoveNext();
	}
	rs->Close();

	// (j.jones 2012-03-06 10:36) - PLID 48646 - if we haven't initialized the
	//cyNewUnitCost, set it at the base cost
	if (cyNewUnitCost.GetStatus() == COleCurrency::invalid) {
		cyNewUnitCost = cyBaseUnitCost;
	}

	RoundCurrency(cyNewUnitCost);
	return cyNewUnitCost;
}

// (j.gruber 2012-01-04 11:44) - PLID 46291
void CBillingDlg::SetBillDescriptionBasedOnResp()
{
	//first make sure this is a bill
	if (m_EntryType != 1) {
		return;
	}

	CString str;
	// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description accessor rather than reading it directly.
	str = GetBillDescription();
	if (!str.IsEmpty()) {
		//there is already something in the description, so we are leaving it
		return;
	}

	CString strDescription;

	//now check our preference
	if (GetRemotePropertyInt("ReplaceBillDescriptionByResp", 0, 0, "<None>") != 0) {
		//they want to replace, so see what our responsibility is
		long nRespID = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
		if (nRespID == 0) {
			//its patient, so get it from the preference
			strDescription = GetRemotePropertyText("PatientRespBillDesc", "", 0, "<None>");
		}
		else {
			strDescription = VarString(m_listBillTo->GetValue(m_listBillTo->CurSel, btcBillDescription), "");
		}

		//now replace the description if its not blank
		if (strDescription != "") {
			// (r.gonet 07/02/2014) - PLID 62567 - Use the bill description mutator rather than writing it directly.
			SetBillDescription(strDescription);
		}
	}
}

// (j.dinatale 2012-03-15 16:34) - PLID 47413 - added ability to bill from glasses order tab
void CBillingDlg::OnBillGlassesOrder(long nGlassesOrderID, long nInsuredPartyID)
{
	try{
		//determine the row to select based on the InsuredPartyID
		m_listBillTo->SetSelByColumn(btcInsuredPartyID, long(nInsuredPartyID));

		long nItemToBill = ROW_BILL_A_GLASSES_ORDER;
		if (m_EntryType == 1) {
			nItemToBill = ROW_BILL_A_GLASSES_ORDER;
		}else {
			// Absolutely should not happen
			ASSERT(FALSE);
		}

		OnSelChosenWhatToAddCombo(m_WhatToAddCombo->SetSelByColumn(0, (long)nItemToBill));

		IRowSettingsPtr pRow = m_GlassesOrderCombo->SetSelByColumn(0, (long)nGlassesOrderID);
		if (pRow) {	//selection did not fail
			OnSelChosenComboGlassesOrders(pRow);
		}
	}NxCatchAll(__FUNCTION__);
}

// (d.singleton 2012-03-07 11:32) - PLID 25098
void CBillingDlg::OnBnClickedVerifyBill()
{
	try {

		// (d.singleton 2014-03-21 08:31) - PLID 61428 - remove old medassist code. keep function per managements request
		AfxThrowNxException("Feature not available");
		return;

		//BOOL bIsShiftKeyDown = (GetAsyncKeyState(VK_SHIFT) & 0x80000000);

		//CWaitCursor cr;
		////save all billing info before validating, if it fails to save do not continue
		//if(SaveChanges() != SCR_SAVED)
		//{
		//	return;
		//}

		//// (d.singleton 2012-06-25 14:10) - PLID 49086 check for use license,  if there are no uses return;
		//if(!g_pLicense->CheckForLicense(CLicense::lcCodeCorrect, CLicense::cflrUse)) {
		//	return;
		//}

		////string to generate our xml text
		//CString strXml;
		//// (d.singleton 2012-04-03 14:44) - PLID 49098 call function to generate xml text, if it fails do not continue
		//if(!MedAssist::GenerateCodeCheckPhyBillingXML(strXml, GetBillID()))
		//{
		//	return;
		//}

		////get xml doc returned from the sent request
		//MSXML2::IXMLDOMDocumentPtr pXmlDoc = MedAssist::SendSoapCodeCheckPhyBillingXML(strXml);
		//if(!pXmlDoc)
		//{
		//	//if we get a null xml doc back return
		//	AfxMessageBox("Failed to retrieve validation results");
		//	return;
		//}

		////if shift is held down open up the returned xml in iexplorer
		//if(bIsShiftKeyDown)
		//{
		//	CString strXml = (LPCTSTR)pXmlDoc->Getxml();
		//	strXml = MedAssist::XMLDecode(strXml);

		//	CFile xmlFile;
		//	xmlFile.Open(GetPracPath(PracPath::SessionPath) ^ "CodeCorrectXml.wsdl", CFile::modeCreate|CFile::modeReadWrite | CFile::shareCompat);
		//	xmlFile.Write(strXml, strXml.GetLength()); 
		//	xmlFile.Close();
		//	if(FileUtils::DoesFileOrDirExist(GetPracPath(PracPath::SessionPath) ^ "CodeCorrectXml.wsdl")) {
		//		ShellExecute(NULL, NULL, "iexplore.exe", GetPracPath(PracPath::SessionPath) ^ "CodeCorrectXml.wsdl", NULL, SW_SHOW);	
		//	}
		//}

		////parse out important info into member array,  but first remove any records from the array just in case.
		//m_aryValidatedParsedResults.RemoveAll();
		//MedAssist::ParseXMLDocument(m_aryValidatedParsedResults, pXmlDoc);

		//IRowSettingsPtr pRow;
		//IColumnSettingsPtr pCol = m_List->GetColumn(BILL_VALIDATION_STATUS);

		//CString strResultText;
		//int i;
		//for(i = 0; i < m_aryValidatedParsedResults.GetCount(); i++ )
		//{
		//	//match the result in array to the correct row based on ChargesT.ID
		//	pRow = m_List->FindByColumn(COLUMN_CHARGE_ID, m_aryValidatedParsedResults.GetAt(i).nChargeID, m_List->GetFirstRow(), FALSE);

		//	if(pRow)
		//	{
		//		//assign statuses to rows
		//		if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsFailure)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconRedX));
		//		}
		//		else if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsWarning)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconWarning));
		//		}
		//		else if(m_aryValidatedParsedResults.GetAt(i).ccrsStatus == MedAssist::ccrsPass)
		//		{
		//			pRow->PutValue(BILL_VALIDATION_STATUS, _variant_t((long)m_hIconCheck));
		//		}
		//	}
		//}
		//// if there were no results( can only happen with errors ) do not show status column
		//if(i != 0) {
		////release the statuses!		
		//pCol->PutStoredWidth(50);
		//}
	}NxCatchAll(__FUNCTION__);
}

// (d.singleton 2012-03-30 12:14) - PLID 49257 function to save an unsaved or saved charge from the billing dialog
void CBillingDlg::AddUnsavedNotes(BOOL bIsUnsavedCharge, _variant_t varChargeID, _variant_t varLineID)
{
	try {
		CNotesDlg dlgNotes(this, bIsUnsavedCharge);
		BillingItemPtr bi;
		int j;
		//match the charge pointer to the row we clicked on
		for (j = 0; j < (int)m_billingItems.size(); j++) {
			if (m_billingItems[j]->LineID.lVal == varLineID.lVal) {
				_variant_t vj = m_billingItems[j]->LineID;
				bi = m_billingItems[j];
				break;
			}
		}
		//if the charge has any unsaved notes copy them to the notes dlg 
		if (!bi->m_arUnsavedChargeNotes.IsEmpty()) {
			for (int i = 0; i < bi->m_arUnsavedChargeNotes.GetCount(); i++) {
				UnsavedChargeNote note;
				note.varDate = bi->m_arUnsavedChargeNotes.GetAt(i).varDate;
				note.varLineItemID = bi->m_arUnsavedChargeNotes.GetAt(i).varLineItemID;
				note.varNote = bi->m_arUnsavedChargeNotes.GetAt(i).varNote;
				note.varNoteID = bi->m_arUnsavedChargeNotes.GetAt(i).varNoteID;
				note.varPersonID = bi->m_arUnsavedChargeNotes.GetAt(i).varPersonID;
				note.varPriority = bi->m_arUnsavedChargeNotes.GetAt(i).varPriority;
				note.varUserID = bi->m_arUnsavedChargeNotes.GetAt(i).varUserID;
				note.varStatement = bi->m_arUnsavedChargeNotes.GetAt(i).varStatement;
				note.varClaim = bi->m_arUnsavedChargeNotes.GetAt(i).varClaim;
				note.varCategory = bi->m_arUnsavedChargeNotes.GetAt(i).varCategory;
				dlgNotes.m_arUnsavedChargeNotes.Add(note);
			}
		}
		dlgNotes.m_bIsBillingNote = true;
		dlgNotes.m_bntBillingNoteType = bntCharge;
		//always going to be -2 when an unsaved charge
		dlgNotes.m_nLineItemID = VarLong(varChargeID);
		//open the notes dialog
		CNxModalParentDlg dlg(this, &dlgNotes, CString("Charge Notes"));
		if (dlg.DoModal() == IDCANCEL && bIsUnsavedCharge) {
			//clear the charges unsaved notes and copy the notes from the notes dialog
			m_billingItems[j]->m_arUnsavedChargeNotes.RemoveAll();
			if (!dlgNotes.m_arUnsavedChargeNotes.IsEmpty()) {
				for (int i = 0; i < dlgNotes.m_arUnsavedChargeNotes.GetCount(); i++) {
					UnsavedChargeNote note;
					note.varDate = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varDate;
					note.varLineItemID = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varLineItemID;
					note.varNote = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varNote;
					note.varNoteID = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varNoteID;
					note.varPersonID = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varPersonID;
					note.varPriority = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varPriority;
					note.varUserID = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varUserID;
					note.varStatement = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varStatement;
					note.varClaim = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varClaim;
					note.varCategory = dlgNotes.m_arUnsavedChargeNotes.GetAt(i).varCategory;
					m_billingItems[j]->m_arUnsavedChargeNotes.Add(note);
				}
				//update the icons if the charge now has notes
				m_billingItems[j]->Notes = _variant_t((long)m_hIconHasNotes);
			}
			else {
				m_billingItems[j]->Notes = _variant_t((long)m_hIconNotes);
			}
			Requery();
		}
		else if (!bIsUnsavedCharge) {
			if (ReturnsRecordsParam("SELECT * FROM NoteInfoT WHERE LineItemID = {INT}", VarLong(varChargeID))) {
				m_billingItems[j]->Notes = _variant_t((long)m_hIconHasNotes);
			}
			else {
				m_billingItems[j]->Notes = _variant_t((long)m_hIconNotes);
			}
			Requery();
		}
	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2012-04-12 09:27) - PLID 49609 - Adds a new unsaved note to a charge.
// This assumes the calling code will later update the datalist.
void CBillingDlg::AddNewUnsavedChargeNote(BillingItemPtr pBillItem, CString strNoteToAdd, BOOL bIsClaimNote)
{
	try {

		//only supported on bills
		if (m_EntryType == 2) {
			return;
		}

		if (pBillItem == NULL) {
			ThrowNxException("AddNewUnsavedChargeNote called with no valid charge pointer!");
		}

		if (pBillItem->ChargeID.vt == VT_NULL || pBillItem->ChargeID.vt == VT_EMPTY) {
			ThrowNxException("AddNewUnsavedChargeNote called with an invalid charge ID!");
		}

		//if a claim note, enforce the maximum length of 80 characters
		if (bIsClaimNote && strNoteToAdd.GetLength() > 80) {
			strNoteToAdd = strNoteToAdd.Left(80);
		}

		//safety check: in the event that our terrible billing code tries
		//to add the same claim note twice on one charge, skip adding a second time
		if (bIsClaimNote && pBillItem->m_arUnsavedChargeNotes.GetSize() > 0) {
			for (int i = 0; i < pBillItem->m_arUnsavedChargeNotes.GetSize(); i++) {
				//compare case-sensitively, as we are only trying to prevent automated additions of identical content
				if (VarString(pBillItem->m_arUnsavedChargeNotes.GetAt(i).varNote, "") == strNoteToAdd) {
					//found it, do not add a second time
					return;
				}
			}
		}

		long nCatID = GetRemotePropertyInt("DefaultNoteCatID", NULL, 0, "<None>", true);
		_variant_t varCatID = nCatID > 0 ? _variant_t(nCatID, VT_I4) : g_cvarNull;

		// (d.singleton 2012-04-13 13:19) - need to get a valid note id
		_RecordsetPtr prs = CreateRecordset("SELECT MAX(ID) + 1 AS TempID FROM Notes");
		long nTempID = AdoFldLong(prs, "TempID");

		UnsavedChargeNote note;
		note.varDate = _variant_t(COleDateTime::GetCurrentTime(), VT_DATE);
		note.varLineItemID = pBillItem->LineID;
		note.varNote = (LPCTSTR)strNoteToAdd;
		note.varNoteID = nTempID + pBillItem->m_arUnsavedChargeNotes.GetCount();
		note.varPersonID = m_nPatientID;
		note.varPriority = (int)3;
		note.varUserID = GetCurrentUserID();
		note.varStatement = g_cvarFalse;
		note.varClaim = bIsClaimNote ? g_cvarTrue : g_cvarFalse;
		note.varCategory = varCatID;
		pBillItem->m_arUnsavedChargeNotes.Add(note);

		//update the icon to reflect that the charge now has notes
		pBillItem->Notes = _variant_t((long)m_hIconHasNotes);

	}NxCatchAll(__FUNCTION__);
}

// (j.dinatale 2012-06-05 16:24) - PLID 49713 - clear the insurance tab!
void CBillingDlg::ClearInsuranceTabInsPlans()
{
	if (m_EntryType == 1 && ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.EnsureInitialized();

		m_GuarantorID1 = -1;
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->SetSelByColumn(0, -1);
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_GuarantorID1 = -1;

		m_GuarantorID2 = -1;
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance2->SetSelByColumn(0, -1);
		((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_GuarantorID2 = -1;

		// also unbatch the claim
		((CButton*)((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetDlgItem(IDC_RADIO_PAPER_BATCH))->SetCheck(FALSE);
		((CButton*)((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetDlgItem(IDC_RADIO_ELECTRONIC_BATCH))->SetCheck(FALSE);
		((CButton*)((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetDlgItem(IDC_RADIO_UNBATCHED))->SetCheck(TRUE);
	}
}

// (j.dinatale 2012-06-25 09:42) - PLID 51138 - show the additional charge info dialog
LRESULT CBillingDlg::OnShowEditAdditionalChargeInfo(WPARAM wParam, LPARAM lParam)
{
	try{
		if (m_EntryType == 1){
			CBillingExtraChargeInfoDlg dlg(this, m_billingItems, ((CBillingModuleDlg*)m_pBillingModuleWnd), m_eHasAccess == batNoAccess);
			dlg.DoModal();
		}
	}NxCatchAll(__FUNCTION__);

	return 0;
}

// (j.jones 2013-07-11 08:53) - PLID 57148 - Retrieves the first charge provider sorted by LineID.
// If Charge 1 has no provider, and Charge 2 has a provider, we'll return the provider ID on Charge 2.
long CBillingDlg::GetFirstChargeProviderID()
{
	//Loop through the datalist, not the array, because the datalist
	//is sorted by LineID and the array is not.

	short nProviderColumn = BILL_COLUMN_PROVIDER;
	if (m_EntryType == 2) {
		nProviderColumn = QUOTE_COLUMN_PROVIDER;
	}

	IRowSettingsPtr pRow = m_pList->GetFirstRow();
	while (pRow) {
		_variant_t varProviderID = pRow->GetValue(nProviderColumn);
		long nProviderID = VarLong(varProviderID, -1);
		if (nProviderID > -1) {
			//return the first valid provider ID
			return nProviderID;
		}

		pRow = pRow->GetNextRow();
	}

	//there was no valid provider ID
	return -1;
}

// (j.gruber 2014-02-19 10:32) - PLID 60878 - new function for loading Default WhichCodes
void CBillingDlg::LoadDefaultWhichCodes(CChargeWhichCodesMapPtr &pWhichCodes)
{
	try {

		if (pWhichCodes == NULL)
		{
			pWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		}

		// (j.jones 2010-08-30 11:02) - PLID 40196 - if this feature is disabled, return an empty string
		if (GetRemotePropertyInt("BillDoNotAutoFillDiagCs", 0, 0, "<None>", true) == 1) {
			return;
		}

		//there is a limit of only 4 indices to use, so cut it off at 4

		long nCountIndices = 0;

		CString strValue;

		for (int i = 0; i < m_arypDiagCodes.GetSize(); i++) {
			// (j.gruber 2014-03-21 12:56) - PLID 61494
			DiagCodeInfoPtr pDiag = (DiagCodeInfoPtr)m_arypDiagCodes.GetAt(i);

			//we have a limit of 4 indices, so if we hit that limit, we're done
			if (nCountIndices == 4) {
				return;
			}

			if (pDiag->nOrderIndex > MAX_DIAG_Cs_INDEX) {
				//disallow adding a number higher than our MAX_DIAG_Cs_INDEX
				//(defined in BillExtraDiagCodesDlg.h)
				continue;
			}
			else {
				pWhichCodes->insert(std::make_pair(CChargeWhichCodePair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID), pDiag));
				nCountIndices++;
			}
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.gruber 2014-02-20 11:03) - PLID 60942
void CBillingDlg::LoadBillWhichCodes(long nBillID)
{
	//get our recordset which will get all the whichcodes saved for this bill
	_RecordsetPtr rsBillWhichCodes = CreateParamRecordset("SELECT ChargeID, BillDiagCodeID, "
		" BillID, ICD9DiagID, ICD10DiagID, OrderIndex, "
		" ICD9Diags.CodeNumber as ICD9Code, ICD9Diags.CodeDesc as ICD9Desc, "
		" ICD10Diags.CodeNumber as ICD10Code, ICD10Diags.CodeDesc as ICD10Desc "
		" FROM BillDiagCodeT INNER JOIN ChargeWhichCodesT ON BillDiagCodeT.ID = ChargeWhichCodesT.BillDiagCodeID "
		" LEFT JOIN DiagCodes ICD9Diags ON BillDiagCodeT.ICD9DiagID = ICD9Diags.ID "
		" LEFT JOIN DiagCodes ICD10Diags ON BillDiagCodeT.ICD10DiagID = ICD10Diags.ID "
		" WHERE BillDiagCodeT.BillID = {INT} ",
		nBillID);

	//now fill our structure		
	while (!rsBillWhichCodes->eof)
	{
		long nChargeID = AdoFldLong(rsBillWhichCodes->Fields, "ChargeID");
		CChargeWhichCodesMapPtr pmapWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		std::map<long, CChargeWhichCodesMapPtr>::iterator itFind = m_mapBillWhichCodes.find(nChargeID);
		if (itFind != m_mapBillWhichCodes.end())
		{
			//we found it, remove it from the map
			pmapWhichCodes = itFind->second;

			m_mapBillWhichCodes.erase(itFind);
		}
		else {
			//we don't have it yet
			pmapWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);

		}

		//add our information
		long nDiag9ID = AdoFldLong(rsBillWhichCodes->Fields, "ICD9DiagID", -1);
		long nDiag10ID = AdoFldLong(rsBillWhichCodes->Fields, "ICD10DiagID", -1);

		CChargeWhichCodePair pair = CChargeWhichCodePair(nDiag9ID, nDiag10ID);

		DiagCodeInfoPtr pInfo = DiagCodeInfoPtr(new DiagCodeInfo);
		pInfo->nDiagCode9ID = nDiag9ID;
		pInfo->nDiagCode10ID = nDiag10ID;
		pInfo->nID = AdoFldLong(rsBillWhichCodes->Fields, "BillDiagCodeID");
		pInfo->nOrderIndex = AdoFldLong(rsBillWhichCodes->Fields, "OrderIndex");
		pInfo->strDiagCode9Code = AdoFldString(rsBillWhichCodes->Fields, "ICD9Code", "");
		pInfo->strDiagCode9Desc = AdoFldString(rsBillWhichCodes->Fields, "ICD9Desc", "");
		pInfo->strDiagCode10Code = AdoFldString(rsBillWhichCodes->Fields, "ICD10Code", "");
		pInfo->strDiagCode10Desc = AdoFldString(rsBillWhichCodes->Fields, "ICD10Desc", "");

		pmapWhichCodes->insert(std::make_pair(pair, pInfo));

		m_mapBillWhichCodes.insert(std::make_pair(nChargeID, pmapWhichCodes));

		rsBillWhichCodes->MoveNext();
	}

}

// (j.gruber 2014-02-20 11:03) - PLID 60942
void CBillingDlg::LoadExistingWhichCodes(CChargeWhichCodesMapPtr &pWhichCodes, long nChargeID)
{
	//ok, so here is how this works, we have a map of all the whichcodes for the entire bill, 
	//so basically all we have to do is find the correct chargeID we are looking for and use that map in our main map

	std::map<long, CChargeWhichCodesMapPtr>::iterator itFind = m_mapBillWhichCodes.find(nChargeID);
	if (itFind != m_mapBillWhichCodes.end())
	{
		//this charge has whichcodes in it, copy it to this charge's whichCodes
		pWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *itFind->second) {
			CChargeWhichCodePair pair = CChargeWhichCodePair(entry.first);

			//make a new diagCode Pointer since we are keeping the billing one for auditing
			//so we don't want it to change
			DiagCodeInfoPtr pInfo = DiagCodeInfoPtr(new DiagCodeInfo);
			pInfo->nDiagCode9ID = entry.second->nDiagCode9ID;
			pInfo->nDiagCode10ID = entry.second->nDiagCode10ID;
			pInfo->nID = entry.second->nID;
			pInfo->nOrderIndex = entry.second->nOrderIndex;
			pInfo->strDiagCode9Code = entry.second->strDiagCode9Code;
			pInfo->strDiagCode9Desc = entry.second->strDiagCode9Desc;
			pInfo->strDiagCode10Code = entry.second->strDiagCode10Code;
			pInfo->strDiagCode10Desc = entry.second->strDiagCode10Desc;


			pWhichCodes->insert(std::make_pair(pair, pInfo));
		}
	}
}

// (j.gruber 2014-03-12 09:40) - PLID 60878
// (j.armen 2014-10-08 14:24) - PLID 63229 - for each
boost::shared_ptr<DiagCodeInfo> CBillingDlg::GetDiagCodeInfoByIndex(long nIndex)
{
	for each(const auto& pDiag in m_arypDiagCodes)
		if (pDiag->nOrderIndex == nIndex)
			return pDiag;

	ThrowNxException("Error in CBillingDlg::GetDiagCodeInfoByIndex - Could not find DiagCode index %li", nIndex);
}

//this function needs to translate indexes back into our map
// (j.gruber 2014-03-12 09:40) - PLID 60878
void CBillingDlg::SaveToWhichCodesMap(CChargeWhichCodesMapPtr &pWhichCodes, _variant_t varNewValue)
{
	//first, let's clear our charge's whichcode map	
	pWhichCodes->clear();

	//now loop through our indexes and match them up to what we need
	if (varNewValue.vt == VT_BSTR)
	{
		CString strNewIndexes = VarString(varNewValue);

		if (!strNewIndexes.IsEmpty()) {

			std::vector<std::string> indexes = ParseDelimitedString<std::string>(strNewIndexes, ",");

			for each(const auto& index in indexes)
			{
				if (index.length() == 1)
				{
					//its an actual index
					// (j.armen 2014-10-08 14:24) - PLID 63229 - Calculate the index based on the alpha character returned
					boost::shared_ptr<DiagCodeInfo> pDiag(GetDiagCodeInfoByIndex(static_cast<long>(index[0]) - 'A' + 1));

					//we found it
					CChargeWhichCodePair pair = CChargeWhichCodePair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID);
					pWhichCodes->insert(std::make_pair(pair, pDiag));
				}
			}
		}
	}
}

// (j.gruber 2014-03-12 09:30) - PLID 60895
CString CBillingDlg::GetIndexStringFromWhichCodeMap(CChargeWhichCodesMapPtr pWhichCodes)
{
	std::vector<long> indexes;
	if (pWhichCodes != NULL && pWhichCodes->size() > 0) {

		for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *pWhichCodes) {
			indexes.push_back(entry.second->nOrderIndex);
		}

		//now sort
		sort(indexes.begin(), indexes.end());

	}

	//now make the string
	// (j.armen 2014-08-07 12:01) - PLID 63229 - Use letters instead of numbers
	CString strIndexes;
	for each(long entry in indexes)
		strIndexes = strIndexes + static_cast<char>('A' + entry - 1) + ',';

	//trim off the last ","
	if (strIndexes != "") {
		strIndexes = strIndexes.Left(strIndexes.GetLength() - 1);
	}
	else {
		strIndexes = "(none)";
	}

	return strIndexes;
}

/*This function takes the codes we have in our list, and displays their indexes*/
// (j.gruber 2014-03-12 09:30) - PLID 60895
void CBillingDlg::DisplayWhichCodes(NXDATALIST2Lib::IRowSettingsPtr &pRow, CChargeWhichCodesMapPtr pWhichCodes)
{
	try {

		CString strIndexes = GetIndexStringFromWhichCodeMap(pWhichCodes);

		//check our preference
		if (ShouldShowDiagExt())
		{
			pRow->PutValue(BILL_COLUMN_WHICH_CODES_EXT, _variant_t(strIndexes));
		}
		else {
			pRow->PutValue(BILL_COLUMN_WHICH_CODES, _variant_t(strIndexes));
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.gruber 2014-08-14 14:23) - PLID 63373 - In an EMN you can link more than 4 diagnosis codes to a cpt code. When you bill an emn it will not show any linking if it is more than 4 diagnosis codes. The pointers only support 4 diagnosis codes.
struct CompareDiagCodes
{
	bool operator()(const DiagCodeInfoPtr& l, const DiagCodeInfoPtr& r) const
	{
		return  (l->nOrderIndex < r->nOrderIndex);
	}
};

// (j.gruber 2014-02-26 13:17) - PLID 60942
void CBillingDlg::LoadEMRWhichCodes(CChargeWhichCodesMapPtr &pWhichCodes, long nDiagCount, long nExternalID)
{
	try {

		// (j.gruber 2014-08-14 14:23) - PLID 63373 - In an EMN you can link more than 4 diagnosis codes to a cpt code. When you bill an emn it will not show any linking if it is more than 4 diagnosis codes. The pointers only support 4 diagnosis codes.
		std::vector<DiagCodeInfoPtr> stCodes;

		if (nDiagCount > 0) {
			//We will have to look it up.
			_RecordsetPtr prsEMRDiags = CreateParamRecordset("SELECT DiagCodeID as DiagCode9ID, DiagCodeID_ICD10 as DiagCode10ID FROM EMRChargesToDiagCodesT WHERE ChargeID = {INT}", nExternalID);
			while (!prsEMRDiags->eof) {
				long nEMRDiag9ID = AdoFldLong(prsEMRDiags, "DiagCode9ID", -1);
				long nEMRDiag10ID = AdoFldLong(prsEMRDiags, "DiagCode10ID", -1);
				CChargeWhichCodePair emnPair(nEMRDiag9ID, nEMRDiag10ID);

				// (j.jones 2009-03-25 12:44) - PLID 9729 - we now support up to 8 DiagCs
				// (j.jones 2010-10-20 17:29) - PLID 40988 - we now support up to 12 codes, but the loop didn't change
				DiagCodeInfoPtr pDiag = GetDiagCodeByPair(emnPair, FALSE);
				// (j.gruber 2014-08-14 14:23) - PLID 63373 - add to the vector
				if (pDiag)
				{
					stCodes.push_back(pDiag);

				}

				prsEMRDiags->MoveNext();
			}
			prsEMRDiags->Close();

			// (j.gruber 2014-08-14 14:23) - PLID 63373 - sort
			std::sort(stCodes.begin(), stCodes.end(), CompareDiagCodes());

			// (j.gruber 2014-08-14 14:23) - PLID 63373 - now add only the first 4
			long nCurrentCount = 0;
			foreach(DiagCodeInfoPtr pDiag, stCodes)
			{
				if (nCurrentCount < 4)
				{
					CChargeWhichCodePair emnPair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID);
					pWhichCodes->insert(std::make_pair(emnPair, pDiag));
					nCurrentCount++;
				}
			}

		}
	}NxCatchAll(__FUNCTION__);
}

// (j.gruber 2014-02-25 12:50) - PLID 60901
BOOL CBillingDlg::CanChargeBeEdited(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	// (j.jones 2011-08-24 09:03) - PLID 44868 - disallow editing on void or original charges
	long nChargeID = VarLong(pRow->GetValue(COLUMN_CHARGE_ID), -2);
	if (nChargeID != -2) {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr bi = m_billingItems[i];
			if (VarLong(bi->ChargeID) == nChargeID) {
				if (VarBool(bi->IsOriginalCharge, FALSE)) {
					MessageBox("This charge has been voided, and is no longer editable. If a corrected charge exists, you can edit that charge in order to make changes.", "Practice", MB_ICONINFORMATION | MB_OK);
					return FALSE;
				}
				else if (VarBool(bi->IsVoidingCharge, FALSE)) {
					MessageBox("This charge voids another charge, and is not editable. If a corrected charge exists, you can edit that charge in order to make changes.", "Practice", MB_ICONINFORMATION | MB_OK);
					return FALSE;
				}
			}
		}
	}

	//also check for a valid chargeID
	COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
	if (varChargeID.vt == VT_EMPTY){
		return FALSE;
	}

	return TRUE;
}

// (j.gruber 2014-02-25 12:50) - PLID 60901
BillingItemPtr CBillingDlg::GetBillingItemByLineID(long nLineID)
{
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr bi = m_billingItems[i];
		if (VarLong(bi->LineID) == nLineID) {
			return bi;
		}
	}

	ThrowNxException("Error in CBillingDlg::GetBillingItemByLineID - could not find billing item line %li", nLineID);
}

// (j.gruber 2014-02-25 12:50) - PLID 60901
void CBillingDlg::ShowWhichCodesSelectionDialog(NXDATALIST2Lib::IRowSettingsPtr pRow)
{
	if (!CanChargeBeEdited(pRow))
	{
		m_bHandlingLeftClickBillList = FALSE;
		return;
	}

	CBillSelectChargeDigsCodeDlg dlg(this);
	dlg.m_bReadOnly = (m_eHasAccess == batNoAccess);

	//load our array into the dialogs			
	for each(const DiagCodeInfoPtr& pDiag in m_arypDiagCodes)
		if (pDiag->nOrderIndex <= MAX_DIAG_Cs_INDEX)
			dlg.m_arypAllDiagCodes.Add(pDiag);

	//now get our billing item for this row
	BillingItemPtr pItem = GetBillingItemByLineID(VarLong(pRow->GetValue(COLUMN_LINE_ID)));
	if (pItem)
	{
		dlg.m_mapSelectedCodes = pItem->whichCodes;
	}
	long nItemType = VarLong(pRow->GetValue(COLUMN_ITEM_TYPE));
	if (nItemType == ITEM_TYPE_CPT)
		dlg.m_strCaption = FormatString("Code '%s'", VarString(pRow->GetValue(BILL_COLUMN_CPT_CODE), ""));
	else
		dlg.m_strCaption = FormatString("'%s'", VarString(pRow->GetValue(BILL_COLUMN_DESCRIPTION), ""));
	if (dlg.DoModal() == IDOK) {

		//update our display
		DisplayWhichCodes(pRow, pItem->whichCodes);

		//tell the dialog this charge has been modified
		COleVariant varChargeID = pRow->GetValue(COLUMN_CHARGE_ID);
		if (varChargeID.lVal != -2)
		{
			AddToModifiedList(varChargeID.lVal);
		}
	}
}

// (j.gruber 2014-02-24 11:33) - PLID 60893 - this function simply returns if the whichCodes for a given charge have changed
BOOL CBillingDlg::HaveWhichCodesChanged(CChargeWhichCodesMapPtr pOriginalWhichCodes, CChargeWhichCodesMapPtr pCurrentWhichCodes)
{
	if (pOriginalWhichCodes->size() != pCurrentWhichCodes->size())
	{
		return TRUE;
	}

	CString strOriginal = GetIndexStringFromWhichCodeMap(pOriginalWhichCodes);
	CString strCurrent = GetIndexStringFromWhichCodeMap(pCurrentWhichCodes);

	if (strOriginal != strCurrent)
	{
		//we know something changed
		return TRUE;
	}

	//just because they are the same, doesn't mean that the underlying diagcodes didn't actually change, so let's check it

	//we know both maps are the same size, so we can do this
	for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type origEntry in *pOriginalWhichCodes) {
		CChargeWhichCodePair originalPair = CChargeWhichCodePair(origEntry.second->nDiagCode9ID, origEntry.second->nDiagCode10ID);

		CChargeWhichCodesIterator itFindCurrent = pCurrentWhichCodes->find(originalPair);
		if (itFindCurrent == pCurrentWhichCodes->end())
		{
			//we didn't find it in our map, so we know they are different
			// (c.haag 2014-10-07) - PLID 63823 - If they're different then we should be returning TRUE, not FALSE
			return TRUE;
		}
		else {
			//its in our map, but is it in the same index
			if (origEntry.second->nOrderIndex != itFindCurrent->second->nOrderIndex)
			{
				// (c.haag 2014-10-07) - PLID 63823 - If they're different then we should be returning TRUE, not FALSE
				return TRUE;
			}
		}
	}

	//if we got here, they are the same 
	// (c.haag 2014-10-07) - PLID 63823 - If they're the same we should be returning FALSE
	return FALSE;

}

// (j.gruber 2014-02-24 11:50) - PLID 60893 - Audit any whichcodes changes
void CBillingDlg::GenerateWhichCodesAudit(long nChargeID, CChargeWhichCodesMapPtr pOriginalWhichCodes, CChargeWhichCodesMapPtr pCurrentWhichCodes)
{
	CString strOriginal = GetIndexStringFromWhichCodeMap(pOriginalWhichCodes);
	CString strCurrent = GetIndexStringFromWhichCodeMap(pCurrentWhichCodes);

	if (strOriginal == strCurrent)
	{
		//the codes behind the indexes may very well have changed, but that will be accounted for with the 
		// bill diag codes auditing.  Since our audit would be the same, we are not auditing this case
		return;
	}
	else {

		CString strPatientName = GetBillPatientName();
		long nAuditID = BeginNewAuditEvent();
		AuditEvent(m_nPatientID, strPatientName, nAuditID, aeiChargeWhichCodes, nChargeID, strOriginal, strCurrent, aepMedium);
	}
}

// (j.gruber 2014-02-24 09:36) - PLID 60893 - new which codes structure saving
void CBillingDlg::AuditAndGenerateSaveStringForWhichCodes(bool bIsNewCharge, long nChargeID, long nBillID, CChargeWhichCodesMapPtr pWhichCodes, CSqlFragment &sqlWhichCodeSave)
{
	//is this a new charge
	if (bIsNewCharge)
	{
		for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *pWhichCodes) {

			//there should only ever be 1, but just in case, only ever choose 1
			sqlWhichCodeSave += CSqlFragment("INSERT INTO ChargeWhichCodesT (ChargeID, BillDiagCodeID) "
				" SELECT TOP 1 @ChargeID, BillDiagCodeT.ID "
				" FROM BillDiagCodeT "
				" WHERE BillDiagCodeT.BillID = {INT} AND {SQL} AND {SQL} \r\n"
				, nBillID
				, entry.second->nDiagCode9ID == -1 ? CSqlFragment("BillDiagCodeT.ICD9DiagID IS NULL") : CSqlFragment("BillDiagCodeT.ICD9DiagID = {INT}", entry.second->nDiagCode9ID)
				, entry.second->nDiagCode10ID == -1 ? CSqlFragment("BillDiagCodeT.ICD10DiagID IS NULL") : CSqlFragment("BillDiagCodeT.ICD10DiagID = {INT}", entry.second->nDiagCode10ID));
		}
	}
	else {

		//did we change any which codes on this charge?

		//first get our original whichCode
		CChargeWhichCodesMapPtr pOriginalWhichCodes;
		std::map<long, CChargeWhichCodesMapPtr>::iterator itFind = m_mapBillWhichCodes.find(nChargeID);
		if (itFind != m_mapBillWhichCodes.end())
		{
			pOriginalWhichCodes = itFind->second;
		}
		else{
			//just set it to blank
			pOriginalWhichCodes = CChargeWhichCodesMapPtr(new CChargeWhichCodesMap);
		}

		if (HaveWhichCodesChanged(pOriginalWhichCodes, pWhichCodes))
		{

			//first Generate the Audit
			GenerateWhichCodesAudit(nChargeID, pOriginalWhichCodes, pWhichCodes);

			//now for the saving, first delete what we have
			sqlWhichCodeSave += CSqlFragment("DELETE FROM ChargeWhichCodesT WHERE ChargeID = {INT} \r\n", nChargeID);

			//now loop through our whichcodes and save them
			for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *pWhichCodes) {

				//is this a new diag code
				if (entry.second->nID == -1)
				{
					//its a new diagcode on this bill, so we don't have the ID yet
					sqlWhichCodeSave += CSqlFragment("INSERT INTO ChargeWhichCodesT (ChargeID, BillDiagCodeID) "
						" SELECT TOP 1 {INT}, BillDiagCodeT.ID "
						" FROM BillDiagCodeT "
						" WHERE BillDiagCodeT.BillID = {INT} AND {SQL} AND {SQL} \r\n"
						, nChargeID
						, nBillID
						, entry.second->nDiagCode9ID == -1 ? CSqlFragment("BillDiagCodeT.ICD9DiagID IS NULL") : CSqlFragment("BillDiagCodeT.ICD9DiagID = {INT}", entry.second->nDiagCode9ID)
						, entry.second->nDiagCode10ID == -1 ? CSqlFragment("BillDiagCodeT.ICD10DiagID IS NULL") : CSqlFragment("BillDiagCodeT.ICD10DiagID = {INT}", entry.second->nDiagCode10ID));
				}
				else {
					//we already have the IDs, so just add them
					sqlWhichCodeSave += CSqlFragment("INSERT INTO ChargeWhichCodesT (ChargeID, BillDiagCodeID) "
						" VALUES ({INT}, {INT}) \r\n", nChargeID, entry.second->nID);
				}
			}
		}
	}
}

// (j.gruber 2014-02-24 13:26) - PLID 60942 - ClearWhichCodes
void CBillingDlg::ClearWhichCodesList()
{
	try {
		m_mapBillWhichCodes.clear();
	}NxCatchAll("Error in CBillingDlg::ClearWhichCodesList");
}

void CBillingDlg::RemoveDiagCode(long nOrderIndex, long nDiag9CodeID, long nDiag10CodeID)
{
	m_arypDiagCodes.RemoveAt(nOrderIndex - 1);
	UpdateDiagCodeList();
	ReflectDiagCodeArrayToInterface();

	// (j.gruber 2014-02-24 15:42) - PLID 61008 - now do the whichcodes
	RemoveDiagCodeFromWhichCodes(nDiag9CodeID, nDiag10CodeID);
}

// (j.gruber 2014-02-24 15:42) - PLID 61008
DiagCodeInfoPtr CBillingDlg::GetDiagCodeByPair(CChargeWhichCodePair pair, BOOL bExpectsExistance /*= TRUE*/)
{
	for (int i = 0; i < m_arypDiagCodes.GetSize(); i++)
	{
		DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i);
		if (pDiag->nDiagCode9ID == pair.first
			&& pDiag->nDiagCode10ID == pair.second)
		{
			return pDiag;
		}

	}

	// (j.gruber 2014-02-26 11:22) - PLID 61033 - if we got here, we didn't find it, but we may expect this
	if (bExpectsExistance) {
		ThrowNxException("Error in CBillingDlg::GetDiagCodeByPair - could not find pair %li, %li", pair.first, pair.second);
	}
	else {
		return DiagCodeInfoPtr();
	}
}

// (j.gruber 2014-02-24 15:42) - PLID 61008
void CBillingDlg::RemoveDiagCodeFromWhichCodes(long nDiagCode9ID, long nDiagCode10ID)
{
	//generate our pair
	CChargeWhichCodePair pair = CChargeWhichCodePair(nDiagCode9ID, nDiagCode10ID);

	//now for each charge in our billingItem array, update our which codes to remove this pair
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr pItem = m_billingItems[i];

		CChargeWhichCodesMapPtr pWhichCodes = pItem->whichCodes;

		CChargeWhichCodesIterator itFind = pWhichCodes->find(pair);
		if (itFind != pWhichCodes->end())
		{
			//we have it, so remove it
			pWhichCodes->erase(itFind);
		}

		//we also have to update all of our order indexes
		for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type entry in *pWhichCodes) {
			entry.second->nOrderIndex = GetDiagCodeByPair(entry.first)->nOrderIndex;
		}

		//update the display
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pList->FindByColumn(COLUMN_LINE_ID, pItem->LineID, NULL, FALSE);
		if (pRow)
		{
			DisplayWhichCodes(pRow, pItem->whichCodes);
		}

		//make sure we set this charge to save
		if (pItem->ChargeID.lVal != -2) {
			//add even if its voided because thats how it was done before
			AddToModifiedList(pItem->ChargeID, TRUE);
		}

	}

	//reset the drop down	
	BuildWhichCodesCombo();
}

// (j.jones 2014-12-22 10:48) - PLID 64490 - added ability to replace an existing code
void CBillingDlg::ReplaceDiagCode(DiagCodeInfoPtr oldDiagCode, DiagCodeInfoPtr newDiagCode)
{
	//first show any insurance warnings
	{
		long nInsCoID = GetCurrentBillToInsuranceCoID();

		vector<long> aryDiagIDs;
		if (newDiagCode->nDiagCode9ID != -1)
		{
			aryDiagIDs.push_back(newDiagCode->nDiagCode9ID);
		}

		if (newDiagCode->nDiagCode10ID != -1) {
			aryDiagIDs.push_back(newDiagCode->nDiagCode10ID);
		}

		if (!OutputInsuranceDiagCodeWarning(nInsCoID, aryDiagIDs, TRUE))
		{
			//they chose to not add the code
			return;
		}
	}

	//don't let them add a duplicate combination
	{
		long nDuplicateOrderIndex = DetectDuplicateDiagnosisCode(newDiagCode);
		if (nDuplicateOrderIndex) {

			CString strCodeWarn = "";
			if (newDiagCode->nDiagCode10ID > 0) {
				strCodeWarn += newDiagCode->strDiagCode10Code;
			}

			if (newDiagCode->nDiagCode9ID > 0) {
				if (!strCodeWarn.IsEmpty()) {
					strCodeWarn += " (" + newDiagCode->strDiagCode9Code + ") \r\n";
				}
				else {
					strCodeWarn += newDiagCode->strDiagCode9Code + "\r\n";
				}
			}

			AfxMessageBox("The following diagnosis code already exists on the bill. "
				"It will not be added again. \r\n\r\n" + strCodeWarn, MB_ICONWARNING | MB_OK);
			return;
		}
	}

	//find and replace the old code with the new code
	for (int i = 0; i < m_arypDiagCodes.GetSize(); i++) {
		DiagCodeInfoPtr pCurDiag = m_arypDiagCodes.GetAt(i);
		if (pCurDiag->nDiagCode9ID == oldDiagCode->nDiagCode9ID
			&& pCurDiag->nDiagCode10ID == oldDiagCode->nDiagCode10ID) {
			
			//found the old code
			m_arypDiagCodes.SetAt(i, newDiagCode);
			break;
		}
	}

	//update the diag list on the screen
	UpdateDiagCodeList();
	ReflectDiagCodeArrayToInterface();
	SaveAllCharges(TRUE);

	//now update whichcodes
	ReplaceDiagCodeInWhichCodes(oldDiagCode, newDiagCode);
}

// (j.jones 2014-12-22 10:48) - PLID 64490 - added ability to replace an existing code
void CBillingDlg::ReplaceDiagCodeInWhichCodes(DiagCodeInfoPtr oldDiagCode, DiagCodeInfoPtr newDiagCode)
{
	//first change pointers
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr billitem = m_billingItems[i];
		if (billitem->whichCodes->size() > 0)
		{
			//find the old code, if present
			for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type whichCode in *billitem->whichCodes) {
				DiagCodeInfoPtr pDiag = whichCode.second;

				//is this our old code?
				if (pDiag->nDiagCode9ID == oldDiagCode->nDiagCode9ID
					&& pDiag->nDiagCode10ID == oldDiagCode->nDiagCode10ID) {

					//found it - replace it now
					CChargeWhichCodePair oldPair = CChargeWhichCodePair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID);
					CChargeWhichCodesIterator itFind = billitem->whichCodes->find(oldPair);
					if (itFind != billitem->whichCodes->end())
					{
						billitem->whichCodes->erase(itFind);
					}
					billitem->whichCodes->insert(std::make_pair(CChargeWhichCodePair(newDiagCode->nDiagCode9ID, newDiagCode->nDiagCode10ID), newDiagCode));

					//save the charge
					long nChargeID = VarLong(billitem->ChargeID, -2);
					if (nChargeID != -2) {
						AddToModifiedList(nChargeID, TRUE);
					}

					break;
				}
			}
		}
	}

	//reset the drop down	
	BuildWhichCodesCombo();
}

// (j.gruber 2014-02-24 15:11) - PLID 61011
//this function just sets the diag code controls based on the member array
void CBillingDlg::ReflectDiagCodeArrayToInterface()
{
	// (j.armen 2014-08-07 10:59) - PLID 63227 - Display diag codes to our new interface, if it exists
	if (m_pBillingDiagSearch)
		m_pBillingDiagSearch->SetDiagCodes(m_arypDiagCodes);
}

// (j.gruber 2014-03-21 13:27) - PLID 61493 - created for
// (j.gruber 2014-03-24 14:54) - PLID 61529 - adding bSilent
long CBillingDlg::AddDiagCode(long nDiag9ID, long nDiag10ID, CString strDiag9Code, CString strDiag10Code, CString strDiag9Desc, CString strDiag10Desc, BOOL bSilent /*= FALSE*/)
{
	DiagCodeInfoPtr pNewDiag = DiagCodeInfoPtr(new DiagCodeInfo);
	pNewDiag->nDiagCode9ID = nDiag9ID;
	pNewDiag->strDiagCode9Code = strDiag9Code;
	pNewDiag->strDiagCode9Desc = strDiag9Desc;
	pNewDiag->nDiagCode10ID = nDiag10ID;
	pNewDiag->strDiagCode10Code = strDiag10Code;
	pNewDiag->strDiagCode10Desc = strDiag10Desc;
	pNewDiag->nID = -1;
	//add to our array of diag codes
	// (j.gruber 2014-03-24 15:03) - PLID 61529 - added bSilent
	return AddDiagCode(pNewDiag, bSilent);
}

// (c.haag 2014-03-04) - PLID 60928 - This is the bottleneck for adding new diagnosis codes to this dialog.
long CBillingDlg::AddDiagCode(DiagCodeInfoPtr pNewDiag, BOOL bSilent /*= FALSE*/)
{

	// (j.gruber 2014-03-24 14:48) - PLID 61529  - if we aren't going to show the warning, don't bother checking
	// (j.armen 2014-03-26 08:29) - PLID 61517 - use vector
	if (!bSilent)
	{
		long nInsCoID = GetCurrentBillToInsuranceCoID();

		vector<long> aryDiagIDs;
		if (pNewDiag->nDiagCode9ID != -1)
		{
			aryDiagIDs.push_back(pNewDiag->nDiagCode9ID);
		}

		if (pNewDiag->nDiagCode10ID != -1) {
			aryDiagIDs.push_back(pNewDiag->nDiagCode10ID);
		}

		if (!OutputInsuranceDiagCodeWarning(nInsCoID, aryDiagIDs, TRUE))
		{
			//they chose to not add the code
			return -1;
		}
	}

	// (b.spivey, March 7, 2014) - PLID 61245 - Don't let them add a duplicate combination. 
	long nDuplicateOrderIndex = DetectDuplicateDiagnosisCode(pNewDiag);
	if (nDuplicateOrderIndex) {

		// (j.gruber 2014-03-24 15:31) - PLID 61529 - added bSilent
		if (!bSilent) {
			CString strCodeWarn = "";
			if (pNewDiag->nDiagCode10ID > 0) {
				strCodeWarn += pNewDiag->strDiagCode10Code;
			}

			if (pNewDiag->nDiagCode9ID > 0) {
				if (!strCodeWarn.IsEmpty()) {
					strCodeWarn += " (" + pNewDiag->strDiagCode9Code + ") \r\n";
				}
				else {
					strCodeWarn += pNewDiag->strDiagCode9Code + "\r\n";
				}
			}

			AfxMessageBox("The following diagnosis code already exists on the bill. "
				"It will not be added again. \r\n\r\n" + strCodeWarn, MB_ICONWARNING | MB_OK);
		}
		return nDuplicateOrderIndex;
	}

	//add to our array of diag codes
	m_arypDiagCodes.Add(pNewDiag);

	//update our array index
	UpdateDiagCodeList();
	//reflect data to controls
	ReflectDiagCodeArrayToInterface();
	// (j.gruber 2014-02-25 10:14) - PLID 60878 - renamed
	BuildWhichCodesCombo();
	// (j.gruber 2014-03-28 08:26) - PLID 60898 - save all charges 
	SaveAllCharges(TRUE);

	return m_arypDiagCodes.GetCount();
}

// (j.armen 2014-08-07 15:12) - PLID 63231 - Called from the billing diag search when code order is modified
void CBillingDlg::DiagOrderModified()
{
	// Get the diag codes from the diag search
	m_arypDiagCodes = m_pBillingDiagSearch->GetDiagCodes();

	// Update our WhichCodes
	ReconcileWhichCodes();
}

// (j.armen 2014-08-07 17:12) - PLID 63236 - Called from the billing diag search when a code is removed
void CBillingDlg::RemoveDiagCode()
{
	// Get the diag codes from the diag search
	m_arypDiagCodes = m_pBillingDiagSearch->GetDiagCodes();

	// Update the code order
	UpdateDiagCodeList();

	//and update the DiagCs column
	BuildWhichCodesCombo();

	// Update our WhichCodes
	ReconcileWhichCodes();
}

// (j.gruber 2014-02-26 10:44) - PLID 61033 - this function changes the whichcodes on the given charges to 
// account for the changes that occurred when using the Code Order dialog
// (j.armen 2014-08-07 15:12) - PLID 63231 - Removed diag array, it was not used
void CBillingDlg::ReconcileWhichCodes()
{
	for each(const BillingItemPtr& billitem in m_billingItems) {

		if (billitem->whichCodes->size() > 0)
		{
			std::vector<CChargeWhichCodePair> pairsToRemove;

			//loop through the whichcodes and change the order index
			for each (std::map<CChargeWhichCodePair, DiagCodeInfoPtr>::value_type whichCode in *billitem->whichCodes) {
				DiagCodeInfoPtr pDiag = whichCode.second;

				//can we find the diag in the new array
				CChargeWhichCodePair pair = CChargeWhichCodePair(pDiag->nDiagCode9ID, pDiag->nDiagCode10ID);
				DiagCodeInfoPtr pNewDiag = GetDiagCodeByPair(pair, FALSE);
				if (pNewDiag)
				{
					//we found it, so just update the order index
					pDiag->nOrderIndex = pNewDiag->nOrderIndex;
				}
				else {
					//they removed it, add it to our removal vector
					pairsToRemove.push_back(pair);
				}
			}

			//now go through and remove the ones we need to
			for each(std::vector<CChargeWhichCodePair>::value_type pair in pairsToRemove)
			{
				CChargeWhichCodesIterator itFind = billitem->whichCodes->find(pair);
				if (itFind != billitem->whichCodes->end())
				{
					billitem->whichCodes->erase(itFind);
				}
			}

			//now update the display
			NXDATALIST2Lib::IRowSettingsPtr pRow = m_pList->FindByColumn(COLUMN_LINE_ID, billitem->LineID, NULL, FALSE);
			if (pRow)
			{
				DisplayWhichCodes(pRow, billitem->whichCodes);
			}
		}
	}
}

//(b.spivey - February 26, 2014) PLID 60994 - Load default diag codes. 
void CBillingDlg::LoadDefaultDiagnosisCodes()
{
	ClearDiagCodesList();
	// (j.jones 2009-03-25 10:02) - PLID 33653 - also clear the "old" array
	ClearOldDiagCodesList();

	_RecordsetPtr rsDiag = CreateParamRecordset(
		"DECLARE @PersonID INT "
		"SET @PersonID = {INT} "

		"SELECT DDQ.OrderIndex, DDQ.ICD9DiagID, DDQ.ICD10DiagID, "
		"	ICD9Codes.CodeDesc AS ICD9CodeDesc, ICD9Codes.CodeNumber AS ICD9Code, "
		"	ICD10Codes.CodeDesc AS ICD10CodeDesc, ICD10Codes.CodeNumber AS ICD10Code "
		"FROM "
		"( "
		"	 SELECT 1, DefaultDiagID1, DefaultICD10DiagID1 FROM PatientsT WHERE PersonID = @PersonID "
		"	 UNION ALL SELECT 2, DefaultDiagID2, DefaultICD10DiagID2 FROM PatientsT WHERE PersonID = @PersonID "
		"	 UNION ALL SELECT 3, DefaultDiagID3, DefaultICD10DiagID3 FROM PatientsT WHERE PersonID = @PersonID "
		"	 UNION ALL SELECT 4, DefaultDiagID4, DefaultICD10DiagID4 FROM PatientsT WHERE PersonID = @PersonID "
		") DDQ (OrderIndex, ICD9DiagID, ICD10DiagID) "
		"LEFT JOIN DiagCodes ICD9Codes ON DDQ.ICD9DiagID = ICD9Codes.ID  "
		"LEFT JOIN DiagCodes ICD10Codes ON DDQ.ICD10DiagID = ICD10Codes.ID AND ICD10Codes.ICD10 = 1 "
		"ORDER BY DDQ.OrderIndex ", m_nPatientID);

	while (!rsDiag->eof) {

			{
				long nICD9ID = AdoFldLong(rsDiag, "ICD9DiagID", -1);
				long nICD10ID = AdoFldLong(rsDiag, "ICD10DiagID", -1);

				if (nICD9ID < 0 && nICD10ID < 0) {
					rsDiag->MoveNext();
					continue;
				}


				DiagCodeInfoPtr pDiagNew = DiagCodeInfoPtr(new DiagCodeInfo);
				pDiagNew->nID = -1;
				pDiagNew->nDiagCode9ID = AdoFldLong(rsDiag, "ICD9DiagID", -1);
				pDiagNew->nDiagCode10ID = AdoFldLong(rsDiag, "ICD10DiagID", -1);
				pDiagNew->strDiagCode9Code = AdoFldString(rsDiag, "ICD9Code", "");
				pDiagNew->strDiagCode10Code = AdoFldString(rsDiag, "ICD10Code", "");
				pDiagNew->strDiagCode9Desc = AdoFldString(rsDiag, "ICD9CodeDesc", "");
				pDiagNew->strDiagCode10Desc = AdoFldString(rsDiag, "ICD10CodeDesc", "");
				pDiagNew->nOrderIndex = AdoFldLong(rsDiag, "OrderIndex");

				//(b.spivey - March 18th, 2014) PLID 60994 - skip duplicates. 
				if (DetectDuplicateDiagnosisCode(pDiagNew)) {
					rsDiag->MoveNext();
					continue;
				}

				m_arypDiagCodes.Add(pDiagNew);
			}

		// (j.jones 2009-03-25 10:07) - PLID 33653 - now add the same info. to our "old" array,
		// which will later be used for auditing
		{
			// (j.gruber 2014-02-21 09:19) - PLID 61494
			DiagCodeInfoPtr pDiagOld = DiagCodeInfoPtr(new DiagCodeInfo);
			pDiagOld->nDiagCode9ID = AdoFldLong(rsDiag, "ICD9DiagID", -1);
			pDiagOld->nDiagCode10ID = AdoFldLong(rsDiag, "ICD10DiagID", -1);
			pDiagOld->strDiagCode9Code = AdoFldString(rsDiag, "ICD9Code", "");
			pDiagOld->strDiagCode10Code = AdoFldString(rsDiag, "ICD10Code", "");
			pDiagOld->strDiagCode9Desc = AdoFldString(rsDiag, "ICD9CodeDesc", "");
			pDiagOld->strDiagCode10Desc = AdoFldString(rsDiag, "ICD10CodeDesc", "");
			pDiagOld->nOrderIndex = AdoFldLong(rsDiag, "OrderIndex");
			m_arypOldDiagCodes.Add(pDiagOld);
		}

		rsDiag->MoveNext();
	}
	rsDiag->Close();

	//now update the list on the screen
	UpdateDiagCodeList();
}

//(b.spivey - March 17th, 2014) PLID 61396 - update g2 diag codes. 
void CBillingDlg::UpdateG2DefaultDiagnosisCodes(bool bPromptToSave)
{

	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr prsDiags = CreateParamRecordset("SELECT DefaultDiagID1, DefaultDiagID2, DefaultDiagID3, DefaultDiagID4, "
		"DefaultICD10DiagID1, DefaultICD10DiagID2, DefaultICD10DiagID3, DefaultICD10DiagID4 "
		"FROM PatientsT WHERE PersonID = {INT}", m_nPatientID);

	long nDefDiag1ICD9, nDefDiag2ICD9, nDefDiag3ICD9, nDefDiag4ICD9, nDefDiag1ICD10, nDefDiag2ICD10, nDefDiag3ICD10, nDefDiag4ICD10;
	nDefDiag1ICD9 = nDefDiag2ICD9 = nDefDiag3ICD9 = nDefDiag4ICD9 = nDefDiag1ICD10 = nDefDiag2ICD10 = nDefDiag3ICD10 = nDefDiag4ICD10 = -1;

	CString strDefaultICD9, strDefaultICD10;
	strDefaultICD9 = strDefaultICD10 = "";

	if (!prsDiags->eof) {
		strDefaultICD9 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultDiagID1", -1));
		strDefaultICD9 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultDiagID2", -1));
		strDefaultICD9 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultDiagID3", -1));
		strDefaultICD9 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultDiagID4", -1));

		strDefaultICD10 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultICD10DiagID1", -1));
		strDefaultICD10 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultICD10DiagID2", -1));
		strDefaultICD10 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultICD10DiagID3", -1));
		strDefaultICD10 += FormatString("%li;", AdoFldLong(prsDiags->Fields, "DefaultICD10DiagID4", -1));
	}

	bool bSave = true;

	CString strICD9, strICD10;

	for (int i = 0; i < 4; i++) {

		DiagCodeInfoPtr pInfo = DiagCodeInfoPtr(new DiagCodeInfo);
		if (i < m_arypDiagCodes.GetCount()) {
			pInfo = m_arypDiagCodes.GetAt(i);
		}
		else {
			pInfo->nDiagCode10ID = -1;
			pInfo->nDiagCode9ID = -1;
		}

		strICD9 += FormatString("%li;", pInfo->nDiagCode9ID);
		strICD10 += FormatString("%li;", pInfo->nDiagCode10ID);
	}

	if (strDefaultICD9.CompareNoCase(strICD9) == 0 && strDefaultICD10.CompareNoCase(strICD10) == 0) {
		return;
	}


	if (bPromptToSave) {
		if (MsgBox(MB_YESNO, "The diagnosis codes on this bill do not match what is on the General 2 tab of the Patient's Module. "
			"Do you want to update the General 2 tab of the Patient's Module?") == IDNO) {
			return;
		}
	}

	long nIt = 0;

	while (nIt < 4) {
		DiagCodeInfoPtr pInfo = DiagCodeInfoPtr(new DiagCodeInfo);
		if (nIt < m_arypDiagCodes.GetCount()) {
			pInfo = m_arypDiagCodes.GetAt(nIt);
		}
		else {
			pInfo->nDiagCode10ID = -1;
			pInfo->nDiagCode9ID = -1;
		}

		_variant_t varDiagICD9 = g_cvarNull;
		_variant_t varDiagICD10 = g_cvarNull;

		if (pInfo->nDiagCode9ID != -1) {
			varDiagICD9 = _variant_t(pInfo->nDiagCode9ID, VT_I4);
		}

		if (pInfo->nDiagCode10ID != -1) {
			varDiagICD10 = _variant_t(pInfo->nDiagCode10ID, VT_I4);
		}

		// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
		ExecuteParamSql(FormatString("UPDATE PatientsT SET DefaultDiagID%li = {VT_I4}, DefaultICD10DiagID%li = {VT_I4} "
			"WHERE PersonID = {INT}", (nIt + 1), (nIt + 1)), varDiagICD9, varDiagICD10, m_nPatientID);

		nIt++;

	}
	// (j.jones 2005-10-25 09:36) - PLID 18061 - this uses the PatG1 tablechecker
	// as a general "this patient's demographics have changed" message
	CClient::RefreshTable(NetUtils::PatG1, m_nPatientID);

	// UPDATE THE PALM RECORD
	UpdatePalm();
}

// (b.spivey, February 27, 2014) - PLID 61081 - This function hits the DB to see what codes still exist-- we may have removed them entirely 
//	from the database. 
void CBillingDlg::UpdateDiagnosisCodesReflectDatabase()
{
	CSqlFragment sql("");

	//Insert all this into a temp table. 
	for (int i = 0; i < m_arypDiagCodes.GetCount(); i++) {
		DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(i);
		sql += CSqlFragment("INSERT INTO @BillDiagCodesT (ICD9_ID, ICD9_Code, ICD9_Desc, ICD10_ID, ICD10_Code, ICD10_Desc, OrderIndex) "
			"VALUES ({INT}, {STRING}, {STRING}, {INT}, {STRING}, {STRING}, {INT}) ",
			pDiag->nDiagCode9ID,
			pDiag->strDiagCode9Code,
			pDiag->strDiagCode9Desc,
			pDiag->nDiagCode10ID,
			pDiag->strDiagCode10Code,
			pDiag->strDiagCode10Desc,
			pDiag->nOrderIndex);

	}

	//Using our queries, we'll have a recordset, ideally in order, 
	ADODB::_RecordsetPtr prs = CreateParamRecordset("SET NOCOUNT ON "
		"	DECLARE @BillDiagCodesT TABLE "
		"	( "
		"		ICD9_ID INT, "
		"		ICD9_Code NVARCHAR(MAX), "
		"		ICD9_Desc NVARCHAR(MAX), "
		"		ICD10_ID INT, "
		"		ICD10_Code NVARCHAR(MAX), "
		"		ICD10_Desc NVARCHAR(MAX),  "
		"		OrderIndex INT "
		"	) "
		"	"
		"{SQL} "
		"	"
		"SELECT ICD9.ID AS ICD9DiagID, ICD9.CodeDesc AS ICD9CodeDesc, ICD9.CodeNumber AS ICD9CodeNum, "
		"ICD10.ID AS ICD10DiagID, ICD10.CodeDesc AS ICD10CodeDesc, ICD10.CodeNumber AS ICD10CodeNum "
		"FROM @BillDiagCodesT BDCT "
		"LEFT JOIN DiagCodes ICD9 ON BDCT.ICD9_ID = ICD9.ID "
		"LEFT JOIN DiagCodes ICD10 ON BDCT.ICD10_ID = ICD10.ID AND ICD10.ICD10 = 1 "
		"ORDER BY BDCT.OrderIndex "
		"SET NOCOUNT OFF ",
		sql);

	long nIt = 0;
	while (!prs->eof) {

		//Go through the same order that we just went through in order to update the array. 
		DiagCodeInfoPtr pDiag = m_arypDiagCodes.GetAt(nIt);
		long nICD9DiagID = AdoFldLong(prs->Fields, "ICD9DiagID", -1);
		long nICD10DiagID = AdoFldLong(prs->Fields, "ICD10DiagID", -1);

		//If it's gone entirely, we need to remove it from our array. 
		if (nICD9DiagID == -1 && nICD10DiagID == -1) {
			m_arypDiagCodes.RemoveAt(nIt);
			prs->MoveNext();
			continue;
		}

		// (b.spivey, March 17th, 2014) - PLID 61081 - set the IDs too. 
		pDiag->nDiagCode9ID = nICD9DiagID;
		pDiag->nDiagCode10ID = nICD10DiagID;

		pDiag->strDiagCode9Code = AdoFldString(prs->Fields, "ICD9CodeNum", "");
		pDiag->strDiagCode10Code = AdoFldString(prs->Fields, "ICD10CodeNum", "");

		pDiag->strDiagCode9Desc = AdoFldString(prs->Fields, "ICD9CodeDesc", "");
		pDiag->strDiagCode10Desc = AdoFldString(prs->Fields, "ICD10CodeDesc", "");

		//if we made it this far, we need to update the next element. 
		nIt++;
		prs->MoveNext();
	}

	//Update array and controls
	UpdateDiagCodeList();
	ReflectDiagCodeArrayToInterface();
}

// (b.spivey, March 7, 2014) - PLID 61245 - Don't let them add a duplicate combination. 
long CBillingDlg::DetectDuplicateDiagnosisCode(DiagCodeInfoPtr pNewDiag)
{
	// (j.gruber 2014-03-31 11:46) - PLID 61602 - made this one use the override
	return DetectDuplicateDiagnosisCode(pNewDiag->nDiagCode9ID, pNewDiag->nDiagCode10ID);
}

// (j.gruber 2014-03-31 11:45) - PLID 61602 - made an override that just takes IDs
long CBillingDlg::DetectDuplicateDiagnosisCode(long nDiagCode9ID, long nDiagCode10ID)
{
	for (int i = 0; i < m_arypDiagCodes.GetCount(); i++) {
		const DiagCodeInfoPtr& pDiag = m_arypDiagCodes[i];
		if ((pDiag->nDiagCode9ID == nDiagCode9ID)
			&& (pDiag->nDiagCode10ID == nDiagCode10ID))
		{
			return i + 1;
		}
	}
	return 0;
}

// (j.gruber 2014-03-31 11:03) - PLID 61602
void CBillingDlg::SetICD9ForDiagCodeInfo(CChargeWhichCodePair pair)
{

	//first popup our selection dialog	
	CSelectDlg dlg(this);
	dlg.m_strTitle = "Select an ICD-9 Code";
	dlg.m_strCaption = "Select an ICD-9 Code.";
	dlg.m_strFromClause = "(SELECT ID, CodeNumber, CodeDesc From DiagCodes WHERE Active = 1 AND ICD10 = 0 ) Q";

	dlg.AddColumn("ID", "ID", FALSE, FALSE);
	dlg.AddColumn("CodeNumber", "Code", TRUE, FALSE, FALSE, -1, 1);
	dlg.AddColumn("CodeDesc", "Description", TRUE, FALSE, FALSE);

	if (IDOK == dlg.DoModal()) {
		long nDiagCodeID = VarLong(dlg.m_arSelectedValues[0], -1);

		if (nDiagCodeID != -1) {
			//we have to lookup the other information we need from data
			CString strCode, strDescription;
			_RecordsetPtr rsDiag = CreateParamRecordset("SELECT CodeNumber, CodeDesc FROM DiagCodes WHERE ID = {INT}", nDiagCodeID);
			if (!rsDiag->eof)
			{
				strCode = AdoFldString(rsDiag->Fields, "CodeNumber");
				strDescription = AdoFldString(rsDiag->Fields, "CodeDesc");
			}

			//now let's get our diagCodeInfoPtr	
			DiagCodeInfoPtr pDiag = GetDiagCodeByPair(pair);

			if (DetectDuplicateDiagnosisCode(nDiagCodeID, pDiag->nDiagCode10ID))
			{
				//pop up a message
				MsgBox("This diagnosis code already exists on the bill. "
					"It will not be added again. \r\n\r\n");

				return;
			}

			//add the 9 information
			pDiag->nDiagCode9ID = nDiagCodeID;
			pDiag->strDiagCode9Code = strCode;
			pDiag->strDiagCode9Desc = strDescription;


			//reflect it in the interface
			ReflectDiagCodeArrayToInterface();

			// (j.gruber 2014-03-28 08:26) - PLID 60898 - save all charges 
			SaveAllCharges(TRUE);

			UpdateWhichCodes(pair, pDiag);
		}
	}
}

// (j.gruber 2014-04-01 15:58) - PLID 61602 - update the which codes pointer 
void CBillingDlg::UpdateWhichCodes(CChargeWhichCodePair oldPair, DiagCodeInfoPtr pNewInfoPtr)
{
	//now for each charge in our billingItem array, update our which codes to remove this pair
	for (int i = 0; i < (int)m_billingItems.size(); i++) {
		BillingItemPtr pItem = m_billingItems[i];

		CChargeWhichCodesMapPtr pWhichCodes = pItem->whichCodes;

		CChargeWhichCodesIterator itFind = pWhichCodes->find(oldPair);
		if (itFind != pWhichCodes->end())
		{
			//we have it, so erase it and add our new one
			pWhichCodes->erase(itFind);
			pWhichCodes->insert(std::make_pair(CChargeWhichCodePair(pNewInfoPtr->nDiagCode9ID, pNewInfoPtr->nDiagCode10ID), pNewInfoPtr));
		}
	}
}

// (j.gruber 2014-03-31 12:42) - PLID 61605
void CBillingDlg::SetICD10ForDiagCodeInfo(CChargeWhichCodePair pair)
{

	//first popup nexCode
	CNexCodeDlg dlg(this);

	if (IDOK == dlg.DoModal()) {
		long nDiagCodeID = dlg.GetDiagCodeID();

		if (nDiagCodeID != -1) {

			//now let's get our diagCodeInfoPtr	
			DiagCodeInfoPtr pDiag = GetDiagCodeByPair(pair);

			if (DetectDuplicateDiagnosisCode(pDiag->nDiagCode9ID, nDiagCodeID))
			{
				//pop up a message
				MsgBox("This diagnosis code already exists on the bill. "
					"It will not be added again. \r\n\r\n");

				return;
			}

			//add the 10 information
			pDiag->nDiagCode10ID = nDiagCodeID;
			pDiag->strDiagCode10Code = dlg.GetDiagCode();
			pDiag->strDiagCode10Desc = dlg.GetDiagCodeDescription();


			//reflect it in the interface
			ReflectDiagCodeArrayToInterface();

			// (j.gruber 2014-03-28 08:26) - PLID 60898 - save all charges 
			SaveAllCharges(TRUE);

			UpdateWhichCodes(pair, pDiag);
		}
	}
}
// (s.tullis 2015-03-24 09:28) - PLID 64973 -  Sets the CPT Category Format setting Pointer
void CBillingDlg::SetCPTCategoryCombo(NXDATALIST2Lib::IRowSettingsPtr pRow, BillingItemPtr pBillItem, BillEntryType type)
{
	try{
		NXDATALIST2Lib::IFormatSettingsPtr pfsLookup(__uuidof(NXDATALIST2Lib::FormatSettings));
		if (pRow){
			pfsLookup = GetCPTMultiCategoryCombo(pBillItem);

			if (pfsLookup != NULL){
				pRow->PutRefCellFormatOverride(type == BillEntryType::Bill ? BILL_COLUMN_CPT_CATEGORY : QUOTE_COLUMN_CPT_CATEGORY, pfsLookup);
			}
			else{
				ASSERT(FALSE);
			}
		}
	
	}NxCatchAll(__FUNCTION__)
}

// (s.tullis 2015-03-24 09:28) - PLID 64973 -  Gets the Format Setting pointer 
NXDATALIST2Lib::IFormatSettingsPtr CBillingDlg::GetCPTMultiCategoryCombo( IN BillingItemPtr pBillItem)
{
		IFormatSettingsPtr pfs(__uuidof(FormatSettings));
		
		long nCategoryCount = VarLong(pBillItem->CPTCategoryCount, -1);
		long nCategoryID = pBillItem->CPTCategoryID.vt == VT_I4 ?  VarLong(pBillItem->CPTCategoryID) : -1 ;
		// (s.tullis 2015-04-09 17:29) - PLID 65537 
		//Need to change the text of the dropdown from (none) to <Select>
		//If they have multiple categories configured and no default set
		CString strComboSource = FormatString(
			"Select CategoriesT.ID AS ID , CategoriesT.Name AS Text "
			"FROM CategoriesT "
			"LEFT JOIN ServiceMultiCategoryT ON CategoriesT.ID = ServiceMultiCategoryT.CategoryID "
			"Where ServiceMultiCategoryT.ServiceID = %li OR CategoriesT.ID =%li "
			"UNION "
			"SELECT '-1' AS ID, CASE WHEN %li = 1 THEN  '     <Select>' ELSE  '     (None)' END AS Text "
			"ORDER BY Text ASC", VarLong(pBillItem->ServiceID),nCategoryID,long( nCategoryCount > 1 ? TRUE: FALSE));
			
			pfs->PutDataType(VT_I4);
			pfs->PutFieldType(cftComboSimple);
			pfs->PutEditable(nCategoryCount > 1 ? VARIANT_TRUE : VARIANT_FALSE);
			pfs->PutConnection(_variant_t((LPDISPATCH)GetRemoteData())); //we're going to let this combo use Practice's connection
			pfs->EmbeddedComboDropDownMaxHeight = 300;
			pfs->EmbeddedComboDropDownWidth = 200;
			pfs->PutComboSource(_bstr_t(strComboSource));

		return pfs;
}

// (j.jones 2014-04-23 10:28) - PLID 61836 - added a function to get the provider combo content
void CBillingDlg::GetProviderComboSql(OUT CString &strProvCombo, OUT CString &strClaimProvCombo, OUT CString &strReferringProvCombo, OUT CString &strOrderingProvCombo, OUT CString &strSupervisingProvCombo)
{
	// (j.jones 2014-04-22 16:49) - PLID 61836 - Moved this code to this function. I also cleaned up this code for consistency.

	// If you sort by Last/First/Middle (the default), all the provider lists sort this way and display the name this way.
	// If you sort by First/Middle/Last, all the provider lists sort this way and display the name this way as well.

	CString strName = "RTRIM([Last] + (CASE WHEN [First] <> '' THEN ', ' ELSE '' END) + [First] + ' ' + Middle + ' ' + Title)";
	CString strOrderBy = "[Last], [First], Middle";

	long nProvSort = GetRemotePropertyInt("SortBillProvList", 0, 0, "<None>", true);
	if (nProvSort == 1) {
		//sort provider list by first name, last name
		strOrderBy = "[First], Middle, [Last]";
		strName = "RTRIM(LTRIM([First] + ' ' + Middle + ' ' + [Last] + ' ' + Title))";
	}

	strProvCombo.Format("SELECT PersonT.ID, (%s) AS Name, "
		"CASE WHEN PersonT.Archived = 0 THEN 1 ELSE 0 END "
		"FROM PersonT INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
		"ORDER BY %s", strName, strOrderBy);

	if (m_EntryType == 1) {
		//for bills only

		strClaimProvCombo.Format("SELECT ProvidersQ.ID, (%s) AS Name, "
			"CASE WHEN ProvidersQ.Archived = 0 THEN 1 ELSE 0 END "
			"FROM (SELECT -1 AS ID, '' AS First, '' AS Middle, ' <Use Default Claim Provider>' AS Last, '' AS Title, 0 AS Archived "
			"	UNION SELECT ID, First, Middle, Last, Title, Archived FROM PersonT INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID) AS ProvidersQ "
			"ORDER BY %s", strName, strOrderBy);

		// (j.jones 2014-04-22 16:41) - PLID 61836 - Added referring, ordering, and supervising providers.
		// Each of these can be providers or referring physicians, but you can only select those with the
		// respective referring/ordering/supervising boolean checked. However they may have chosen a provider
		// on an existing bill that is no longer configured as that provider type, so we still need to
		// re-select it, and treat it like an inactive provider.
		{
			//since all three of these special provider lists are the same base logic,
			//assign one base query to all of them and change the title and field names
			//as needed
			CString strBaseQuery;
			strBaseQuery.Format("SELECT ProvidersQ.ID, (%s) AS Name, "
				"CASE WHEN ProvidersQ.Archived = 0 THEN 1 ELSE 0 END "
				"FROM (SELECT -1 AS ID, '' AS First, '' AS Middle, ' <No [TYPENAME] Provider>' AS Last, '' AS Title, 0 AS Archived "
				"	UNION SELECT ID, First, Middle, Last, Title, "
				"		CASE WHEN PersonT.Archived = 1 OR ProvidersT.[TYPENAME]Provider = 0 THEN 1 ELSE 0 END AS IsInactive "
				"		FROM PersonT "
				"		INNER JOIN ProvidersT ON PersonT.ID = ProvidersT.PersonID "
				"	UNION SELECT ID, First, Middle, Last, Title, "
				"		CASE WHEN PersonT.Archived = 1 OR ReferringPhysT.[TYPENAME]Provider = 0 THEN 1 ELSE 0 END AS IsInactive "
				"		FROM PersonT "
				"		INNER JOIN ReferringPhysT ON PersonT.ID = ReferringPhysT.PersonID "
				") AS ProvidersQ "
				"ORDER BY %s", strName, strOrderBy);

			strReferringProvCombo = strBaseQuery;
			strOrderingProvCombo = strBaseQuery;
			strSupervisingProvCombo = strBaseQuery;
		}

		//now change each query to reference the right field
		strReferringProvCombo.Replace("[TYPENAME]", "Referring");
		strOrderingProvCombo.Replace("[TYPENAME]", "Ordering");
		strSupervisingProvCombo.Replace("[TYPENAME]", "Supervising");
	}
}

// (j.jones 2014-04-23 10:11) - PLID 61836 - Generic function to force showing
// a column, in the event it is currently at 0 width.
// Billing columns use a percent width if not remembering widths,
// and a pixel width if we are remembering widths.
void CBillingDlg::ForceShowColumn(short iColumnIndex, long nPercentWidth, long nPixelWidth)
{
	if (nPercentWidth <= 0 || nPixelWidth <= 0 || nPercentWidth >= 100) {
		//You clearly have missed the point of this function.
		//All callers must provide nonzero numbers in both fields,
		//and percent width cannot be > 100.
		ASSERT(FALSE);
		ThrowNxException("CBillingDlg::ForceShowColumn could not size column %li appropriately.", iColumnIndex);
	}

	if (nPercentWidth >= nPixelWidth) {
		//are you sure you didn't enter these numbers backwards?
		ASSERT(FALSE);
	}

	//m_pList may refer to the bill list or the quote list
	IColumnSettingsPtr pCol = m_pList->GetColumn(iColumnIndex);
	if (pCol == NULL) {
		//should be impossible
		ThrowNxException("CBillingDlg::ForceShowColumn could not find column index %li.", iColumnIndex);
	}

	if (pCol->GetStoredWidth() == 0) {
		//the column is not shown, so show it

		long nStyle = pCol->ColumnStyle;
		if (nStyle & csWidthPercent) {
			//percent width
			pCol->PutStoredWidth(nPercentWidth);
		}
		else {
			//pixel width
			pCol->PutStoredWidth(nPixelWidth);
		}
	}
}

// (j.jones 2014-04-23 10:11) - PLID 61836 - these functions will forcibly show the
// Referring, Ordering, or Supervising provider columns in the charge list, if
// they happen to be hidden
void CBillingDlg::ShowReferringProviderColumn()
{
	if (m_EntryType != 1) {
		//this should only be called on a bill
		ASSERT(FALSE);
		return;
	}

	ForceShowColumn(BILL_COLUMN_REFERRING_PROVIDER, 10, 74);
}

void CBillingDlg::ShowOrderingProviderColumn()
{
	if (m_EntryType != 1) {
		//this should only be called on a bill
		ASSERT(FALSE);
		return;
	}

	ForceShowColumn(BILL_COLUMN_ORDERING_PROVIDER, 10, 74);
}

void CBillingDlg::ShowSupervisingProviderColumn()
{
	if (m_EntryType != 1) {
		//this should only be called on a bill
		ASSERT(FALSE);
		return;
	}

	ForceShowColumn(BILL_COLUMN_SUPERVISING_PROVIDER, 10, 74);
}
// (s.tullis 2015-04-07 16:54) - PLID 64975  - Use force show column to show category column on bill or quote dlg if multiple categories are configured
void CBillingDlg::ShowCPTCategoryColumn(BillEntryType type)
{
	ForceShowColumn(type == BillEntryType::Bill ? BILL_COLUMN_CPT_CATEGORY : QUOTE_COLUMN_CPT_CATEGORY, 10, 74);
}

// (r.gonet 2015-03-27 18:50) - PLID 65277 - Show on hide the Gift Certificate column.
void CBillingDlg::ShowValueColumn(bool bShow)
{
	if (m_EntryType != 1) {
		//quotes don't show the value column
		return;
	}

	IColumnSettingsPtr pCol = m_List->GetColumn(BILL_COLUMN_VALUE);
	pCol->PutColumnStyle(csVisible | csEditable);
	if (bShow) {
		ForceShowColumn(BILL_COLUMN_VALUE, 10, 74);
	} else {
		// Hide the column.
		pCol->PutStoredWidth(0);
	}
}

// (j.jones 2014-04-30 15:25) - PLID 61837 - Called when a charge is added,
// or changed in such a way that may cause the Referring, Ordering, or
// Supervising provider columns to show or hide.
// Set bIsAdding if this is called while adding a new charge.
// Set bUpdateProviders to false if you only want to show the columns,
// but not try to load data.
// Set bEditedClaimProvider to true if the claim provider just changed,
// which causes thes calculations to behave somewhat differently.
void CBillingDlg::TryShowChargeProviderColumns(BillingItemPtr pItem, bool bIsAdding, bool bUpdateProviders /*= true*/, bool bEditedClaimProvider /*= false*/)
{
	try {

		if (m_EntryType != 1) {
			//only do this on bills
			return;
		}

		long nChargeID = VarLong(pItem->ChargeID, -2);
		if (nChargeID != -2 && IsOriginalOrVoidCharge(nChargeID)) {
			//do not change anything on original/void charges
			return;
		}

		long nServiceID = VarLong(pItem->ServiceID, -1);
		long nProviderID = VarLong(pItem->Provider, -1);

		// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
		long nOrdProviderID = VarLong(pItem->OrderingProviderID, -1);

		//if these aren't filled, don't continue
		if (nServiceID == -1 || nProviderID == -1) {
			//having no service ID should be impossible
			ASSERT(nServiceID != -1);
			return;
		}

		//same for the bill location
		if (m_nCurLocationID == -1) {
			//this shouldn't actually be possible
			ASSERT(FALSE);
			return;
		}

		//if a new charge, use the 'bill to' insured party ID, otherwise get the insured party ID
		//from the insurance tab of the bill
		long nInsuredPartyID = -1;
		if (bIsAdding) {
			nInsuredPartyID = GetCurrentBillToInsuredPartyID();
		}
		else if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.EnsureInitialized();
			long nRow = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->CurSel;
			if (nRow != -1) {
				nInsuredPartyID = VarLong(((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.m_pInsurance1->GetValue(nRow, 0), -1);
			}
		}

		//if no insured party, don't do anything
		if (nInsuredPartyID == -1) {
			return;
		}

		// CalculateChargeClaimProviders caches its data, the bForceReload boolean tells it whether to wipe the cache.
		// If the boolean is false but we haven't called this function before, the data is still loaded.
		bool bForceReload = m_ClaimProviderChecker.Changed();

		//now get the settings for this charge
		ChargeClaimProviderSettings pSettings = CalculateChargeClaimProviders(nServiceID, nProviderID, m_nCurLocationID, nInsuredPartyID, bForceReload);

		bool bMadeChanges = false;
		bool bNeedRefresh = false;

		//referring provider
		{
			bool bShowColumn = false;
			bool bNeedChangeProvider = false;
			long nNewReferringProviderID = -1;
			CalculateChargeProviderColumn(pSettings.eReferringProviderOption, pSettings.nReferringProviderID,
				bUpdateProviders, bEditedClaimProvider, VarLong(pItem->Provider, -1), VarLong(pItem->ClaimProvider, -1), nInsuredPartyID,
				VarLong(pItem->ReferringProviderID, -1), bShowColumn, bNeedChangeProvider, nNewReferringProviderID);

			if (bShowColumn) {
				//this will do nothing if the column is already visible
				ShowReferringProviderColumn();

				//track that this column is required
				pItem->ReferringProviderIDRequired = g_cvarTrue;
			}
			else {
				if (VarBool(pItem->ReferringProviderIDRequired, FALSE)) {
					//if switching from true to false, we need a refresh
					bNeedRefresh = true;
				}
				pItem->ReferringProviderIDRequired = g_cvarFalse;

				//if the charge no longer needs a provider, clear it
				if (bUpdateProviders && VarLong(pItem->ReferringProviderID, -1) != -1) {
					pItem->ReferringProviderID = (long)-1;
					bMadeChanges = true;
				}
			}

			//if we're loading a bill, bUpdateProviders would be false
			if (bUpdateProviders && bNeedChangeProvider) {
				//it is assumed that this boolean is trustworthy,
				//and is only set to true if the provider is not -1 and
				//different from the current provider
				ASSERT(bShowColumn);
				ASSERT(nNewReferringProviderID != -1);
				ASSERT(nNewReferringProviderID != VarLong(pItem->ReferringProviderID, -1));

				pItem->ReferringProviderID = (long)nNewReferringProviderID;
				bMadeChanges = true;
			}

			//if the provider is required, but unselected, force a refresh such
			//that FillBillList will color the cell red
			if (bShowColumn && VarLong(pItem->ReferringProviderID, -1) == -1) {
				bNeedRefresh = true;
			}
		}

		//ordering provider
		{
			// (b.eyers 2015-06-23) - PLID 66208 - set ordering provider from hl7  
			if (nOrdProviderID != -1 && bIsAdding) {
				ShowOrderingProviderColumn();
				// (v.maida 2016-05-09 16:41) - NX-100473 - Removed some code that made ChargeLevelProviderConfigT require an ordering provider when receiving
				// an HL7 bill with an ordering provider.

			}
			//if no ordering provider from hl7 or else where, look up to see if there is a default one
			else {
				bool bShowColumn = false;
				bool bNeedChangeProvider = false;
				long nNewOrderingProviderID = -1;
				CalculateChargeProviderColumn(pSettings.eOrderingProviderOption, pSettings.nOrderingProviderID,
					bUpdateProviders, bEditedClaimProvider, VarLong(pItem->Provider, -1), VarLong(pItem->ClaimProvider, -1), nInsuredPartyID,
					VarLong(pItem->OrderingProviderID, -1), bShowColumn, bNeedChangeProvider, nNewOrderingProviderID);

				if (bShowColumn) {
					//this will do nothing if the column is already visible
					ShowOrderingProviderColumn();

					//track that this column is required
					pItem->OrderingProviderIDRequired = g_cvarTrue;
				}
				else {
					if (VarBool(pItem->OrderingProviderIDRequired, FALSE)) {
						//if switching from true to false, we need a refresh
						bNeedRefresh = true;
					}
					pItem->OrderingProviderIDRequired = g_cvarFalse;

					//if the charge no longer needs a provider, clear it
					if (bUpdateProviders && VarLong(pItem->OrderingProviderID, -1) != -1) {
						pItem->OrderingProviderID = (long)-1;
						bMadeChanges = true;
					}
				}

				//if we're loading a bill, bUpdateProviders would be false
				if (bUpdateProviders && bNeedChangeProvider) {
					//it is assumed that this boolean is trustworthy,
					//and is only set to true if the provider is not -1 and
					//different from the current provider
					ASSERT(bShowColumn);
					ASSERT(nNewOrderingProviderID != -1);
					ASSERT(nNewOrderingProviderID != VarLong(pItem->OrderingProviderID, -1));

					pItem->OrderingProviderID = (long)nNewOrderingProviderID;
					bMadeChanges = true;
				}

				//if the provider is required, but unselected, force a refresh such
				//that FillBillList will color the cell red
				if (bShowColumn && VarLong(pItem->OrderingProviderID, -1) == -1) {
					bNeedRefresh = true;
				}
			}
		}

		//supervising provider
		{
			bool bShowColumn = false;
			bool bNeedChangeProvider = false;
			long nNewSupervisingProviderID = -1;
			CalculateChargeProviderColumn(pSettings.eSupervisingProviderOption, pSettings.nSupervisingProviderID,
				bUpdateProviders, bEditedClaimProvider, VarLong(pItem->Provider, -1), VarLong(pItem->ClaimProvider, -1), nInsuredPartyID,
				VarLong(pItem->SupervisingProviderID, -1), bShowColumn, bNeedChangeProvider, nNewSupervisingProviderID);

			if (bShowColumn) {
				//this will do nothing if the column is already visible
				ShowSupervisingProviderColumn();

				//track that this column is required
				pItem->SupervisingProviderIDRequired = g_cvarTrue;
			}
			else {
				if (VarBool(pItem->SupervisingProviderIDRequired, FALSE)) {
					//if switching from true to false, we need a refresh
					bNeedRefresh = true;
				}
				pItem->SupervisingProviderIDRequired = g_cvarFalse;

				//if the charge no longer needs a provider, clear it
				if (bUpdateProviders && VarLong(pItem->SupervisingProviderID, -1) != -1) {
					pItem->SupervisingProviderID = (long)-1;
					bMadeChanges = true;
				}
			}

			//if we're loading a bill, bUpdateProviders would be false
			if (bUpdateProviders && bNeedChangeProvider) {
				//it is assumed that this boolean is trustworthy,
				//and is only set to true if the provider is not -1 and
				//different from the current provider
				ASSERT(bShowColumn);
				ASSERT(nNewSupervisingProviderID != -1);
				ASSERT(nNewSupervisingProviderID != VarLong(pItem->SupervisingProviderID, -1));

				pItem->SupervisingProviderID = (long)nNewSupervisingProviderID;
				bMadeChanges = true;
			}

			//if the provider is required, but unselected, force a refresh such
			//that FillBillList will color the cell red
			if (bShowColumn && VarLong(pItem->SupervisingProviderID, -1) == -1) {
				bNeedRefresh = true;
			}
		}

		//If a column was already shown, but is no longer required,
		//we do NOT hide the column on the fly. It will, however,
		//be hidden when the bill is reopened.

		if (bMadeChanges) {

			//if we're loading a bill, bUpdateProviders would be false,
			//so bMadeChanges should never be true!
			if (!bUpdateProviders) {
				//how did this happen?
				ASSERT(FALSE);
				ThrowNxException("Changes were made when bUpdateProviders was false.");
			}

			//flag this charge as changed, if it is not new
			if (nChargeID != -2) {
				AddToModifiedList(nChargeID);
			}
			//refresh the list
			FillBillList();
		}

	}NxCatchAll(__FUNCTION__);
}

// (j.jones 2014-05-05 11:14) - PLID 61837 - helper function to TryShowChargeProviderColumns
void CBillingDlg::CalculateChargeProviderColumn(const ChargeLevelProviderConfigOption eConfigOption, const long nConfigProviderID,
	const bool bUpdateProviders, const bool bEditedClaimProvider,
	const long nCurChargeProviderID, const long nCurClaimProviderID, const long nInsuredPartyID, const long nCurSpecialProviderID,
	OUT bool &bShowColumn, OUT bool &bNeedChangeProvider, OUT long &nNewSpecialProviderID)
{
	//initialize our return values
	bShowColumn = false;
	bNeedChangeProvider = false;
	nNewSpecialProviderID = -1;

	if (eConfigOption != ChargeLevelProviderConfigOption::NoSelection)  {

		//we will show this column
		bShowColumn = true;

		//if we're loading a bill, bUpdateProviders would be false
		if (bUpdateProviders) {
			long nNewProviderID = -1;

			//if the option is set for a specific provider, change the selection
			if (eConfigOption == ChargeLevelProviderConfigOption::ChargeProvider) {
				nNewProviderID = nCurChargeProviderID;
			}
			else if (eConfigOption == ChargeLevelProviderConfigOption::ClaimProvider) {
				//try to use the claim provider
				nNewProviderID = nCurClaimProviderID;

				//if -1, calculate the actual provider ID
				if (nNewProviderID == -1) {
					nNewProviderID = CalculateDefaultClaimProviderID(nCurChargeProviderID, nCurClaimProviderID, nInsuredPartyID);
				}
			}
			//the selected provider may be -1 if it is improperly set up or perhaps inactive,
			//so don't force an unselection in that case
			else if (eConfigOption == ChargeLevelProviderConfigOption::Required
				&& nConfigProviderID != -1) {

				nNewProviderID = nConfigProviderID;
			}

			if (nNewProviderID != -1 && nCurSpecialProviderID != nNewProviderID) {

				//if the action that triggered this function was merely changing the
				//claim provider, don't overwrite the existing provider unless
				//the settings say to use the claim provider
				if (!bEditedClaimProvider || eConfigOption == ChargeLevelProviderConfigOption::ClaimProvider) {
					nNewSpecialProviderID = nNewProviderID;
					bNeedChangeProvider = true;
				}
			}
		}
	}
}

// (j.jones 2014-05-05 09:12) - PLID 61837 - calculates what the claim provider
// would be on a charge if "use default claim provider" is selected
long CBillingDlg::CalculateDefaultClaimProviderID(const long nCurChargeProviderID, const long nCurClaimProviderID, const long nInsuredPartyID)
{
	//throw exceptions to the caller

	//this should not be called on quotes

	//if a specific claim provider ID is in use, use that
	if (nCurClaimProviderID != -1) {
		return nCurClaimProviderID;
	}

	//if the insured party ID is -1, just use the charge provider
	if (nInsuredPartyID == -1) {
		return nCurChargeProviderID;
	}

	//if this is not a HCFA form, use the charge provider ID
	if (((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetSafeHwnd()
		&& ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_dlgInsuranceBilling.GetFormTypeID() != 1) {

		return nCurChargeProviderID;
	}

	//cache results such that if we look up the exact same 
	//information again, we don't hit the database
	static long nLastCheckedInsuredPartyID = -1;
	static long nLastPatientID = -1;
	static long nLastChargeProviderID = -1;
	static long nLastQueriedClaimProviderID = -1;

	long nNewClaimProviderID = -1;

	if (nLastCheckedInsuredPartyID != nInsuredPartyID
		|| nLastPatientID != m_nPatientID
		|| nLastChargeProviderID != nCurChargeProviderID) {

		//remember that on the charge level, claim provider ID is controlled by
		//the 2310B setup
		_RecordsetPtr rs = CreateParamRecordset("SELECT "
			"Coalesce(HCFAClaimProvidersT.ANSI_2310B_ProviderID, "
			"	(CASE WHEN HCFASetupT.Box33Setup = 2 THEN PatientProvidersT.ProviderID ELSE NULL END) "
			") AS ProviderID "
			""
			"FROM InsuredPartyT "
			"INNER JOIN InsuranceCoT ON InsuredPartyT.InsuranceCoID = InsuranceCoT.PersonID "
			"INNER JOIN HCFASetupT ON InsuranceCoT.HCFASetupGroupID = HCFASetupT.ID "
			"CROSS JOIN (SELECT PersonT.ID AS ProviderID "
			"	FROM PatientsT "
			"	INNER JOIN PersonT ON PatientsT.MainPhysician = PersonT.ID "
			"	WHERE PatientsT.PersonID = {INT} AND PersonT.Archived = 0) AS PatientProvidersT "
			"LEFT JOIN HCFAClaimProvidersT ON InsuranceCoT.PersonID = HCFAClaimProvidersT.InsuranceCoID "
			"	AND (CASE WHEN HCFASetupT.Box33Setup = 2 THEN PatientProvidersT.ProviderID ELSE {INT} END) = HCFAClaimProvidersT.ProviderID "
			"WHERE InsuredPartyT.PersonID = {INT}", m_nPatientID, nCurChargeProviderID, nInsuredPartyID);
		if (!rs->eof) {
			nNewClaimProviderID = VarLong(rs->Fields->Item["ProviderID"]->Value, -1);
		}
		rs->Close();

		//set our cached values
		nLastCheckedInsuredPartyID = nInsuredPartyID;
		nLastPatientID = m_nPatientID;
		nLastChargeProviderID = nCurChargeProviderID;
		nLastQueriedClaimProviderID = nNewClaimProviderID;
	}
	else {
		//use the cached value
		nNewClaimProviderID = nLastQueriedClaimProviderID;
	}

	//if this result is -1, use the charge's provider ID
	if (nNewClaimProviderID == -1) {
		nNewClaimProviderID = nCurChargeProviderID;
	}

	return nNewClaimProviderID;
}

// (j.jones 2014-05-29 10:57) - PLID 61837 - allows the insurance tab to refresh
// the charge provider columns
void CBillingDlg::TryShowAllChargeProviderColumns()
{
	//throw exceptions to the caller

	if (m_EntryType == 1) {
		for (int i = 0; i < (int)m_billingItems.size(); i++) {
			BillingItemPtr pItem = m_billingItems[i];
			TryShowChargeProviderColumns(pItem, false);
		}
	}
}

// (r.gonet 07/02/2014) - PLID 62567 - Sets the bill description edit box value.
// The intention is to hide the prepending of the status prefix. The opposite of this function
// is GetBillDescription()
void CBillingDlg::SetBillDescription(CString strBillDescription)
{
	((CBillingModuleDlg*)m_pBillingModuleWnd)->SetBillDescription(strBillDescription);
}

// (r.gonet 07/02/2014) - PLID 62567 - Gets the bill description edit box value, with the status prefix.
CString CBillingDlg::GetBillDescriptionWithPrefix()
{
	return ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetBillDescriptionWithPrefix();
}

// (r.gonet 07/02/2014) - PLID 62567 - Gets the bill description edit box value, without the status prefix.
// The intention is to hide the prepending of the status prefix. The opposite of this function
// is SetBillDescription(str)
CString CBillingDlg::GetBillDescription()
{
	return ((CBillingModuleDlg*)m_pBillingModuleWnd)->GetBillDescription();
}

// (r.gonet 07/01/2014) - PLID 62567 - When the user selects a status, there may be
// certain things we need to do to the bill dialog if the bill is a special type.
void CBillingDlg::SelChosenBillStatusCombo(LPDISPATCH lpRow)
{
	try {
		CString strBillDescription;
		strBillDescription = GetBillDescriptionWithPrefix();
		CString strOnHoldPrefix = ((CBillingModuleDlg*)m_pBillingModuleWnd)->m_strOnHoldPrefix;
		if (strBillDescription.Find(strOnHoldPrefix) == 0) {
			strBillDescription = strBillDescription.Mid(strOnHoldPrefix.GetLength());
		}
		SetBillDescription(strBillDescription);

		// (r.gonet 07/23/2014) - PLID 62569 - If the bill is set to on hold, then we need to remove the on hold status from all charges.
		if (GetBillStatusType() == EBillStatusType::OnHold) {
			ClearChargeHolds();
		}
	} NxCatchAll(__FUNCTION__);
}

// (r.gonet 07/01/2014) - PLID 62533 - In the bill, add an ellipsis button next to the status drop down to
// open the bill status config dialog.
void CBillingDlg::OnBnClickedBillStatusConfigBtn()
{
	try {
		// (r.gonet 07/03/2014) - PLID 62533 - Open the status setup dialog.
		CBillStatusSetupDlg dlg(this, GetNxColor());
		dlg.DoModal();

		// The statuses may have changed, so reflect it in our status list immediately (table checkers will take care
		// of other sessions).

		// Remember what we had selected before we requery.
		NXDATALIST2Lib::IRowSettingsPtr pRow = m_pBillStatusCombo->CurSel;
		long nSelectedStatusID;
		if (pRow) {
			nSelectedStatusID = VarLong(pRow->GetValue((short)EBillStatusComboColumns::ID), -1);
		} else {
			// The no selection row is selected.
			nSelectedStatusID = -1;
		}
		// We'll also need the non-prefixed bill description because the status could change its type, which would
		// mean that the prefix to the bill description could change. We'll ensure the bill description is updated later.
		// This should only happen if the bill is unsaved since they can't change status names or types if the status is in 
		// use by an existing bill.
		CString strCurrentBillDescription = GetBillDescription();

		// Get the latest statuses.
		RefreshBillStatusList();

		EBillStatusType eNewBillStatusType = EBillStatusType::None;
		// Try to re-select our old selected row.
		NXDATALIST2Lib::IRowSettingsPtr pFoundRow = m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, nSelectedStatusID);
		if (pFoundRow) {
			// The old row is now selected once more.
			eNewBillStatusType = (EBillStatusType)VarLong(pFoundRow->GetValue((short)EBillStatusComboColumns::Type), (long)EBillStatusType::None);
		} else if (nSelectedStatusID != -1) {
			// Hm. Not found. Must be inactive or maybe it was deleted in the setup dialog. Try to load it from the database
			_RecordsetPtr prs = CreateParamRecordset(
				"SELECT BillStatusT.ID, BillStatusT.Name, BillStatusT.Type, BillStatusT.Inactive, BillStatusT.Custom "
				"FROM BillStatusT "
				"WHERE ID = {INT}; "
				, nSelectedStatusID);
			if (prs->eof) {
				// Status was deleted in the setup dialog, unselect it here. Don't bother telling the user through a message box since they most likely did
				// the deletion.
				m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, (long)-1);
				eNewBillStatusType = EBillStatusType::None;
			} else {
				// It is inactive. Add a row to the datalist.
				CString strStatusName = AdoFldString(prs->Fields, "Name", "");
				EBillStatusType eBillStatusType = eNewBillStatusType = (EBillStatusType)AdoFldLong(prs->Fields, "Type", (long)EBillStatusType::None);
				BOOL bInactive = AdoFldBool(prs->Fields, "Inactive");
				BOOL bCustom = AdoFldBool(prs->Fields, "Custom");

				pRow = m_pBillStatusCombo->GetNewRow();
				pRow->PutValue((short)EBillStatusComboColumns::ID, (long)nSelectedStatusID);
				pRow->PutValue((short)EBillStatusComboColumns::Name, _bstr_t(strStatusName));
				pRow->PutValue((short)EBillStatusComboColumns::Type, (long)eBillStatusType);
				pRow->PutValue((short)EBillStatusComboColumns::Inactive, bInactive ? g_cvarTrue : g_cvarFalse);
				pRow->PutValue((short)EBillStatusComboColumns::Custom, bCustom ? g_cvarTrue : g_cvarFalse);
				pRow->Visible = VARIANT_FALSE;
				m_pBillStatusCombo->AddRowSorted(pRow, NULL);
				m_pBillStatusCombo->CurSel = pRow;
			}
		} else { // There is supposed to be a default No Status row with ID = -1. We couldn't find it. Where the heck did it go?
			ThrowNxException("%s : The default No Status row could not be found in the bill status combo box!", __FUNCTION__);
		}
		// We need to ensure the bill description is up to date because the status type may have changed.
		SetBillDescription(strCurrentBillDescription);

		if (eNewBillStatusType == EBillStatusType::OnHold) {
			ClearChargeHolds();
		}
	} NxCatchAll(__FUNCTION__);
}

// (r.gonet 07/01/2014) - PLID 62523 - When the user selects a custom status note, then update the status note edit box.
void CBillingDlg::SelChosenBillStatusNoteCombo(LPDISPATCH lpRow)
{
	try {
		NXDATALIST2Lib::IRowSettingsPtr pRow(lpRow);
		if (!pRow) {
			return;
		}

		// Append the username to the note.
		CString strText = VarString(pRow->GetValue((short)EBillStatusNoteComboColumns::Text), "");
		m_nxeditBillStatusNote.SetWindowText(strText);
		m_pBillStatusNoteCombo->CurSel = NULL;
	} NxCatchAll(__FUNCTION__);
}

// (r.gonet 07/01/2014) - PLID 62520 - In the bill, next to the status drop down, add an ellipsis button to
// configure the custom statuses.
void CBillingDlg::OnBnClickedBillStatusNoteConfigBtn()
{
	try {
		CEditComboBox dlg(this, 80, "Edit Bill Status Notes");
		dlg.DoModal();

		m_pBillStatusNoteCombo->Requery();
	} NxCatchAll(__FUNCTION__);
}

// (r.gonet 07/02/2014) - PLID 62567 - Returns the currently selected bill status's type or None if no status is selected.
EBillStatusType CBillingDlg::GetBillStatusType()
{
	if (!m_pBillStatusCombo) {
		return EBillStatusType::None;
	}

	EBillStatusType eBillStatusType;
	NXDATALIST2Lib::IRowSettingsPtr pBillStatusRow = m_pBillStatusCombo->CurSel;
	if (pBillStatusRow) {
		eBillStatusType = (EBillStatusType)VarLong(pBillStatusRow->GetValue((short)EBillStatusComboColumns::Type), (long)EBillStatusType::None);
	} else {
		eBillStatusType = EBillStatusType::None;
	}
	return eBillStatusType;
}

// (r.gonet 07/02/2014) - PLID 62567 - Updates the tracked bill status type in the billing module dialog.
void CBillingDlg::CurSelWasSetBillStatusCombo()
{
	try {
		if (m_pBillingModuleWnd) {
			((CBillingModuleDlg*)m_pBillingModuleWnd)->m_eBillStatusType = GetBillStatusType();
		}
	} NxCatchAll(__FUNCTION__);
}

// (r.gonet 07/01/2014) - PLID 62525 - In the NoteDataT table, the username is appended to the end of the note,
// but we don't want the username actually appearing in the bill editor dialog, so this function removes it.
CString CBillingDlg::RemoveUsernameFromStatusNote(CString strStatusNote, CString strUsername)
{
	CString strUsernameSuffix = FormatString(" (%s)", strUsername);
	if (strStatusNote.Right(strUsernameSuffix.GetLength()) == strUsernameSuffix) {
		return strStatusNote.Left(strStatusNote.GetLength() - strUsernameSuffix.GetLength());
	} else {
		return strStatusNote;
	}
}

// (r.gonet 07/01/2014) - PLID 62525 - Appends the current user's username to a bill status note.
CString CBillingDlg::AddCurrentUsernameToStatusNote(CString strStatusNote)
{
	return FormatString("%s (%s)", strStatusNote, GetCurrentUserName());
}

// (r.gonet 07/09/2014) - PLID 62834 - Gets the number of charges on the bill that are not on hold
long CBillingDlg::GetNotOnHoldChargeCount()
{
	long nCount = 0;
	for each(const BillingItemPtr &pBillingItem in m_billingItems)
	{
		if (!VarBool(pBillingItem->OnHold, FALSE)) {
			nCount++;
		}
	}
	return nCount;
}

// (r.gonet 07/09/2014) - PLID 62834 - Gets the number of charges on the bill that are on hold
long CBillingDlg::GetOnHoldChargeCount()
{
	long nCount = 0;
	for each(const BillingItemPtr &pBillingItem in m_billingItems)
	{
		if (VarBool(pBillingItem->OnHold, FALSE)) {
			nCount++;
		}
	}
	return nCount;
}

// (r.gonet 07/09/2014) - PLID 62834 - Returns the billing items that are on hold.
void CBillingDlg::GetOnHoldCharges(std::vector<BillingItemPtr> &vecOnHoldCharges)
{
	vecOnHoldCharges.clear();
	for each(const BillingItemPtr &pBillingItem in m_billingItems)
	{
		if (VarBool(pBillingItem->OnHold, FALSE)) {
			vecOnHoldCharges.push_back(pBillingItem);
		}
	}
}

// (r.gonet 07/09/2014) - PLID 62834 - Sets all charges in the bill that are on hold to not on hold.
void CBillingDlg::ClearChargeHolds()
{
	for each(const BillingItemPtr& billingItem in m_billingItems)
	{
		billingItem->OnHold = g_cvarFalse;
	}

	IRowSettingsPtr pRow = m_List->GetFirstRow();
	while (pRow) {
		pRow->PutValue(BILL_COLUMN_ON_HOLD, g_cvarFalse);
		pRow->BackColor = RGB(255, 255, 255);
		pRow->BackColorSel = 1;
		pRow = pRow->GetNextRow();
	}
}

// (j.jones 2014-07-28 09:31) - PLID 56662 - Added modular function to requery the product combo.
// Will filter on the bill's location unless a specific location ID is provided.
void CBillingDlg::RequeryProductCombo(long nLocationID /*= -1*/)
{
	//this code was copied in a lot of places, I unified it into one function

	//if the location ID is -1, and it often will be, use the location on the bill
	if (nLocationID == -1) {
		m_LocationCombo->WaitForRequery(NXDATALISTLib::dlPatienceLevelWaitIndefinitely);
		nLocationID = GetCurrentLocationID();
		if (m_LocationCombo->GetCurSel() != sriNoRow) {
			nLocationID = VarLong(m_LocationCombo->GetValue(m_LocationCombo->GetCurSel(), 0));
		}
	}

	//this should not be possible
	ASSERT(nLocationID != -1);

	CString strWhere;
	strWhere.Format("ProductLocationInfoT.LocationID = %li AND ProductLocationInfoT.Billable = 1 AND ServiceT.Active = 1", nLocationID);
	m_ProductsCombo->PutWhereClause(_bstr_t(strWhere));
	m_ProductsCombo->Requery();
	m_bProductsCombo = TRUE;
}

void CBillingDlg::SetStartingFocus()
{
	switch (m_EntryType)
	{
		case BillEntryType::Bill:
			if (m_pBillingDiagSearch)
			{
				// (j.armen 2014-08-14 14:20) - PLID 63334 - Specify which control on the billing dialog should be taking focus
				m_pBillingDiagSearch->SetFocus();
				m_pBillingDiagSearch->PostMessage(WM_NEXTDLGCTL, (WPARAM)m_pBillingDiagSearch->GetDlgItem(IDC_BILLING_DIAG_SEARCH)->GetSafeHwnd(), TRUE);
			}
			return;
		case BillEntryType::Quote:
			GetDlgItem(IDC_WHAT_TO_ADD_COMBO)->SetFocus();
			return;
	}
}

// (j.armen 2014-08-12 09:39) - PLID 63334 - When the billing diag search reaches the end of it's tab sequence
//	It calls this function to tell us to set focus to our preferred control
void CBillingDlg::EndOfTabSequence()
{
	GetDlgItem(IDC_COMBO_BILL_TO)->SetFocus();
}

// (j.armen 2014-08-14 14:20) - PLID 63334 - Handle a shift-tab operation setting focus from the diag search to the parent
void CBillingDlg::BeginningOfTabSequence()
{
	GetParent()->SetFocus();
	m_peditBillDescription->SetFocus();
}

// (j.armen 2014-08-13 11:14) - PLID 63352 - When the billing diag search tries to reoder codes, it will first check
//	to verify if the code order change must first remove any linked charges
bool CBillingDlg::VerifyChargeCodeOrder(std::pair<long, long> pair, long nOrderOffset)
{
	for each(const auto& pItem in m_billingItems)
	{
		for each(const auto& whichCode in *pItem->whichCodes)
		{
			if (whichCode.first == pair && whichCode.second->nOrderIndex + nOrderOffset > MAX_DIAG_Cs_INDEX)
			{
				bool bUnlink = IDOK == AfxMessageBox(
					FormatString("The diagnosis code '%s' is linked to at least one charge.\r\nChanging the code order will unlink this code from all charges.",
					GetDiagDescription(whichCode.second)), MB_OKCANCEL);

				if (bUnlink)
					RemoveDiagCodeFromWhichCodes(pair.first, pair.second);

				return bUnlink;
			}
		}
	}

	return true;
	m_ProductsCombo->Requery();
	m_bProductsCombo = TRUE;
}




// (s.tullis 2014-08-06 12:24) - PLID 62779 -
void CBillingDlg::SetAlbertaBillStatus(){
	// Get the Ins Resp Select
	NXDATALIST2Lib::IRowSettingsPtr pRow;
	long nRespType = 0; // default to patient resp
	nRespType = VarLong(m_listBillTo->GetValue(m_listBillTo->CurSel, btcID));
	pRow = m_pBillStatusCombo->GetCurSel();
	long nBillStatusID = -1; // default to <No status> selection

	// make sure its not null
	if (pRow){
		nBillStatusID = VarLong(pRow->GetValue((short)EBillStatusComboColumns::ID));
	}
		//Need to have Primary Responsbility and <No Status> as a Bill status
	if (nRespType == 1 && nBillStatusID == -1){
		//Get the Bill Status ID	
		long nBillStatusID = GetAlbertaBillStatusID(AlbertaBillingStatus::eEntered);
				
		// GetAlbertaBillStatus calls EnsureAlbertaBillStatus which checks if the entered status exists
		// if it does not exist is will create the entered status
		// so we need to check if the status is in the list
		// if not requery the list and select the entered status
		pRow = m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, nBillStatusID);
		if (pRow == NULL){
			RefreshBillStatusList();
			m_pBillStatusCombo->SetSelByColumn((short)EBillStatusComboColumns::ID, nBillStatusID);
		}

		
	}

}


// (s.tullis 2014-08-06 12:24) - PLID 62779 - Incase the status was not created we need to refresh the list
void CBillingDlg::RefreshBillStatusList(){
	// Need to re-add the no selection row.
	NXDATALIST2Lib::IRowSettingsPtr pRow = m_pBillStatusCombo->GetNewRow();
	if (pRow){

		// Get the latest statuses.
		m_pBillStatusCombo->Requery();


		pRow->PutValue((short)EBillStatusComboColumns::ID, (long)-1);
		pRow->PutValue((short)EBillStatusComboColumns::Name, _bstr_t(" <No Status>"));
		pRow->PutValue((short)EBillStatusComboColumns::Type, g_cvarNull);
		pRow->PutValue((short)EBillStatusComboColumns::Inactive, g_cvarFalse);
		pRow->PutValue((short)EBillStatusComboColumns::Custom, g_cvarFalse);
		m_pBillStatusCombo->AddRowSorted(pRow,m_pBillStatusCombo->GetFirstRow());

	}

}
// (s.tullis 2015-03-27 14:48) - PLID 64976 - Fuction to generate Multi Category Warning Message
CString CBillingDlg::GetMultCategoryCPTWarning(std::vector<CString> arrNoCPTCatSelCharges){

	CString strWarningMessage= "";
	CString strCPTNames = "";
	try{
		long arrSize = arrNoCPTCatSelCharges.size();
for (int i = 0; i < arrSize; i++)
{
	strCPTNames = strCPTNames + arrNoCPTCatSelCharges[i] + " \r\n";
}

strWarningMessage.Format("The following charges have multiple charge category options, but a charge category has not been selected.\r\n"
	"\r\n"
	"%s"
	"\r\n"
	"Please make a selection before saving the bill.", strCPTNames);

	}NxCatchAll(__FUNCTION__)
		return strWarningMessage;
}

// (s.tullis 2015-04-10 15:09) - PLID 65537 - Added fuction to update list cell colors
void CBillingDlg::UpDateBillQuoteListCellColors(NXDATALIST2Lib::IRowSettingsPtr pRow, BillingItemPtr pBillItem, BillEntryType type)
{
	try {

		bool bColorRed = false;
		if (pRow) {

			if (type == BillEntryType::Bill)
			{
				//if the provider is required, color the cell red if not filled
				bColorRed = (VarBool(pBillItem->ReferringProviderIDRequired, TRUE) && VarLong(pBillItem->ReferringProviderID, -1) == -1) ? true : false;
				pRow->PutCellForeColor(BILL_COLUMN_REFERRING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
				pRow->PutCellForeColorSel(BILL_COLUMN_REFERRING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));

				//if the provider is required, color the cell red if not filled
				bColorRed = (VarBool(pBillItem->OrderingProviderIDRequired, FALSE) && VarLong(pBillItem->OrderingProviderID, -1) == -1) ? true : false;
				pRow->PutCellForeColor(BILL_COLUMN_ORDERING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
				pRow->PutCellForeColorSel(BILL_COLUMN_ORDERING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));

				//if the provider is required, color the cell red if not filled
				bColorRed = (VarBool(pBillItem->SupervisingProviderIDRequired, FALSE) && VarLong(pBillItem->SupervisingProviderID, -1) == -1) ? true : false;
				pRow->PutCellForeColor(BILL_COLUMN_SUPERVISING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
				pRow->PutCellForeColorSel(BILL_COLUMN_SUPERVISING_PROVIDER, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));

				// (s.tullis 2015-04-09 17:24) - PLID 65537 - Need to color the cell red if the user needs to select a category
				// IE Multiple categories configured and no default category
				bColorRed = ((VarLong(pBillItem->CPTCategoryID, -1) < 0) && (VarLong(pBillItem->CPTCategoryCount, 0)) > 1) ? true : false;
				pRow->PutCellForeColor(BILL_COLUMN_CPT_CATEGORY, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
				pRow->PutCellForeColorSel(BILL_COLUMN_CPT_CATEGORY, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));


			}
			else if (type == BillEntryType::Quote)
			{
				// (s.tullis 2015-04-09 17:24) - PLID 65537 - Need to color the cell red if the user needs to select a category
				// IE Multiple categories configured and no default category
				bColorRed = ((VarLong(pBillItem->CPTCategoryID, -1) < 0) && (VarLong(pBillItem->CPTCategoryCount, 0)) > 1) ? true : false;
				pRow->PutCellForeColor(QUOTE_COLUMN_CPT_CATEGORY, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
				pRow->PutCellForeColorSel(QUOTE_COLUMN_CPT_CATEGORY, bColorRed ? RGB(255, 0, 0) : RGB(0, 0, 0));
			}
			else
			{
				ASSERT(FALSE);
			}

		}

	}NxCatchAll(__FUNCTION__)

}
//(s.dhole 3/24/2015 12:41 PM ) - PLID 61135 this function will check service code and insurance combo has any warning
BOOL CBillingDlg::IsCodeSelectedBasedOnWarning(const long nServiceID)
{
	BOOL bResult = TRUE;
	long InsID = GetCurrentBillToInsuranceCoID();
	if (InsID <= 0)
	{ // no need to execute query since insurence party is not responsible to bill
		return  bResult;
	}
	// (a.walling 2010-11-01 12:38) - PLID 40965 - Parameterized
	_RecordsetPtr rsNote = CreateParamRecordset("SELECT CPTCodeT.Code, ServiceT.Name, CptInsNotesT.Notes FROM ServiceT INNER JOIN CPTCodeT ON ServiceT.ID  =CPTCodeT.ID   "
		" INNER JOIN CptInsNotesT ON  CptInsNotesT.CPTCodeID = CPTCodeT.ID WHERE CptInsNotesT.CptCodeID = { INT } AND CptInsNotesT.InsuranceCoID = { INT }", nServiceID, InsID);
	if (!rsNote->eof) {
		CString strNote = AdoFldString(rsNote, "Notes", "");
		if (!strNote.IsEmpty()) {
			CString strCode = AdoFldString(rsNote, "Code", "");
			CString strCodeName = AdoFldString(rsNote, "Name", "");
			if (MsgBox(MB_YESNO, "This Service Code (%s - %s) and Insurance Company combination has the following warning:\r\n\r\n%s\r\n\r\nAre you sure you wish to select this code?", strCode, strCodeName, strNote) == IDNO)
			{
				bResult = FALSE;
			}
		}
	}
	rsNote->Close();
	return bResult;
}

// (j.jones 2016-04-07 15:43) - NX-100077 - used when billing a product that requires the provider
// to default to the last provider who sold the product to this patient, will update the pointer accordingly
void CBillingDlg::UpdateChargeToMostRecentProviderSold(IN OUT BillingItemPtr pBillingItem)
{
	try {

		//safety check
		if (VarLong(pBillingItem->ServiceID, -1) == -1) {
			//this should be impossible
			return;
		}

		long nFoundProviderID = -1;
		CString strSkillCode = "";	//only needed for Alberta

		//first look to see if any charge on this bill (aside this charge, of course)
		//is for the same ServiceID, if so use that charge's provider
		for (int i = 0; i < (int)m_billingItems.size() && nFoundProviderID == -1; i++)
		{
			if (VarLong(m_billingItems[i]->LineID) != VarLong(pBillingItem->LineID)
				&& VarLong(m_billingItems[i]->ServiceID) == VarLong(pBillingItem->ServiceID))
			{

				//we found the same ServiceID on a different charge - is a provider selected?
				long nProviderID = VarLong(m_billingItems[i]->Provider, -1);
				if (nProviderID > 0)
				{
					//got one!
					nFoundProviderID = nProviderID;

					//for Alberta only, we need the taxonomy code as the SkillCode
					if (UseAlbertaHLINK()) {
						_RecordsetPtr prs = CreateParamRecordset("SELECT TaxonomyCode FROM ProvidersT WHERE PersonID = {INT}", nFoundProviderID);
						if (!prs->eof) {
							strSkillCode = AdoFldString(prs, "TaxonomyCode", "");
							if (strSkillCode.GetLength() > 4) {
								strSkillCode = "";
							}
						}
						prs->Close();
					}
					break;
				}
			}
		}

		if (nFoundProviderID == -1)
		{
			//look for the most recent charge for the same ServiceID, non-voided, by service date,
			//and use that charge's provider - but not if they are inactive
			_RecordsetPtr rs = CreateParamRecordset("SELECT TOP 1 ProvidersT.PersonID, ProvidersT.TaxonomyCode "
				"FROM ProvidersT "
				"INNER JOIN PersonT ON ProvidersT.PersonID = PersonT.ID "
				"INNER JOIN ChargesT ON ProvidersT.PersonID = ChargesT.DoctorsProviders "
				"INNER JOIN LineItemT ON ChargesT.ID = LineItemT.ID "
				"LEFT JOIN LineItemCorrectionsT OrigLineItems ON LineItemT.ID = OrigLineItems.OriginalLineItemID "
				"LEFT JOIN LineItemCorrectionsT AS VoidingLineItemsQ ON LineItemT.ID = VoidingLineItemsQ.VoidingLineItemID "
				"WHERE VoidingLineItemsQ.VoidingLineItemID IS NULL AND OrigLineItems.OriginalLineItemID IS NULL "
				"AND LineItemT.Type = 10 "
				"AND LineItemT.Deleted = 0 "
				"AND PersonT.Archived = 0 "
				"AND LineItemT.PatientID = {INT} "
				"AND ChargesT.ServiceID = {INT} "
				"ORDER BY LineItemT.Date DESC", m_nPatientID, VarLong(pBillingItem->ServiceID));
			if (!rs->eof) {
				//any result here represents the most recently used active provider for this serviceID
				nFoundProviderID = VarLong(rs->Fields->Item["PersonID"]->Value);

				//for Alberta only, we need the taxonomy code as the SkillCode
				if (UseAlbertaHLINK()) {
					strSkillCode = AdoFldString(rs, "TaxonomyCode", "");
					if (strSkillCode.GetLength() > 4) {
						strSkillCode = "";
					}
				}
			}
			rs->Close();
		}

		//if no provider found, do nothing
		if (nFoundProviderID == -1) {
			return;
		}

		//assign the provider
		pBillingItem->Provider = nFoundProviderID;

		//for Alberta only, we need the taxonomy code as the SkillCode
		if (UseAlbertaHLINK()) {
			pBillingItem->Skill = _bstr_t(strSkillCode);
		}

		//this is likely never to happen on existing charges,
		//but if it does, mark the charge as modified
		long nChargeID = VarLong(pBillingItem->ChargeID, -2);
		if (nChargeID != -2) {
			AddToModifiedList(nChargeID, TRUE);
		}

	}NxCatchAll(__FUNCTION__);
}